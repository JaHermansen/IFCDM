import {
  FILE_DESCRIPTION,
  FILE_NAME,
  Handle,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCELEMENTQUANTITY,
  IFCOPENINGELEMENT,
  IFCOWNERHISTORY,
  IFCPROJECT,
  IFCPROPERTYSET,
  IFCRELAGGREGATES,
  IFCRELASSIGNSTOGROUP,
  IFCRELASSOCIATESCLASSIFICATION,
  IFCRELASSOCIATESMATERIAL,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCRELDEFINESBYPROPERTIES,
  IFCRELDEFINESBYTEMPLATE,
  IFCRELDEFINESBYTYPE,
  IFCSITE,
  IFCSPACE,
  IFCUNITASSIGNMENT,
  IfcAPI2,
  LogLevel,
  Ne,
  Re,
  Ue,
  ae,
  an,
  fn,
  ke,
  web_ifc_api_exports
} from "./chunk-7F5QJTWE.js";
import {
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  ColorManagement,
  CylinderGeometry,
  DataTexture,
  DepthFormat,
  DepthTexture,
  DoubleSide,
  DynamicDrawUsage,
  EdgesGeometry,
  Euler,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Group,
  HalfFloatType,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBufferAttribute,
  Line,
  Line3,
  LineBasicMaterial,
  LineSegments,
  LinearFilter,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  NearestFilter,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Points,
  PointsMaterial,
  Quaternion,
  RGBAFormat,
  Ray,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  Scene,
  ShaderLib,
  ShaderMaterial,
  ShapeUtils,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  Triangle,
  UniformsLib,
  UniformsUtils,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  WebGLMultipleRenderTargets,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry
} from "./chunk-UZOV2HZI.js";

// node_modules/@thatopen/components-front/dist/index.js
var nu = Object.defineProperty;
var su = (h, t, e) => t in h ? nu(h, t, { enumerable: true, configurable: true, writable: true, value: e }) : h[t] = e;
var b = (h, t, e) => (su(h, typeof t != "symbol" ? t + "" : t, e), e);
var Su = Object.defineProperty;
var Au = (h, t, e) => t in h ? Su(h, t, { enumerable: true, configurable: true, writable: true, value: e }) : h[t] = e;
var S = (h, t, e) => (Au(h, typeof t != "symbol" ? t + "" : t, e), e);
var Oc = 0;
var Fu = 1;
var Ru = 2;
var vl = 2;
var _o = 1.25;
var Il = 1;
var yr = 6 * 4 + 4 + 4;
var Wr = 65535;
var Pu = Math.pow(2, -24);
var Uo = Symbol("SKIP_GENERATION");
function Mu(h) {
  return h.index ? h.index.count : h.attributes.position.count;
}
function Es(h) {
  return Mu(h) / 3;
}
function Ou(h, t = ArrayBuffer) {
  return h > 65535 ? new Uint32Array(new t(4 * h)) : new Uint16Array(new t(2 * h));
}
function Du(h, t) {
  if (!h.index) {
    const e = h.attributes.position.count, n = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, s = Ou(e, n);
    h.setIndex(new BufferAttribute(s, 1));
    for (let i = 0; i < e; i++)
      s[i] = i;
  }
}
function Dc(h) {
  const t = Es(h), e = h.drawRange, n = e.start / 3, s = (e.start + e.count) / 3, i = Math.max(0, n), r = Math.min(t, s) - i;
  return [{
    offset: Math.floor(i),
    count: Math.floor(r)
  }];
}
function Lc(h) {
  if (!h.groups || !h.groups.length)
    return Dc(h);
  const t = [], e = /* @__PURE__ */ new Set(), n = h.drawRange, s = n.start / 3, i = (n.start + n.count) / 3;
  for (const o of h.groups) {
    const l = o.start / 3, u = (o.start + o.count) / 3;
    e.add(Math.max(s, l)), e.add(Math.min(i, u));
  }
  const r = Array.from(e.values()).sort((o, l) => o - l);
  for (let o = 0; o < r.length - 1; o++) {
    const l = r[o], u = r[o + 1];
    t.push({
      offset: Math.floor(l),
      count: Math.floor(u - l)
    });
  }
  return t;
}
function Lu(h) {
  if (h.groups.length === 0)
    return false;
  const t = Es(h), e = Lc(h).sort((i, r) => i.offset - r.offset), n = e[e.length - 1];
  n.count = Math.min(t - n.offset, n.count);
  let s = 0;
  return e.forEach(({ count: i }) => s += i), t !== s;
}
function Ye(h, t, e) {
  return e.min.x = t[h], e.min.y = t[h + 1], e.min.z = t[h + 2], e.max.x = t[h + 3], e.max.y = t[h + 4], e.max.z = t[h + 5], e;
}
function Nu(h) {
  h[0] = h[1] = h[2] = 1 / 0, h[3] = h[4] = h[5] = -1 / 0;
}
function yl(h) {
  let t = -1, e = -1 / 0;
  for (let n = 0; n < 3; n++) {
    const s = h[n + 3] - h[n];
    s > e && (e = s, t = n);
  }
  return t;
}
function wl(h, t) {
  t.set(h);
}
function Cl(h, t, e) {
  let n, s;
  for (let i = 0; i < 3; i++) {
    const r = i + 3;
    n = h[i], s = t[i], e[i] = n < s ? n : s, n = h[r], s = t[r], e[r] = n > s ? n : s;
  }
}
function Gi(h, t, e) {
  for (let n = 0; n < 3; n++) {
    const s = t[h + 2 * n], i = t[h + 2 * n + 1], r = s - i, o = s + i;
    r < e[n] && (e[n] = r), o > e[n + 3] && (e[n + 3] = o);
  }
}
function Bs(h) {
  const t = h[3] - h[0], e = h[4] - h[1], n = h[5] - h[2];
  return 2 * (t * e + e * n + n * t);
}
function Bo(h, t, e, n, s = null) {
  let i = 1 / 0, r = 1 / 0, o = 1 / 0, l = -1 / 0, u = -1 / 0, d = -1 / 0, m = 1 / 0, f = 1 / 0, g = 1 / 0, v = -1 / 0, y = -1 / 0, x = -1 / 0;
  const A = s !== null;
  for (let R = t * 6, P = (t + e) * 6; R < P; R += 6) {
    const C = h[R + 0], O = h[R + 1], B = C - O, Y = C + O;
    B < i && (i = B), Y > l && (l = Y), A && C < m && (m = C), A && C > v && (v = C);
    const H = h[R + 2], K = h[R + 3], Z = H - K, q = H + K;
    Z < r && (r = Z), q > u && (u = q), A && H < f && (f = H), A && H > y && (y = H);
    const ne = h[R + 4], se = h[R + 5], he = ne - se, me = ne + se;
    he < o && (o = he), me > d && (d = me), A && ne < g && (g = ne), A && ne > x && (x = ne);
  }
  n[0] = i, n[1] = r, n[2] = o, n[3] = l, n[4] = u, n[5] = d, A && (s[0] = m, s[1] = f, s[2] = g, s[3] = v, s[4] = y, s[5] = x);
}
function _u(h, t, e, n) {
  let s = 1 / 0, i = 1 / 0, r = 1 / 0, o = -1 / 0, l = -1 / 0, u = -1 / 0;
  for (let d = t * 6, m = (t + e) * 6; d < m; d += 6) {
    const f = h[d + 0];
    f < s && (s = f), f > o && (o = f);
    const g = h[d + 2];
    g < i && (i = g), g > l && (l = g);
    const v = h[d + 4];
    v < r && (r = v), v > u && (u = v);
  }
  n[0] = s, n[1] = i, n[2] = r, n[3] = o, n[4] = l, n[5] = u;
}
function Uu(h, t) {
  Nu(t);
  const e = h.attributes.position, n = h.index ? h.index.array : null, s = Es(h), i = new Float32Array(s * 6), r = e.normalized, o = e.array, l = e.offset || 0;
  let u = 3;
  e.isInterleavedBufferAttribute && (u = e.data.stride);
  const d = ["getX", "getY", "getZ"];
  for (let m = 0; m < s; m++) {
    const f = m * 3, g = m * 6;
    let v = f + 0, y = f + 1, x = f + 2;
    n && (v = n[v], y = n[y], x = n[x]), r || (v = v * u + l, y = y * u + l, x = x * u + l);
    for (let A = 0; A < 3; A++) {
      let R, P, C;
      r ? (R = e[d[A]](v), P = e[d[A]](y), C = e[d[A]](x)) : (R = o[v + A], P = o[y + A], C = o[x + A]);
      let O = R;
      P < O && (O = P), C < O && (O = C);
      let B = R;
      P > B && (B = P), C > B && (B = C);
      const Y = (B - O) / 2, H = A * 2;
      i[g + H + 0] = O + Y, i[g + H + 1] = Y + (Math.abs(O) + Y) * Pu, O < t[A] && (t[A] = O), B > t[A + 3] && (t[A + 3] = B);
    }
  }
  return i;
}
var en = 32;
var Bu = (h, t) => h.candidate - t.candidate;
var pn = new Array(en).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
}));
var Yi = new Float32Array(6);
function ku(h, t, e, n, s, i) {
  let r = -1, o = 0;
  if (i === Oc)
    r = yl(t), r !== -1 && (o = (t[r] + t[r + 3]) / 2);
  else if (i === Fu)
    r = yl(h), r !== -1 && (o = zu(e, n, s, r));
  else if (i === Ru) {
    const l = Bs(h);
    let u = _o * s;
    const d = n * 6, m = (n + s) * 6;
    for (let f = 0; f < 3; f++) {
      const g = t[f], v = (t[f + 3] - g) / en;
      if (s < en / 4) {
        const y = [...pn];
        y.length = s;
        let x = 0;
        for (let R = d; R < m; R += 6, x++) {
          const P = y[x];
          P.candidate = e[R + 2 * f], P.count = 0;
          const {
            bounds: C,
            leftCacheBounds: O,
            rightCacheBounds: B
          } = P;
          for (let Y = 0; Y < 3; Y++)
            B[Y] = 1 / 0, B[Y + 3] = -1 / 0, O[Y] = 1 / 0, O[Y + 3] = -1 / 0, C[Y] = 1 / 0, C[Y + 3] = -1 / 0;
          Gi(R, e, C);
        }
        y.sort(Bu);
        let A = s;
        for (let R = 0; R < A; R++) {
          const P = y[R];
          for (; R + 1 < A && y[R + 1].candidate === P.candidate; )
            y.splice(R + 1, 1), A--;
        }
        for (let R = d; R < m; R += 6) {
          const P = e[R + 2 * f];
          for (let C = 0; C < A; C++) {
            const O = y[C];
            P >= O.candidate ? Gi(R, e, O.rightCacheBounds) : (Gi(R, e, O.leftCacheBounds), O.count++);
          }
        }
        for (let R = 0; R < A; R++) {
          const P = y[R], C = P.count, O = s - P.count, B = P.leftCacheBounds, Y = P.rightCacheBounds;
          let H = 0;
          C !== 0 && (H = Bs(B) / l);
          let K = 0;
          O !== 0 && (K = Bs(Y) / l);
          const Z = Il + _o * (H * C + K * O);
          Z < u && (r = f, u = Z, o = P.candidate);
        }
      } else {
        for (let A = 0; A < en; A++) {
          const R = pn[A];
          R.count = 0, R.candidate = g + v + A * v;
          const P = R.bounds;
          for (let C = 0; C < 3; C++)
            P[C] = 1 / 0, P[C + 3] = -1 / 0;
        }
        for (let A = d; A < m; A += 6) {
          let R = ~~((e[A + 2 * f] - g) / v);
          R >= en && (R = en - 1);
          const P = pn[R];
          P.count++, Gi(A, e, P.bounds);
        }
        const y = pn[en - 1];
        wl(y.bounds, y.rightCacheBounds);
        for (let A = en - 2; A >= 0; A--) {
          const R = pn[A], P = pn[A + 1];
          Cl(R.bounds, P.rightCacheBounds, R.rightCacheBounds);
        }
        let x = 0;
        for (let A = 0; A < en - 1; A++) {
          const R = pn[A], P = R.count, C = R.bounds, O = pn[A + 1].rightCacheBounds;
          P !== 0 && (x === 0 ? wl(C, Yi) : Cl(C, Yi, Yi)), x += P;
          let B = 0, Y = 0;
          x !== 0 && (B = Bs(Yi) / l);
          const H = s - x;
          H !== 0 && (Y = Bs(O) / l);
          const K = Il + _o * (B * x + Y * H);
          K < u && (r = f, u = K, o = R.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);
  return { axis: r, pos: o };
}
function zu(h, t, e, n) {
  let s = 0;
  for (let i = t, r = t + e; i < r; i++)
    s += h[i * 6 + n * 2];
  return s / e;
}
var Hi = class {
  constructor() {
  }
};
function Vu(h, t, e, n, s, i) {
  let r = n, o = n + s - 1;
  const l = i.pos, u = i.axis * 2;
  for (; ; ) {
    for (; r <= o && e[r * 6 + u] < l; )
      r++;
    for (; r <= o && e[o * 6 + u] >= l; )
      o--;
    if (r < o) {
      for (let d = 0; d < 3; d++) {
        let m = t[r * 3 + d];
        t[r * 3 + d] = t[o * 3 + d], t[o * 3 + d] = m;
      }
      for (let d = 0; d < 6; d++) {
        let m = e[r * 6 + d];
        e[r * 6 + d] = e[o * 6 + d], e[o * 6 + d] = m;
      }
      r++, o--;
    } else
      return r;
  }
}
function Gu(h, t, e, n, s, i) {
  let r = n, o = n + s - 1;
  const l = i.pos, u = i.axis * 2;
  for (; ; ) {
    for (; r <= o && e[r * 6 + u] < l; )
      r++;
    for (; r <= o && e[o * 6 + u] >= l; )
      o--;
    if (r < o) {
      let d = h[r];
      h[r] = h[o], h[o] = d;
      for (let m = 0; m < 6; m++) {
        let f = e[r * 6 + m];
        e[r * 6 + m] = e[o * 6 + m], e[o * 6 + m] = f;
      }
      r++, o--;
    } else
      return r;
  }
}
function Yu(h, t) {
  const e = (h.index ? h.index.count : h.attributes.position.count) / 3, n = e > 2 ** 16, s = n ? 4 : 2, i = t ? new SharedArrayBuffer(e * s) : new ArrayBuffer(e * s), r = n ? new Uint32Array(i) : new Uint16Array(i);
  for (let o = 0, l = r.length; o < l; o++)
    r[o] = o;
  return r;
}
function Hu(h, t) {
  const e = h.geometry, n = e.index ? e.index.array : null, s = t.maxDepth, i = t.verbose, r = t.maxLeafTris, o = t.strategy, l = t.onProgress, u = Es(e), d = h._indirectBuffer;
  let m = false;
  const f = new Float32Array(6), g = new Float32Array(6), v = Uu(e, f), y = t.indirect ? Gu : Vu, x = [], A = t.indirect ? Dc(e) : Lc(e);
  if (A.length === 1) {
    const C = A[0], O = new Hi();
    O.boundingData = f, _u(v, C.offset, C.count, g), P(O, C.offset, C.count, g), x.push(O);
  } else
    for (let C of A) {
      const O = new Hi();
      O.boundingData = new Float32Array(6), Bo(v, C.offset, C.count, O.boundingData, g), P(O, C.offset, C.count, g), x.push(O);
    }
  return x;
  function R(C) {
    l && l(C / u);
  }
  function P(C, O, B, Y = null, H = 0) {
    if (!m && H >= s && (m = true, i && (console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`), console.warn(e))), B <= r || H >= s)
      return R(O + B), C.offset = O, C.count = B, C;
    const K = ku(C.boundingData, Y, v, O, B, o);
    if (K.axis === -1)
      return R(O + B), C.offset = O, C.count = B, C;
    const Z = y(d, n, v, O, B, K);
    if (Z === O || Z === O + B)
      R(O + B), C.offset = O, C.count = B;
    else {
      C.splitAxis = K.axis;
      const q = new Hi(), ne = O, se = Z - O;
      C.left = q, q.boundingData = new Float32Array(6), Bo(v, ne, se, q.boundingData, g), P(q, ne, se, g, H + 1);
      const he = new Hi(), me = Z, Ie = B - se;
      C.right = he, he.boundingData = new Float32Array(6), Bo(v, me, Ie, he.boundingData, g), P(he, me, Ie, g, H + 1);
    }
    return C;
  }
}
function Wu(h, t) {
  const e = h.geometry;
  t.indirect && (h._indirectBuffer = Yu(e, t.useSharedArrayBuffer), Lu(e) && !t.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), h._indirectBuffer || Du(e, t);
  const n = Hu(h, t);
  let s, i, r;
  const o = [], l = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let m = 0; m < n.length; m++) {
    const f = n[m];
    let g = u(f);
    const v = new l(yr * g);
    s = new Float32Array(v), i = new Uint32Array(v), r = new Uint16Array(v), d(0, f), o.push(v);
  }
  h._roots = o;
  return;
  function u(m) {
    return m.count ? 1 : 1 + u(m.left) + u(m.right);
  }
  function d(m, f) {
    const g = m / 4, v = m / 2, y = !!f.count, x = f.boundingData;
    for (let A = 0; A < 6; A++)
      s[g + A] = x[A];
    if (y) {
      const A = f.offset, R = f.count;
      return i[g + 6] = A, r[v + 14] = R, r[v + 15] = Wr, m + yr;
    } else {
      const A = f.left, R = f.right, P = f.splitAxis;
      let C;
      if (C = d(m + yr, A), C / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return i[g + 6] = C / 4, C = d(C, R), i[g + 7] = P, C;
    }
  }
}
var sn = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, e) {
    let n = 1 / 0, s = -1 / 0;
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i][e];
      n = o < n ? o : n, s = o > s ? o : s;
    }
    this.min = n, this.max = s;
  }
  setFromPoints(t, e) {
    let n = 1 / 0, s = -1 / 0;
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i], l = t.dot(o);
      n = l < n ? l : n, s = l > s ? l : s;
    }
    this.min = n, this.max = s;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
};
sn.prototype.setFromBox = function() {
  const h = new Vector3();
  return function(t, e) {
    const n = e.min, s = e.max;
    let i = 1 / 0, r = -1 / 0;
    for (let o = 0; o <= 1; o++)
      for (let l = 0; l <= 1; l++)
        for (let u = 0; u <= 1; u++) {
          h.x = n.x * o + s.x * (1 - o), h.y = n.y * l + s.y * (1 - l), h.z = n.z * u + s.z * (1 - u);
          const d = t.dot(h);
          i = Math.min(d, i), r = Math.max(d, r);
        }
    this.min = i, this.max = r;
  };
}();
var Ku = function() {
  const h = new Vector3(), t = new Vector3(), e = new Vector3();
  return function(n, s, i) {
    const r = n.start, o = h, l = s.start, u = t;
    e.subVectors(r, l), h.subVectors(n.end, n.start), t.subVectors(s.end, s.start);
    const d = e.dot(u), m = u.dot(o), f = u.dot(u), g = e.dot(o), v = o.dot(o) * f - m * m;
    let y, x;
    v !== 0 ? y = (d * m - g * f) / v : y = 0, x = (d + y * m) / f, i.x = y, i.y = x;
  };
}();
var Pa = function() {
  const h = new Vector2(), t = new Vector3(), e = new Vector3();
  return function(n, s, i, r) {
    Ku(n, s, h);
    let o = h.x, l = h.y;
    if (o >= 0 && o <= 1 && l >= 0 && l <= 1) {
      n.at(o, i), s.at(l, r);
      return;
    } else if (o >= 0 && o <= 1) {
      l < 0 ? s.at(0, r) : s.at(1, r), n.closestPointToPoint(r, true, i);
      return;
    } else if (l >= 0 && l <= 1) {
      o < 0 ? n.at(0, i) : n.at(1, i), s.closestPointToPoint(i, true, r);
      return;
    } else {
      let u;
      o < 0 ? u = n.start : u = n.end;
      let d;
      l < 0 ? d = s.start : d = s.end;
      const m = t, f = e;
      if (n.closestPointToPoint(d, true, t), s.closestPointToPoint(u, true, e), m.distanceToSquared(d) <= f.distanceToSquared(u)) {
        i.copy(m), r.copy(d);
        return;
      } else {
        i.copy(u), r.copy(f);
        return;
      }
    }
  };
}();
var ju = function() {
  const h = new Vector3(), t = new Vector3(), e = new Plane(), n = new Line3();
  return function(s, i) {
    const { radius: r, center: o } = s, { a: l, b: u, c: d } = i;
    if (n.start = l, n.end = u, n.closestPointToPoint(o, true, h).distanceTo(o) <= r || (n.start = l, n.end = d, n.closestPointToPoint(o, true, h).distanceTo(o) <= r) || (n.start = u, n.end = d, n.closestPointToPoint(o, true, h).distanceTo(o) <= r))
      return true;
    const m = i.getPlane(e);
    if (Math.abs(m.distanceToPoint(o)) <= r) {
      const f = m.projectPoint(o, t);
      if (i.containsPoint(f))
        return true;
    }
    return false;
  };
}();
var Xu = 1e-15;
function ko(h) {
  return Math.abs(h) < Xu;
}
var Lt = class extends Triangle {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new sn()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(t) {
    return ju(t, this);
  }
  update() {
    const t = this.a, e = this.b, n = this.c, s = this.points, i = this.satAxes, r = this.satBounds, o = i[0], l = r[0];
    this.getNormal(o), l.setFromPoints(o, s);
    const u = i[1], d = r[1];
    u.subVectors(t, e), d.setFromPoints(u, s);
    const m = i[2], f = r[2];
    m.subVectors(e, n), f.setFromPoints(m, s);
    const g = i[3], v = r[3];
    g.subVectors(n, t), v.setFromPoints(g, s), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, t), this.needsUpdate = false;
  }
};
Lt.prototype.closestPointToSegment = function() {
  const h = new Vector3(), t = new Vector3(), e = new Line3();
  return function(n, s = null, i = null) {
    const { start: r, end: o } = n, l = this.points;
    let u, d = 1 / 0;
    for (let m = 0; m < 3; m++) {
      const f = (m + 1) % 3;
      e.start.copy(l[m]), e.end.copy(l[f]), Pa(e, n, h, t), u = h.distanceToSquared(t), u < d && (d = u, s && s.copy(h), i && i.copy(t));
    }
    return this.closestPointToPoint(r, h), u = r.distanceToSquared(h), u < d && (d = u, s && s.copy(h), i && i.copy(r)), this.closestPointToPoint(o, h), u = o.distanceToSquared(h), u < d && (d = u, s && s.copy(h), i && i.copy(o)), Math.sqrt(d);
  };
}();
Lt.prototype.intersectsTriangle = function() {
  const h = new Lt(), t = new Array(3), e = new Array(3), n = new sn(), s = new sn(), i = new Vector3(), r = new Vector3(), o = new Vector3(), l = new Vector3(), u = new Vector3(), d = new Line3(), m = new Line3(), f = new Line3(), g = new Vector3();
  function v(y, x, A) {
    const R = y.points;
    let P = 0, C = -1;
    for (let O = 0; O < 3; O++) {
      const { start: B, end: Y } = d;
      B.copy(R[O]), Y.copy(R[(O + 1) % 3]), d.delta(r);
      const H = ko(x.distanceToPoint(B));
      if (ko(x.normal.dot(r)) && H) {
        A.copy(d), P = 2;
        break;
      }
      const K = x.intersectLine(d, g);
      if (!K && H && g.copy(B), (K || H) && !ko(g.distanceTo(Y))) {
        if (P <= 1)
          (P === 1 ? A.start : A.end).copy(g), H && (C = P);
        else if (P >= 2) {
          (C === 1 ? A.start : A.end).copy(g), P = 2;
          break;
        }
        if (P++, P === 2 && C === -1)
          break;
      }
    }
    return P;
  }
  return function(y, x = null, A = false) {
    this.needsUpdate && this.update(), y.isExtendedTriangle ? y.needsUpdate && y.update() : (h.copy(y), h.update(), y = h);
    const R = this.plane, P = y.plane;
    if (Math.abs(R.normal.dot(P.normal)) > 1 - 1e-10) {
      const C = this.satBounds, O = this.satAxes;
      e[0] = y.a, e[1] = y.b, e[2] = y.c;
      for (let H = 0; H < 4; H++) {
        const K = C[H], Z = O[H];
        if (n.setFromPoints(Z, e), K.isSeparated(n))
          return false;
      }
      const B = y.satBounds, Y = y.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let H = 0; H < 4; H++) {
        const K = B[H], Z = Y[H];
        if (n.setFromPoints(Z, t), K.isSeparated(n))
          return false;
      }
      for (let H = 0; H < 4; H++) {
        const K = O[H];
        for (let Z = 0; Z < 4; Z++) {
          const q = Y[Z];
          if (i.crossVectors(K, q), n.setFromPoints(i, t), s.setFromPoints(i, e), n.isSeparated(s))
            return false;
        }
      }
      return x && (A || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), x.start.set(0, 0, 0), x.end.set(0, 0, 0)), true;
    } else {
      const C = v(this, P, m);
      if (C === 1 && y.containsPoint(m.end))
        return x && (x.start.copy(m.end), x.end.copy(m.end)), true;
      if (C !== 2)
        return false;
      const O = v(y, R, f);
      if (O === 1 && this.containsPoint(f.end))
        return x && (x.start.copy(f.end), x.end.copy(f.end)), true;
      if (O !== 2)
        return false;
      if (m.delta(o), f.delta(l), o.dot(l) < 0) {
        let ne = f.start;
        f.start = f.end, f.end = ne;
      }
      const B = m.start.dot(o), Y = m.end.dot(o), H = f.start.dot(o), K = f.end.dot(o), Z = Y < H, q = B < K;
      return B !== K && H !== Y && Z === q ? false : (x && (u.subVectors(m.start, f.start), u.dot(o) > 0 ? x.start.copy(m.start) : x.start.copy(f.start), u.subVectors(m.end, f.end), u.dot(o) < 0 ? x.end.copy(m.end) : x.end.copy(f.end)), true);
    }
  };
}();
Lt.prototype.distanceToPoint = function() {
  const h = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, h), t.distanceTo(h);
  };
}();
Lt.prototype.distanceToTriangle = function() {
  const h = new Vector3(), t = new Vector3(), e = ["a", "b", "c"], n = new Line3(), s = new Line3();
  return function(i, r = null, o = null) {
    const l = r || o ? n : null;
    if (this.intersectsTriangle(i, l))
      return (r || o) && (r && l.getCenter(r), o && l.getCenter(o)), 0;
    let u = 1 / 0;
    for (let d = 0; d < 3; d++) {
      let m;
      const f = e[d], g = i[f];
      this.closestPointToPoint(g, h), m = g.distanceToSquared(h), m < u && (u = m, r && r.copy(h), o && o.copy(g));
      const v = this[f];
      i.closestPointToPoint(v, h), m = v.distanceToSquared(h), m < u && (u = m, r && r.copy(v), o && o.copy(h));
    }
    for (let d = 0; d < 3; d++) {
      const m = e[d], f = e[(d + 1) % 3];
      n.set(this[m], this[f]);
      for (let g = 0; g < 3; g++) {
        const v = e[g], y = e[(g + 1) % 3];
        s.set(i[v], i[y]), Pa(n, s, h, t);
        const x = h.distanceToSquared(t);
        x < u && (u = x, r && r.copy(h), o && o.copy(t));
      }
    }
    return Math.sqrt(u);
  };
}();
var ht = class {
  constructor(t, e, n) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new sn()), this.alignedSatBounds = new Array(3).fill().map(() => new sn()), this.needsUpdate = false, t && this.min.copy(t), e && this.max.copy(e), n && this.matrix.copy(n);
  }
  set(t, e, n) {
    this.min.copy(t), this.max.copy(e), this.matrix.copy(n), this.needsUpdate = true;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = true;
  }
};
ht.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const h = this.matrix, t = this.min, e = this.max, n = this.points;
    for (let l = 0; l <= 1; l++)
      for (let u = 0; u <= 1; u++)
        for (let d = 0; d <= 1; d++) {
          const m = 1 * l | 2 * u | 4 * d, f = n[m];
          f.x = l ? e.x : t.x, f.y = u ? e.y : t.y, f.z = d ? e.z : t.z, f.applyMatrix4(h);
        }
    const s = this.satBounds, i = this.satAxes, r = n[0];
    for (let l = 0; l < 3; l++) {
      const u = i[l], d = s[l], m = 1 << l, f = n[m];
      u.subVectors(r, f), d.setFromPoints(u, n);
    }
    const o = this.alignedSatBounds;
    o[0].setFromPointsField(n, "x"), o[1].setFromPointsField(n, "y"), o[2].setFromPointsField(n, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  };
}();
ht.prototype.intersectsBox = function() {
  const h = new sn();
  return function(t) {
    this.needsUpdate && this.update();
    const e = t.min, n = t.max, s = this.satBounds, i = this.satAxes, r = this.alignedSatBounds;
    if (h.min = e.x, h.max = n.x, r[0].isSeparated(h) || (h.min = e.y, h.max = n.y, r[1].isSeparated(h)) || (h.min = e.z, h.max = n.z, r[2].isSeparated(h)))
      return false;
    for (let o = 0; o < 3; o++) {
      const l = i[o], u = s[o];
      if (h.setFromBox(l, t), u.isSeparated(h))
        return false;
    }
    return true;
  };
}();
ht.prototype.intersectsTriangle = function() {
  const h = new Lt(), t = new Array(3), e = new sn(), n = new sn(), s = new Vector3();
  return function(i) {
    this.needsUpdate && this.update(), i.isExtendedTriangle ? i.needsUpdate && i.update() : (h.copy(i), h.update(), i = h);
    const r = this.satBounds, o = this.satAxes;
    t[0] = i.a, t[1] = i.b, t[2] = i.c;
    for (let m = 0; m < 3; m++) {
      const f = r[m], g = o[m];
      if (e.setFromPoints(g, t), f.isSeparated(e))
        return false;
    }
    const l = i.satBounds, u = i.satAxes, d = this.points;
    for (let m = 0; m < 3; m++) {
      const f = l[m], g = u[m];
      if (e.setFromPoints(g, d), f.isSeparated(e))
        return false;
    }
    for (let m = 0; m < 3; m++) {
      const f = o[m];
      for (let g = 0; g < 4; g++) {
        const v = u[g];
        if (s.crossVectors(f, v), e.setFromPoints(s, t), n.setFromPoints(s, d), e.isSeparated(n))
          return false;
      }
    }
    return true;
  };
}();
ht.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(h, t) {
    return this.needsUpdate && this.update(), t.copy(h).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  };
}();
ht.prototype.distanceToPoint = function() {
  const h = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, h), t.distanceTo(h);
  };
}();
ht.prototype.distanceToBox = function() {
  const h = ["x", "y", "z"], t = new Array(12).fill().map(() => new Line3()), e = new Array(12).fill().map(() => new Line3()), n = new Vector3(), s = new Vector3();
  return function(i, r = 0, o = null, l = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(i))
      return (o || l) && (i.getCenter(s), this.closestPointToPoint(s, n), i.closestPointToPoint(n, s), o && o.copy(n), l && l.copy(s)), 0;
    const u = r * r, d = i.min, m = i.max, f = this.points;
    let g = 1 / 0;
    for (let y = 0; y < 8; y++) {
      const x = f[y];
      s.copy(x).clamp(d, m);
      const A = x.distanceToSquared(s);
      if (A < g && (g = A, o && o.copy(x), l && l.copy(s), A < u))
        return Math.sqrt(A);
    }
    let v = 0;
    for (let y = 0; y < 3; y++)
      for (let x = 0; x <= 1; x++)
        for (let A = 0; A <= 1; A++) {
          const R = (y + 1) % 3, P = (y + 2) % 3, C = x << R | A << P, O = 1 << y | x << R | A << P, B = f[C], Y = f[O];
          t[v].set(B, Y);
          const H = h[y], K = h[R], Z = h[P], q = e[v], ne = q.start, se = q.end;
          ne[H] = d[H], ne[K] = x ? d[K] : m[K], ne[Z] = A ? d[Z] : m[K], se[H] = m[H], se[K] = x ? d[K] : m[K], se[Z] = A ? d[Z] : m[K], v++;
        }
    for (let y = 0; y <= 1; y++)
      for (let x = 0; x <= 1; x++)
        for (let A = 0; A <= 1; A++) {
          s.x = y ? m.x : d.x, s.y = x ? m.y : d.y, s.z = A ? m.z : d.z, this.closestPointToPoint(s, n);
          const R = s.distanceToSquared(n);
          if (R < g && (g = R, o && o.copy(n), l && l.copy(s), R < u))
            return Math.sqrt(R);
        }
    for (let y = 0; y < 12; y++) {
      const x = t[y];
      for (let A = 0; A < 12; A++) {
        const R = e[A];
        Pa(x, R, n, s);
        const P = n.distanceToSquared(s);
        if (P < g && (g = P, o && o.copy(n), l && l.copy(s), P < u))
          return Math.sqrt(P);
      }
    }
    return Math.sqrt(g);
  };
}();
var Ma = class {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
};
var Zu = class extends Ma {
  constructor() {
    super(() => new Lt());
  }
};
var wt = new Zu();
function gt(h, t) {
  return t[h + 15] === 65535;
}
function Et(h, t) {
  return t[h + 6];
}
function Ct(h, t) {
  return t[h + 14];
}
function Tt(h) {
  return h + 8;
}
function bt(h, t) {
  return t[h + 6];
}
function Nc(h, t) {
  return t[h + 7];
}
var Qu = class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t = [];
    let e = null;
    this.setBuffer = (n) => {
      e && t.push(e), e = n, this.float32Array = new Float32Array(n), this.uint16Array = new Uint16Array(n), this.uint32Array = new Uint32Array(n);
    }, this.clearBuffer = () => {
      e = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, t.length !== 0 && this.setBuffer(t.pop());
    };
  }
};
var ke2 = new Qu();
var In;
var ds;
var Xn = [];
var Wi = new Ma(() => new Box3());
function qu(h, t, e, n, s, i) {
  In = Wi.getPrimitive(), ds = Wi.getPrimitive(), Xn.push(In, ds), ke2.setBuffer(h._roots[t]);
  const r = aa(0, h.geometry, e, n, s, i);
  ke2.clearBuffer(), Wi.releasePrimitive(In), Wi.releasePrimitive(ds), Xn.pop(), Xn.pop();
  const o = Xn.length;
  return o > 0 && (ds = Xn[o - 1], In = Xn[o - 2]), r;
}
function aa(h, t, e, n, s = null, i = 0, r = 0) {
  const { float32Array: o, uint16Array: l, uint32Array: u } = ke2;
  let d = h * 2;
  if (gt(d, l)) {
    const m = Et(h, u), f = Ct(d, l);
    return Ye(h, o, In), n(m, f, false, r, i + h, In);
  } else {
    let m = function(q) {
      const { uint16Array: ne, uint32Array: se } = ke2;
      let he = q * 2;
      for (; !gt(he, ne); )
        q = Tt(q), he = q * 2;
      return Et(q, se);
    }, f = function(q) {
      const { uint16Array: ne, uint32Array: se } = ke2;
      let he = q * 2;
      for (; !gt(he, ne); )
        q = bt(q, se), he = q * 2;
      return Et(q, se) + Ct(he, ne);
    };
    const g = Tt(h), v = bt(h, u);
    let y = g, x = v, A, R, P, C;
    if (s && (P = In, C = ds, Ye(y, o, P), Ye(x, o, C), A = s(P), R = s(C), R < A)) {
      y = v, x = g;
      const q = A;
      A = R, R = q, P = C;
    }
    P || (P = In, Ye(y, o, P));
    const O = gt(y * 2, l), B = e(P, O, A, r + 1, i + y);
    let Y;
    if (B === vl) {
      const q = m(y), ne = f(y) - q;
      Y = n(q, ne, true, r + 1, i + y, P);
    } else
      Y = B && aa(
        y,
        t,
        e,
        n,
        s,
        i,
        r + 1
      );
    if (Y)
      return true;
    C = ds, Ye(x, o, C);
    const H = gt(x * 2, l), K = e(C, H, R, r + 1, i + x);
    let Z;
    if (K === vl) {
      const q = m(x), ne = f(x) - q;
      Z = n(q, ne, true, r + 1, i + x, C);
    } else
      Z = K && aa(
        x,
        t,
        e,
        n,
        s,
        i,
        r + 1
      );
    return !!Z;
  }
}
var ks = new Vector3();
var zo = new Vector3();
function Ju(h, t, e = {}, n = 0, s = 1 / 0) {
  const i = n * n, r = s * s;
  let o = 1 / 0, l = null;
  if (h.shapecast(
    {
      boundsTraverseOrder: (d) => (ks.copy(t).clamp(d.min, d.max), ks.distanceToSquared(t)),
      intersectsBounds: (d, m, f) => f < o && f < r,
      intersectsTriangle: (d, m) => {
        d.closestPointToPoint(t, ks);
        const f = t.distanceToSquared(ks);
        return f < o && (zo.copy(ks), o = f, l = m), f < i;
      }
    }
  ), o === 1 / 0)
    return null;
  const u = Math.sqrt(o);
  return e.point ? e.point.copy(zo) : e.point = zo.clone(), e.distance = u, e.faceIndex = l, e;
}
var Zn = new Vector3();
var Qn = new Vector3();
var qn = new Vector3();
var Ki = new Vector2();
var ji = new Vector2();
var Xi = new Vector2();
var Tl = new Vector3();
var bl = new Vector3();
var xl = new Vector3();
var Zi = new Vector3();
function $u(h, t, e, n, s, i) {
  let r;
  return i === BackSide ? r = h.intersectTriangle(n, e, t, true, s) : r = h.intersectTriangle(t, e, n, i !== DoubleSide, s), r === null ? null : {
    distance: h.origin.distanceTo(s),
    point: s.clone()
  };
}
function ed(h, t, e, n, s, i, r, o, l) {
  Zn.fromBufferAttribute(t, i), Qn.fromBufferAttribute(t, r), qn.fromBufferAttribute(t, o);
  const u = $u(h, Zn, Qn, qn, Zi, l);
  if (u) {
    n && (Ki.fromBufferAttribute(n, i), ji.fromBufferAttribute(n, r), Xi.fromBufferAttribute(n, o), u.uv = Triangle.getInterpolation(Zi, Zn, Qn, qn, Ki, ji, Xi, new Vector2())), s && (Ki.fromBufferAttribute(s, i), ji.fromBufferAttribute(s, r), Xi.fromBufferAttribute(s, o), u.uv1 = Triangle.getInterpolation(Zi, Zn, Qn, qn, Ki, ji, Xi, new Vector2())), e && (Tl.fromBufferAttribute(e, i), bl.fromBufferAttribute(e, r), xl.fromBufferAttribute(e, o), u.normal = Triangle.getInterpolation(Zi, Zn, Qn, qn, Tl, bl, xl, new Vector3()), u.normal.dot(h.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = {
      a: i,
      b: r,
      c: o,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(Zn, Qn, qn, d.normal), u.face = d, u.faceIndex = i;
  }
  return u;
}
function Kr(h, t, e, n, s) {
  const i = n * 3;
  let r = i + 0, o = i + 1, l = i + 2;
  const u = h.index;
  h.index && (r = u.getX(r), o = u.getX(o), l = u.getX(l));
  const { position: d, normal: m, uv: f, uv1: g } = h.attributes, v = ed(e, d, m, f, g, r, o, l, t);
  return v ? (v.faceIndex = n, s && s.push(v), v) : null;
}
function Qe(h, t, e, n) {
  const s = h.a, i = h.b, r = h.c;
  let o = t, l = t + 1, u = t + 2;
  e && (o = e.getX(o), l = e.getX(l), u = e.getX(u)), s.x = n.getX(o), s.y = n.getY(o), s.z = n.getZ(o), i.x = n.getX(l), i.y = n.getY(l), i.z = n.getZ(l), r.x = n.getX(u), r.y = n.getY(u), r.z = n.getZ(u);
}
function td(h, t, e, n, s, i) {
  const { geometry: r, _indirectBuffer: o } = h;
  for (let l = n, u = n + s; l < u; l++)
    Kr(r, t, e, l, i);
}
function nd(h, t, e, n, s) {
  const { geometry: i, _indirectBuffer: r } = h;
  let o = 1 / 0, l = null;
  for (let u = n, d = n + s; u < d; u++) {
    let m;
    m = Kr(i, t, e, u), m && m.distance < o && (l = m, o = m.distance);
  }
  return l;
}
function sd(h, t, e, n, s, i, r) {
  const { geometry: o } = e, { index: l } = o, u = o.attributes.position;
  for (let d = h, m = t + h; d < m; d++) {
    let f;
    if (f = d, Qe(r, f * 3, l, u), r.needsUpdate = true, n(r, f, s, i))
      return true;
  }
  return false;
}
function id(h, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = h.geometry, n = e.index ? e.index.array : null, s = e.attributes.position;
  let i, r, o, l, u = 0;
  const d = h._roots;
  for (let f = 0, g = d.length; f < g; f++)
    i = d[f], r = new Uint32Array(i), o = new Uint16Array(i), l = new Float32Array(i), m(0, u), u += i.byteLength;
  function m(f, g, v = false) {
    const y = f * 2;
    if (o[y + 15] === Wr) {
      const x = r[f + 6], A = o[y + 14];
      let R = 1 / 0, P = 1 / 0, C = 1 / 0, O = -1 / 0, B = -1 / 0, Y = -1 / 0;
      for (let H = 3 * x, K = 3 * (x + A); H < K; H++) {
        let Z = n[H];
        const q = s.getX(Z), ne = s.getY(Z), se = s.getZ(Z);
        q < R && (R = q), q > O && (O = q), ne < P && (P = ne), ne > B && (B = ne), se < C && (C = se), se > Y && (Y = se);
      }
      return l[f + 0] !== R || l[f + 1] !== P || l[f + 2] !== C || l[f + 3] !== O || l[f + 4] !== B || l[f + 5] !== Y ? (l[f + 0] = R, l[f + 1] = P, l[f + 2] = C, l[f + 3] = O, l[f + 4] = B, l[f + 5] = Y, true) : false;
    } else {
      const x = f + 8, A = r[f + 6], R = x + g, P = A + g;
      let C = v, O = false, B = false;
      t ? C || (O = t.has(R), B = t.has(P), C = !O && !B) : (O = true, B = true);
      const Y = C || O, H = C || B;
      let K = false;
      Y && (K = m(x, g, C));
      let Z = false;
      H && (Z = m(A, g, C));
      const q = K || Z;
      if (q)
        for (let ne = 0; ne < 3; ne++) {
          const se = x + ne, he = A + ne, me = l[se], Ie = l[se + 3], Ee = l[he], ue = l[he + 3];
          l[f + ne] = me < Ee ? me : Ee, l[f + ne + 3] = Ie > ue ? Ie : ue;
        }
      return q;
    }
  }
}
var Sl = new Box3();
function wn(h, t, e, n) {
  return Ye(h, t, Sl), e.intersectBox(Sl, n);
}
function rd(h, t, e, n, s, i) {
  const { geometry: r, _indirectBuffer: o } = h;
  for (let l = n, u = n + s; l < u; l++) {
    let d = o ? o[l] : l;
    Kr(r, t, e, d, i);
  }
}
function od(h, t, e, n, s) {
  const { geometry: i, _indirectBuffer: r } = h;
  let o = 1 / 0, l = null;
  for (let u = n, d = n + s; u < d; u++) {
    let m;
    m = Kr(i, t, e, r ? r[u] : u), m && m.distance < o && (l = m, o = m.distance);
  }
  return l;
}
function ad(h, t, e, n, s, i, r) {
  const { geometry: o } = e, { index: l } = o, u = o.attributes.position;
  for (let d = h, m = t + h; d < m; d++) {
    let f;
    if (f = e.resolveTriangleIndex(d), Qe(r, f * 3, l, u), r.needsUpdate = true, n(r, f, s, i))
      return true;
  }
  return false;
}
var Al = new Vector3();
function ld(h, t, e, n, s) {
  ke2.setBuffer(h._roots[t]), la(0, h, e, n, s), ke2.clearBuffer();
}
function la(h, t, e, n, s) {
  const { float32Array: i, uint16Array: r, uint32Array: o } = ke2, l = h * 2;
  if (gt(l, r)) {
    const u = Et(h, o), d = Ct(l, r);
    td(t, e, n, u, d, s);
  } else {
    const u = Tt(h);
    wn(u, i, n, Al) && la(u, t, e, n, s);
    const d = bt(h, o);
    wn(d, i, n, Al) && la(d, t, e, n, s);
  }
}
var Fl = new Vector3();
var cd = ["x", "y", "z"];
function hd(h, t, e, n) {
  ke2.setBuffer(h._roots[t]);
  const s = ca(0, h, e, n);
  return ke2.clearBuffer(), s;
}
function ca(h, t, e, n) {
  const { float32Array: s, uint16Array: i, uint32Array: r } = ke2;
  let o = h * 2;
  if (gt(o, i)) {
    const l = Et(h, r), u = Ct(o, i);
    return nd(t, e, n, l, u);
  } else {
    const l = Nc(h, r), u = cd[l], d = n.direction[u] >= 0;
    let m, f;
    d ? (m = Tt(h), f = bt(h, r)) : (m = bt(h, r), f = Tt(h));
    const g = wn(m, s, n, Fl) ? ca(m, t, e, n) : null;
    if (g) {
      const y = g.point[u];
      if (d ? y <= s[f + l] : (
        // min bounding data
        y >= s[f + l + 3]
      ))
        return g;
    }
    const v = wn(f, s, n, Fl) ? ca(f, t, e, n) : null;
    return g && v ? g.distance <= v.distance ? g : v : g || v || null;
  }
}
var Qi = new Box3();
var Jn = new Lt();
var $n = new Lt();
var zs = new Matrix4();
var Rl = new ht();
var qi = new ht();
function ud(h, t, e, n) {
  ke2.setBuffer(h._roots[t]);
  const s = ha(0, h, e, n);
  return ke2.clearBuffer(), s;
}
function ha(h, t, e, n, s = null) {
  const { float32Array: i, uint16Array: r, uint32Array: o } = ke2;
  let l = h * 2;
  if (s === null && (e.boundingBox || e.computeBoundingBox(), Rl.set(e.boundingBox.min, e.boundingBox.max, n), s = Rl), gt(l, r)) {
    const u = t.geometry, d = u.index, m = u.attributes.position, f = e.index, g = e.attributes.position, v = Et(h, o), y = Ct(l, r);
    if (zs.copy(n).invert(), e.boundsTree)
      return Ye(h, i, qi), qi.matrix.copy(zs), qi.needsUpdate = true, e.boundsTree.shapecast({
        intersectsBounds: (x) => qi.intersectsBox(x),
        intersectsTriangle: (x) => {
          x.a.applyMatrix4(n), x.b.applyMatrix4(n), x.c.applyMatrix4(n), x.needsUpdate = true;
          for (let A = v * 3, R = (y + v) * 3; A < R; A += 3)
            if (Qe($n, A, d, m), $n.needsUpdate = true, x.intersectsTriangle($n))
              return true;
          return false;
        }
      });
    for (let x = v * 3, A = (y + v) * 3; x < A; x += 3) {
      Qe(Jn, x, d, m), Jn.a.applyMatrix4(zs), Jn.b.applyMatrix4(zs), Jn.c.applyMatrix4(zs), Jn.needsUpdate = true;
      for (let R = 0, P = f.count; R < P; R += 3)
        if (Qe($n, R, f, g), $n.needsUpdate = true, Jn.intersectsTriangle($n))
          return true;
    }
  } else {
    const u = h + 8, d = o[h + 6];
    return Ye(u, i, Qi), !!(s.intersectsBox(Qi) && ha(u, t, e, n, s) || (Ye(d, i, Qi), s.intersectsBox(Qi) && ha(d, t, e, n, s)));
  }
}
var Ji = new Matrix4();
var Vo = new ht();
var Vs = new ht();
var dd = new Vector3();
var fd = new Vector3();
var pd = new Vector3();
var md = new Vector3();
function gd(h, t, e, n = {}, s = {}, i = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), Vo.set(t.boundingBox.min, t.boundingBox.max, e), Vo.needsUpdate = true;
  const o = h.geometry, l = o.attributes.position, u = o.index, d = t.attributes.position, m = t.index, f = wt.getPrimitive(), g = wt.getPrimitive();
  let v = dd, y = fd, x = null, A = null;
  s && (x = pd, A = md);
  let R = 1 / 0, P = null, C = null;
  return Ji.copy(e).invert(), Vs.matrix.copy(Ji), h.shapecast(
    {
      boundsTraverseOrder: (O) => Vo.distanceToBox(O),
      intersectsBounds: (O, B, Y) => Y < R && Y < r ? (B && (Vs.min.copy(O.min), Vs.max.copy(O.max), Vs.needsUpdate = true), true) : false,
      intersectsRange: (O, B) => {
        if (t.boundsTree)
          return t.boundsTree.shapecast({
            boundsTraverseOrder: (Y) => Vs.distanceToBox(Y),
            intersectsBounds: (Y, H, K) => K < R && K < r,
            intersectsRange: (Y, H) => {
              for (let K = Y, Z = Y + H; K < Z; K++) {
                Qe(g, 3 * K, m, d), g.a.applyMatrix4(e), g.b.applyMatrix4(e), g.c.applyMatrix4(e), g.needsUpdate = true;
                for (let q = O, ne = O + B; q < ne; q++) {
                  Qe(f, 3 * q, u, l), f.needsUpdate = true;
                  const se = f.distanceToTriangle(g, v, x);
                  if (se < R && (y.copy(v), A && A.copy(x), R = se, P = q, C = K), se < i)
                    return true;
                }
              }
            }
          });
        {
          const Y = Es(t);
          for (let H = 0, K = Y; H < K; H++) {
            Qe(g, 3 * H, m, d), g.a.applyMatrix4(e), g.b.applyMatrix4(e), g.c.applyMatrix4(e), g.needsUpdate = true;
            for (let Z = O, q = O + B; Z < q; Z++) {
              Qe(f, 3 * Z, u, l), f.needsUpdate = true;
              const ne = f.distanceToTriangle(g, v, x);
              if (ne < R && (y.copy(v), A && A.copy(x), R = ne, P = Z, C = H), ne < i)
                return true;
            }
          }
        }
      }
    }
  ), wt.releasePrimitive(f), wt.releasePrimitive(g), R === 1 / 0 ? null : (n.point ? n.point.copy(y) : n.point = y.clone(), n.distance = R, n.faceIndex = P, s && (s.point ? s.point.copy(A) : s.point = A.clone(), s.point.applyMatrix4(Ji), y.applyMatrix4(Ji), s.distance = y.sub(s.point).length(), s.faceIndex = C), n);
}
function Ed(h, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = h.geometry, n = e.index ? e.index.array : null, s = e.attributes.position;
  let i, r, o, l, u = 0;
  const d = h._roots;
  for (let f = 0, g = d.length; f < g; f++)
    i = d[f], r = new Uint32Array(i), o = new Uint16Array(i), l = new Float32Array(i), m(0, u), u += i.byteLength;
  function m(f, g, v = false) {
    const y = f * 2;
    if (o[y + 15] === Wr) {
      const x = r[f + 6], A = o[y + 14];
      let R = 1 / 0, P = 1 / 0, C = 1 / 0, O = -1 / 0, B = -1 / 0, Y = -1 / 0;
      for (let H = x, K = x + A; H < K; H++) {
        const Z = 3 * h.resolveTriangleIndex(H);
        for (let q = 0; q < 3; q++) {
          let ne = Z + q;
          ne = n ? n[ne] : ne;
          const se = s.getX(ne), he = s.getY(ne), me = s.getZ(ne);
          se < R && (R = se), se > O && (O = se), he < P && (P = he), he > B && (B = he), me < C && (C = me), me > Y && (Y = me);
        }
      }
      return l[f + 0] !== R || l[f + 1] !== P || l[f + 2] !== C || l[f + 3] !== O || l[f + 4] !== B || l[f + 5] !== Y ? (l[f + 0] = R, l[f + 1] = P, l[f + 2] = C, l[f + 3] = O, l[f + 4] = B, l[f + 5] = Y, true) : false;
    } else {
      const x = f + 8, A = r[f + 6], R = x + g, P = A + g;
      let C = v, O = false, B = false;
      t ? C || (O = t.has(R), B = t.has(P), C = !O && !B) : (O = true, B = true);
      const Y = C || O, H = C || B;
      let K = false;
      Y && (K = m(x, g, C));
      let Z = false;
      H && (Z = m(A, g, C));
      const q = K || Z;
      if (q)
        for (let ne = 0; ne < 3; ne++) {
          const se = x + ne, he = A + ne, me = l[se], Ie = l[se + 3], Ee = l[he], ue = l[he + 3];
          l[f + ne] = me < Ee ? me : Ee, l[f + ne + 3] = Ie > ue ? Ie : ue;
        }
      return q;
    }
  }
}
var Pl = new Vector3();
function vd(h, t, e, n, s) {
  ke2.setBuffer(h._roots[t]), ua(0, h, e, n, s), ke2.clearBuffer();
}
function ua(h, t, e, n, s) {
  const { float32Array: i, uint16Array: r, uint32Array: o } = ke2, l = h * 2;
  if (gt(l, r)) {
    const u = Et(h, o), d = Ct(l, r);
    rd(t, e, n, u, d, s);
  } else {
    const u = Tt(h);
    wn(u, i, n, Pl) && ua(u, t, e, n, s);
    const d = bt(h, o);
    wn(d, i, n, Pl) && ua(d, t, e, n, s);
  }
}
var Ml = new Vector3();
var Id = ["x", "y", "z"];
function yd(h, t, e, n) {
  ke2.setBuffer(h._roots[t]);
  const s = da(0, h, e, n);
  return ke2.clearBuffer(), s;
}
function da(h, t, e, n) {
  const { float32Array: s, uint16Array: i, uint32Array: r } = ke2;
  let o = h * 2;
  if (gt(o, i)) {
    const l = Et(h, r), u = Ct(o, i);
    return od(t, e, n, l, u);
  } else {
    const l = Nc(h, r), u = Id[l], d = n.direction[u] >= 0;
    let m, f;
    d ? (m = Tt(h), f = bt(h, r)) : (m = bt(h, r), f = Tt(h));
    const g = wn(m, s, n, Ml) ? da(m, t, e, n) : null;
    if (g) {
      const y = g.point[u];
      if (d ? y <= s[f + l] : (
        // min bounding data
        y >= s[f + l + 3]
      ))
        return g;
    }
    const v = wn(f, s, n, Ml) ? da(f, t, e, n) : null;
    return g && v ? g.distance <= v.distance ? g : v : g || v || null;
  }
}
var $i = new Box3();
var es = new Lt();
var ts = new Lt();
var Gs = new Matrix4();
var Ol = new ht();
var er = new ht();
function wd(h, t, e, n) {
  ke2.setBuffer(h._roots[t]);
  const s = fa(0, h, e, n);
  return ke2.clearBuffer(), s;
}
function fa(h, t, e, n, s = null) {
  const { float32Array: i, uint16Array: r, uint32Array: o } = ke2;
  let l = h * 2;
  if (s === null && (e.boundingBox || e.computeBoundingBox(), Ol.set(e.boundingBox.min, e.boundingBox.max, n), s = Ol), gt(l, r)) {
    const u = t.geometry, d = u.index, m = u.attributes.position, f = e.index, g = e.attributes.position, v = Et(h, o), y = Ct(l, r);
    if (Gs.copy(n).invert(), e.boundsTree)
      return Ye(h, i, er), er.matrix.copy(Gs), er.needsUpdate = true, e.boundsTree.shapecast({
        intersectsBounds: (x) => er.intersectsBox(x),
        intersectsTriangle: (x) => {
          x.a.applyMatrix4(n), x.b.applyMatrix4(n), x.c.applyMatrix4(n), x.needsUpdate = true;
          for (let A = v, R = y + v; A < R; A++)
            if (Qe(ts, 3 * t.resolveTriangleIndex(A), d, m), ts.needsUpdate = true, x.intersectsTriangle(ts))
              return true;
          return false;
        }
      });
    for (let x = v, A = y + v; x < A; x++) {
      const R = t.resolveTriangleIndex(x);
      Qe(es, 3 * R, d, m), es.a.applyMatrix4(Gs), es.b.applyMatrix4(Gs), es.c.applyMatrix4(Gs), es.needsUpdate = true;
      for (let P = 0, C = f.count; P < C; P += 3)
        if (Qe(ts, P, f, g), ts.needsUpdate = true, es.intersectsTriangle(ts))
          return true;
    }
  } else {
    const u = h + 8, d = o[h + 6];
    return Ye(u, i, $i), !!(s.intersectsBox($i) && fa(u, t, e, n, s) || (Ye(d, i, $i), s.intersectsBox($i) && fa(d, t, e, n, s)));
  }
}
var tr = new Matrix4();
var Go = new ht();
var Ys = new ht();
var Cd = new Vector3();
var Td = new Vector3();
var bd = new Vector3();
var xd = new Vector3();
function Sd(h, t, e, n = {}, s = {}, i = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), Go.set(t.boundingBox.min, t.boundingBox.max, e), Go.needsUpdate = true;
  const o = h.geometry, l = o.attributes.position, u = o.index, d = t.attributes.position, m = t.index, f = wt.getPrimitive(), g = wt.getPrimitive();
  let v = Cd, y = Td, x = null, A = null;
  s && (x = bd, A = xd);
  let R = 1 / 0, P = null, C = null;
  return tr.copy(e).invert(), Ys.matrix.copy(tr), h.shapecast(
    {
      boundsTraverseOrder: (O) => Go.distanceToBox(O),
      intersectsBounds: (O, B, Y) => Y < R && Y < r ? (B && (Ys.min.copy(O.min), Ys.max.copy(O.max), Ys.needsUpdate = true), true) : false,
      intersectsRange: (O, B) => {
        if (t.boundsTree) {
          const Y = t.boundsTree;
          return Y.shapecast({
            boundsTraverseOrder: (H) => Ys.distanceToBox(H),
            intersectsBounds: (H, K, Z) => Z < R && Z < r,
            intersectsRange: (H, K) => {
              for (let Z = H, q = H + K; Z < q; Z++) {
                const ne = Y.resolveTriangleIndex(Z);
                Qe(g, 3 * ne, m, d), g.a.applyMatrix4(e), g.b.applyMatrix4(e), g.c.applyMatrix4(e), g.needsUpdate = true;
                for (let se = O, he = O + B; se < he; se++) {
                  const me = h.resolveTriangleIndex(se);
                  Qe(f, 3 * me, u, l), f.needsUpdate = true;
                  const Ie = f.distanceToTriangle(g, v, x);
                  if (Ie < R && (y.copy(v), A && A.copy(x), R = Ie, P = se, C = Z), Ie < i)
                    return true;
                }
              }
            }
          });
        } else {
          const Y = Es(t);
          for (let H = 0, K = Y; H < K; H++) {
            Qe(g, 3 * H, m, d), g.a.applyMatrix4(e), g.b.applyMatrix4(e), g.c.applyMatrix4(e), g.needsUpdate = true;
            for (let Z = O, q = O + B; Z < q; Z++) {
              const ne = h.resolveTriangleIndex(Z);
              Qe(f, 3 * ne, u, l), f.needsUpdate = true;
              const se = f.distanceToTriangle(g, v, x);
              if (se < R && (y.copy(v), A && A.copy(x), R = se, P = Z, C = H), se < i)
                return true;
            }
          }
        }
      }
    }
  ), wt.releasePrimitive(f), wt.releasePrimitive(g), R === 1 / 0 ? null : (n.point ? n.point.copy(y) : n.point = y.clone(), n.distance = R, n.faceIndex = P, s && (s.point ? s.point.copy(A) : s.point = A.clone(), s.point.applyMatrix4(tr), y.applyMatrix4(tr), s.distance = y.sub(s.point).length(), s.faceIndex = C), n);
}
function Ad() {
  return typeof SharedArrayBuffer < "u";
}
var $s = new ke2.constructor();
var xr = new ke2.constructor();
var En = new Ma(() => new Box3());
var ns = new Box3();
var ss = new Box3();
var Yo = new Box3();
var Ho = new Box3();
var Wo = false;
function Fd(h, t, e, n) {
  if (Wo)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Wo = true;
  const s = h._roots, i = t._roots;
  let r, o = 0, l = 0;
  const u = new Matrix4().copy(e).invert();
  for (let d = 0, m = s.length; d < m; d++) {
    $s.setBuffer(s[d]), l = 0;
    const f = En.getPrimitive();
    Ye(0, $s.float32Array, f), f.applyMatrix4(u);
    for (let g = 0, v = i.length; g < v && (xr.setBuffer(i[d]), r = Rt(
      0,
      0,
      e,
      u,
      n,
      o,
      l,
      0,
      0,
      f
    ), xr.clearBuffer(), l += i[g].length, !r); g++)
      ;
    if (En.releasePrimitive(f), $s.clearBuffer(), o += s[d].length, r)
      break;
  }
  return Wo = false, r;
}
function Rt(h, t, e, n, s, i = 0, r = 0, o = 0, l = 0, u = null, d = false) {
  let m, f;
  d ? (m = xr, f = $s) : (m = $s, f = xr);
  const g = m.float32Array, v = m.uint32Array, y = m.uint16Array, x = f.float32Array, A = f.uint32Array, R = f.uint16Array, P = h * 2, C = t * 2, O = gt(P, y), B = gt(C, R);
  let Y = false;
  if (B && O)
    d ? Y = s(
      Et(t, A),
      Ct(t * 2, R),
      Et(h, v),
      Ct(h * 2, y),
      l,
      r + t,
      o,
      i + h
    ) : Y = s(
      Et(h, v),
      Ct(h * 2, y),
      Et(t, A),
      Ct(t * 2, R),
      o,
      i + h,
      l,
      r + t
    );
  else if (B) {
    const H = En.getPrimitive();
    Ye(t, x, H), H.applyMatrix4(e);
    const K = Tt(h), Z = bt(h, v);
    Ye(K, g, ns), Ye(Z, g, ss);
    const q = H.intersectsBox(ns), ne = H.intersectsBox(ss);
    Y = q && Rt(
      t,
      K,
      n,
      e,
      s,
      r,
      i,
      l,
      o + 1,
      H,
      !d
    ) || ne && Rt(
      t,
      Z,
      n,
      e,
      s,
      r,
      i,
      l,
      o + 1,
      H,
      !d
    ), En.releasePrimitive(H);
  } else {
    const H = Tt(t), K = bt(t, A);
    Ye(H, x, Yo), Ye(K, x, Ho);
    const Z = u.intersectsBox(Yo), q = u.intersectsBox(Ho);
    if (Z && q)
      Y = Rt(
        h,
        H,
        e,
        n,
        s,
        i,
        r,
        o,
        l + 1,
        u,
        d
      ) || Rt(
        h,
        K,
        e,
        n,
        s,
        i,
        r,
        o,
        l + 1,
        u,
        d
      );
    else if (Z)
      if (O)
        Y = Rt(
          h,
          H,
          e,
          n,
          s,
          i,
          r,
          o,
          l + 1,
          u,
          d
        );
      else {
        const ne = En.getPrimitive();
        ne.copy(Yo).applyMatrix4(e);
        const se = Tt(h), he = bt(h, v);
        Ye(se, g, ns), Ye(he, g, ss);
        const me = ne.intersectsBox(ns), Ie = ne.intersectsBox(ss);
        Y = me && Rt(
          H,
          se,
          n,
          e,
          s,
          r,
          i,
          l,
          o + 1,
          ne,
          !d
        ) || Ie && Rt(
          H,
          he,
          n,
          e,
          s,
          r,
          i,
          l,
          o + 1,
          ne,
          !d
        ), En.releasePrimitive(ne);
      }
    else if (q)
      if (O)
        Y = Rt(
          h,
          K,
          e,
          n,
          s,
          i,
          r,
          o,
          l + 1,
          u,
          d
        );
      else {
        const ne = En.getPrimitive();
        ne.copy(Ho).applyMatrix4(e);
        const se = Tt(h), he = bt(h, v);
        Ye(se, g, ns), Ye(he, g, ss);
        const me = ne.intersectsBox(ns), Ie = ne.intersectsBox(ss);
        Y = me && Rt(
          K,
          se,
          n,
          e,
          s,
          r,
          i,
          l,
          o + 1,
          ne,
          !d
        ) || Ie && Rt(
          K,
          he,
          n,
          e,
          s,
          r,
          i,
          l,
          o + 1,
          ne,
          !d
        ), En.releasePrimitive(ne);
      }
  }
  return Y;
}
var nr = new ht();
var Dl = new Box3();
var Oa = class _Oa {
  static serialize(t, e = {}) {
    e = {
      cloneBuffers: true,
      ...e
    };
    const n = t.geometry, s = t._roots, i = t._indirectBuffer, r = n.getIndex();
    let o;
    return e.cloneBuffers ? o = {
      roots: s.map((l) => l.slice()),
      index: r.array.slice(),
      indirectBuffer: i ? i.slice() : null
    } : o = {
      roots: s,
      index: r.array,
      indirectBuffer: i
    }, o;
  }
  static deserialize(t, e, n = {}) {
    n = {
      setIndex: true,
      indirect: !!t.indirectBuffer,
      ...n
    };
    const { index: s, roots: i, indirectBuffer: r } = t, o = new _Oa(e, { ...n, [Uo]: true });
    if (o._roots = i, o._indirectBuffer = r || null, n.setIndex) {
      const l = e.getIndex();
      if (l === null) {
        const u = new BufferAttribute(t.index, 1, false);
        e.setIndex(u);
      } else
        l.array !== s && (l.array.set(s), l.needsUpdate = true);
    }
    return o;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t, e = {}) {
    if (t.isBufferGeometry) {
      if (t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (e = Object.assign({
      strategy: Oc,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Uo]: false
    }, e), e.useSharedArrayBuffer && !Ad())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t, this._roots = null, this._indirectBuffer = null, e[Uo] || (Wu(this, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new Box3())));
    const { _indirectBuffer: n } = this;
    this.resolveTriangleIndex = e.indirect ? (s) => n[s] : (s) => s;
  }
  refit(t = null) {
    return (this.indirect ? Ed : id)(this, t);
  }
  traverse(t, e = 0) {
    const n = this._roots[e], s = new Uint32Array(n), i = new Uint16Array(n);
    r(0);
    function r(o, l = 0) {
      const u = o * 2, d = i[u + 15] === Wr;
      if (d) {
        const m = s[o + 6], f = i[u + 14];
        t(l, d, new Float32Array(n, o * 4, 6), m, f);
      } else {
        const m = o + yr / 4, f = s[o + 6], g = s[o + 7];
        t(l, d, new Float32Array(n, o * 4, 6), g) || (r(m, l + 1), r(f, l + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(t, e = FrontSide) {
    const n = this._roots, s = this.geometry, i = [], r = e.isMaterial, o = Array.isArray(e), l = s.groups, u = r ? e.side : e, d = this.indirect ? vd : ld;
    for (let m = 0, f = n.length; m < f; m++) {
      const g = o ? e[l[m].materialIndex].side : u, v = i.length;
      if (d(this, m, g, t, i), o) {
        const y = l[m].materialIndex;
        for (let x = v, A = i.length; x < A; x++)
          i[x].face.materialIndex = y;
      }
    }
    return i;
  }
  raycastFirst(t, e = FrontSide) {
    const n = this._roots, s = this.geometry, i = e.isMaterial, r = Array.isArray(e);
    let o = null;
    const l = s.groups, u = i ? e.side : e, d = this.indirect ? yd : hd;
    for (let m = 0, f = n.length; m < f; m++) {
      const g = r ? e[l[m].materialIndex].side : u, v = d(this, m, g, t);
      v != null && (o == null || v.distance < o.distance) && (o = v, r && (v.face.materialIndex = l[m].materialIndex));
    }
    return o;
  }
  intersectsGeometry(t, e) {
    let n = false;
    const s = this._roots, i = this.indirect ? wd : ud;
    for (let r = 0, o = s.length; r < o && (n = i(this, r, t, e), !n); r++)
      ;
    return n;
  }
  shapecast(t) {
    const e = wt.getPrimitive(), n = this.indirect ? ad : sd;
    let {
      boundsTraverseOrder: s,
      intersectsBounds: i,
      intersectsRange: r,
      intersectsTriangle: o
    } = t;
    if (r && o) {
      const m = r;
      r = (f, g, v, y, x) => m(f, g, v, y, x) ? true : n(f, g, this, o, v, y, e);
    } else
      r || (o ? r = (m, f, g, v) => n(m, f, this, o, g, v, e) : r = (m, f, g) => g);
    let l = false, u = 0;
    const d = this._roots;
    for (let m = 0, f = d.length; m < f; m++) {
      const g = d[m];
      if (l = qu(this, m, i, r, s, u), l)
        break;
      u += g.byteLength;
    }
    return wt.releasePrimitive(e), l;
  }
  bvhcast(t, e, n) {
    let {
      intersectsRanges: s,
      intersectsTriangles: i
    } = n;
    const r = wt.getPrimitive(), o = this.geometry.index, l = this.geometry.attributes.position, u = this.indirect ? (v) => {
      const y = this.resolveTriangleIndex(v);
      Qe(r, y * 3, o, l);
    } : (v) => {
      Qe(r, v * 3, o, l);
    }, d = wt.getPrimitive(), m = t.geometry.index, f = t.geometry.attributes.position, g = t.indirect ? (v) => {
      const y = t.resolveTriangleIndex(v);
      Qe(d, y * 3, m, f);
    } : (v) => {
      Qe(d, v * 3, m, f);
    };
    if (i) {
      const v = (y, x, A, R, P, C, O, B) => {
        for (let Y = A, H = A + R; Y < H; Y++) {
          g(Y), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = true;
          for (let K = y, Z = y + x; K < Z; K++)
            if (u(K), r.needsUpdate = true, i(r, d, K, Y, P, C, O, B))
              return true;
        }
        return false;
      };
      if (s) {
        const y = s;
        s = function(x, A, R, P, C, O, B, Y) {
          return y(x, A, R, P, C, O, B, Y) ? true : v(x, A, R, P, C, O, B, Y);
        };
      } else
        s = v;
    }
    return Fd(this, t, e, s);
  }
  /* Derived Cast Functions */
  intersectsBox(t, e) {
    return nr.set(t.min, t.max, e), nr.needsUpdate = true, this.shapecast(
      {
        intersectsBounds: (n) => nr.intersectsBox(n),
        intersectsTriangle: (n) => nr.intersectsTriangle(n)
      }
    );
  }
  intersectsSphere(t) {
    return this.shapecast(
      {
        intersectsBounds: (e) => t.intersectsBox(e),
        intersectsTriangle: (e) => e.intersectsSphere(t)
      }
    );
  }
  closestPointToGeometry(t, e, n = {}, s = {}, i = 0, r = 1 / 0) {
    return (this.indirect ? Sd : gd)(
      this,
      t,
      e,
      n,
      s,
      i,
      r
    );
  }
  closestPointToPoint(t, e = {}, n = 0, s = 1 / 0) {
    return Ju(
      this,
      t,
      e,
      n,
      s
    );
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((e) => {
      Ye(0, new Float32Array(e), Dl), t.union(Dl);
    }), t;
  }
};
function Ll(h, t, e) {
  return h === null || (h.point.applyMatrix4(t.matrixWorld), h.distance = h.point.distanceTo(e.ray.origin), h.object = t, h.distance < e.near || h.distance > e.far) ? null : h;
}
var Ko = new Ray();
var Nl = new Matrix4();
var Rd = Mesh.prototype.raycast;
function Pd(h, t) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    Nl.copy(this.matrixWorld).invert(), Ko.copy(h.ray).applyMatrix4(Nl);
    const e = this.geometry.boundsTree;
    if (h.firstHitOnly === true) {
      const n = Ll(e.raycastFirst(Ko, this.material), this, h);
      n && t.push(n);
    } else {
      const n = e.raycast(Ko, this.material);
      for (let s = 0, i = n.length; s < i; s++) {
        const r = Ll(n[s], this, h);
        r && t.push(r);
      }
    }
  } else
    Rd.call(this, h, t);
}
function Md(h) {
  return this.boundsTree = new Oa(this, h), this.boundsTree;
}
function Od() {
  this.boundsTree = null;
}
var $ = class {
  constructor() {
    S(this, "trigger", (t) => {
      const e = this.handlers.slice(0);
      for (const n of e)
        n(t);
    }), S(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(t) {
    this.handlers.push(t);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(t) {
    this.handlers = this.handlers.filter((e) => e !== t);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var ei = class {
  constructor() {
    S(this, "trigger", async (t) => {
      const e = this.handlers.slice(0);
      for (const n of e)
        await n(t);
    }), S(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(t) {
    this.handlers.push(t);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(t) {
    this.handlers = this.handlers.filter((e) => e !== t);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var Da = class {
  constructor(t) {
    S(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this), S(this, "isResizeable", () => "resize" in this && "getSize" in this), S(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this), S(this, "isHideable", () => "visible" in this), S(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this), this.components = t;
  }
};
var Fe = class extends Da {
};
var _c = class extends Da {
  constructor(t) {
    super(t), S(this, "worlds", /* @__PURE__ */ new Map()), S(this, "onWorldChanged", new $()), S(this, "currentWorld", null), this.onWorldChanged.add(({ world: e, action: n }) => {
      n === "removed" && this.worlds.delete(e.uuid);
    });
  }
};
var Dd = class extends _c {
  constructor() {
    super(...arguments), S(this, "hasCameraControls", () => "controls" in this);
  }
};
var Ld = class extends _c {
  constructor() {
    super(...arguments), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onDisposed", new $()), S(this, "onResize", new $()), S(this, "onClippingPlanesUpdated", new $()), S(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(t, e, n) {
    e.isLocal = n;
    const s = this.clippingPlanes.indexOf(e);
    t && s === -1 ? this.clippingPlanes.push(e) : !t && s > -1 && this.clippingPlanes.splice(s, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (i) => !i.isLocal
    );
  }
};
var Uc = class pa extends Fe {
  constructor(t) {
    super(t), S(this, "_disposedComponents", /* @__PURE__ */ new Set()), S(this, "enabled", true), t.add(pa.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, e = true, n = true) {
    t.removeFromParent();
    const s = t;
    s.dispose && s.dispose(), this.disposeGeometryAndMaterials(t, e), n && s.children && s.children.length && this.disposeChildren(s), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    t.boundsTree && t.disposeBoundsTree && t.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, e) {
    const n = t;
    n.geometry && this.disposeGeometry(n.geometry), e && n.material && pa.disposeMaterial(n), n.material = [], n.geometry = null;
  }
  disposeChildren(t) {
    for (const e of t.children)
      this.destroy(e);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const e of t.material)
          e.dispose();
      else
        t.material.dispose();
  }
};
S(Uc, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var rn = Uc;
var wr = 0;
var Nd = 1;
var _d = new Vector3();
var _l = new Line3();
var jo = new Plane();
var Ul = new Vector3();
var sr = new Triangle();
var Ud = class {
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new Bl(), this.unassigned = new Bl(), this.vertices = [];
  }
  setFromPoints(t) {
    if (t.length >= 4) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++)
        this.vertices.push(new Bd(t[e]));
      this.compute();
    }
    return this;
  }
  setFromObject(t) {
    const e = [];
    return t.updateMatrixWorld(true), t.traverse(function(n) {
      const s = n.geometry;
      if (s !== void 0) {
        const i = s.attributes.position;
        if (i !== void 0)
          for (let r = 0, o = i.count; r < o; r++) {
            const l = new Vector3();
            l.fromBufferAttribute(i, r).applyMatrix4(n.matrixWorld), e.push(l);
          }
      }
    }), this.setFromPoints(e);
  }
  containsPoint(t) {
    const e = this.faces;
    for (let n = 0, s = e.length; n < s; n++)
      if (e[n].distanceToPoint(t) > this.tolerance)
        return false;
    return true;
  }
  intersectRay(t, e) {
    const n = this.faces;
    let s = -1 / 0, i = 1 / 0;
    for (let r = 0, o = n.length; r < o; r++) {
      const l = n[r], u = l.distanceToPoint(t.origin), d = l.normal.dot(t.direction);
      if (u > 0 && d >= 0)
        return null;
      const m = d !== 0 ? -u / d : 0;
      if (!(m <= 0) && (d > 0 ? i = Math.min(m, i) : s = Math.max(m, s), s > i))
        return null;
    }
    return s !== -1 / 0 ? t.at(s, e) : t.at(i, e), e;
  }
  intersectsRay(t) {
    return this.intersectRay(t, _d) !== null;
  }
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(t, e) {
    return t.face = e, e.outside === null ? this.assigned.append(t) : this.assigned.insertBefore(e.outside, t), e.outside = t, this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(t, e) {
    return t === e.outside && (t.next !== null && t.next.face === e ? e.outside = t.next : e.outside = null), this.assigned.remove(t), this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(t) {
    if (t.outside !== null) {
      const e = t.outside;
      let n = t.outside;
      for (; n.next !== null && n.next.face === t; )
        n = n.next;
      return this.assigned.removeSubList(e, n), e.prev = n.next = null, t.outside = null, e;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(t, e) {
    const n = this.removeAllVerticesFromFace(t);
    if (n !== void 0)
      if (e === void 0)
        this.unassigned.appendChain(n);
      else {
        let s = n;
        do {
          const i = s.next;
          e.distanceToPoint(s.point) > this.tolerance ? this.addVertexToFace(s, e) : this.unassigned.append(s), s = i;
        } while (s !== null);
      }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(t) {
    if (this.unassigned.isEmpty() === false) {
      let e = this.unassigned.first();
      do {
        const n = e.next;
        let s = this.tolerance, i = null;
        for (let r = 0; r < t.length; r++) {
          const o = t[r];
          if (o.mark === wr) {
            const l = o.distanceToPoint(e.point);
            if (l > s && (s = l, i = o), s > 1e3 * this.tolerance)
              break;
          }
        }
        i !== null && this.addVertexToFace(e, i), e = n;
      } while (e !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const t = new Vector3(), e = new Vector3(), n = [], s = [];
    for (let i = 0; i < 3; i++)
      n[i] = s[i] = this.vertices[0];
    t.copy(this.vertices[0].point), e.copy(this.vertices[0].point);
    for (let i = 0, r = this.vertices.length; i < r; i++) {
      const o = this.vertices[i], l = o.point;
      for (let u = 0; u < 3; u++)
        l.getComponent(u) < t.getComponent(u) && (t.setComponent(u, l.getComponent(u)), n[u] = o);
      for (let u = 0; u < 3; u++)
        l.getComponent(u) > e.getComponent(u) && (e.setComponent(u, l.getComponent(u)), s[u] = o);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(t.x), Math.abs(e.x)) + Math.max(Math.abs(t.y), Math.abs(e.y)) + Math.max(Math.abs(t.z), Math.abs(e.z))), { min: n, max: s };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const t = this.vertices, e = this.computeExtremes(), n = e.min, s = e.max;
    let i = 0, r = 0;
    for (let f = 0; f < 3; f++) {
      const g = s[f].point.getComponent(f) - n[f].point.getComponent(f);
      g > i && (i = g, r = f);
    }
    const o = n[r], l = s[r];
    let u, d;
    i = 0, _l.set(o.point, l.point);
    for (let f = 0, g = this.vertices.length; f < g; f++) {
      const v = t[f];
      if (v !== o && v !== l) {
        _l.closestPointToPoint(v.point, true, Ul);
        const y = Ul.distanceToSquared(v.point);
        y > i && (i = y, u = v);
      }
    }
    i = -1, jo.setFromCoplanarPoints(o.point, l.point, u.point);
    for (let f = 0, g = this.vertices.length; f < g; f++) {
      const v = t[f];
      if (v !== o && v !== l && v !== u) {
        const y = Math.abs(jo.distanceToPoint(v.point));
        y > i && (i = y, d = v);
      }
    }
    const m = [];
    if (jo.distanceToPoint(d.point) < 0) {
      m.push(
        Mt.create(o, l, u),
        Mt.create(d, l, o),
        Mt.create(d, u, l),
        Mt.create(d, o, u)
      );
      for (let f = 0; f < 3; f++) {
        const g = (f + 1) % 3;
        m[f + 1].getEdge(2).setTwin(m[0].getEdge(g)), m[f + 1].getEdge(1).setTwin(m[g + 1].getEdge(0));
      }
    } else {
      m.push(
        Mt.create(o, u, l),
        Mt.create(d, o, l),
        Mt.create(d, l, u),
        Mt.create(d, u, o)
      );
      for (let f = 0; f < 3; f++) {
        const g = (f + 1) % 3;
        m[f + 1].getEdge(2).setTwin(m[0].getEdge((3 - f) % 3)), m[f + 1].getEdge(0).setTwin(m[g + 1].getEdge(1));
      }
    }
    for (let f = 0; f < 4; f++)
      this.faces.push(m[f]);
    for (let f = 0, g = t.length; f < g; f++) {
      const v = t[f];
      if (v !== o && v !== l && v !== u && v !== d) {
        i = this.tolerance;
        let y = null;
        for (let x = 0; x < 4; x++) {
          const A = this.faces[x].distanceToPoint(v.point);
          A > i && (i = A, y = this.faces[x]);
        }
        y !== null && this.addVertexToFace(v, y);
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const t = [];
    for (let e = 0; e < this.faces.length; e++) {
      const n = this.faces[e];
      n.mark === wr && t.push(n);
    }
    return this.faces = t, this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let t, e = 0;
      const n = this.assigned.first().face;
      let s = n.outside;
      do {
        const i = n.distanceToPoint(s.point);
        i > e && (e = i, t = s), s = s.next;
      } while (s !== null && s.face === n);
      return t;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(t, e, n, s) {
    this.deleteFaceVertices(n), n.mark = Nd;
    let i;
    e === null ? i = e = n.getEdge(0) : i = e.next;
    do {
      const r = i.twin, o = r.face;
      o.mark === wr && (o.distanceToPoint(t) > this.tolerance ? this.computeHorizon(t, r, o, s) : s.push(i)), i = i.next;
    } while (i !== e);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(t, e) {
    const n = Mt.create(t, e.tail(), e.head());
    return this.faces.push(n), n.getEdge(-1).setTwin(e.twin), n.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(t, e) {
    this.newFaces = [];
    let n = null, s = null;
    for (let i = 0; i < e.length; i++) {
      const r = e[i], o = this.addAdjoiningFace(t, r);
      n === null ? n = o : o.next.setTwin(s), this.newFaces.push(o.face), s = o;
    }
    return n.next.setTwin(s), this;
  }
  // Adds a vertex to the hull
  addVertexToHull(t) {
    const e = [];
    return this.unassigned.clear(), this.removeVertexFromFace(t, t.face), this.computeHorizon(t.point, null, t.face, e), this.addNewFaces(t, e), this.resolveUnassignedPoints(this.newFaces), this;
  }
  cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  compute() {
    let t;
    for (this.computeInitialHull(); (t = this.nextVertexToAdd()) !== void 0; )
      this.addVertexToHull(t);
    return this.reindexFaces(), this.cleanup(), this;
  }
};
var Mt = class _Mt {
  constructor() {
    this.normal = new Vector3(), this.midpoint = new Vector3(), this.area = 0, this.constant = 0, this.outside = null, this.mark = wr, this.edge = null;
  }
  static create(t, e, n) {
    const s = new _Mt(), i = new Xo(t, s), r = new Xo(e, s), o = new Xo(n, s);
    return i.next = o.prev = r, r.next = i.prev = o, o.next = r.prev = i, s.edge = i, s.compute();
  }
  getEdge(t) {
    let e = this.edge;
    for (; t > 0; )
      e = e.next, t--;
    for (; t < 0; )
      e = e.prev, t++;
    return e;
  }
  compute() {
    const t = this.edge.tail(), e = this.edge.head(), n = this.edge.next.head();
    return sr.set(t.point, e.point, n.point), sr.getNormal(this.normal), sr.getMidpoint(this.midpoint), this.area = sr.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) - this.constant;
  }
};
var Xo = class {
  constructor(t, e) {
    this.vertex = t, this.prev = null, this.next = null, this.twin = null, this.face = e;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const t = this.head(), e = this.tail();
    return e !== null ? e.point.distanceTo(t.point) : -1;
  }
  lengthSquared() {
    const t = this.head(), e = this.tail();
    return e !== null ? e.point.distanceToSquared(t.point) : -1;
  }
  setTwin(t) {
    return this.twin = t, t.twin = this, this;
  }
};
var Bd = class {
  constructor(t) {
    this.point = t, this.prev = null, this.next = null, this.face = null;
  }
};
var Bl = class {
  constructor() {
    this.head = null, this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return this.head = this.tail = null, this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(t, e) {
    return e.prev = t.prev, e.next = t, e.prev === null ? this.head = e : e.prev.next = e, t.prev = e, this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(t, e) {
    return e.prev = t, e.next = t.next, e.next === null ? this.tail = e : e.next.prev = e, t.next = e, this;
  }
  // Appends a vertex to the end of the linked list
  append(t) {
    return this.head === null ? this.head = t : this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t, this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(t) {
    for (this.head === null ? this.head = t : this.tail.next = t, t.prev = this.tail; t.next !== null; )
      t = t.next;
    return this.tail = t, this;
  }
  // Removes a vertex from the linked list
  remove(t) {
    return t.prev === null ? this.head = t.next : t.prev.next = t.next, t.next === null ? this.tail = t.prev : t.next.prev = t.prev, this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(t, e) {
    return t.prev === null ? this.head = e.next : t.prev.next = e.next, e.next === null ? this.tail = t.prev : e.next.prev = t.prev, this;
  }
  isEmpty() {
    return this.head === null;
  }
};
var ma = [2, 2, 1];
var ga = [1, 0, 0];
function Wt(h, t) {
  return h * 3 + t;
}
function kd(h) {
  const t = h.elements;
  let e = 0;
  for (let n = 0; n < 9; n++)
    e += t[n] * t[n];
  return Math.sqrt(e);
}
function zd(h) {
  const t = h.elements;
  let e = 0;
  for (let n = 0; n < 3; n++) {
    const s = t[Wt(ma[n], ga[n])];
    e += 2 * s * s;
  }
  return Math.sqrt(e);
}
function Vd(h, t) {
  let e = 0, n = 1;
  const s = h.elements;
  for (let u = 0; u < 3; u++) {
    const d = Math.abs(s[Wt(ma[u], ga[u])]);
    d > e && (e = d, n = u);
  }
  let i = 1, r = 0;
  const o = ga[n], l = ma[n];
  if (Math.abs(s[Wt(l, o)]) > Number.EPSILON) {
    const u = s[Wt(l, l)], d = s[Wt(o, o)], m = s[Wt(l, o)], f = (u - d) / 2 / m;
    let g;
    f < 0 ? g = -1 / (-f + Math.sqrt(1 + f * f)) : g = 1 / (f + Math.sqrt(1 + f * f)), i = 1 / Math.sqrt(1 + g * g), r = g * i;
  }
  return t.identity(), t.elements[Wt(o, o)] = i, t.elements[Wt(l, l)] = i, t.elements[Wt(l, o)] = r, t.elements[Wt(o, l)] = -r, t;
}
function Gd(h, t) {
  let e = 0, n = 0;
  const s = 10;
  t.unitary.identity(), t.diagonal.copy(h);
  const i = t.unitary, r = t.diagonal, o = new Matrix3(), l = new Matrix3(), u = Number.EPSILON * kd(r);
  for (; n < s && zd(r) > u; )
    Vd(r, o), l.copy(o).transpose(), r.multiply(o), r.premultiply(l), i.multiply(o), ++e > 2 && (n++, e = 0);
  return t;
}
function Yd(h) {
  const t = [];
  for (let je = 0; je < h.length - 2; je += 3) {
    const pe = h[je], Ge = h[je + 1], St = h[je + 2];
    t.push(new Vector3(pe, Ge, St));
  }
  const e = new Ud();
  e.setFromPoints(t);
  const n = {
    unitary: new Matrix3(),
    diagonal: new Matrix3()
  }, s = e.faces, i = [], r = [];
  for (let je = 0, pe = s.length; je < pe; je++) {
    const Ge = s[je];
    let St = Ge.edge;
    i.length = 0;
    do
      i.push(St), St = St.next;
    while (St !== Ge.edge);
    const Oe = i.length - 2;
    for (let _t = 1, qr = Oe; _t <= qr; _t++) {
      const At = i[0].vertex, ys = i[_t + 0].vertex, ws = i[_t + 1].vertex;
      r.push(At.point.x, At.point.y, At.point.z), r.push(ys.point.x, ys.point.y, ys.point.z), r.push(ws.point.x, ws.point.y, ws.point.z);
    }
  }
  const o = new Vector3(), l = new Vector3(), u = new Vector3(), d = new Vector3(), m = new Vector3(), f = new Vector3(), g = new Vector3(), v = new Vector3();
  let y = 0, x = 0, A = 0, R = 0, P = 0, C = 0, O = 0;
  for (let je = 0, pe = r.length; je < pe; je += 9) {
    o.fromArray(r, je), l.fromArray(r, je + 3), u.fromArray(r, je + 6), g.set(0, 0, 0), g.add(o).add(l).add(u).divideScalar(3), d.subVectors(l, o), m.subVectors(u, o);
    const Ge = f.crossVectors(d, m).length() / 2;
    v.add(f.copy(g).multiplyScalar(Ge)), y += Ge, x += (9 * g.x * g.x + o.x * o.x + l.x * l.x + u.x * u.x) * (Ge / 12), A += (9 * g.x * g.y + o.x * o.y + l.x * l.y + u.x * u.y) * (Ge / 12), R += (9 * g.x * g.z + o.x * o.z + l.x * l.z + u.x * u.z) * (Ge / 12), P += (9 * g.y * g.y + o.y * o.y + l.y * l.y + u.y * u.y) * (Ge / 12), C += (9 * g.y * g.z + o.y * o.z + l.y * l.z + u.y * u.z) * (Ge / 12), O += (9 * g.z * g.z + o.z * o.z + l.z * l.z + u.z * u.z) * (Ge / 12);
  }
  v.divideScalar(y), x /= y, A /= y, R /= y, P /= y, C /= y, O /= y, x -= v.x * v.x, A -= v.x * v.y, R -= v.x * v.z, P -= v.y * v.y, C -= v.y * v.z, O -= v.z * v.z;
  const B = new Matrix3();
  B.elements[0] = x, B.elements[1] = A, B.elements[2] = R, B.elements[3] = A, B.elements[4] = P, B.elements[5] = C, B.elements[6] = R, B.elements[7] = C, B.elements[8] = O, Gd(B, n);
  const Y = n.unitary, H = new Vector3(), K = new Vector3(), Z = new Vector3();
  Y.extractBasis(H, K, Z);
  let q = -1 / 0, ne = -1 / 0, se = -1 / 0, he = 1 / 0, me = 1 / 0, Ie = 1 / 0;
  for (let je = 0, pe = t.length; je < pe; je++) {
    const Ge = t[je];
    q = Math.max(H.dot(Ge), q), ne = Math.max(K.dot(Ge), ne), se = Math.max(Z.dot(Ge), se), he = Math.min(H.dot(Ge), he), me = Math.min(K.dot(Ge), me), Ie = Math.min(Z.dot(Ge), Ie);
  }
  H.multiplyScalar(0.5 * (he + q)), K.multiplyScalar(0.5 * (me + ne)), Z.multiplyScalar(0.5 * (Ie + se));
  const Ee = new Vector3(), ue = new Vector3(), Le = new Matrix3();
  Ee.add(H).add(K).add(Z), ue.x = q - he, ue.y = ne - me, ue.z = se - Ie, ue.multiplyScalar(0.5), Le.copy(Y);
  const { x: we, y: Ke, z: Nt } = ue, vt = new Matrix4();
  vt.makeScale(we * 2, Ke * 2, Nt * 2);
  const Is = new Matrix4();
  Is.makeTranslation(-we, -Ke, -Nt);
  const Cn = new Matrix4();
  Cn.makeTranslation(Ee.x, Ee.y, Ee.z);
  const Zt = new Matrix4();
  Zt.setFromMatrix3(Le);
  const Qt = new Matrix4();
  return Qt.multiply(Cn), Qt.multiply(Zt), Qt.multiply(Is), Qt.multiply(vt), { center: Ee, halfSizes: ue, rotation: Le, transformation: Qt };
}
function Hd(h, t, e) {
  const n = [
    h[0] - t[0],
    h[1] - t[1],
    h[2] - t[2]
  ];
  return e[0] * n[0] + e[1] * n[1] + e[2] * n[2] > 0;
}
var kl = class {
  static isTransparent(t) {
    return t.transparent && t.opacity < 1;
  }
};
var Ea = class $e {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0;
    return `${$e._lut[t & 255] + $e._lut[t >> 8 & 255] + $e._lut[t >> 16 & 255] + $e._lut[t >> 24 & 255]}-${$e._lut[e & 255]}${$e._lut[e >> 8 & 255]}-${$e._lut[e >> 16 & 15 | 64]}${$e._lut[e >> 24 & 255]}-${$e._lut[n & 63 | 128]}${$e._lut[n >> 8 & 255]}-${$e._lut[n >> 16 & 255]}${$e._lut[n >> 24 & 255]}${$e._lut[s & 255]}${$e._lut[s >> 8 & 255]}${$e._lut[s >> 16 & 255]}${$e._lut[s >> 24 & 255]}`.toLowerCase();
  }
  static validate(t) {
    if (!$e._pattern.test(t))
      throw new Error(
        `${t} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
S(Ea, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/), // prettier-ignore
S(Ea, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var La = Ea;
var Wd = class extends Fe {
  constructor(t, e) {
    super(t), S(this, "onDisposed", new $()), S(this, "onVertexFound", new $()), S(this, "onVertexLost", new $()), S(this, "components"), S(this, "workingPlane", null), S(this, "_pickedPoint", null), S(this, "_config"), S(this, "_enabled", false), this.components = t, this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...e
    }, this.enabled = false;
  }
  /**
   * Sets the enabled state of the VertexPicker.
   * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
   * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
   *
   * @param value - The new enabled state.
   */
  set enabled(t) {
    this._enabled = t, t || (this._pickedPoint = null);
  }
  /**
   * Gets the current enabled state of the VertexPicker.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the configuration for the VertexPicker component.
   *
   * @param value - A Partial object containing the configuration properties to update.
   * The properties not provided in the value object will retain their current values.
   *
   * @example
   * ```typescript
   * vertexPicker.config = {
   *   snapDistance: 0.5,
   *   showOnlyVertex: true,
   * };
   * ```
   */
  set config(t) {
    this._config = { ...this._config, ...t };
  }
  /**
   * Gets the current configuration for the VertexPicker component.
   *
   * @returns A copy of the current VertexPickerConfig object.
   *
   * @example
   * ```typescript
   * const currentConfig = vertexPicker.config;
   * console.log(currentConfig.snapDistance); // Output: 0.25
   * ```
   */
  get config() {
    return this._config;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onVertexFound.reset(), this.onVertexLost.reset(), this.components = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Performs the vertex picking operation based on the current state of the VertexPicker.
   *
   * @param world - The World instance to use for raycasting.
   *
   * @returns The current picked point, or null if no point is picked.
   *
   * @remarks
   * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
   * If enabled, it performs raycasting to find the closest intersecting object.
   * It then determines the closest vertex or point on the face, based on the configuration settings.
   * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
   * If the picked point is not on the working plane, it resets the `pickedPoint`.
   * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
   */
  get(t) {
    if (!this.enabled)
      return this._pickedPoint;
    const e = this.components.get(Dt).get(t).castRay();
    if (!e)
      return this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint;
    const n = this.getClosestVertex(e);
    return n ? !this.workingPlane || Math.abs(this.workingPlane.distanceToPoint(n)) < 1e-3 ? ((this._pickedPoint === null || !this._pickedPoint.equals(n)) && (this._pickedPoint = n.clone(), this.onVertexFound.trigger(this._pickedPoint)), this._pickedPoint) : (this._pickedPoint = null, this._pickedPoint) : (this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint);
  }
  getClosestVertex(t) {
    let e = new Vector3(), n = false, s = Number.MAX_SAFE_INTEGER;
    const i = this.getVertices(t);
    if (i === null)
      return null;
    for (const r of i) {
      if (!r)
        continue;
      const o = t.point.distanceTo(r);
      o > s || o > this._config.snapDistance || (n = true, e = r, s = t.point.distanceTo(r));
    }
    return n ? e : this.config.showOnlyVertex ? null : t.point;
  }
  getVertices(t) {
    const e = t.object;
    if (!t.face || !e)
      return null;
    const n = e.geometry, s = new Matrix4(), { instanceId: i } = t, r = i !== void 0, o = e instanceof InstancedMesh;
    return o && r && e.getMatrixAt(i, s), [
      this.getVertex(t.face.a, n),
      this.getVertex(t.face.b, n),
      this.getVertex(t.face.c, n)
    ].map((l) => (l && (o && r && l.applyMatrix4(s), l.applyMatrix4(e.matrixWorld)), l));
  }
  getVertex(t, e) {
    if (t === void 0)
      return null;
    const n = e.attributes.position;
    return new Vector3(
      n.getX(t),
      n.getY(t),
      n.getZ(t)
    );
  }
};
var Bc = class kc {
  constructor() {
    S(this, "onDisposed", new $()), S(this, "list", /* @__PURE__ */ new Map()), S(this, "enabled", false), S(this, "_clock"), S(this, "update", () => {
      if (!this.enabled)
        return;
      const t = this._clock.getDelta();
      for (const [e, n] of this.list)
        n.enabled && n.isUpdateable() && n.update(t);
      requestAnimationFrame(this.update);
    }), this._clock = new Clock(), kc.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  add(t, e) {
    if (this.list.has(t))
      throw new Error(
        "You're trying to add a component that already exists in the components instance. Use Components.get() instead."
      );
    La.validate(t), this.list.set(t, e);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  get(t) {
    const e = t.uuid;
    if (!this.list.has(e)) {
      const n = new t(this);
      return this.list.has(e) || this.add(e, n), n;
    }
    return this.list.get(e);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   *
   * @returns {void}
   */
  init() {
    this.enabled = true, this._clock.start(), this.update();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.enabled = false, e.isDisposeable() && e.dispose();
    this._clock.stop(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = Md, BufferGeometry.prototype.disposeBoundsTree = Od, Mesh.prototype.raycast = Pd;
  }
};
S(Bc, "release", "2.0.20");
var Kd = Bc;
var jd = class {
  constructor(t) {
    S(this, "_event"), S(this, "_position", new Vector2()), S(this, "onDisposed", new $()), S(this, "updateMouseInfo", (e) => {
      this._event = e;
    }), this.dom = t, this.setupEvents(true);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const t = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(t, this._event), this._position.y = this.getPositionY(t, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  getPositionY(t, e) {
    return -((e.clientY - t.top) / (t.bottom - t.top)) * 2 + 1;
  }
  getPositionX(t, e) {
    return (e.clientX - t.left) / (t.right - t.left) * 2 - 1;
  }
  setupEvents(t) {
    t ? this.dom.addEventListener("pointermove", this.updateMouseInfo) : this.dom.removeEventListener("pointermove", this.updateMouseInfo);
  }
};
var Xd = class {
  constructor(t, e) {
    S(this, "enabled", true), S(this, "components"), S(this, "onDisposed", new $()), S(this, "mouse"), S(this, "three", new Raycaster()), S(this, "world");
    const n = e.renderer;
    if (!n)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = e, this.mouse = new jd(n.three.domElement), this.components = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   */
  castRay(t = Array.from(this.world.meshes)) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const e = this.world.camera.three;
    return this.three.setFromCamera(this.mouse.position, e), this.intersect(t);
  }
  /**
   * Casts a ray from a given origin in a given direction and returns the first item found.
   * This method also takes into account the clipping planes used by the renderer.
   *
   * @param origin - The origin of the ray.
   * @param direction - The direction of the ray.
   * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
   * @returns The first intersection found or `null` if no intersection was found.
   */
  castRayFromVector(t, e, n = Array.from(this.world.meshes)) {
    return this.three.set(t, e), this.intersect(n);
  }
  intersect(t = Array.from(this.world.meshes)) {
    const e = this.three.intersectObjects(t), n = this.filterClippingPlanes(e);
    return n.length > 0 ? n[0] : null;
  }
  filterClippingPlanes(t) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const e = this.world.renderer.three;
    if (!e.clippingPlanes)
      return t;
    const n = e.clippingPlanes;
    return t.length <= 0 || !n || (n == null ? void 0 : n.length) <= 0 ? t : t.filter(
      (s) => n.every((i) => i.distanceToPoint(s.point) > 0)
    );
  }
};
var zc = class Vc extends Fe {
  constructor(t) {
    super(t), S(this, "enabled", true), S(this, "list", /* @__PURE__ */ new Map()), S(this, "onDisposed", new $()), t.add(Vc.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Xd(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
S(zc, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var Dt = zc;
var Zd = class extends Da {
  constructor() {
    super(...arguments), S(this, "meshes", /* @__PURE__ */ new Set()), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onDisposed", new $()), S(this, "isDisposing", false), S(this, "enabled", true), S(this, "uuid", La.create()), S(this, "name"), S(this, "_scene"), S(this, "_camera"), S(this, "_renderer", null);
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(t) {
    this._camera = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  /** {@link Disposable.dispose} */
  dispose(t = true) {
    if (this.enabled = false, this.isDisposing = true, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const e = this.components.get(rn);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const n of this.meshes)
        e.destroy(n);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.onDisposed.trigger();
  }
};
var Qd = class extends Ld {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(t, e, n) {
    super(t), S(this, "enabled", true), S(this, "container"), S(this, "three"), S(this, "_canvas"), S(this, "_parameters"), S(this, "_resizeObserver", null), S(this, "onContainerUpdated", new $()), S(this, "_resizing", false), S(this, "resize", (r) => {
      if (this._resizing)
        return;
      this._resizing = true, this.onContainerUpdated.trigger();
      const o = r ? r.x : this.container.clientWidth, l = r ? r.y : this.container.clientHeight;
      this.three.setSize(o, l), this.onResize.trigger(new Vector2(o, l)), this._resizing = false;
    }), S(this, "resizeEvent", () => {
      this.resize();
    }), S(this, "onContextLost", (r) => {
      r.preventDefault(), this.enabled = false;
    }), S(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      }), this.enabled = true;
    }), this.container = e, this._parameters = n, this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...n
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(true), this.resize(), this._canvas = this.three.domElement;
    const s = this.three.getContext(), { canvas: i } = s;
    i.addEventListener("webglcontextlost", this.onContextLost, false), i.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, e = this.currentWorld.camera.three;
    this.three.render(t, e), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.setupEvents(false), this.three.domElement.remove(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(t) {
    const e = this.three.domElement.parentElement;
    if (!e)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(e), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = true, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
};
var ye = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var J = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var is = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function On(h) {
  return h.isPerspectiveCamera;
}
function gn(h) {
  return h.isOrthographicCamera;
}
var rs = Math.PI * 2;
var zl = Math.PI / 2;
var Gc = 1e-5;
var Hs = Math.PI / 180;
function Pt(h, t, e) {
  return Math.max(t, Math.min(e, h));
}
function Ue2(h, t = Gc) {
  return Math.abs(h) < t;
}
function De(h, t, e = Gc) {
  return Ue2(h - t, e);
}
function Vl(h, t) {
  return Math.round(h / t) * t;
}
function Ws(h) {
  return isFinite(h) ? h : h < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Ks(h) {
  return Math.abs(h) < Number.MAX_VALUE ? h : h * (1 / 0);
}
function ir(h, t, e, n, s = 1 / 0, i) {
  n = Math.max(1e-4, n);
  const r = 2 / n, o = r * i, l = 1 / (1 + o + 0.48 * o * o + 0.235 * o * o * o);
  let u = h - t;
  const d = t, m = s * n;
  u = Pt(u, -m, m), t = h - u;
  const f = (e.value + r * u) * i;
  e.value = (e.value - r * f) * l;
  let g = t + (u + f) * l;
  return d - h > 0 == g > d && (g = d, e.value = (g - d) / i), g;
}
function Gl(h, t, e, n, s = 1 / 0, i, r) {
  n = Math.max(1e-4, n);
  const o = 2 / n, l = o * i, u = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
  let d = t.x, m = t.y, f = t.z, g = h.x - d, v = h.y - m, y = h.z - f;
  const x = d, A = m, R = f, P = s * n, C = P * P, O = g * g + v * v + y * y;
  if (O > C) {
    const me = Math.sqrt(O);
    g = g / me * P, v = v / me * P, y = y / me * P;
  }
  d = h.x - g, m = h.y - v, f = h.z - y;
  const B = (e.x + o * g) * i, Y = (e.y + o * v) * i, H = (e.z + o * y) * i;
  e.x = (e.x - o * B) * u, e.y = (e.y - o * Y) * u, e.z = (e.z - o * H) * u, r.x = d + (g + B) * u, r.y = m + (v + Y) * u, r.z = f + (y + H) * u;
  const K = x - h.x, Z = A - h.y, q = R - h.z, ne = r.x - x, se = r.y - A, he = r.z - R;
  return K * ne + Z * se + q * he > 0 && (r.x = x, r.y = A, r.z = R, e.x = (r.x - x) / i, e.y = (r.y - A) / i, e.z = (r.z - R) / i), r;
}
function Zo(h, t) {
  t.set(0, 0), h.forEach((e) => {
    t.x += e.clientX, t.y += e.clientY;
  }), t.x /= h.length, t.y /= h.length;
}
function Qo(h, t) {
  return gn(h) ? (console.warn(`${t} is not supported in OrthographicCamera`), true) : false;
}
var qd = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(t, e) {
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    const n = this._listeners[t];
    if (n !== void 0) {
      const s = n.indexOf(e);
      s !== -1 && n.splice(s, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(t) {
    if (!t) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(t) {
    const e = this._listeners[t.type];
    if (e !== void 0) {
      t.target = this;
      const n = e.slice(0);
      for (let s = 0, i = n.length; s < i; s++)
        n[s].call(this, t);
    }
  }
};
var Jd = "2.7.3";
var rr = 1 / 8;
var Yc = typeof window < "u";
var $d = Yc && /Mac/.test(navigator.platform);
var ef = !(Yc && "PointerEvent" in window);
var ve;
var Yl;
var or;
var qo;
var dt;
var be;
var Pe;
var os;
var js;
var zt;
var Vt;
var Dn;
var Hl;
var Wl;
var yt;
var Xs;
var as;
var Kl;
var Jo;
var jl;
var $o;
var ea;
var ar;
var oi = class _oi extends qd {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(t) {
    ve = t.THREE, Yl = Object.freeze(new ve.Vector3(0, 0, 0)), or = Object.freeze(new ve.Vector3(0, 1, 0)), qo = Object.freeze(new ve.Vector3(0, 0, 1)), dt = new ve.Vector2(), be = new ve.Vector3(), Pe = new ve.Vector3(), os = new ve.Vector3(), js = new ve.Vector3(), zt = new ve.Vector3(), Vt = new ve.Vector3(), Dn = new ve.Vector3(), Hl = new ve.Vector3(), Wl = new ve.Vector3(), yt = new ve.Spherical(), Xs = new ve.Spherical(), as = new ve.Box3(), Kl = new ve.Box3(), Jo = new ve.Sphere(), jl = new ve.Quaternion(), $o = new ve.Quaternion(), ea = new ve.Matrix4(), ar = new ve.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return J;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(t, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.verticalDragToForward = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = J.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = is.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new ve.Vector3(), this._focalOffsetVelocity = new ve.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (C, O, B) => {
      let Y, H;
      if (On(this._camera)) {
        const K = be.copy(this._camera.position).sub(this._target), Z = this._camera.getEffectiveFOV() * Hs, q = K.length() * Math.tan(Z * 0.5);
        Y = this.truckSpeed * C * q / this._elementRect.height, H = this.truckSpeed * O * q / this._elementRect.height;
      } else if (gn(this._camera)) {
        const K = this._camera;
        Y = C * (K.right - K.left) / K.zoom / this._elementRect.width, H = O * (K.top - K.bottom) / K.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (B ? this.setFocalOffset(this._focalOffsetEnd.x + Y, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(Y, 0, true), this.forward(-H, true)) : B ? this.setFocalOffset(this._focalOffsetEnd.x + Y, this._focalOffsetEnd.y + H, this._focalOffsetEnd.z, true) : this.truck(Y, H, true);
    }, this._rotateInternal = (C, O) => {
      const B = rs * this.azimuthRotateSpeed * C / this._elementRect.height, Y = rs * this.polarRotateSpeed * O / this._elementRect.height;
      this.rotate(B, Y, true);
    }, this._dollyInternal = (C, O, B) => {
      const Y = Math.pow(0.95, -C * this.dollySpeed), H = this._sphericalEnd.radius, K = this._sphericalEnd.radius * Y, Z = Pt(K, this.minDistance, this.maxDistance), q = Z - K;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(K, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(q, true), this._dollyToNoClamp(Z, true)) : this._dollyToNoClamp(Z, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? K : Z) - H, this._dollyControlCoord.set(O, B)), this._lastDollyDirection = Math.sign(-C);
    }, this._zoomInternal = (C, O, B) => {
      const Y = Math.pow(0.95, C * this.dollySpeed), H = this._zoom, K = this._zoom * Y;
      this.zoomTo(K, true), this.dollyToCursor && (this._changedZoom += K - H, this._dollyControlCoord.set(O, B));
    }, typeof ve > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = new ve.Quaternion().setFromUnitVectors(this._camera.up, or), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = J.NONE, this._target = new ve.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new ve.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new ve.Spherical().setFromVector3(be.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new ve.Vector3(),
      new ve.Vector3(),
      new ve.Vector3(),
      new ve.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new ve.Box3(new ve.Vector3(-1 / 0, -1 / 0, -1 / 0), new ve.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new ve.Vector2(), this.mouseButtons = {
      left: J.ROTATE,
      middle: J.DOLLY,
      right: J.TRUCK,
      wheel: On(this._camera) ? J.DOLLY : gn(this._camera) ? J.ZOOM : J.NONE
    }, this.touches = {
      one: J.TOUCH_ROTATE,
      two: On(this._camera) ? J.TOUCH_DOLLY_TRUCK : gn(this._camera) ? J.TOUCH_ZOOM_TRUCK : J.NONE,
      three: J.TOUCH_TRUCK
    };
    const n = new ve.Vector2(), s = new ve.Vector2(), i = new ve.Vector2(), r = (C) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const Y = this._domElement.getBoundingClientRect(), H = C.clientX / Y.width, K = C.clientY / Y.height;
        if (H < this._interactiveArea.left || H > this._interactiveArea.right || K < this._interactiveArea.top || K > this._interactiveArea.bottom)
          return;
      }
      const O = C.pointerType !== "mouse" ? null : (C.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (C.buttons & ye.MIDDLE) === ye.MIDDLE ? ye.MIDDLE : (C.buttons & ye.RIGHT) === ye.RIGHT ? ye.RIGHT : null;
      if (O !== null) {
        const Y = this._findPointerByMouseButton(O);
        Y && this._disposePointer(Y);
      }
      if ((C.buttons & ye.LEFT) === ye.LEFT && this._lockedPointer)
        return;
      const B = {
        pointerId: C.pointerId,
        clientX: C.clientX,
        clientY: C.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: O
      };
      this._activePointers.push(B), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.ownerDocument.addEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", d), this._isDragging = true, y(C);
    }, o = (C) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const Y = this._domElement.getBoundingClientRect(), H = C.clientX / Y.width, K = C.clientY / Y.height;
        if (H < this._interactiveArea.left || H > this._interactiveArea.right || K < this._interactiveArea.top || K > this._interactiveArea.bottom)
          return;
      }
      const O = (C.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (C.buttons & ye.MIDDLE) === ye.MIDDLE ? ye.MIDDLE : (C.buttons & ye.RIGHT) === ye.RIGHT ? ye.RIGHT : null;
      if (O !== null) {
        const Y = this._findPointerByMouseButton(O);
        Y && this._disposePointer(Y);
      }
      const B = {
        pointerId: 1,
        clientX: C.clientX,
        clientY: C.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (C.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (C.buttons & ye.MIDDLE) === ye.LEFT ? ye.MIDDLE : (C.buttons & ye.RIGHT) === ye.LEFT ? ye.RIGHT : null
      };
      this._activePointers.push(B), this._domElement.ownerDocument.removeEventListener("mousemove", u), this._domElement.ownerDocument.removeEventListener("mouseup", m), this._domElement.ownerDocument.addEventListener("mousemove", u), this._domElement.ownerDocument.addEventListener("mouseup", m), this._isDragging = true, y(C);
    }, l = (C) => {
      C.cancelable && C.preventDefault();
      const O = C.pointerId, B = this._lockedPointer || this._findPointerById(O);
      if (B) {
        if (B.clientX = C.clientX, B.clientY = C.clientY, B.deltaX = C.movementX, B.deltaY = C.movementY, this._state = 0, C.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (C.buttons & ye.LEFT) === ye.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (C.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (C.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right);
        x();
      }
    }, u = (C) => {
      const O = this._lockedPointer || this._findPointerById(1);
      O && (O.clientX = C.clientX, O.clientY = C.clientY, O.deltaX = C.movementX, O.deltaY = C.movementY, this._state = 0, (this._lockedPointer || (C.buttons & ye.LEFT) === ye.LEFT) && (this._state = this._state | this.mouseButtons.left), (C.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (C.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right), x());
    }, d = (C) => {
      const O = this._findPointerById(C.pointerId);
      if (!(O && O === this._lockedPointer)) {
        if (O && this._disposePointer(O), C.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = J.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = J.NONE;
        A();
      }
    }, m = () => {
      const C = this._findPointerById(1);
      C && C === this._lockedPointer || (C && this._disposePointer(C), this._state = J.NONE, A());
    };
    let f = -1;
    const g = (C) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === J.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const K = this._domElement.getBoundingClientRect(), Z = C.clientX / K.width, q = C.clientY / K.height;
        if (Z < this._interactiveArea.left || Z > this._interactiveArea.right || q < this._interactiveArea.top || q > this._interactiveArea.bottom)
          return;
      }
      if (C.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === J.ROTATE || this.mouseButtons.wheel === J.TRUCK) {
        const K = performance.now();
        f - K < 1e3 && this._getClientRect(this._elementRect), f = K;
      }
      const O = $d ? -1 : -3, B = C.deltaMode === 1 ? C.deltaY / O : C.deltaY / (O * 10), Y = this.dollyToCursor ? (C.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, H = this.dollyToCursor ? (C.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case J.ROTATE: {
          this._rotateInternal(C.deltaX, C.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case J.TRUCK: {
          this._truckInternal(C.deltaX, C.deltaY, false), this._isUserControllingTruck = true;
          break;
        }
        case J.OFFSET: {
          this._truckInternal(C.deltaX, C.deltaY, true), this._isUserControllingOffset = true;
          break;
        }
        case J.DOLLY: {
          this._dollyInternal(-B, Y, H), this._isUserControllingDolly = true;
          break;
        }
        case J.ZOOM: {
          this._zoomInternal(-B, Y, H), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, v = (C) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _oi.ACTION.NONE) {
          const O = C instanceof PointerEvent ? C.pointerId : 0, B = this._findPointerById(O);
          B && this._disposePointer(B), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.ownerDocument.removeEventListener("mousemove", u), this._domElement.ownerDocument.removeEventListener("mouseup", m);
          return;
        }
        C.preventDefault();
      }
    }, y = (C) => {
      if (this._enabled) {
        if (Zo(this._activePointers, dt), this._getClientRect(this._elementRect), n.copy(dt), s.copy(dt), this._activePointers.length >= 2) {
          const O = dt.x - this._activePointers[1].clientX, B = dt.y - this._activePointers[1].clientY, Y = Math.sqrt(O * O + B * B);
          i.set(0, Y);
          const H = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, K = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
          s.set(H, K);
        }
        if (this._state = 0, !C)
          this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
        else if ("pointerType" in C && C.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          !this._lockedPointer && (C.buttons & ye.LEFT) === ye.LEFT && (this._state = this._state | this.mouseButtons.left), (C.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (C.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right);
        ((this._state & J.ROTATE) === J.ROTATE || (this._state & J.TOUCH_ROTATE) === J.TOUCH_ROTATE || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & J.TRUCK) === J.TRUCK || (this._state & J.TOUCH_TRUCK) === J.TOUCH_TRUCK || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & J.DOLLY) === J.DOLLY || (this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & J.ZOOM) === J.ZOOM || (this._state & J.TOUCH_ZOOM) === J.TOUCH_ZOOM || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & J.OFFSET) === J.OFFSET || (this._state & J.TOUCH_OFFSET) === J.TOUCH_OFFSET || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
      }
    }, x = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, Zo(this._activePointers, dt);
      const C = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, O = C ? -C.deltaX : s.x - dt.x, B = C ? -C.deltaY : s.y - dt.y;
      if (s.copy(dt), ((this._state & J.ROTATE) === J.ROTATE || (this._state & J.TOUCH_ROTATE) === J.TOUCH_ROTATE || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(O, B), this._isUserControllingRotate = true), (this._state & J.DOLLY) === J.DOLLY || (this._state & J.ZOOM) === J.ZOOM) {
        const Y = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, H = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, K = this.dollyDragInverted ? -1 : 1;
        (this._state & J.DOLLY) === J.DOLLY ? (this._dollyInternal(K * B * rr, Y, H), this._isUserControllingDolly = true) : (this._zoomInternal(K * B * rr, Y, H), this._isUserControllingZoom = true);
      }
      if ((this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_ZOOM) === J.TOUCH_ZOOM || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) {
        const Y = dt.x - this._activePointers[1].clientX, H = dt.y - this._activePointers[1].clientY, K = Math.sqrt(Y * Y + H * H), Z = i.y - K;
        i.set(0, K);
        const q = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, ne = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(Z * rr, q, ne), this._isUserControllingDolly = true) : (this._zoomInternal(Z * rr, q, ne), this._isUserControllingZoom = true);
      }
      ((this._state & J.TRUCK) === J.TRUCK || (this._state & J.TOUCH_TRUCK) === J.TOUCH_TRUCK || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK) && (this._truckInternal(O, B, false), this._isUserControllingTruck = true), ((this._state & J.OFFSET) === J.OFFSET || (this._state & J.TOUCH_OFFSET) === J.TOUCH_OFFSET || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET) && (this._truckInternal(O, B, true), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, A = () => {
      Zo(this._activePointers, dt), s.copy(dt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", u), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.ownerDocument.removeEventListener("mouseup", m), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", R), this._domElement.ownerDocument.addEventListener("pointerlockerror", P), this._domElement.ownerDocument.addEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", d), y());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", P));
    };
    const R = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, P = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (C) => {
      this._domElement = C, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), ef && this._domElement.addEventListener("mousedown", o), this._domElement.addEventListener("pointercancel", d), this._domElement.addEventListener("wheel", g, { passive: false }), this._domElement.addEventListener("contextmenu", v);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("mousedown", o), this._domElement.removeEventListener("pointercancel", d), this._domElement.removeEventListener("wheel", g, { passive: false }), this._domElement.removeEventListener("contextmenu", v), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", u), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.ownerDocument.removeEventListener("mouseup", m), this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", P));
    }, this.cancel = () => {
      this._state !== J.NONE && (this._state = J.NONE, this._activePointers.length = 0, A());
    }, e && this.connect(e), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(t) {
    this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this._domElement && (t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(t) {
    this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t) {
    this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t) {
    this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t) {
    this._boundaryEnclosesCamera = t, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(t) {
    this._interactiveArea.width = Pt(t.width, 0, 1), this._interactiveArea.height = Pt(t.height, 0, 1), this._interactiveArea.x = Pt(t.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Pt(t.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    super.addEventListener(t, e);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    super.removeEventListener(t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(t, e, n = false) {
    return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, n);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(t, e = false) {
    return this.rotateTo(t, this._sphericalEnd.phi, e);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(t, e = false) {
    return this.rotateTo(this._sphericalEnd.theta, t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(t, e, n = false) {
    this._isUserControllingRotate = false;
    const s = Pt(t, this.minAzimuthAngle, this.maxAzimuthAngle), i = Pt(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = s, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = true, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !n || De(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && De(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(t, e = false) {
    return this.dollyTo(this._sphericalEnd.radius - t, e);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(t, e = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = is.NONE, this._changedDolly = 0, this._dollyToNoClamp(Pt(t, this.minDistance, this.maxDistance), e);
  }
  _dollyToNoClamp(t, e = false) {
    const n = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const i = this._collisionTest(), r = De(i, this._spherical.radius);
      if (!(n > t) && r)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(t, i);
    } else
      this._sphericalEnd.radius = t;
    this._needsUpdate = true, e || (this._spherical.radius = this._sphericalEnd.radius);
    const s = !e || De(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(t, e = false) {
    this._targetEnd.add(this._getCameraDirection(js).multiplyScalar(t)), e || this._target.copy(this._targetEnd);
    const n = !e || De(this._target.x, this._targetEnd.x, this.restThreshold) && De(this._target.y, this._targetEnd.y, this.restThreshold) && De(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(t, e = false) {
    return this.zoomTo(this._zoomEnd + t, e);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(t, e = false) {
    this._isUserControllingZoom = false, this._zoomEnd = Pt(t, this.minZoom, this.maxZoom), this._needsUpdate = true, e || (this._zoom = this._zoomEnd);
    const n = !e || De(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(n);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(t, e, n = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t, e, n);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(t, e, n = false) {
    this._camera.updateMatrix(), zt.setFromMatrixColumn(this._camera.matrix, 0), Vt.setFromMatrixColumn(this._camera.matrix, 1), zt.multiplyScalar(t), Vt.multiplyScalar(-e);
    const s = be.copy(zt).add(Vt), i = Pe.copy(this._targetEnd).add(s);
    return this.moveTo(i.x, i.y, i.z, n);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(t, e = false) {
    be.setFromMatrixColumn(this._camera.matrix, 0), be.crossVectors(this._camera.up, be), be.multiplyScalar(t);
    const n = Pe.copy(this._targetEnd).add(be);
    return this.moveTo(n.x, n.y, n.z, e);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(t, e = false) {
    return be.copy(this._camera.up).multiplyScalar(t), this.moveTo(this._targetEnd.x + be.x, this._targetEnd.y + be.y, this._targetEnd.z + be.z, e);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(t, e, n, s = false) {
    this._isUserControllingTruck = false;
    const i = be.set(t, e, n).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = true, s || this._target.copy(this._targetEnd);
    const r = !s || De(this._target.x, this._targetEnd.x, this.restThreshold) && De(this._target.y, this._targetEnd.y, this.restThreshold) && De(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(t, e, n, s = false) {
    const i = be.set(t, e, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(i.x, i.y, i.z, s);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(t, e, { cover: n = false, paddingLeft: s = 0, paddingRight: i = 0, paddingBottom: r = 0, paddingTop: o = 0 } = {}) {
    const l = [], u = t.isBox3 ? as.copy(t) : as.setFromObject(t);
    u.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const d = Vl(this._sphericalEnd.theta, zl), m = Vl(this._sphericalEnd.phi, zl);
    l.push(this.rotateTo(d, m, e));
    const f = be.setFromSpherical(this._sphericalEnd).normalize(), g = jl.setFromUnitVectors(f, qo), v = De(Math.abs(f.y), 1);
    v && g.multiply($o.setFromAxisAngle(or, d)), g.multiply(this._yAxisUpSpaceInverse);
    const y = Kl.makeEmpty();
    Pe.copy(u.min).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(u.min).setX(u.max.x).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(u.min).setY(u.max.y).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(u.max).setZ(u.min.z).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(u.min).setZ(u.max.z).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(u.max).setY(u.min.y).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(u.max).setX(u.min.x).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(u.max).applyQuaternion(g), y.expandByPoint(Pe), y.min.x -= s, y.min.y -= r, y.max.x += i, y.max.y += o, g.setFromUnitVectors(qo, f), v && g.premultiply($o.invert()), g.premultiply(this._yAxisUpSpace);
    const x = y.getSize(be), A = y.getCenter(Pe).applyQuaternion(g);
    if (On(this._camera)) {
      const R = this.getDistanceToFitBox(x.x, x.y, x.z, n);
      l.push(this.moveTo(A.x, A.y, A.z, e)), l.push(this.dollyTo(R, e)), l.push(this.setFocalOffset(0, 0, 0, e));
    } else if (gn(this._camera)) {
      const R = this._camera, P = R.right - R.left, C = R.top - R.bottom, O = n ? Math.max(P / x.x, C / x.y) : Math.min(P / x.x, C / x.y);
      l.push(this.moveTo(A.x, A.y, A.z, e)), l.push(this.zoomTo(O, e)), l.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(l);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(t, e) {
    const n = [], s = t instanceof ve.Sphere ? Jo.copy(t) : _oi.createBoundingSphere(t, Jo);
    if (n.push(this.moveTo(s.center.x, s.center.y, s.center.z, e)), On(this._camera)) {
      const i = this.getDistanceToFitSphere(s.radius);
      n.push(this.dollyTo(i, e));
    } else if (gn(this._camera)) {
      const i = this._camera.right - this._camera.left, r = this._camera.top - this._camera.bottom, o = 2 * s.radius, l = Math.min(i / o, r / o);
      n.push(this.zoomTo(l, e));
    }
    return n.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(n);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(t, e, n, s, i, r, o = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = is.NONE, this._changedDolly = 0;
    const l = Pe.set(s, i, r), u = be.set(t, e, n);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(u.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, o || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const d = !o || De(this._target.x, this._targetEnd.x, this.restThreshold) && De(this._target.y, this._targetEnd.y, this.restThreshold) && De(this._target.z, this._targetEnd.z, this.restThreshold) && De(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && De(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && De(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(d);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(t, e, n, s, i, r, o, l, u, d, m, f, g, v = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = is.NONE, this._changedDolly = 0;
    const y = be.set(s, i, r), x = Pe.set(t, e, n);
    yt.setFromVector3(x.sub(y).applyQuaternion(this._yAxisUpSpace));
    const A = os.set(d, m, f), R = Pe.set(o, l, u);
    Xs.setFromVector3(R.sub(A).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(y.lerp(A, g));
    const P = Xs.theta - yt.theta, C = Xs.phi - yt.phi, O = Xs.radius - yt.radius;
    this._sphericalEnd.set(yt.radius + O * g, yt.phi + C * g, yt.theta + P * g), this.normalizeRotations(), this._needsUpdate = true, v || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const B = !v || De(this._target.x, this._targetEnd.x, this.restThreshold) && De(this._target.y, this._targetEnd.y, this.restThreshold) && De(this._target.z, this._targetEnd.z, this.restThreshold) && De(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && De(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && De(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(B);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(t, e, n, s = false) {
    return this.setLookAt(t, e, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(t, e, n, s = false) {
    const i = this.getPosition(be), r = this.setLookAt(i.x, i.y, i.z, t, e, n, s);
    return this._sphericalEnd.phi = Pt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(t, e, n, s = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(t, e, n), this._needsUpdate = true, s || this._focalOffset.copy(this._focalOffsetEnd);
    const i = !s || De(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && De(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && De(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(t, e, n) {
    this._camera.updateMatrixWorld(), zt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Vt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Dn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const s = be.set(t, e, n), i = s.distanceTo(this._camera.position), r = s.sub(this._camera.position);
    zt.multiplyScalar(r.x), Vt.multiplyScalar(r.y), Dn.multiplyScalar(r.z), be.copy(zt).add(Vt).add(Dn), be.z = be.z + i, this.dollyTo(i, false), this.setFocalOffset(-be.x, be.y, -be.z, false), this.moveTo(t, e, n, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(t) {
    if (!t) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(t, e, n, s) {
    if (t === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new ve.Vector4(), typeof t == "number" ? this._viewport.set(t, e, n, s) : this._viewport.copy(t);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(t, e, n, s = false) {
    if (Qo(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const i = t / e, r = this._camera.getEffectiveFOV() * Hs, o = this._camera.aspect;
    return ((s ? i > o : i < o) ? e : t / o) * 0.5 / Math.tan(r * 0.5) + n * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(t) {
    if (Qo(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * Hs, n = Math.atan(Math.tan(e * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? e : n;
    return t / Math.sin(s * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(t, e = true) {
    return (t && t.isVector3 ? t : new ve.Vector3()).copy(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(t, e = true) {
    return (t && t.isVector3 ? t : new ve.Vector3()).setFromSpherical(e ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(t, e = true) {
    return (t && t instanceof ve.Spherical ? t : new ve.Spherical()).copy(e ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(t, e = true) {
    return (t && t.isVector3 ? t : new ve.Vector3()).copy(e ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % rs, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += rs), this._spherical.theta += rs * Math.round((this._sphericalEnd.theta - this._spherical.theta) / rs);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(t = false) {
    if (!De(this._camera.up.x, this._cameraUp0.x) || !De(this._camera.up.y, this._cameraUp0.y) || !De(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const n = this.getPosition(be);
      this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
    }
    const e = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t),
      this.zoomTo(this._zoom0, t)
    ];
    return Promise.all(e);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, or), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const t = be.subVectors(this._target, this._camera.position).normalize(), e = Pe.crossVectors(t, this._camera.up);
    this._camera.up.crossVectors(e, t).normalize(), this._camera.updateMatrixWorld();
    const n = this.getPosition(be);
    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(t) {
    const e = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = Hl.subVectors(this._targetEnd, this._target), r = Wl.subVectors(this._focalOffsetEnd, this._focalOffset), o = this._zoomEnd - this._zoom;
    if (Ue2(e))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = ir(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, d, 1 / 0, t), this._needsUpdate = true;
    }
    if (Ue2(n))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = ir(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, d, 1 / 0, t), this._needsUpdate = true;
    }
    if (Ue2(s))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const d = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = ir(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, d, this.maxSpeed, t), this._needsUpdate = true;
    }
    if (Ue2(i.x) && Ue2(i.y) && Ue2(i.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const d = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      Gl(this._target, this._targetEnd, this._targetVelocity, d, this.maxSpeed, t, this._target), this._needsUpdate = true;
    }
    if (Ue2(r.x) && Ue2(r.y) && Ue2(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const d = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      Gl(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, d, this.maxSpeed, t, this._focalOffset), this._needsUpdate = true;
    }
    if (Ue2(o))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const d = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = ir(this._zoom, this._zoomEnd, this._zoomVelocity, d, 1 / 0, t);
    }
    if (this.dollyToCursor) {
      if (On(this._camera) && this._changedDolly !== 0) {
        const d = this._spherical.radius - this._lastDistance, m = this._camera, f = this._getCameraDirection(js), g = be.copy(f).cross(m.up).normalize();
        g.lengthSq() === 0 && (g.x = 1);
        const v = Pe.crossVectors(g, f), y = this._sphericalEnd.radius * Math.tan(m.getEffectiveFOV() * Hs * 0.5), x = (this._sphericalEnd.radius - d - this._sphericalEnd.radius) / this._sphericalEnd.radius, A = os.copy(this._targetEnd).add(g.multiplyScalar(this._dollyControlCoord.x * y * m.aspect)).add(v.multiplyScalar(this._dollyControlCoord.y * y)), R = be.copy(this._targetEnd).lerp(A, x), P = this._lastDollyDirection === is.IN && this._spherical.radius <= this.minDistance, C = this._lastDollyDirection === is.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (P || C)) {
          this._sphericalEnd.radius -= d, this._spherical.radius -= d;
          const B = Pe.copy(f).multiplyScalar(-d);
          R.add(B);
        }
        this._boundary.clampPoint(R, R);
        const O = Pe.subVectors(R, this._targetEnd);
        this._targetEnd.copy(R), this._target.add(O), this._changedDolly -= d, Ue2(this._changedDolly) && (this._changedDolly = 0);
      } else if (gn(this._camera) && this._changedZoom !== 0) {
        const d = this._zoom - this._lastZoom, m = this._camera, f = be.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (m.near + m.far) / (m.near - m.far)).unproject(m), g = Pe.set(0, 0, -1).applyQuaternion(m.quaternion), v = os.copy(f).add(g.multiplyScalar(-f.dot(m.up))), y = -(this._zoom - d - this._zoom) / this._zoom, x = this._getCameraDirection(js), A = this._targetEnd.dot(x), R = be.copy(this._targetEnd).lerp(v, y), P = R.dot(x), C = x.multiplyScalar(P - A);
        R.sub(C), this._boundary.clampPoint(R, R);
        const O = Pe.subVectors(R, this._targetEnd);
        this._targetEnd.copy(R), this._target.add(O), this._changedZoom -= d, Ue2(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const l = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Ue2(this._focalOffset.x) || !Ue2(this._focalOffset.y) || !Ue2(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), zt.setFromMatrixColumn(this._camera.matrix, 0), Vt.setFromMatrixColumn(this._camera.matrix, 1), Dn.setFromMatrixColumn(this._camera.matrix, 2), zt.multiplyScalar(this._focalOffset.x), Vt.multiplyScalar(-this._focalOffset.y), Dn.multiplyScalar(this._focalOffset.z), be.copy(zt).add(Vt).add(Dn), this._camera.position.add(be)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), be.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const u = this._needsUpdate;
    return u && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), Ue2(e, this.restThreshold) && Ue2(n, this.restThreshold) && Ue2(s, this.restThreshold) && Ue2(i.x, this.restThreshold) && Ue2(i.y, this.restThreshold) && Ue2(i.z, this.restThreshold) && Ue2(r.x, this.restThreshold) && Ue2(r.y, this.restThreshold) && Ue2(r.z, this.restThreshold) && Ue2(o, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = u, this._needsUpdate = false, u;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Ws(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Ws(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Ws(this.maxPolarAngle),
      minAzimuthAngle: Ws(this.minAzimuthAngle),
      maxAzimuthAngle: Ws(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: be.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(t, e = false) {
    const n = JSON.parse(t);
    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = Ks(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = Ks(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = Ks(n.maxPolarAngle), this.minAzimuthAngle = Ks(n.minAzimuthAngle), this.maxAzimuthAngle = Ks(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], e), yt.setFromVector3(be.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(yt.theta, yt.phi, e), this.dollyTo(yt.radius, e), this.zoomTo(n.zoom, e), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], e), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(t) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    t.setAttribute("data-camera-controls-version", Jd), this._addAllEventListeners(t), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(t) {
    return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(t) {
    return this._getTargetDirection(t).negate();
  }
  _findPointerById(t) {
    return this._activePointers.find((e) => e.pointerId === t);
  }
  _findPointerByMouseButton(t) {
    return this._activePointers.find((e) => e.mouseButton === t);
  }
  _disposePointer(t) {
    this._activePointers.splice(this._activePointers.indexOf(t), 1);
  }
  _encloseToBoundary(t, e, n) {
    const s = e.lengthSq();
    if (s === 0)
      return t;
    const i = Pe.copy(e).add(t), r = this._boundary.clampPoint(i, os).sub(i), o = r.lengthSq();
    if (o === 0)
      return t.add(e);
    if (o === s)
      return t;
    if (n === 0)
      return t.add(e).add(r);
    {
      const l = 1 + n * o / e.dot(r);
      return t.add(Pe.copy(e).multiplyScalar(l)).add(r.multiplyScalar(1 - n));
    }
  }
  _updateNearPlaneCorners() {
    if (On(this._camera)) {
      const t = this._camera, e = t.near, n = t.getEffectiveFOV() * Hs, s = Math.tan(n * 0.5) * e, i = s * t.aspect;
      this._nearPlaneCorners[0].set(-i, -s, 0), this._nearPlaneCorners[1].set(i, -s, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(-i, s, 0);
    } else if (gn(this._camera)) {
      const t = this._camera, e = 1 / t.zoom, n = t.left * e, s = t.right * e, i = t.top * e, r = t.bottom * e;
      this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(s, i, 0), this._nearPlaneCorners[2].set(s, r, 0), this._nearPlaneCorners[3].set(n, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let t = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Qo(this._camera, "_collisionTest"))
      return t;
    const e = this._getTargetDirection(js);
    ea.lookAt(Yl, e, this._camera.up);
    for (let n = 0; n < 4; n++) {
      const s = Pe.copy(this._nearPlaneCorners[n]);
      s.applyMatrix4(ea);
      const i = os.addVectors(this._target, s);
      ar.set(i, e), ar.far = this._spherical.radius + 1;
      const r = ar.intersectObjects(this.colliderMeshes);
      r.length !== 0 && r[0].distance < t && (t = r[0].distance);
    }
    return t;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(t) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = e.width, t.height = e.height), t;
  }
  _createOnRestPromise(t) {
    return t ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const n = () => {
        this.removeEventListener("rest", n), e();
      };
      this.addEventListener("rest", n);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(t) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(t) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(t) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(t, e = new ve.Sphere()) {
    const n = e, s = n.center;
    as.makeEmpty(), t.traverseVisible((r) => {
      r.isMesh && as.expandByObject(r);
    }), as.getCenter(s);
    let i = 0;
    return t.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const o = r, l = o.geometry.clone();
      l.applyMatrix4(o.matrixWorld);
      const u = l.attributes.position;
      for (let d = 0, m = u.count; d < m; d++)
        be.fromBufferAttribute(u, d), i = Math.max(i, s.distanceToSquared(be));
    }), n.radius = Math.sqrt(i), n;
  }
};
var Sr = class _Sr extends Dd {
  constructor(t) {
    super(t), S(this, "onBeforeUpdate", new $()), S(this, "onAfterUpdate", new $()), S(this, "onAspectUpdated", new $()), S(this, "onDisposed", new $()), S(this, "three"), S(this, "_allControls", /* @__PURE__ */ new Map()), S(this, "updateAspect", () => {
      var e;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((e = this.currentWorld.renderer) != null && e.isResizeable()) {
          const n = this.currentWorld.renderer.getSize();
          this.three.aspect = n.width / n.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    }), this.three = this.setupCamera(), this.setupEvents(true), this.onWorldChanged.add(({ action: e, world: n }) => {
      if (e === "added") {
        const s = this.newCameraControls();
        this._allControls.set(n.uuid, s);
      }
      if (e === "removed") {
        const s = this._allControls.get(n.uuid);
        s && (s.dispose(), this._allControls.delete(n.uuid));
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    return this.currentWorld === null ? false : this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(t) {
    this.currentWorld !== null && (this.controls.enabled = t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, e] of this._allControls)
      e.dispose();
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, e = new PerspectiveCamera(60, t, 1, 1e3);
    return e.position.set(50, 50, 50), e.lookAt(new Vector3(0, 0, 0)), e;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    oi.install({ THREE: _Sr.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, e = new oi(this.three, t);
    return e.smoothTime = 0.2, e.dollyToCursor = true, e.infinityDolly = true, e;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var Hc = class Wc extends Fe {
  constructor(t) {
    super(t), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onDisposed", new $()), S(this, "onWorldCreated", new $()), S(this, "onWorldDeleted", new $()), S(this, "list", /* @__PURE__ */ new Map()), S(this, "enabled", true), t.add(Wc.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new Zd(this.components), e = t.uuid;
    if (this.list.has(e))
      throw new Error("There is already a world with this name!");
    return this.list.set(e, t), this.onWorldCreated.trigger(t), t;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   *
   * @returns {void}
   */
  delete(t) {
    if (!this.list.has(t.uuid))
      throw new Error("The provided world is not found in the list!");
    const e = t.uuid;
    this.list.delete(t.uuid), t.dispose(), this.onWorldDeleted.trigger(e);
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   *
   * @returns {void}
   */
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(t) {
    if (this.enabled)
      for (const [e, n] of this.list)
        n.update(t);
  }
};
S(Hc, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var tf = Hc;
var nf = class {
  constructor(t, e, n) {
    S(this, "onDisposed", new $()), S(this, "world"), S(this, "components"), S(this, "three"), S(this, "_fade", 3), S(this, "updateZoom", () => {
      this.world.camera instanceof Sr && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    }), this.world = e;
    const { color: s, size1: i, size2: r, distance: o } = n;
    this.components = t;
    const l = new PlaneGeometry(2, 2, 1, 1), u = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: i
        },
        uSize2: {
          value: r
        },
        uColor: {
          value: s
        },
        uDistance: {
          value: o
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new Mesh(l, u), this.three.frustumCulled = false, e.scene.three.add(this.three), this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(t) {
    t ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(t) {
    this._fade = t ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.components.get(rn).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(t) {
    if (this.world.isDisposing || !(this.world.camera instanceof Sr))
      return;
    const e = this.world.camera.controls;
    t ? e.addEventListener("update", this.updateZoom) : e.removeEventListener("update", this.updateZoom);
  }
};
var sf = class Kc extends Fe {
  constructor(t) {
    super(t), S(this, "list", /* @__PURE__ */ new Map()), S(this, "config", {
      color: new Color(12303291),
      size1: 1,
      size2: 10,
      distance: 500
    }), S(this, "onDisposed", new $()), S(this, "enabled", true), t.add(Kc.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const e = new nf(this.components, t, this.config);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
S(sf, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var Ln = new Raycaster();
var ot = new Vector3();
var mn = new Vector3();
var Ve = new Quaternion();
var Xl = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var ta = { type: "change" };
var Zl = { type: "mouseDown" };
var Ql = { type: "mouseUp", mode: null };
var ql = { type: "objectChange" };
var rf = class extends Object3D {
  constructor(t, e) {
    super(), e === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), e = document), this.isTransformControls = true, this.visible = false, this.domElement = e, this.domElement.style.touchAction = "none";
    const n = new uf();
    this._gizmo = n, this.add(n);
    const s = new df();
    this._plane = s, this.add(s);
    const i = this;
    function r(R, P) {
      let C = P;
      Object.defineProperty(i, R, {
        get: function() {
          return C !== void 0 ? C : P;
        },
        set: function(O) {
          C !== O && (C = O, s[R] = O, n[R] = O, i.dispatchEvent({ type: R + "-changed", value: O }), i.dispatchEvent(ta));
        }
      }), i[R] = P, s[R] = P, n[R] = P;
    }
    r("camera", t), r("object", void 0), r("enabled", true), r("axis", null), r("mode", "translate"), r("translationSnap", null), r("rotationSnap", null), r("scaleSnap", null), r("space", "world"), r("size", 1), r("dragging", false), r("showX", true), r("showY", true), r("showZ", true);
    const o = new Vector3(), l = new Vector3(), u = new Quaternion(), d = new Quaternion(), m = new Vector3(), f = new Quaternion(), g = new Vector3(), v = new Vector3(), y = new Vector3(), x = 0, A = new Vector3();
    r("worldPosition", o), r("worldPositionStart", l), r("worldQuaternion", u), r("worldQuaternionStart", d), r("cameraPosition", m), r("cameraQuaternion", f), r("pointStart", g), r("pointEnd", v), r("rotationAxis", y), r("rotationAngle", x), r("eye", A), this._offset = new Vector3(), this._startNorm = new Vector3(), this._endNorm = new Vector3(), this._cameraScale = new Vector3(), this._parentPosition = new Vector3(), this._parentQuaternion = new Quaternion(), this._parentQuaternionInv = new Quaternion(), this._parentScale = new Vector3(), this._worldScaleStart = new Vector3(), this._worldQuaternionInv = new Quaternion(), this._worldScale = new Vector3(), this._positionStart = new Vector3(), this._quaternionStart = new Quaternion(), this._scaleStart = new Vector3(), this._getPointer = of.bind(this), this._onPointerDown = lf.bind(this), this._onPointerHover = af.bind(this), this._onPointerMove = cf.bind(this), this._onPointerUp = hf.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(t) {
    if (this.object === void 0 || this.dragging === true)
      return;
    Ln.setFromCamera(t, this.camera);
    const e = na(this._gizmo.picker[this.mode], Ln);
    e ? this.axis = e.object.name : this.axis = null;
  }
  pointerDown(t) {
    if (!(this.object === void 0 || this.dragging === true || t.button !== 0) && this.axis !== null) {
      Ln.setFromCamera(t, this.camera);
      const e = na(this._plane, Ln, true);
      e && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(e.point).sub(this.worldPositionStart)), this.dragging = true, Zl.mode = this.mode, this.dispatchEvent(Zl);
    }
  }
  pointerMove(t) {
    const e = this.axis, n = this.mode, s = this.object;
    let i = this.space;
    if (n === "scale" ? i = "local" : (e === "E" || e === "XYZE" || e === "XYZ") && (i = "world"), s === void 0 || e === null || this.dragging === false || t.button !== -1)
      return;
    Ln.setFromCamera(t, this.camera);
    const r = na(this._plane, Ln, true);
    if (r) {
      if (this.pointEnd.copy(r.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), i === "local" && e !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), e.indexOf("X") === -1 && (this._offset.x = 0), e.indexOf("Y") === -1 && (this._offset.y = 0), e.indexOf("Z") === -1 && (this._offset.z = 0), i === "local" && e !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), s.position.copy(this._offset).add(this._positionStart), this.translationSnap && (i === "local" && (s.position.applyQuaternion(Ve.copy(this._quaternionStart).invert()), e.search("X") !== -1 && (s.position.x = Math.round(s.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (s.position.y = Math.round(s.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (s.position.z = Math.round(s.position.z / this.translationSnap) * this.translationSnap), s.position.applyQuaternion(this._quaternionStart)), i === "world" && (s.parent && s.position.add(ot.setFromMatrixPosition(s.parent.matrixWorld)), e.search("X") !== -1 && (s.position.x = Math.round(s.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (s.position.y = Math.round(s.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (s.position.z = Math.round(s.position.z / this.translationSnap) * this.translationSnap), s.parent && s.position.sub(ot.setFromMatrixPosition(s.parent.matrixWorld))));
      else if (n === "scale") {
        if (e.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), mn.set(o, o, o);
        } else
          ot.copy(this.pointStart), mn.copy(this.pointEnd), ot.applyQuaternion(this._worldQuaternionInv), mn.applyQuaternion(this._worldQuaternionInv), mn.divide(ot), e.search("X") === -1 && (mn.x = 1), e.search("Y") === -1 && (mn.y = 1), e.search("Z") === -1 && (mn.z = 1);
        s.scale.copy(this._scaleStart).multiply(mn), this.scaleSnap && (e.search("X") !== -1 && (s.scale.x = Math.round(s.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Y") !== -1 && (s.scale.y = Math.round(s.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Z") !== -1 && (s.scale.z = Math.round(s.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(ot.setFromMatrixPosition(this.camera.matrixWorld));
        let l = false;
        e === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(ot.copy(this.rotationAxis).cross(this.eye)) * o) : (e === "X" || e === "Y" || e === "Z") && (this.rotationAxis.copy(Xl[e]), ot.copy(Xl[e]), i === "local" && ot.applyQuaternion(this.worldQuaternion), ot.cross(this.eye), ot.length() === 0 ? l = true : this.rotationAngle = this._offset.dot(ot.normalize()) * o), (e === "E" || l) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), i === "local" && e !== "E" && e !== "XYZE" ? (s.quaternion.copy(this._quaternionStart), s.quaternion.multiply(Ve.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), s.quaternion.copy(Ve.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), s.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(ta), this.dispatchEvent(ql);
    }
  }
  pointerUp(t) {
    t.button === 0 && (this.dragging && this.axis !== null && (Ql.mode = this.mode, this.dispatchEvent(Ql)), this.dragging = false, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(t) {
      t.geometry && t.geometry.dispose(), t.material && t.material.dispose();
    });
  }
  // Set current object
  attach(t) {
    return this.object = t, this.visible = true, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = false, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(ta), this.dispatchEvent(ql), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Ln;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(t) {
    this.mode = t;
  }
  setTranslationSnap(t) {
    this.translationSnap = t;
  }
  setRotationSnap(t) {
    this.rotationSnap = t;
  }
  setScaleSnap(t) {
    this.scaleSnap = t;
  }
  setSize(t) {
    this.size = t;
  }
  setSpace(t) {
    this.space = t;
  }
};
function of(h) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: h.button
    };
  {
    const t = this.domElement.getBoundingClientRect();
    return {
      x: (h.clientX - t.left) / t.width * 2 - 1,
      y: -(h.clientY - t.top) / t.height * 2 + 1,
      button: h.button
    };
  }
}
function af(h) {
  if (this.enabled)
    switch (h.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(h));
        break;
    }
}
function lf(h) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(h.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(h)), this.pointerDown(this._getPointer(h)));
}
function cf(h) {
  this.enabled && this.pointerMove(this._getPointer(h));
}
function hf(h) {
  this.enabled && (this.domElement.releasePointerCapture(h.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(h)));
}
function na(h, t, e) {
  const n = t.intersectObject(h, true);
  for (let s = 0; s < n.length; s++)
    if (n[s].object.visible || e)
      return n[s];
  return false;
}
var lr = new Euler();
var _e = new Vector3(0, 1, 0);
var Jl = new Vector3(0, 0, 0);
var $l = new Matrix4();
var cr = new Quaternion();
var Cr = new Quaternion();
var Gt = new Vector3();
var ec = new Matrix4();
var qs = new Vector3(1, 0, 0);
var Nn = new Vector3(0, 1, 0);
var Js = new Vector3(0, 0, 1);
var hr = new Vector3();
var Zs = new Vector3();
var Qs = new Vector3();
var uf = class extends Object3D {
  constructor() {
    super(), this.isTransformControlsGizmo = true, this.type = "TransformControlsGizmo";
    const t = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), e = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), n = t.clone();
    n.opacity = 0.15;
    const s = e.clone();
    s.opacity = 0.5;
    const i = t.clone();
    i.color.setHex(16711680);
    const r = t.clone();
    r.color.setHex(65280);
    const o = t.clone();
    o.color.setHex(255);
    const l = t.clone();
    l.color.setHex(16711680), l.opacity = 0.5;
    const u = t.clone();
    u.color.setHex(65280), u.opacity = 0.5;
    const d = t.clone();
    d.color.setHex(255), d.opacity = 0.5;
    const m = t.clone();
    m.opacity = 0.25;
    const f = t.clone();
    f.color.setHex(16776960), f.opacity = 0.25, t.clone().color.setHex(16776960);
    const g = t.clone();
    g.color.setHex(7895160);
    const v = new CylinderGeometry(0, 0.04, 0.1, 12);
    v.translate(0, 0.05, 0);
    const y = new BoxGeometry(0.08, 0.08, 0.08);
    y.translate(0, 0.04, 0);
    const x = new BufferGeometry();
    x.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const A = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    A.translate(0, 0.25, 0);
    function R(he, me) {
      const Ie = new TorusGeometry(he, 75e-4, 3, 64, me * Math.PI * 2);
      return Ie.rotateY(Math.PI / 2), Ie.rotateX(Math.PI / 2), Ie;
    }
    function P() {
      const he = new BufferGeometry();
      return he.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), he;
    }
    const C = {
      X: [
        [new Mesh(v, i), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(v, i), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(A, i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(v, r), [0, 0.5, 0]],
        [new Mesh(v, r), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(A, r)]
      ],
      Z: [
        [new Mesh(v, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(v, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(A, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), m.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), d.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), u.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, O = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), n)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, B = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), s), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), s), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(P(), s), null, null, null, "helper"]
      ],
      X: [
        [new Line(x, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(x, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(x, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, Y = {
      XYZE: [
        [new Mesh(R(0.5, 1), g), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(R(0.5, 0.5), i)]
      ],
      Y: [
        [new Mesh(R(0.5, 0.5), r), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(R(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(R(0.75, 1), f), null, [0, Math.PI / 2, 0]]
      ]
    }, H = {
      AXIS: [
        [new Line(x, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, K = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), n)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), n)]
      ]
    }, Z = {
      X: [
        [new Mesh(y, i), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(A, i), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(y, i), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(y, r), [0, 0.5, 0]],
        [new Mesh(A, r)],
        [new Mesh(y, r), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(y, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(A, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(y, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), d), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), u), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), m.clone())]
      ]
    }, q = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), n), [0, 0, 0]]
      ]
    }, ne = {
      X: [
        [new Line(x, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(x, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(x, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function se(he) {
      const me = new Object3D();
      for (const Ie in he)
        for (let Ee = he[Ie].length; Ee--; ) {
          const ue = he[Ie][Ee][0].clone(), Le = he[Ie][Ee][1], we = he[Ie][Ee][2], Ke = he[Ie][Ee][3], Nt = he[Ie][Ee][4];
          ue.name = Ie, ue.tag = Nt, Le && ue.position.set(Le[0], Le[1], Le[2]), we && ue.rotation.set(we[0], we[1], we[2]), Ke && ue.scale.set(Ke[0], Ke[1], Ke[2]), ue.updateMatrix();
          const vt = ue.geometry.clone();
          vt.applyMatrix4(ue.matrix), ue.geometry = vt, ue.renderOrder = 1 / 0, ue.position.set(0, 0, 0), ue.rotation.set(0, 0, 0), ue.scale.set(1, 1, 1), me.add(ue);
        }
      return me;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = se(C)), this.add(this.gizmo.rotate = se(Y)), this.add(this.gizmo.scale = se(Z)), this.add(this.picker.translate = se(O)), this.add(this.picker.rotate = se(K)), this.add(this.picker.scale = se(q)), this.add(this.helper.translate = se(B)), this.add(this.helper.rotate = se(H)), this.add(this.helper.scale = se(ne)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(t) {
    const e = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Cr;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let n = [];
    n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
    for (let s = 0; s < n.length; s++) {
      const i = n[s];
      i.visible = true, i.rotation.set(0, 0, 0), i.position.copy(this.worldPosition);
      let r;
      if (this.camera.isOrthographicCamera ? r = (this.camera.top - this.camera.bottom) / this.camera.zoom : r = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), i.scale.set(1, 1, 1).multiplyScalar(r * this.size / 4), i.tag === "helper") {
        i.visible = false, i.name === "AXIS" ? (i.visible = !!this.axis, this.axis === "X" && (Ve.setFromEuler(lr.set(0, 0, 0)), i.quaternion.copy(e).multiply(Ve), Math.abs(_e.copy(qs).applyQuaternion(e).dot(this.eye)) > 0.9 && (i.visible = false)), this.axis === "Y" && (Ve.setFromEuler(lr.set(0, 0, Math.PI / 2)), i.quaternion.copy(e).multiply(Ve), Math.abs(_e.copy(Nn).applyQuaternion(e).dot(this.eye)) > 0.9 && (i.visible = false)), this.axis === "Z" && (Ve.setFromEuler(lr.set(0, Math.PI / 2, 0)), i.quaternion.copy(e).multiply(Ve), Math.abs(_e.copy(Js).applyQuaternion(e).dot(this.eye)) > 0.9 && (i.visible = false)), this.axis === "XYZE" && (Ve.setFromEuler(lr.set(0, Math.PI / 2, 0)), _e.copy(this.rotationAxis), i.quaternion.setFromRotationMatrix($l.lookAt(Jl, _e, Nn)), i.quaternion.multiply(Ve), i.visible = this.dragging), this.axis === "E" && (i.visible = false)) : i.name === "START" ? (i.position.copy(this.worldPositionStart), i.visible = this.dragging) : i.name === "END" ? (i.position.copy(this.worldPosition), i.visible = this.dragging) : i.name === "DELTA" ? (i.position.copy(this.worldPositionStart), i.quaternion.copy(this.worldQuaternionStart), ot.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), ot.applyQuaternion(this.worldQuaternionStart.clone().invert()), i.scale.copy(ot), i.visible = this.dragging) : (i.quaternion.copy(e), this.dragging ? i.position.copy(this.worldPositionStart) : i.position.copy(this.worldPosition), this.axis && (i.visible = this.axis.search(i.name) !== -1));
        continue;
      }
      i.quaternion.copy(e), this.mode === "translate" || this.mode === "scale" ? (i.name === "X" && Math.abs(_e.copy(qs).applyQuaternion(e).dot(this.eye)) > 0.99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "Y" && Math.abs(_e.copy(Nn).applyQuaternion(e).dot(this.eye)) > 0.99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "Z" && Math.abs(_e.copy(Js).applyQuaternion(e).dot(this.eye)) > 0.99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "XY" && Math.abs(_e.copy(Js).applyQuaternion(e).dot(this.eye)) < 0.2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "YZ" && Math.abs(_e.copy(qs).applyQuaternion(e).dot(this.eye)) < 0.2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "XZ" && Math.abs(_e.copy(Nn).applyQuaternion(e).dot(this.eye)) < 0.2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false)) : this.mode === "rotate" && (cr.copy(e), _e.copy(this.eye).applyQuaternion(Ve.copy(e).invert()), i.name.search("E") !== -1 && i.quaternion.setFromRotationMatrix($l.lookAt(this.eye, Jl, Nn)), i.name === "X" && (Ve.setFromAxisAngle(qs, Math.atan2(-_e.y, _e.z)), Ve.multiplyQuaternions(cr, Ve), i.quaternion.copy(Ve)), i.name === "Y" && (Ve.setFromAxisAngle(Nn, Math.atan2(_e.x, _e.z)), Ve.multiplyQuaternions(cr, Ve), i.quaternion.copy(Ve)), i.name === "Z" && (Ve.setFromAxisAngle(Js, Math.atan2(_e.y, _e.x)), Ve.multiplyQuaternions(cr, Ve), i.quaternion.copy(Ve))), i.visible = i.visible && (i.name.indexOf("X") === -1 || this.showX), i.visible = i.visible && (i.name.indexOf("Y") === -1 || this.showY), i.visible = i.visible && (i.name.indexOf("Z") === -1 || this.showZ), i.visible = i.visible && (i.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), i.material._color = i.material._color || i.material.color.clone(), i.material._opacity = i.material._opacity || i.material.opacity, i.material.color.copy(i.material._color), i.material.opacity = i.material._opacity, this.enabled && this.axis && (i.name === this.axis || this.axis.split("").some(function(o) {
        return i.name === o;
      })) && (i.material.color.setHex(16776960), i.material.opacity = 1);
    }
    super.updateMatrixWorld(t);
  }
};
var df = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    ), this.isTransformControlsPlane = true, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(t) {
    let e = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), hr.copy(qs).applyQuaternion(e === "local" ? this.worldQuaternion : Cr), Zs.copy(Nn).applyQuaternion(e === "local" ? this.worldQuaternion : Cr), Qs.copy(Js).applyQuaternion(e === "local" ? this.worldQuaternion : Cr), _e.copy(Zs), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _e.copy(this.eye).cross(hr), Gt.copy(hr).cross(_e);
            break;
          case "Y":
            _e.copy(this.eye).cross(Zs), Gt.copy(Zs).cross(_e);
            break;
          case "Z":
            _e.copy(this.eye).cross(Qs), Gt.copy(Qs).cross(_e);
            break;
          case "XY":
            Gt.copy(Qs);
            break;
          case "YZ":
            Gt.copy(hr);
            break;
          case "XZ":
            _e.copy(Qs), Gt.copy(Zs);
            break;
          case "XYZ":
          case "E":
            Gt.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Gt.set(0, 0, 0);
    }
    Gt.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (ec.lookAt(ot.set(0, 0, 0), Gt, _e), this.quaternion.setFromRotationMatrix(ec)), super.updateMatrixWorld(t);
  }
};
var jr = class _jr {
  constructor(t, e, n, s, i, r = 5, o = true) {
    if (S(this, "onDraggingStarted", new $()), S(this, "onDraggingEnded", new $()), S(this, "onDisposed", new $()), S(this, "normal"), S(this, "origin"), S(this, "three", new Plane()), S(this, "components"), S(this, "world"), S(this, "_helper"), S(this, "_visible", true), S(this, "_enabled", true), S(this, "_controlsActive", false), S(this, "_arrowBoundBox", new Mesh()), S(this, "_planeMesh"), S(this, "_controls"), S(this, "_hiddenMaterial", new MeshBasicMaterial({
      visible: false
    })), S(this, "update", () => {
      this._enabled && this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    }), S(this, "changeDrag", (l) => {
      this._visible = !l.value, this.preventCameraMovement(), this.notifyDraggingChanged(l);
    }), this.components = t, this.world = e, !e.renderer)
      throw new Error("The given world must have a renderer!");
    this.normal = s, this.origin = n, e.renderer.setPlane(true, this.three), this._planeMesh = _jr.newPlaneMesh(r, i), this._helper = this.newHelper(), this._controls = this.newTransformControls(), this.three.setFromNormalAndCoplanarPoint(s, n), o && this.toggleControls(true);
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(t) {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    this._enabled = t, this.world.renderer.setPlane(t, this.three);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t, this._controls.visible = t, this._helper.visible = t, this.toggleControls(t);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(t) {
    this._planeMesh.material = t;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(t) {
    this._planeMesh.scale.set(t, t, t);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(t, e) {
    this.reset(), this.normal.equals(t) || (this.normal.copy(t), this._helper.lookAt(t)), this.origin.copy(e), this._helper.position.copy(e), this._helper.updateMatrix(), this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false, this.onDraggingStarted.reset(), this.onDraggingEnded.reset(), this._helper.removeFromParent(), this.world.renderer && this.world.renderer.setPlane(false, this.three), this._arrowBoundBox.removeFromParent(), this._arrowBoundBox.geometry.dispose(), this._planeMesh.geometry.dispose(), this._controls.removeFromParent(), this._controls.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  reset() {
    const t = new Vector3(1, 0, 0), e = new Vector3();
    this.normal.equals(t) || (this.normal.copy(t), this._helper.lookAt(t)), this.origin.copy(e), this._helper.position.copy(e), this._helper.updateMatrix();
  }
  toggleControls(t) {
    if (t) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update), this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else
      this._controls.removeEventListener("change", this.update), this._controls.removeEventListener("dragging-changed", this.changeDrag);
    this._controlsActive = t;
  }
  newTransformControls() {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    const t = this.world.camera.three, e = this.world.renderer.three.domElement, n = new rf(t, e);
    return this.initializeControls(n), this.world.scene.three.add(n), n;
  }
  initializeControls(t) {
    t.attach(this._helper), t.showX = false, t.showY = false, t.setSpace("local"), this.createArrowBoundingBox(), t.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2), this._arrowBoundBox.material = this._hiddenMaterial, this._arrowBoundBox.rotateX(Math.PI / 2), this._arrowBoundBox.updateMatrix(), this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(t) {
    t.value ? this.onDraggingStarted.trigger() : this.onDraggingEnded.trigger();
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const t = new Object3D();
    return t.lookAt(this.normal), t.position.copy(this.origin), this._planeMesh.position.z += 0.01, t.add(this._planeMesh), this.world.scene.three.add(t), t;
  }
  static newPlaneMesh(t, e) {
    const n = new PlaneGeometry(1), s = new Mesh(n, e);
    return s.scale.set(t, t, t), s;
  }
};
var jc = class va extends Fe {
  constructor(t) {
    super(t), S(this, "onBeforeDrag", new $()), S(this, "onAfterDrag", new $()), S(this, "onBeforeCreate", new $()), S(this, "onBeforeCancel", new $()), S(this, "onAfterCancel", new $()), S(this, "onBeforeDelete", new $()), S(this, "onAfterCreate", new $()), S(this, "onAfterDelete", new $()), S(this, "onDisposed", new $()), S(this, "orthogonalY", false), S(this, "toleranceOrthogonalY", 0.7), S(this, "Type", jr), S(this, "list", []), S(this, "_material", new MeshBasicMaterial({
      color: 12255487,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    })), S(this, "_size", 5), S(this, "_enabled", false), S(this, "_visible", true), S(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    }), S(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    }), this.components.add(va.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const e of this.list)
      e.enabled = t;
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t;
    for (const e of this.list)
      e.visible = t;
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(t) {
    this._material = t;
    for (const e of this.list)
      e.planeMaterial = t;
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(t) {
    this._size = t;
    for (const e of this.list)
      e.size = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    for (const t of this.list)
      t.dispose();
    this.list.length = 0, this._material.dispose(), this.onBeforeCreate.reset(), this.onBeforeCancel.reset(), this.onBeforeDelete.reset(), this.onBeforeDrag.reset(), this.onAfterCreate.reset(), this.onAfterCancel.reset(), this.onAfterDelete.reset(), this.onAfterDrag.reset(), this.onDisposed.trigger(va.uuid), this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(t) {
    const e = this.components.get(Dt).get(t).castRay();
    e && this.createPlaneFromIntersection(t, e);
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(t, e, n) {
    const s = this.newPlane(t, n, e);
    return this.updateMaterialsAndPlanes(), s;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(t, e) {
    e || (e = this.pickPlane(t)), e && this.deletePlane(e);
  }
  /** Deletes all the existing clipping planes. */
  deleteAll() {
    for (; this.list.length > 0; ) {
      const t = this.list[0];
      this.delete(t.world, t);
    }
  }
  deletePlane(t) {
    const e = this.list.indexOf(t);
    if (e !== -1) {
      if (this.list.splice(e, 1), !t.world.renderer)
        throw new Error("Renderer not found for this plane's world!");
      t.world.renderer.setPlane(false, t.three), t.dispose(), this.updateMaterialsAndPlanes(), this.onAfterDelete.trigger(t);
    }
  }
  pickPlane(t) {
    const e = this.components.get(Dt).get(t), n = this.getAllPlaneMeshes(), s = e.castRay(n);
    if (s) {
      const i = s.object;
      return this.list.find((r) => r.meshes.includes(i));
    }
  }
  getAllPlaneMeshes() {
    const t = [];
    for (const e of this.list)
      t.push(...e.meshes);
    return t;
  }
  createPlaneFromIntersection(t, e) {
    var n;
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    const s = e.point.distanceTo(new Vector3(0, 0, 0)), i = (n = e.face) == null ? void 0 : n.normal;
    if (!s || !i)
      return;
    const r = this.getWorldNormal(e, i), o = this.newPlane(t, e.point, r.negate());
    o.visible = this._visible, o.size = this._size, t.renderer.setPlane(true, o.three), this.updateMaterialsAndPlanes();
  }
  getWorldNormal(t, e) {
    const n = t.object;
    let s = t.object.matrixWorld.clone();
    if (n instanceof InstancedMesh && t.instanceId !== void 0) {
      const o = new Matrix4();
      n.getMatrixAt(t.instanceId, o), s = o.multiply(s);
    }
    const i = new Matrix3().getNormalMatrix(s), r = e.clone().applyMatrix3(i).normalize();
    return this.normalizePlaneDirectionY(r), r;
  }
  normalizePlaneDirectionY(t) {
    this.orthogonalY && (t.y > this.toleranceOrthogonalY && (t.x = 0, t.y = 1, t.z = 0), t.y < -this.toleranceOrthogonalY && (t.x = 0, t.y = -1, t.z = 0));
  }
  newPlane(t, e, n) {
    const s = new this.Type(
      this.components,
      t,
      e,
      n,
      this._material
    );
    return s.onDraggingStarted.add(this._onStartDragging), s.onDraggingEnded.add(this._onEndDragging), this.list.push(s), this.onAfterCreate.trigger(s), s;
  }
  updateMaterialsAndPlanes() {
    const t = this.components.get(tf);
    for (const [e, n] of t.list) {
      if (!n.renderer)
        continue;
      n.renderer.updateClippingPlanes();
      const { clippingPlanes: s } = n.renderer;
      for (const i of n.meshes)
        if (Array.isArray(i.material))
          for (const r of i.material)
            r.clippingPlanes = s;
        else
          i.material.clippingPlanes = s;
    }
  }
};
S(jc, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
var ai = jc;
function ff(h, t, e, n) {
  return new Promise((s, i) => {
    function r() {
      const o = h.clientWaitSync(t, e, 0);
      if (o === h.WAIT_FAILED) {
        i();
        return;
      }
      if (o === h.TIMEOUT_EXPIRED) {
        setTimeout(r, n);
        return;
      }
      s();
    }
    r();
  });
}
async function pf(h, t, e, n, s, i, r) {
  const o = h.fenceSync(h.SYNC_GPU_COMMANDS_COMPLETE, 0);
  h.flush(), await ff(h, o, 0, 10), h.deleteSync(o), h.bindBuffer(t, e), h.getBufferSubData(t, n, s, i, r), h.bindBuffer(t, null);
}
async function mf(h, t, e, n, s, i, r, o) {
  const l = h.createBuffer();
  return h.bindBuffer(h.PIXEL_PACK_BUFFER, l), h.bufferData(h.PIXEL_PACK_BUFFER, o.byteLength, h.STREAM_READ), h.readPixels(t, e, n, s, i, r, 0), h.bindBuffer(h.PIXEL_PACK_BUFFER, null), await pf(h, h.PIXEL_PACK_BUFFER, l, 0, o), h.deleteBuffer(l), o;
}
var Xc = class {
  constructor(t, e, n) {
    if (S(this, "onDisposed", new $()), S(this, "onViewUpdated", new ei()), S(this, "enabled", true), S(this, "needsUpdate", false), S(this, "renderDebugFrame", false), S(this, "components"), S(this, "world"), S(this, "renderer"), S(this, "autoUpdate", true), S(this, "updateInterval", 1e3), S(this, "worker"), S(this, "scene", new Scene()), S(this, "_width", 512), S(this, "_height", 512), S(this, "_availableColor", 1), S(this, "renderTarget"), S(this, "bufferSize"), S(this, "_buffer"), S(this, "_isWorkerBusy", false), S(this, "updateVisibility", async (r) => {
      if (!this.enabled || !this.needsUpdate && !r || this._isWorkerBusy)
        return;
      this._isWorkerBusy = true;
      const o = this.world.camera.three;
      o.updateMatrix(), this.renderer.setSize(this._width, this._height), this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, o);
      const l = this.renderer.getContext();
      await mf(
        l,
        0,
        0,
        this._width,
        this._height,
        l.RGBA,
        l.UNSIGNED_BYTE,
        this._buffer
      ), this.renderer.setRenderTarget(null), this.renderDebugFrame && this.renderer.render(this.scene, o), this.worker.postMessage({
        buffer: this._buffer
      }), this.needsUpdate = false;
    }), !e.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = t, this.applySettings(n), this.world = e, this.renderer = new WebGLRenderer(), this.renderTarget = new WebGLRenderTarget(this._width, this._height), this.bufferSize = this._width * this._height * 4, this._buffer = new Uint8Array(this.bufferSize), this.renderer.clippingPlanes = e.renderer.clippingPlanes;
    const s = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `, i = new Blob([s], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(i));
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    for (const t of this.scene.children)
      t.removeFromParent();
    this.onViewUpdated.reset(), this.worker.terminate(), this.renderer.dispose(), this.renderTarget.dispose(), this._buffer = null, this.onDisposed.reset();
  }
  getAvailableColor() {
    let t = BigInt(this._availableColor.toString());
    const e = [];
    do
      e.unshift(Number(t % 256n)), t /= 256n;
    while (t);
    for (; e.length !== 3; )
      e.unshift(0);
    const [n, s, i] = e, r = `${n}-${s}-${i}`;
    return { r: n, g: s, b: i, code: r };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
  applySettings(t) {
    t && (t.updateInterval !== void 0 && (this.updateInterval = t.updateInterval), t.height !== void 0 && (this._height = t.height), t.width !== void 0 && (this._width = t.width), t.autoUpdate !== void 0 && (this.autoUpdate = t.autoUpdate));
  }
};
var gf = class extends Xc {
  constructor(t, e, n) {
    super(t, e, n), S(this, "onViewUpdated", new $()), S(this, "threshold", 100), S(this, "colorMeshes", /* @__PURE__ */ new Map()), S(this, "isProcessing", false), S(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map()), S(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map()), S(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set()), S(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set()), S(this, "_intervalID", null), S(this, "_transparentMat", new MeshBasicMaterial({
      transparent: true,
      opacity: 0
    })), S(this, "handleWorkerMessage", async (s) => {
      if (this.isProcessing)
        return;
      const i = s.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes), this._currentVisibleMeshes.clear();
      for (const [r, o] of i) {
        if (o < this.threshold)
          continue;
        const l = this._colorCodeMeshMap.get(r);
        l && (this._currentVisibleMeshes.add(l), this._recentlyHiddenMeshes.delete(l));
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      }), this._isWorkerBusy = false;
    }), this.worker.addEventListener("message", this.handleWorkerMessage), this.autoUpdate && window.setInterval(async () => {
      this.isProcessing || await this.updateVisibility();
    }, this.updateInterval), this.onViewUpdated.add(({ seen: s, unseen: i }) => {
      for (const r of s)
        r.visible = true;
      for (const r of i)
        r.visible = false;
    });
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null), this._currentVisibleMeshes.clear(), this._recentlyHiddenMeshes.clear(), this._meshIDColorCodeMap.clear(), this._transparentMat.dispose(), this._colorCodeMeshMap.clear();
    const t = this.components.get(rn);
    for (const e in this.colorMeshes) {
      const n = this.colorMeshes.get(e);
      n && t.destroy(n, true);
    }
    this.colorMeshes.clear();
  }
  /**
   * Adds a mesh to the culler. When the mesh is not visibile anymore, it will be removed from the scene. When it's visible again, it will be added to the scene.
   * @param mesh - The mesh to add. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   * @returns {void}
   */
  add(t) {
    if (!this.enabled)
      return;
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const e = t instanceof InstancedMesh, { geometry: n, material: s } = t, { colorMaterial: i, code: r } = this.getAvailableMaterial();
    let o;
    if (Array.isArray(s)) {
      let d = true;
      const m = [];
      for (const f of s)
        kl.isTransparent(f) ? m.push(this._transparentMat) : (d = false, m.push(i));
      if (d) {
        i.dispose(), this.isProcessing = false;
        return;
      }
      o = m;
    } else if (kl.isTransparent(s)) {
      i.dispose(), this.isProcessing = false;
      return;
    } else
      o = i;
    this._colorCodeMeshMap.set(r, t), this._meshIDColorCodeMap.set(t.uuid, r);
    const l = e ? t.count : 1, u = new InstancedMesh(n, o, l);
    e ? u.instanceMatrix = t.instanceMatrix : u.setMatrixAt(0, new Matrix4()), t.visible = false, t.updateWorldMatrix(true, false), u.applyMatrix4(t.matrixWorld), u.updateMatrix(), this.scene.add(u), this.colorMeshes.set(t.uuid, u), this.increaseColor(), this.isProcessing = false;
  }
  /**
   * Removes a mesh from the culler, so its visibility is not controlled by the culler anymore.
   * When the mesh is removed, it will be hidden from the scene and its color-coded mesh will be destroyed.
   * @param mesh - The mesh to remove. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   * @returns {void}
   */
  remove(t) {
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const e = this.components.get(rn);
    this._currentVisibleMeshes.delete(t), this._recentlyHiddenMeshes.delete(t);
    const n = this.colorMeshes.get(t.uuid), s = this._meshIDColorCodeMap.get(t.uuid);
    if (!n || !s) {
      this.isProcessing = false, console.log(t.visible);
      return;
    }
    this._colorCodeMeshMap.delete(s), this._meshIDColorCodeMap.delete(t.uuid), this.colorMeshes.delete(t.uuid), n.geometry = void 0, n.material = [], e.destroy(n, true), this._recentlyHiddenMeshes.delete(t), this._currentVisibleMeshes.delete(t), this.isProcessing = false;
  }
  getAvailableMaterial() {
    const { r: t, g: e, b: n, code: s } = this.getAvailableColor(), i = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const r = new Color(`rgb(${t}, ${e}, ${n})`);
    if (!this.world.renderer)
      throw new Error("Renderer not found in the world!");
    const o = this.world.renderer.clippingPlanes, l = new MeshBasicMaterial({
      color: r,
      clippingPlanes: o,
      side: DoubleSide
    });
    return ColorManagement.enabled = i, { colorMaterial: l, code: s };
  }
};
var Zc = class Ia extends Fe {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "_enabled", true), S(this, "list", /* @__PURE__ */ new Map()), t.add(Ia.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const [e, n] of this.list)
      n.enabled = t;
  }
  /**
   * Creates a new MeshCullerRenderer for the given world.
   * If a MeshCullerRenderer already exists for the world, it will return the existing one.
   *
   * @param world - The world for which to create the MeshCullerRenderer.
   * @param config - Optional configuration settings for the MeshCullerRenderer.
   *
   * @returns The newly created or existing MeshCullerRenderer for the given world.
   */
  create(t, e) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const n = new gf(this.components, t, e);
    return this.list.set(t.uuid, n), n;
  }
  /**
   * Deletes the MeshCullerRenderer associated with the given world.
   * If a MeshCullerRenderer exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the MeshCullerRenderer.
   *
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.onDisposed.trigger(Ia.uuid), this.onDisposed.reset();
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear();
  }
};
S(Zc, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
var Ef = Zc;
var vf = class {
  constructor(t) {
    if (S(this, "onDisposed", new $()), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onResize", new $()), S(this, "frontOffset", 0), S(this, "overrideMaterial", new MeshDepthMaterial()), S(this, "backgroundColor", new Color(395274)), S(this, "renderer"), S(this, "enabled", true), S(this, "world"), S(this, "_lockRotation", true), S(this, "_camera"), S(this, "_plane"), S(this, "_size", new Vector2(320, 160)), S(this, "_tempVector1", new Vector3()), S(this, "_tempVector2", new Vector3()), S(this, "_tempTarget", new Vector3()), S(this, "down", new Vector3(0, -1, 0)), S(this, "updatePlanes", () => {
      if (!this.world.renderer)
        throw new Error("The given world must have a renderer!");
      const s = [], i = this.world.renderer.three;
      for (const r of i.clippingPlanes)
        s.push(r);
      s.push(this._plane), this.renderer.clippingPlanes = s;
    }), this.world = t, !this.world.renderer)
      throw new Error("The given world must have a renderer!");
    this.renderer = new WebGLRenderer(), this.renderer.setSize(this._size.x, this._size.y);
    const e = 1, n = this._size.x / this._size.y;
    this._camera = new OrthographicCamera(
      e * n / -2,
      e * n / 2,
      e / 2,
      e / -2
    ), this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes), this._camera.position.set(0, 200, 0), this._camera.zoom = 0.1, this._camera.rotation.x = -Math.PI / 2, this._plane = new Plane(this.down, 200), this.updatePlanes();
  }
  /**
   * Gets or sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   */
  get lockRotation() {
    return this._lockRotation;
  }
  /**
   * Sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   * @param active - If `true`, rotation is locked. If `false`, rotation is not locked.
   */
  set lockRotation(t) {
    this._lockRotation = t, t && (this._camera.rotation.z = 0);
  }
  /**
   * Gets the current zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @returns The current zoom level of the minimap.
   */
  get zoom() {
    return this._camera.zoom;
  }
  /**
   * Sets the zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @param value - The new zoom level of the minimap.
   */
  set zoom(t) {
    this._camera.zoom = t, this._camera.updateProjectionMatrix();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.onResize.reset(), this.overrideMaterial.dispose(), this.renderer.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** Returns the camera used by the MiniMap */
  get() {
    return this._camera;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const t = this.world.scene.three, e = this.world.camera;
    if (!e.hasCameraControls())
      throw new Error("The given world must use camera controls!");
    if (!(t instanceof Scene))
      throw new Error("The given world must have a THREE.Scene as a root!");
    const n = e.controls;
    if (n.getPosition(this._tempVector1), this._camera.position.x = this._tempVector1.x, this._camera.position.z = this._tempVector1.z, this.frontOffset !== 0 && (n.getTarget(this._tempVector2), this._tempVector2.sub(this._tempVector1), this._tempVector2.normalize().multiplyScalar(this.frontOffset), this._camera.position.x += this._tempVector2.x, this._camera.position.z += this._tempVector2.z), !this._lockRotation) {
      n.getTarget(this._tempTarget);
      const i = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = i + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const s = t.background;
    t.background = this.backgroundColor, this.renderer.render(t, this._camera), t.background = s, this.onAfterUpdate.trigger();
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    return this._size;
  }
  /** {@link Resizeable.resize} */
  resize(t = this._size) {
    this._size.copy(t), this.renderer.setSize(t.x, t.y);
    const e = t.x / t.y, n = 1;
    this._camera.left = n * e / -2, this._camera.right = n * e / 2, this._camera.top = n / 2, this._camera.bottom = -n / 2, this._camera.updateProjectionMatrix(), this.onResize.trigger(t);
  }
};
var If = class Qc extends Fe {
  constructor(t) {
    super(t), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onDisposed", new $()), S(this, "enabled", true), S(this, "list", /* @__PURE__ */ new Map()), this.components.add(Qc.uuid, this);
  }
  /**
   * Creates a new {@link MiniMap} instance associated with the given world.
   * If a {@link MiniMap} instance already exists for the given world, an error will be thrown.
   *
   * @param world - The {@link World} for which to create a {@link MiniMap} instance.
   * @returns The newly created {@link MiniMap} instance.
   * @throws Will throw an error if a {@link MiniMap} instance already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a minimap!");
    const e = new vf(t);
    return this.list.set(t.uuid, e), e;
  }
  /**
   * Deletes a {@link MiniMap} instance associated with the given world ID.
   * If a {@link MiniMap} instance does not exist for the given ID, nothing happens.
   *
   * @param id - The unique identifier of the world for which to delete the {@link MiniMap} instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t);
    e && e.dispose(), this.list.delete(t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update() {
    for (const [t, e] of this.list)
      e.update();
  }
};
S(If, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
var qc = class tn extends Fe {
  constructor(t) {
    super(t), S(this, "enabled", true), S(this, "onDisposed", new $()), S(this, "_absoluteMin"), S(this, "_absoluteMax"), S(this, "_meshes", []), this.components.add(tn.uuid, this), this._absoluteMin = tn.newBound(true), this._absoluteMax = tn.newBound(false);
  }
  /**
   * A static method to calculate the dimensions of a given bounding box.
   *
   * @param bbox - The bounding box to calculate the dimensions for.
   * @returns An object containing the width, height, depth, and center of the bounding box.
   */
  static getDimensions(t) {
    const { min: e, max: n } = t, s = Math.abs(n.x - e.x), i = Math.abs(n.y - e.y), r = Math.abs(n.z - e.z), o = new Vector3();
    return o.subVectors(n, e).divideScalar(2).add(e), { width: s, height: i, depth: r, center: o };
  }
  /**
   * A static method to create a new bounding box boundary.
   *
   * @param positive - A boolean indicating whether to create a boundary for positive or negative values.
   * @returns A new THREE.Vector3 representing the boundary.
   *
   * @remarks
   * This method is used to create a new boundary for calculating bounding boxes.
   * It sets the x, y, and z components of the returned vector to positive or negative infinity,
   * depending on the value of the `positive` parameter.
   *
   * @example
   * ```typescript
   * const positiveBound = BoundingBoxer.newBound(true);
   * console.log(positiveBound); // Output: Vector3 { x: Infinity, y: Infinity, z: Infinity }
   *
   * const negativeBound = BoundingBoxer.newBound(false);
   * console.log(negativeBound); // Output: Vector3 { x: -Infinity, y: -Infinity, z: -Infinity }
   * ```
   */
  static newBound(t) {
    const e = t ? 1 : -1;
    return new Vector3(
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE
    );
  }
  /**
   * A static method to calculate the bounding box of a set of points.
   *
   * @param points - An array of THREE.Vector3 representing the points.
   * @param min - An optional THREE.Vector3 representing the minimum bounds. If not provided, it will be calculated.
   * @param max - An optional THREE.Vector3 representing the maximum bounds. If not provided, it will be calculated.
   * @returns A THREE.Box3 representing the bounding box of the given points.
   *
   * @remarks
   * This method calculates the bounding box of a set of points by iterating through each point and updating the minimum and maximum bounds accordingly.
   * If the `min` or `max` parameters are provided, they will be used as the initial bounds. Otherwise, the initial bounds will be set to positive and negative infinity.
   *
   * @example
   * ```typescript
   * const points = [
   *   new THREE.Vector3(1, 2, 3),
   *   new THREE.Vector3(4, 5, 6),
   *   new THREE.Vector3(7, 8, 9),
   * ];
   *
   * const bbox = BoundingBoxer.getBounds(points);
   * console.log(bbox); // Output: Box3 { min: Vector3 { x: 1, y: 2, z: 3 }, max: Vector3 { x: 7, y: 8, z: 9 } }
   * ```
   */
  static getBounds(t, e, n) {
    const s = n || this.newBound(false), i = e || this.newBound(true);
    for (const r of t)
      r.x < i.x && (i.x = r.x), r.y < i.y && (i.y = r.y), r.z < i.z && (i.z = r.z), r.x > s.x && (s.x = r.x), r.y > s.y && (s.y = r.y), r.z > s.z && (s.z = r.z);
    return new Box3(e, n);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(rn);
    for (const e of this._meshes)
      t.destroy(e);
    this._meshes = [], this.onDisposed.trigger(tn.uuid), this.onDisposed.reset();
  }
  /**
   * Returns the bounding box of the calculated fragments.
   *
   * @returns A new THREE.Box3 instance representing the bounding box.
   *
   * @remarks
   * This method clones the internal minimum and maximum vectors and returns a new THREE.Box3 instance.
   * The returned box represents the bounding box of the calculated fragments.
   *
   * @example
   * ```typescript
   * const boundingBox = boundingBoxer.get();
   * console.log(boundingBox); // Output: Box3 { min: Vector3 { x: -10, y: -10, z: -10 }, max: Vector3 { x: 10, y: 10, z: 10 } }
   * ```
   */
  get() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone();
    return new Box3(t, e);
  }
  /**
   * Calculates and returns a sphere that encompasses the entire bounding box.
   *
   * @returns A new THREE.Sphere instance representing the calculated sphere.
   *
   * @remarks
   * This method calculates the center and radius of a sphere that encompasses the entire bounding box.
   * The center is calculated as the midpoint between the minimum and maximum bounds of the bounding box.
   * The radius is calculated as the distance from the center to the minimum bound.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingSphere = boundingBoxer.getSphere();
   * console.log(boundingSphere); // Output: Sphere { center: Vector3 { x: 0, y: 0, z: 0 }, radius: 10 }
   * ```
   */
  getSphere() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone(), n = Math.abs((e.x - t.x) / 2), s = Math.abs((e.y - t.y) / 2), i = Math.abs((e.z - t.z) / 2), r = new Vector3(t.x + n, t.y + s, t.z + i), o = r.distanceTo(t);
    return new Sphere(r, o);
  }
  /**
   * Returns a THREE.Mesh instance representing the bounding box.
   *
   * @returns A new THREE.Mesh instance representing the bounding box.
   *
   * @remarks
   * This method calculates the dimensions of the bounding box using the `getDimensions` method.
   * It then creates a new THREE.BoxGeometry with the calculated dimensions.
   * A new THREE.Mesh is created using the box geometry, and it is added to the `_meshes` array.
   * The position of the mesh is set to the center of the bounding box.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingBoxMesh = boundingBoxer.getMesh();
   * scene.add(boundingBoxMesh);
   * ```
   */
  getMesh() {
    const t = new Box3(this._absoluteMin, this._absoluteMax), e = tn.getDimensions(t), { width: n, height: s, depth: i, center: r } = e, o = new BoxGeometry(n, s, i), l = new Mesh(o);
    return this._meshes.push(l), l.position.copy(r), l;
  }
  /**
   * Resets the internal minimum and maximum vectors to positive and negative infinity, respectively.
   * This method is used to prepare the BoundingBoxer for a new set of fragments.
   *
   * @remarks
   * This method is called when a new set of fragments is added to the BoundingBoxer.
   * It ensures that the bounding box calculations are accurate and up-to-date.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * // ...
   * boundingBoxer.reset();
   * ```
   */
  reset() {
    this._absoluteMin = tn.newBound(true), this._absoluteMax = tn.newBound(false);
  }
  /**
   * Adds a FragmentsGroup to the BoundingBoxer.
   *
   * @param group - The FragmentsGroup to add.
   *
   * @remarks
   * This method iterates through each fragment in the provided FragmentsGroup,
   * and calls the `addMesh` method for each fragment's mesh.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * ```
   */
  add(t) {
    for (const e of t.items)
      this.addMesh(e.mesh);
  }
  /**
   * Adds a mesh to the BoundingBoxer and calculates the bounding box.
   *
   * @param mesh - The mesh to add. It can be an instance of THREE.InstancedMesh, THREE.Mesh, or FRAGS.CurveMesh.
   * @param itemIDs - An optional iterable of numbers representing the item IDs.
   *
   * @remarks
   * This method calculates the bounding box of the provided mesh and updates the internal minimum and maximum vectors.
   * If the mesh is an instance of THREE.InstancedMesh, it calculates the bounding box for each instance.
   * If the mesh is an instance of FRAGS.FragmentMesh and itemIDs are provided, it calculates the bounding box for the specified item IDs.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.addMesh(mesh);
   * ```
   */
  addMesh(t, e) {
    if (!t.geometry.index)
      return;
    const n = tn.getFragmentBounds(t);
    t.updateMatrixWorld();
    const s = t.matrixWorld, i = new Matrix4(), r = t instanceof InstancedMesh, o = /* @__PURE__ */ new Set();
    if (e && t instanceof ae)
      for (const l of e) {
        const u = t.fragment.getInstancesIDs(l);
        if (u)
          for (const d of u)
            o.add(d);
      }
    else
      o.add(0);
    for (const l of o) {
      const u = n.min.clone(), d = n.max.clone();
      r && (t.getMatrixAt(l, i), u.applyMatrix4(i), d.applyMatrix4(i)), u.applyMatrix4(s), d.applyMatrix4(s), u.x < this._absoluteMin.x && (this._absoluteMin.x = u.x), u.y < this._absoluteMin.y && (this._absoluteMin.y = u.y), u.z < this._absoluteMin.z && (this._absoluteMin.z = u.z), u.x > this._absoluteMax.x && (this._absoluteMax.x = u.x), u.y > this._absoluteMax.y && (this._absoluteMax.y = u.y), u.z > this._absoluteMax.z && (this._absoluteMax.z = u.z), d.x > this._absoluteMax.x && (this._absoluteMax.x = d.x), d.y > this._absoluteMax.y && (this._absoluteMax.y = d.y), d.z > this._absoluteMax.z && (this._absoluteMax.z = d.z), d.x < this._absoluteMin.x && (this._absoluteMin.x = d.x), d.y < this._absoluteMin.y && (this._absoluteMin.y = d.y), d.z < this._absoluteMin.z && (this._absoluteMin.z = d.z);
    }
  }
  static getFragmentBounds(t) {
    const e = t.geometry.attributes.position, n = Number.MAX_VALUE, s = -n, i = new Vector3(n, n, n), r = new Vector3(s, s, s);
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = Array.from(t.geometry.index.array);
    for (let l = 0; l < o.length; l++) {
      if (l % 3 === 0 && o[l] === 0 && o[l + 1] === 0 && o[l + 2] === 0) {
        l += 2;
        continue;
      }
      const u = o[l], d = e.getX(u), m = e.getY(u), f = e.getZ(u);
      d < i.x && (i.x = d), m < i.y && (i.y = m), f < i.z && (i.z = f), d > r.x && (r.x = d), m > r.y && (r.y = m), f > r.z && (r.z = f);
    }
    return new Box3(i, r);
  }
};
S(qc, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
var Jc = qc;
var $c = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  3940055652,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014
]);
var eh = class th extends Fe {
  constructor(t) {
    super(t), S(this, "enabled", true), t.add(th.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(t, e, n = false, s = true) {
    const i = {}, r = new Set(t.GetIfcEntityList(e)), o = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const l of o)
      r.add(l);
    for (const l of r) {
      if ($c.has(l))
        continue;
      const u = o.has(l) && s, d = t.GetLineIDsWithType(e, l);
      for (const m of d) {
        const f = t.GetLine(0, m, u, n);
        i[f.expressID] = f;
      }
    }
    return i;
  }
};
S(eh, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
var yf = eh;
var nh = class sh extends Fe {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "onFragmentsLoaded", new $()), S(this, "onFragmentsDisposed", new $()), S(this, "list", /* @__PURE__ */ new Map()), S(this, "groups", /* @__PURE__ */ new Map()), S(this, "baseCoordinationModel", ""), S(this, "enabled", true), S(this, "_loader", new an()), this.components.add(sh.uuid, this);
  }
  /**
   * Getter for the meshes of all fragments in the FragmentsManager.
   * It iterates over the fragments in the list and pushes their meshes into an array.
   * @returns {THREE.Mesh[]} An array of THREE.Mesh objects representing the fragments.
   */
  get meshes() {
    const t = [];
    for (const [e, n] of this.list)
      t.push(n.mesh);
    return t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.groups)
      e.dispose(true);
    this.baseCoordinationModel = "", this.groups.clear(), this.list.clear(), this.onFragmentsLoaded.reset(), this.onFragmentsDisposed.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Dispose of a specific fragment group.
   * This method removes the group from the groups map, deletes all fragments within the group from the list,
   * disposes of the group, and triggers the onFragmentsDisposed event.
   *
   * @param group - The fragment group to be disposed.
   */
  disposeGroup(t) {
    const { uuid: e } = t, n = [];
    for (const s of t.items)
      n.push(s.id), this.list.delete(s.id);
    t.dispose(true), this.groups.delete(t.uuid), this.onFragmentsDisposed.trigger({
      groupID: e,
      fragmentIDs: n
    });
  }
  /**
   * Loads a binary file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(t, e) {
    const n = { coordinate: true, ...e }, { coordinate: s, name: i, properties: r, relationsMap: o } = n, l = this._loader.import(t);
    i && (l.name = i);
    for (const u of l.items)
      u.group = l, this.list.set(u.id, u);
    return s && this.coordinate([l]), this.groups.set(l.uuid, l), r && l.setLocalProperties(r), o && this.components.get(Xr).setRelationMap(l, o), this.onFragmentsLoaded.trigger(l), l;
  }
  /**
   * Export the specified fragmentsgroup to binary data.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(t) {
    return this._loader.export(t);
  }
  /**
   * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
   * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
   * @returns A map of model IDs to sets of express IDs.
   */
  getModelIdMap(t) {
    const e = {};
    for (const n in t) {
      const s = this.list.get(n);
      if (!(s && s.group))
        continue;
      const i = s.group;
      i.uuid in e || (e[i.uuid] = /* @__PURE__ */ new Set());
      const r = t[n];
      for (const o of r)
        e[i.uuid].add(o);
    }
    return e;
  }
  /**
   * Converts a map of model IDs to sets of express IDs to a fragment ID map.
   * @param modelIdMap - A map of model IDs to their corresponding express IDs.
   * @returns A fragment ID map.
   * @remarks
   * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
   * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
   * The fragment ID maps are then merged into a single map and returned.
   * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
   */
  modelIdToFragmentIdMap(t) {
    let e = {};
    for (const n in t) {
      const s = this.groups.get(n);
      if (!s)
        continue;
      const i = t[n], r = s.getFragmentMap(i);
      e = { ...e, ...r };
    }
    return e;
  }
  /**
   * Applies coordinate transformation to the provided models.
   * If no models are provided, all groups are used.
   * The first model in the list becomes the base model for coordinate transformation.
   * All other models are then transformed to match the base model's coordinate system.
   *
   * @param models - The models to apply coordinate transformation to.
   * If not provided, all groups are used.
   *
   * @returns {void}
   */
  coordinate(t = Array.from(this.groups.values())) {
    if (this.baseCoordinationModel.length === 0) {
      const n = t.pop();
      if (!n)
        return;
      this.baseCoordinationModel = n.uuid;
    }
    if (!t.length)
      return;
    const e = this.groups.get(this.baseCoordinationModel);
    if (!e) {
      console.log("No base model found for coordination!");
      return;
    }
    for (const n of t)
      n !== e && (n.position.set(0, 0, 0), n.rotation.set(0, 0, 0), n.scale.set(1, 1, 1), n.updateMatrix(), n.applyMatrix4(n.coordinationMatrix.clone().invert()), n.applyMatrix4(e.coordinationMatrix));
  }
};
S(nh, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var He = nh;
var wf = /* @__PURE__ */ new Map([
  [
    IFCRELAGGREGATES,
    {
      forRelating: "IsDecomposedBy",
      forRelated: "Decomposes"
    }
  ],
  [
    IFCRELASSOCIATESMATERIAL,
    {
      forRelating: "AssociatedTo",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelating: "ClassificationForObjects",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSIGNSTOGROUP,
    {
      forRelating: "IsGroupedBy",
      forRelated: "HasAssignments"
    }
  ],
  [
    IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ]
]);
var ih = class ya extends Fe {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "onRelationsIndexed", new $()), S(this, "relationMaps", {}), S(this, "enabled", true), S(this, "_relToAttributesMap", wf), S(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements"
    ]), S(this, "_ifcRels", [
      IFCRELAGGREGATES,
      IFCRELASSOCIATESMATERIAL,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP,
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELDEFINESBYTEMPLATE,
      IFCRELCONTAINEDINSPATIALSTRUCTURE
    ]), S(this, "onFragmentsDisposed", (e) => {
      delete this.relationMaps[e.groupID];
    }), this.components.add(ya.uuid, this), t.get(He).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(t, e, n, s) {
    const i = Object.keys(e).find(
      (m) => m.startsWith("Relating")
    ), r = Object.keys(e).find(
      (m) => m.startsWith("Related")
    );
    if (!(i && r))
      return;
    const o = e[i].value, l = e[r].map((m) => m.value), u = t.get(o) ?? /* @__PURE__ */ new Map(), d = this._inverseAttributes.indexOf(s);
    u.set(d, l), t.set(o, u);
    for (const m of l) {
      const f = t.get(m) ?? /* @__PURE__ */ new Map(), g = this._inverseAttributes.indexOf(n), v = f.get(g) ?? [];
      v.push(o), f.set(g, v), t.set(m, f);
    }
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(t, e) {
    this.relationMaps[t.uuid] = e, this.onRelationsIndexed.trigger({
      modelID: t.uuid,
      relationsMap: e
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(t) {
    if (!t.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let e = this.relationMaps[t.uuid];
    if (e)
      return e;
    e = /* @__PURE__ */ new Map();
    for (const n of this._ifcRels) {
      const s = await t.getAllPropertiesOfType(n);
      if (!s)
        continue;
      const i = this._relToAttributesMap.get(n);
      if (!i)
        continue;
      const { forRelated: r, forRelating: o } = i;
      for (const l in s) {
        const u = s[l];
        this.indexRelations(e, u, r, o);
      }
    }
    return this.setRelationMap(t, e), e;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const s of this._ifcRels) {
      const i = this._relToAttributesMap.get(s);
      if (!i)
        continue;
      const { forRelated: r, forRelating: o } = i, l = t.GetLineIDsWithType(e, s);
      for (let u = 0; u < l.size(); u++) {
        const d = await t.properties.getItemProperties(
          e,
          l.get(u)
        );
        this.indexRelations(n, d, r, o);
      }
    }
    return this.onRelationsIndexed.trigger({
      modelID: e.toString(),
      relationsMap: n
    }), n;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity.
   * @param expressID The unique identifier of the entity within the model.
   * @param relationName The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities, or `null` if no relations are found
   * or the specified relation name is not indexed.
   */
  getEntityRelations(t, e, n) {
    const s = this.relationMaps[t.uuid];
    if (!s)
      return null;
    const i = s.get(e), r = this._inverseAttributes.indexOf(n);
    return !i || r === -1 ? null : i.get(r) || null;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(t) {
    const e = {};
    for (const [n, s] of t.entries()) {
      e[n] || (e[n] = {});
      for (const [i, r] of s.entries())
        e[n][i] = r;
    }
    return JSON.stringify(e);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(t) {
    const e = this.relationMaps[t.uuid];
    return e ? this.serializeRelations(e) : null;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const t = {};
    for (const e in this.relationMaps) {
      const n = this.relationMaps[e], s = {};
      for (const [i, r] of n.entries()) {
        s[i] || (s[i] = {});
        for (const [o, l] of r.entries())
          s[i][o] = l;
      }
      t[e] = s;
    }
    return JSON.stringify(t);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(t) {
    const e = JSON.parse(t), n = /* @__PURE__ */ new Map();
    for (const s in e) {
      const i = e[s], r = /* @__PURE__ */ new Map();
      for (const o in i)
        r.set(Number(o), i[o]);
      n.set(Number(s), r);
    }
    return n;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.relationMaps = {}, this.components.get(He).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(ya.uuid), this.onDisposed.reset();
  }
};
S(ih, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
var Xr = ih;
var rh = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
var yn = class _yn {
  static async getUnits(t) {
    var e;
    const { IFCUNITASSIGNMENT: n } = web_ifc_api_exports, s = await t.getAllPropertiesOfType(n);
    if (!s)
      return 1;
    const i = Object.keys(s), r = s[parseInt(i[0], 10)];
    for (const o of r.Units) {
      if (o.value === void 0 || o.value === null)
        continue;
      const l = await t.getProperties(o.value);
      if (!l || !l.UnitType || !l.UnitType.value || l.UnitType.value !== "LENGTHUNIT")
        continue;
      let u = 1, d = 1;
      return l.Name.value === "METRE" && (d = 1), l.Name.value === "FOOT" && (d = 0.3048), ((e = l.Prefix) == null ? void 0 : e.value) === "MILLI" && (u = 1e-3), d * u;
    }
    return 1;
  }
  static async findItemByGuid(t, e) {
    var n;
    const s = t.getAllPropertiesIDs();
    for (const i of s) {
      const r = await t.getProperties(i);
      if (r && ((n = r.GlobalId) == null ? void 0 : n.value) === e)
        return r;
    }
    return null;
  }
  static async getRelationMap(t, e, n) {
    var s;
    const i = n ?? (async () => {
    }), r = {}, o = t.getAllPropertiesIDs();
    for (const l of o) {
      const u = await t.getProperties(l);
      if (!u)
        continue;
      const d = u.type === e, m = Object.keys(u).find(
        (x) => x.startsWith("Relating")
      ), f = Object.keys(u).find(
        (x) => x.startsWith("Related")
      );
      if (!(d && m && f))
        continue;
      const g = await t.getProperties((s = u[m]) == null ? void 0 : s.value), v = u[f];
      if (!g || !v || !(v && Array.isArray(v)))
        continue;
      const y = v.map((x) => x.value);
      await i(g.expressID, y), r[g.expressID] = y;
    }
    return r;
  }
  static async getQsetQuantities(t, e, n) {
    const s = n ?? (() => {
    }), i = await t.getProperties(e);
    return !i || i.type !== IFCELEMENTQUANTITY ? null : (i.Quantities ?? [{}]).map((r) => (r.value && s(r.value), r.value)).filter((r) => r !== null);
  }
  static async getPsetProps(t, e, n) {
    const s = n ?? (() => {
    }), i = await t.getProperties(e);
    return !i || i.type !== IFCPROPERTYSET ? null : (i.HasProperties ?? [{}]).map((r) => (r.value && s(r.value), r.value)).filter((r) => r !== null);
  }
  static async getPsetRel(t, e) {
    var n;
    if (!await t.getProperties(e))
      return null;
    const s = await t.getAllPropertiesOfType(
      IFCRELDEFINESBYPROPERTIES
    );
    if (!s)
      return null;
    const i = Object.values(s);
    let r = null;
    for (const o of i)
      ((n = o.RelatingPropertyDefinition) == null ? void 0 : n.value) === e && (r = o.expressID);
    return r;
  }
  static async getQsetRel(t, e) {
    return _yn.getPsetRel(t, e);
  }
  static async getEntityName(t, e) {
    var n;
    const s = await t.getProperties(e);
    if (!s)
      return { key: null, name: null };
    const i = Object.keys(s).find((o) => o.endsWith("Name")) ?? null, r = i ? (n = s[i]) == null ? void 0 : n.value : null;
    return { key: i, name: r };
  }
  static async getQuantityValue(t, e) {
    const n = await t.getProperties(e);
    if (!n)
      return { key: null, value: null };
    const s = Object.keys(n).find((r) => r.endsWith("Value")) ?? null;
    let i;
    return s === null || n[s] === void 0 || n[s] === null ? i = null : i = n[s].value, { key: s, value: i };
  }
  static isRel(t) {
    return rh[t].startsWith("IFCREL");
  }
  static async attributeExists(t, e, n) {
    const s = await t.getProperties(e);
    return s ? Object.keys(s).includes(n) : false;
  }
  static async groupEntitiesByType(t, e) {
    var n;
    const s = /* @__PURE__ */ new Map();
    for (const i of e) {
      const r = await t.getProperties(i);
      if (!r)
        continue;
      const o = r.type;
      s.get(o) || s.set(o, /* @__PURE__ */ new Set()), (n = s.get(o)) == null || n.add(i);
    }
    return s;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
};
var Cf = class {
  constructor() {
    S(this, "factor", 1), S(this, "complement", 1);
  }
  apply(t) {
    const e = this.getScaleMatrix().multiply(t);
    t.copy(e);
  }
  setUp(t) {
    var e;
    this.factor = 1;
    const n = this.getLengthUnits(t);
    if (!n)
      return;
    const s = n == null, i = n.Name === void 0 || n.Name === null;
    s || i || (n.Name.value === "FOOT" ? this.factor = 0.3048 : ((e = n.Prefix) == null ? void 0 : e.value) === "MILLI" && (this.complement = 1e-3));
  }
  getLengthUnits(t) {
    try {
      const e = t.GetLineIDsWithType(
        0,
        IFCUNITASSIGNMENT
      ).get(0), n = t.GetLine(0, e);
      for (const s of n.Units) {
        if (!s || s.value === null || s.value === void 0)
          continue;
        const i = t.GetLine(0, s.value);
        if (i.UnitType && i.UnitType.value === "LENGTHUNIT")
          return i;
      }
      return null;
    } catch {
      return console.log("Could not get units"), null;
    }
  }
  getScaleMatrix() {
    const t = this.factor;
    return new Matrix4().fromArray([
      t,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ]);
  }
};
var oh = class {
  constructor() {
    S(this, "itemsByFloor", {}), S(this, "_units", new Cf());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(t) {
    this._units.setUp(t), this.cleanUp();
    try {
      const e = t.GetLineIDsWithType(
        0,
        IFCRELCONTAINEDINSPATIALSTRUCTURE
      ), n = /* @__PURE__ */ new Set(), s = t.GetLineIDsWithType(0, IFCSPACE);
      for (let u = 0; u < s.size(); u++)
        n.add(s.get(u));
      const i = t.GetLineIDsWithType(0, IFCRELAGGREGATES), r = i.size();
      for (let u = 0; u < r; u++) {
        const d = i.get(u), m = t.GetLine(0, d);
        if (!m || !m.RelatingObject || !m.RelatedObjects)
          continue;
        const f = m.RelatingObject.value, g = m.RelatedObjects;
        for (const v of g) {
          const y = v.value;
          n.has(y) && (this.itemsByFloor[y] = f);
        }
      }
      const o = {}, l = e.size();
      for (let u = 0; u < l; u++) {
        const d = e.get(u), m = t.GetLine(0, d);
        if (!m || !m.RelatingStructure || !m.RelatedElements)
          continue;
        const f = m.RelatingStructure.value, g = m.RelatedElements;
        if (n.has(f))
          for (const v of g) {
            o[f] || (o[f] = []);
            const y = v.value;
            o[f].push(y);
          }
        else
          for (const v of g) {
            const y = v.value;
            this.itemsByFloor[y] = f;
          }
      }
      for (const u in o) {
        const d = this.itemsByFloor[u];
        if (d !== void 0) {
          const m = o[u];
          for (const f of m)
            this.itemsByFloor[f] = d;
        }
      }
      for (let u = 0; u < r; u++) {
        const d = i.get(u), m = t.GetLine(0, d);
        if (!m || !m.RelatingObject || !m.RelatedObjects)
          continue;
        const f = m.RelatingObject.value, g = m.RelatedObjects;
        for (const v of g) {
          const y = v.value, x = this.itemsByFloor[f];
          x !== void 0 && (this.itemsByFloor[y] = x);
        }
      }
    } catch {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
};
var Na = class {
  constructor() {
    S(this, "includeProperties", true), S(this, "optionalCategories", [IFCSPACE]), S(this, "coordinate", true), S(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: LogLevel.LOG_LEVEL_OFF
    }), S(this, "excludedCategories", /* @__PURE__ */ new Set()), S(this, "saveLocations", false), S(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true
      // OPTIMIZE_PROFILES: true,
    }), S(this, "autoSetWasm", true), S(this, "customLocateFileHandler", null);
  }
};
var ah = class {
  constructor() {
    S(this, "defLineMat", new LineBasicMaterial({ color: 16777215 }));
  }
  read(t) {
    const e = t.GetAllAlignments(0), n = t.GetAllCrossSections2D(0), s = t.GetAllCrossSections3D(0), i = {
      IfcAlignment: e,
      IfcCrossSection2D: n,
      IfcCrossSection3D: s
    };
    return this.get(i);
  }
  get(t) {
    if (t.IfcAlignment) {
      const e = /* @__PURE__ */ new Map();
      for (const n of t.IfcAlignment) {
        const s = new Ne();
        s.absolute = this.getCurves(n.curve3D, s), s.horizontal = this.getCurves(n.horizontal, s), s.vertical = this.getCurves(n.vertical, s), e.set(e.size, s);
      }
      return { alignments: e, coordinationMatrix: new Matrix4() };
    }
  }
  getCurves(t, e) {
    const n = [];
    let s = 0;
    for (const i of t) {
      const r = {};
      if (i.data)
        for (const f of i.data) {
          const [g, v] = f.split(": "), y = parseFloat(v);
          r[g] = y || v;
        }
      const { points: o } = i, l = new Float32Array(o.length * 3);
      for (let f = 0; f < o.length; f++) {
        const { x: g, y: v, z: y } = o[f];
        l[f * 3] = g, l[f * 3 + 1] = v, l[f * 3 + 2] = y || 0;
      }
      const u = new BufferAttribute(l, 3), d = new EdgesGeometry();
      d.setAttribute("position", u);
      const m = new ke(
        s,
        r,
        e,
        d,
        this.defLineMat
      );
      n.push(m.curve), s++;
    }
    return n;
  }
};
var lh = class {
  getNameInfo(t) {
    var e;
    const n = {}, { arguments: s } = t.GetHeaderLine(0, FILE_NAME) || {};
    if (!s)
      return n;
    const [
      i,
      r,
      o,
      l,
      u,
      d,
      m
    ] = s;
    if (i != null && i.value && (n.name = i.value), r != null && r.value && (n.creationDate = new Date(r.value)), o) {
      n.author = {};
      const [f, g] = o;
      f != null && f.value && (n.author.name = f.value), g != null && g.value && (n.author.email = g.value);
    }
    return (e = l[0]) != null && e.value && (n.organization = l[0].value), u != null && u.value && (n.preprocessorVersion = u == null ? void 0 : u.value), d != null && d.value && (n.originatingSystem = d == null ? void 0 : d.value), m != null && m.value && (n.authorization = m == null ? void 0 : m.value), n;
  }
  getDescriptionInfo(t) {
    var e;
    const n = {}, { arguments: s } = t.GetHeaderLine(0, FILE_DESCRIPTION) || {};
    if (!s)
      return n;
    const [i, r] = s;
    if ((e = i[0]) != null && e.value) {
      const o = i[0].value.match(/\[([^\]]+)\]/);
      o && o[1] && (n.viewDefinition = o[1]);
    }
    return r != null && r.value && (n.implementationLevel = r.value), n;
  }
};
var ch = class wa extends Fe {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "onIfcStartedLoading", new $()), S(this, "onSetup", new $()), S(this, "settings", new Na()), S(this, "webIfc", new IfcAPI2()), S(this, "enabled", true), S(this, "_material", new MeshLambertMaterial()), S(this, "_spatialTree", new oh()), S(this, "_metaData", new lh()), S(this, "_fragmentInstances", /* @__PURE__ */ new Map()), S(this, "_civil", new ah()), S(this, "_visitedFragments", /* @__PURE__ */ new Map()), S(this, "_materialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    })), this.components.add(wa.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null, this.onDisposed.trigger(wa.uuid), this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(t) {
    this.settings = { ...this.settings, ...t }, this.settings.autoSetWasm && await this.autoSetWasm(), this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Optional boolean indicating whether to coordinate the loaded IFC data. Default is true.
   *
   * @returns A Promise that resolves to the FragmentsGroup containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const group = await ifcLoader.load(ifcData);
   * ```
   */
  async load(t, e = true) {
    const n = performance.now();
    this.onIfcStartedLoading.trigger(), await this.readIfcFile(t);
    const s = await this.getAllGeometries(), i = await this.components.get(yf).export(this.webIfc, 0);
    s.setLocalProperties(i), this.cleanUp();
    const r = this.components.get(He);
    r.groups.set(s.uuid, s);
    for (const o of s.items)
      r.list.set(o.id, o), o.mesh.uuid = o.id, o.group = s;
    return r.onFragmentsLoaded.trigger(s), e && r.coordinate([s]), console.log(`Streaming the IFC took ${performance.now() - n} ms!`), s;
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    return this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedFragments.clear(), this._fragmentInstances.clear();
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const t = this.webIfc.GetIfcEntityList(0), e = new Re();
    e.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const n = [];
    for (const i of t) {
      if (!this.webIfc.IsIfcElement(i) && i !== IFCSPACE || this.settings.excludedCategories.has(i))
        continue;
      const r = this.webIfc.GetLineIDsWithType(0, i), o = r.size();
      for (let l = 0; l < o; l++) {
        const u = r.get(l);
        n.push(u);
        const d = this._spatialTree.itemsByFloor[u] || 0;
        e.data.set(u, [[], [d, i]]);
      }
    }
    this._spatialTree.cleanUp(), this.webIfc.StreamMeshes(0, n, (i) => {
      this.getMesh(i, e);
    });
    for (const i of this._visitedFragments) {
      const { index: r, fragment: o } = i[1];
      e.keyFragments.set(r, o.id);
    }
    for (const i of e.items) {
      const r = this._fragmentInstances.get(i.id);
      if (!r)
        throw new Error("Fragment not found!");
      const o = [];
      for (const [l, u] of r)
        o.push(u);
      i.add(o);
    }
    const s = this.webIfc.GetCoordinationMatrix(0);
    return e.coordinationMatrix.fromArray(s), e.civilData = this._civil.read(this.webIfc), e;
  }
  getMesh(t, e) {
    const n = t.geometries.size(), s = t.expressID;
    for (let i = 0; i < n; i++) {
      const r = t.geometries.get(i), { x: o, y: l, z: u, w: d } = r.color, m = d !== 1, { geometryExpressID: f } = r, g = `${f}-${m}`;
      if (!this._visitedFragments.has(g)) {
        const C = this.getGeometry(this.webIfc, f), O = m ? this._materialT : this._material, B = new Ue(C, O, 1);
        e.add(B.mesh), e.items.push(B);
        const Y = this._visitedFragments.size;
        this._visitedFragments.set(g, { index: Y, fragment: B });
      }
      const v = new Color().setRGB(o, l, u, "srgb"), y = new Matrix4();
      y.fromArray(r.flatTransformation);
      const x = this._visitedFragments.get(g);
      if (x === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const A = e.data.get(s);
      if (!A)
        throw new Error("Data not found!");
      A[0].push(x.index);
      const { fragment: R } = x;
      this._fragmentInstances.has(R.id) || this._fragmentInstances.set(R.id, /* @__PURE__ */ new Map());
      const P = this._fragmentInstances.get(R.id);
      if (!P)
        throw new Error("Instances not found!");
      if (P.has(s)) {
        const C = P.get(s);
        if (!C)
          throw new Error("Instance not found!");
        C.transforms.push(y), C.colors && C.colors.push(v);
      } else
        P.set(s, { id: s, transforms: [y], colors: [v] });
    }
  }
  getGeometry(t, e) {
    const n = t.GetGeometry(0, e), s = t.GetIndexArray(
      n.GetIndexData(),
      n.GetIndexDataSize()
    ), i = t.GetVertexArray(
      n.GetVertexData(),
      n.GetVertexDataSize()
    ), r = new Float32Array(i.length / 2), o = new Float32Array(i.length / 2);
    for (let m = 0; m < i.length; m += 6)
      r[m / 2] = i[m], r[m / 2 + 1] = i[m + 1], r[m / 2 + 2] = i[m + 2], o[m / 2] = i[m + 3], o[m / 2 + 1] = i[m + 4], o[m / 2 + 2] = i[m + 5];
    const l = new BufferGeometry(), u = new BufferAttribute(r, 3), d = new BufferAttribute(o, 3);
    return l.setAttribute("position", u), l.setAttribute("normal", d), l.setIndex(Array.from(s)), n.delete(), l;
  }
  async autoSetWasm() {
    const t = await fetch(
      `https://unpkg.com/@thatopen/components@${Kd.release}/package.json`
    );
    if (!t.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const e = await t.json();
    if (!("web-ifc" in e.peerDependencies))
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    else {
      const n = e.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${n}/`, this.settings.wasm.absolute = true;
    }
  }
};
S(ch, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
var Tf = ch;
var bf = class cs extends Fe {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "onRequestFile", new $()), S(this, "ifcToExport", null), S(this, "onElementToPset", new $()), S(this, "onPropToPset", new $()), S(this, "onPsetRemoved", new $()), S(this, "onDataChanged", new $()), S(this, "wasm", {
      path: "/",
      absolute: false
    }), S(this, "enabled", true), S(this, "attributeListeners", {}), S(this, "selectedModel"), S(this, "changeMap", {}), this.components.add(cs.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.selectedModel = void 0, this.attributeListeners = {}, this.changeMap = {}, this.onElementToPset.reset(), this.onPropToPset.reset(), this.onPsetRemoved.reset(), this.onDataChanged.reset(), this.onDisposed.trigger(cs.uuid), this.onDisposed.reset();
  }
  /**
   * Static method to retrieve the IFC schema from a given model.
   *
   * @param model - The FragmentsGroup model from which to retrieve the IFC schema.
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @returns The IFC schema associated with the given model.
   */
  static getIFCSchema(t) {
    const e = t.ifcMetadata.schema;
    if (!e)
      throw new Error("IFC Schema not found");
    return e;
  }
  /**
   * Method to set properties data in the model.
   *
   * @param model - The FragmentsGroup model in which to set the properties.
   * @param dataToSave - An array of objects representing the properties to be saved.
   * Each object must have an `expressID` property, which is the express ID of the entity in the model.
   * The rest of the properties will be set as the properties of the entity.
   *
   * @returns {Promise<void>} A promise that resolves when all the properties have been set.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `dataToSave` array.
   */
  async setData(t, ...e) {
    for (const n of e) {
      const s = n.expressID;
      s && (await t.setProperties(s, n), this.registerChange(t, s));
    }
  }
  /**
   * Creates a new Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the Pset.
   * @param name - The name of the Pset.
   * @param description - (Optional) The description of the Pset.
   *
   * @returns A promise that resolves with an object containing the newly created Pset and its relation.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  async newPset(t, e, n) {
    const s = cs.getIFCSchema(t), { ownerHistoryHandle: i } = await this.getOwnerHistory(t), r = this.newGUID(t), o = new web_ifc_api_exports[s].IfcLabel(e), l = n ? new web_ifc_api_exports[s].IfcText(n) : null, u = new web_ifc_api_exports[s].IfcPropertySet(
      r,
      i,
      o,
      l,
      []
    );
    u.expressID = this.increaseMaxID(t);
    const d = this.newGUID(t), m = new web_ifc_api_exports[s].IfcRelDefinesByProperties(
      d,
      i,
      null,
      null,
      [],
      new Handle(u.expressID)
    );
    return m.expressID = this.increaseMaxID(t), await this.setData(t, u, m), { pset: u, rel: m };
  }
  /**
   * Removes a Property Set (Pset) from the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the Pset.
   * @param psetID - The express IDs of the Psets to be removed.
   *
   * @returns {Promise<void>} A promise that resolves when all the Psets have been removed.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `psetID` array.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async removePset(t, ...e) {
    for (const n of e) {
      const s = await t.getProperties(n);
      if ((s == null ? void 0 : s.type) !== IFCPROPERTYSET)
        continue;
      const i = await yn.getPsetRel(t, n);
      if (i && (await t.setProperties(i, null), this.registerChange(t, i)), s) {
        for (const r of s.HasProperties)
          await t.setProperties(r.value, null);
        await t.setProperties(n, null), this.onPsetRemoved.trigger({ model: t, psetID: n }), this.registerChange(t, n);
      }
    }
  }
  /**
   * Creates a new single-value property of type string in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a string property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a string.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleStringProperty(t, e, n, s) {
    return this.newSingleProperty(t, e, n, s);
  }
  /**
   * Creates a new single-value property of type numeric in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a numeric property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a number.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleNumericProperty(t, e, n, s) {
    return this.newSingleProperty(t, e, n, s);
  }
  /**
   * Creates a new single-value property of type boolean in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a boolean property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a boolean.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleBooleanProperty(t, e, n, s) {
    return this.newSingleProperty(t, e, n, s);
  }
  /**
   * Removes a property from a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the property.
   * @param psetID - The express ID of the Pset from which to remove the property.
   * @param propID - The express ID of the property to be removed.
   *
   * @returns {Promise<void>} A promise that resolves when the property has been removed.
   *
   * @throws Will throw an error if the Pset or the property to be removed are not found in the model.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   */
  async removePsetProp(t, e, n) {
    const s = await t.getProperties(e), i = await t.getProperties(n);
    !s || !i || s.type === IFCPROPERTYSET && i && (s.HasProperties = s.HasProperties.filter((r) => r.value !== n), await t.setProperties(n, null), this.registerChange(t, e, n));
  }
  async addElementToPset(t, e, ...n) {
    const s = await yn.getPsetRel(t, e);
    if (!s)
      return;
    const i = await t.getProperties(s);
    if (i) {
      for (const r of n) {
        const o = new Handle(r);
        i.RelatedObjects.push(o), this.onElementToPset.trigger({
          model: t,
          psetID: e,
          elementID: r
        });
      }
      this.registerChange(t, e);
    }
  }
  /**
   * Adds elements to a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to add the elements.
   * @param psetID - The express ID of the Pset to which to add the elements.
   * @param elementID - The express IDs of the elements to be added.
   *
   * @returns {Promise<void>} A promise that resolves when all the elements have been added.
   *
   * @throws Will throw an error if the Pset or the elements to be added are not found in the model.
   * @throws Will throw an error if the Pset to be added to is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async addPropToPset(t, e, ...n) {
    const s = await t.getProperties(e);
    if (s) {
      for (const i of n) {
        if (s.HasProperties.includes(i))
          continue;
        const r = new Handle(i);
        s.HasProperties.push(r), this.onPropToPset.trigger({ model: t, psetID: e, propID: i });
      }
      this.registerChange(t, e);
    }
  }
  /**
   * Saves the changes made to the model to a new IFC file.
   *
   * @param model - The FragmentsGroup model from which to save the changes.
   * @param ifcToSaveOn - The Uint8Array representing the original IFC file.
   *
   * @returns A promise that resolves with the modified IFC data as a Uint8Array.
   *
   * @throws Will throw an error if any issues occur during the saving process.
   */
  async saveToIfc(t, e) {
    const n = this.components.get(Tf), s = n.webIfc, i = await n.readIfcFile(e), r = this.changeMap[t.uuid] ?? [];
    for (const l of r) {
      const u = await t.getProperties(l);
      if (u)
        try {
          s.WriteLine(i, u);
        } catch {
        }
      else
        try {
          s.DeleteLine(i, l);
        } catch {
        }
    }
    const o = s.SaveModel(i);
    return n.webIfc.CloseModel(i), n.cleanUp(), o;
  }
  /**
   * Sets an attribute listener for a specific attribute of an entity in the model.
   * The listener will trigger an event whenever the attribute's value changes.
   *
   * @param model - The FragmentsGroup model in which to set the attribute listener.
   * @param expressID - The express ID of the entity for which to set the listener.
   * @param attributeName - The name of the attribute for which to set the listener.
   *
   * @returns The event that will be triggered when the attribute's value changes.
   *
   * @throws Will throw an error if the entity with the given expressID doesn't exist.
   * @throws Will throw an error if the attribute is an array or null, and it can't have a listener.
   * @throws Will throw an error if the attribute has a badly defined handle.
   */
  async setAttributeListener(t, e, n) {
    this.attributeListeners[t.uuid] || (this.attributeListeners[t.uuid] = {});
    const s = this.attributeListeners[t.uuid][e] ? this.attributeListeners[t.uuid][e][n] : null;
    if (s)
      return s;
    const i = await t.getProperties(e);
    if (!i)
      throw new Error(`Entity with expressID ${e} doesn't exists.`);
    const r = i[n];
    if (Array.isArray(r) || !r)
      throw new Error(
        `Attribute ${n} is array or null, and it can't have a listener.`
      );
    const o = r.value;
    if (o === void 0 || o == null)
      throw new Error(`Attribute ${n} has a badly defined handle.`);
    const l = new $();
    return Object.defineProperty(i[n], "value", {
      get() {
        return this._value;
      },
      async set(u) {
        this._value = u, l.trigger(u);
      }
    }), i[n].value = o, this.attributeListeners[t.uuid][e] || (this.attributeListeners[t.uuid][e] = {}), this.attributeListeners[t.uuid][e][n] = l, l;
  }
  increaseMaxID(t) {
    return t.ifcMetadata.maxExpressID++, t.ifcMetadata.maxExpressID;
  }
  newGUID(t) {
    const e = cs.getIFCSchema(t);
    return new web_ifc_api_exports[e].IfcGloballyUniqueId(La.create());
  }
  async getOwnerHistory(t) {
    const e = await t.getAllPropertiesOfType(
      IFCOWNERHISTORY
    );
    if (!e)
      throw new Error("No OwnerHistory was found.");
    const n = Object.keys(e).map((r) => parseInt(r, 10)), s = e[n[0]], i = new Handle(s.expressID);
    return { ownerHistory: s, ownerHistoryHandle: i };
  }
  registerChange(t, ...e) {
    this.changeMap[t.uuid] || (this.changeMap[t.uuid] = /* @__PURE__ */ new Set());
    for (const n of e)
      this.changeMap[t.uuid].add(n), this.onDataChanged.trigger({ model: t, expressID: n });
  }
  async newSingleProperty(t, e, n, s) {
    const i = cs.getIFCSchema(t), r = new web_ifc_api_exports[i].IfcIdentifier(n), o = new web_ifc_api_exports[i][e](s), l = new web_ifc_api_exports[i].IfcPropertySingleValue(
      r,
      null,
      o,
      null
    );
    return l.expressID = this.increaseMaxID(t), await this.setData(t, l), l;
  }
};
S(bf, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
var hh = class uh extends Fe {
  constructor(t) {
    super(t), S(this, "enabled", true), S(this, "list", {}), S(this, "onDisposed", new $()), S(this, "onFragmentsDisposed", (e) => {
      const { groupID: n, fragmentIDs: s } = e;
      for (const i in this.list) {
        const r = this.list[i], o = Object.keys(r);
        if (o.includes(n))
          delete r[n], Object.values(r).length === 0 && delete this.list[i];
        else
          for (const l of o) {
            const u = r[l];
            for (const d of s)
              delete u[d];
            Object.values(u).length === 0 && delete r[l];
          }
      }
    }), t.add(uh.uuid, this), t.get(He).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list = {}, this.components.get(He).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Removes a fragment from the classification based on its unique identifier (guid).
   * This method iterates through all classification systems and classes, and deletes the fragment with the specified guid from the respective group.
   *
   * @param guid - The unique identifier of the fragment to be removed.
   */
  remove(t) {
    for (const e in this.list) {
      const n = this.list[e];
      for (const s in n) {
        const i = n[s];
        delete i[t];
      }
    }
  }
  /**
   * Finds and returns fragments based on the provided filter criteria.
   * If no filter is provided, it returns all fragments.
   *
   * @param filter - An optional object containing filter criteria.
   * The keys of the object represent the classification system names,
   * and the values are arrays of class names to match.
   *
   * @returns A map of fragment GUIDs to their respective express IDs,
   * where the express IDs are filtered based on the provided filter criteria.
   *
   * @throws Will throw an error if the fragments map is malformed.
   */
  find(t) {
    const e = this.components.get(He);
    if (!t) {
      const r = {};
      for (const [o, l] of e.list)
        r[o] = new Set(l.ids);
      return r;
    }
    const n = Object.keys(t).length, s = {};
    for (const r in t) {
      const o = t[r];
      if (!this.list[r]) {
        console.warn(`Classification ${r} does not exist.`);
        continue;
      }
      for (const l of o) {
        const u = this.list[r][l];
        if (u)
          for (const d in u) {
            s[d] || (s[d] = /* @__PURE__ */ new Map());
            for (const m of u[d]) {
              const f = s[d].get(m);
              f === void 0 ? s[d].set(m, 1) : s[d].set(m, f + 1);
            }
          }
      }
    }
    const i = {};
    for (const r in s) {
      const o = s[r];
      for (const [l, u] of o) {
        if (u === void 0)
          throw new Error("Malformed fragments map!");
        u === n && (i[r] || (i[r] = /* @__PURE__ */ new Set()), i[r].add(l));
      }
    }
    return i;
  }
  /**
   * Classifies fragments based on their modelID.
   *
   * @param modelID - The unique identifier of the model to classify fragments by.
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the fragments in the provided group,
   * and classifies them based on their modelID.
   * The classification is stored in the `list.models` property,
   * with the modelID as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   */
  byModel(t, e) {
    this.list.models || (this.list.models = {});
    const n = this.list.models;
    n[t] || (n[t] = {});
    const s = n[t];
    for (const [i, r] of e.data) {
      const o = r[0];
      for (const l of o) {
        const u = e.keyFragments.get(l);
        u && (s[u] || (s[u] = /* @__PURE__ */ new Set()), s[u].add(i));
      }
    }
  }
  /**
   * Classifies fragments based on their PredefinedType property.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the properties of the fragments in the provided group,
   * and classifies them based on their PredefinedType property.
   * The classification is stored in the `list.predefinedTypes` property,
   * with the PredefinedType as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  async byPredefinedType(t) {
    var e;
    this.list.predefinedTypes || (this.list.predefinedTypes = {});
    const n = this.list.predefinedTypes, s = t.getAllPropertiesIDs();
    for (const i of s) {
      const r = await t.getProperties(i);
      if (!r)
        continue;
      const o = String((e = r.PredefinedType) == null ? void 0 : e.value).toUpperCase();
      n[o] || (n[o] = {});
      const l = n[o];
      for (const [u, d] of t.data) {
        const m = d[0];
        for (const f of m) {
          const g = t.keyFragments.get(f);
          if (!g)
            throw new Error("Fragment ID not found!");
          l[g] || (l[g] = /* @__PURE__ */ new Set()), l[g].add(r.expressID);
        }
      }
    }
  }
  /**
   * Classifies fragments based on their entity type.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their entity type.
   * The classification is stored in the `list.entities` property,
   * with the entity type as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  byEntity(t) {
    this.list.entities || (this.list.entities = {});
    for (const [e, n] of t.data) {
      const s = n[1][1], i = rh[s];
      this.saveItem(t, "entities", i, e);
    }
  }
  /**
   * Classifies fragments based on a specific IFC relationship.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   * @param ifcRel - The IFC relationship number to classify fragments by.
   * @param systemName - The name of the classification system to store the classification.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on the specified IFC relationship.
   * The classification is stored in the `list` property under the specified system name,
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the IFC relationship is not valid.
   */
  async byIfcRel(t, e, n) {
    yn.isRel(e) && await yn.getRelationMap(
      t,
      e,
      async (s, i) => {
        const { name: r } = await yn.getEntityName(
          t,
          s
        );
        for (const o of i)
          this.saveItem(
            t,
            n,
            r ?? "NO REL NAME",
            o
          );
      }
    );
  }
  /**
   * Classifies fragments based on their spatial structure in the IFC model.
   *
   * @param model - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their spatial structure in the IFC model.
   * The classification is stored in the `list` property under the system name "spatialStructures",
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the model relations do not exist.
   */
  async bySpatialStructure(t) {
    var e;
    const n = this.components.get(Xr), s = n.relationMaps[t.uuid];
    if (!s)
      throw new Error(
        `Classifier: model relations of ${t.name || t.uuid} have to exists to group by spatial structure.`
      );
    const i = "spatialStructures";
    for (const [r] of s) {
      const o = n.getEntityRelations(
        t,
        r,
        "ContainsElements"
      ), l = await t.getProperties(r);
      if (!(o && l))
        continue;
      const u = (e = l.Name) == null ? void 0 : e.value;
      for (const d of o) {
        this.saveItem(t, i, u, d);
        const m = n.getEntityRelations(
          t,
          Number(d),
          "IsDecomposedBy"
        );
        if (m)
          for (const f of m)
            this.saveItem(t, i, u, f);
      }
    }
  }
  /**
   * Sets the color of the specified fragments.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   * @param color - The color to set for the fragments.
   * @param override - A boolean indicating whether to override the existing color of the fragments.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and sets their color using the `setColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  setColor(t, e, n = false) {
    const s = this.components.get(He);
    for (const i in t) {
      const r = s.list.get(i);
      if (!r)
        continue;
      const o = t[i];
      r.setColor(e, o, n);
    }
  }
  /**
   * Resets the color of the specified fragments to their original color.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and resets their color using the `resetColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  resetColor(t) {
    const e = this.components.get(He);
    for (const n in t) {
      const s = e.list.get(n);
      if (!s)
        continue;
      const i = t[n];
      s.resetColor(i);
    }
  }
  saveItem(t, e, n, s) {
    this.list[e] || (this.list[e] = {});
    const i = t.data.get(s);
    if (i)
      for (const r of i[0]) {
        const o = t.keyFragments.get(r);
        if (o) {
          const l = this.list[e];
          l[n] || (l[n] = {}), l[n][o] || (l[n][o] = /* @__PURE__ */ new Set()), l[n][o].add(s);
        }
      }
  }
};
S(hh, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
var xf = hh;
var Sf = class dh extends Fe {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "enabled", true), S(this, "height", 10), S(this, "groupName", "spatialStructures"), S(this, "list", /* @__PURE__ */ new Set()), t.add(dh.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Sets the explosion state of the fragments.
   *
   * @param active - A boolean indicating whether to activate or deactivate the explosion.
   *
   * @remarks
   * This method applies a vertical transformation to the fragments based on the `active` parameter.
   * If `active` is true, the fragments are moved upwards by a distance determined by the `height` property.
   * If `active` is false, the fragments are moved back to their original position.
   *
   * The method also keeps track of the exploded items using the `list` set.
   *
   * @throws Will throw an error if the `Classifier` or `FragmentsManager` components are not found in the `components` system.
   */
  set(t) {
    if (!this.enabled)
      return;
    const e = this.components.get(xf), n = this.components.get(He), s = t ? 1 : -1;
    let i = 0;
    const r = e.list[this.groupName], o = new Matrix4();
    for (const l in r) {
      o.elements[13] = i * s * this.height;
      for (const u in r[l]) {
        const d = n.list.get(u), m = l + u, f = this.list.has(m);
        if (!d || t && f || !t && !f)
          continue;
        t ? this.list.add(m) : this.list.delete(m);
        const g = r[l][u];
        d.applyTransform(g, o);
      }
      i++;
    }
  }
};
S(Sf, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
var Af = class fh extends Fe {
  constructor(t) {
    super(t), S(this, "enabled", true), this.components.add(fh.uuid, this);
  }
  /**
   * Sets the visibility of fragments within the 3D scene.
   * If no `items` parameter is provided, all fragments will be set to the specified visibility.
   * If `items` is provided, only the specified fragments will be affected.
   *
   * @param visible - The visibility state to set for the fragments.
   * @param items - An optional map of fragment IDs and their corresponding sub-fragment IDs to be affected.
   * If not provided, all fragments will be affected.
   *
   * @returns {void}
   */
  set(t, e) {
    const n = this.components.get(He);
    if (!e) {
      for (const [s, i] of n.list)
        i && (i.setVisibility(t), this.updateCulledVisibility(i));
      return;
    }
    for (const s in e) {
      const i = e[s], r = n.list.get(s);
      r && (r.setVisibility(t, i), this.updateCulledVisibility(r));
    }
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param items - A map of fragment IDs and their corresponding sub-fragment IDs to be isolated.
   * If not provided, all fragments will be isolated.
   *
   * @returns {void}
   */
  isolate(t) {
    this.set(false), this.set(true, t);
  }
  updateCulledVisibility(t) {
    const e = this.components.get(Ef);
    for (const [n, s] of e.list) {
      const i = s.colorMeshes.get(t.id);
      i && (i.count = t.mesh.count);
    }
  }
};
S(Af, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
var Ff = class extends Na {
  constructor() {
    super(...arguments), S(this, "minGeometrySize", 10), S(this, "minAssetsSize", 1e3);
  }
};
var Rf = class ph extends Fe {
  constructor(t) {
    super(t), S(this, "onGeometryStreamed", new $()), S(this, "onAssetStreamed", new $()), S(this, "onProgress", new $()), S(this, "onIfcLoaded", new $()), S(this, "onDisposed", new $()), S(this, "settings", new Ff()), S(this, "enabled", true), S(this, "webIfc", new IfcAPI2()), S(this, "_spatialTree", new oh()), S(this, "_metaData", new lh()), S(this, "_visitedGeometries", /* @__PURE__ */ new Map()), S(this, "_streamSerializer", new fn()), S(this, "_geometries", /* @__PURE__ */ new Map()), S(this, "_geometryCount", 0), S(this, "_civil", new ah()), S(this, "_groupSerializer", new an()), S(this, "_assets", []), S(this, "_meshesWithHoles", /* @__PURE__ */ new Set()), this.components.add(ph.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onIfcLoaded.reset(), this.onGeometryStreamed.reset(), this.onAssetStreamed.reset(), this.webIfc = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * This method streams the IFC file from a given buffer.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   * @example
   * ```typescript
   * const ifcData = await fetch('path/to/ifc/file.ifc');
   * const rawBuffer = await response.arrayBuffer();
   * const ifcBuffer = new Uint8Array(rawBuffer);
   * await ifcGeometryTiler.streamFromBuffer(ifcBuffer);
   * ```
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  /**
   * This method streams the IFC file from a given callback.
   *
   * @param loadCallback - The callback function that will be used to load the IFC file.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllGeometries() {
    const { minGeometrySize: t, minAssetsSize: e } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const n = this.webIfc.GetIfcEntityList(0), s = [[]], i = new Re();
    i.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let r = 0, o = 0;
    for (const y of n) {
      if (!this.webIfc.IsIfcElement(y) && y !== IFCSPACE || this.settings.excludedCategories.has(y))
        continue;
      const x = this.webIfc.GetLineIDsWithType(0, y), A = x.size();
      for (let R = 0; R < A; R++) {
        r > t && (r = 0, o++, s.push([]));
        const P = x.get(R);
        s[o].push(P);
        const C = this._spatialTree.itemsByFloor[P] || 0;
        i.data.set(P, [[], [C, y]]), r++;
      }
    }
    this._spatialTree.cleanUp();
    let l = 0.01, u = 0;
    for (const y of s) {
      u++, this.webIfc.StreamMeshes(0, y, (A) => {
        this.getMesh(this.webIfc, A, i);
      }), this._geometryCount > t && await this.streamGeometries(), this._assets.length > e && await this.streamAssets();
      const x = u / s.length;
      x > l && (l += 0.01, l = Math.max(l, x), this.onProgress.trigger(Math.round(l * 100) / 100));
    }
    this._geometryCount && await this.streamGeometries(), this._assets.length && await this.streamAssets();
    const { opaque: d, transparent: m } = i.geometryIDs;
    for (const [y, { index: x, uuid: A }] of this._visitedGeometries)
      i.keyFragments.set(x, A), (y > 1 ? d : m).set(y, x);
    const f = i.data.keys();
    for (const y of f) {
      const [x] = i.data.get(y);
      x.length || i.data.delete(y);
    }
    const g = this.webIfc.GetCoordinationMatrix(0);
    i.coordinationMatrix.fromArray(g), i.civilData = this._civil.read(this.webIfc);
    const v = this._groupSerializer.export(i);
    this.onIfcLoaded.trigger(v), i.dispose(true);
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedGeometries.clear(), this._geometries.clear(), this._assets = [], this._meshesWithHoles.clear();
  }
  getMesh(t, e, n) {
    const s = e.geometries.size(), i = e.expressID, r = { id: i, geometries: [] };
    for (let o = 0; o < s; o++) {
      const l = e.geometries.get(o), u = l.geometryExpressID, d = l.color.w === 1 ? 1 : -1, m = u * d;
      if (!this._visitedGeometries.has(m)) {
        this._visitedGeometries.has(u) || this.getGeometry(t, u);
        const C = this._visitedGeometries.size, O = MathUtils.generateUUID();
        this._visitedGeometries.set(m, { uuid: O, index: C });
      }
      const f = this._visitedGeometries.get(m);
      if (f === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const g = n.data.get(i);
      if (!g)
        throw new Error("Data not found!");
      g[0].push(f.index);
      const { x: v, y, z: x, w: A } = l.color, R = [v, y, x, A], P = l.flatTransformation;
      r.geometries.push({ color: R, geometryID: u, transformation: P });
    }
    this._assets.push(r);
  }
  getGeometry(t, e) {
    const n = t.GetGeometry(0, e), s = t.GetIndexArray(
      n.GetIndexData(),
      n.GetIndexDataSize()
    ), i = t.GetVertexArray(
      n.GetVertexData(),
      n.GetVertexDataSize()
    ), r = new Float32Array(i.length / 2), o = new Float32Array(i.length / 2);
    for (let f = 0; f < i.length; f += 6)
      r[f / 2] = i[f], r[f / 2 + 1] = i[f + 1], r[f / 2 + 2] = i[f + 2], o[f / 2] = i[f + 3], o[f / 2 + 1] = i[f + 4], o[f / 2 + 2] = i[f + 5];
    const l = Yd(r), u = new Float32Array(l.transformation.elements), d = [l.center.x, l.center.y, l.center.z];
    let m = false;
    for (let f = 0; f < r.length - 2; f += 3) {
      const g = r[f], v = r[f + 1], y = r[f + 2], x = o[f], A = o[f + 1], R = o[f + 2];
      if (Hd(d, [g, v, y], [x, A, R])) {
        m = true;
        break;
      }
    }
    this._geometries.set(e, {
      position: r,
      normal: o,
      index: s,
      boundingBox: u,
      hasHoles: m
    }), n.delete(), this._geometryCount++;
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets), this._assets = null, this._assets = [];
  }
  async streamGeometries() {
    let t = this._streamSerializer.export(this._geometries), e = {};
    for (const [n, { boundingBox: s, hasHoles: i }] of this._geometries)
      e[n] = { boundingBox: s, hasHoles: i };
    this.onGeometryStreamed.trigger({ data: e, buffer: t }), e = null, t = null, this._geometries.clear(), this._geometryCount = 0;
  }
};
S(Rf, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
var Pf = class extends Na {
  constructor() {
    super(...arguments), S(this, "propertiesSize", 100);
  }
};
var Mf = class extends Fe {
  constructor() {
    super(...arguments), S(this, "onPropertiesStreamed", new ei()), S(this, "onProgress", new ei()), S(this, "onIndicesStreamed", new ei()), S(this, "onDisposed", new $()), S(this, "enabled", true), S(this, "settings", new Pf()), S(this, "webIfc", new IfcAPI2());
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  /**
   * This method converts properties from an IFC file to tiles given its data as a Uint8Array.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  /**
   * This method converts properties from an IFC file to tiles using a given callback function to read the file.
   *
   * @param loadCallback - A callback function that loads the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, e = new Set(this.webIfc.GetIfcEntityList(0)), n = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const o of n)
      e.add(o);
    let s = 0.01, i = 0;
    for (const o of e) {
      if (i++, $c.has(o))
        continue;
      const l = n.has(o), u = this.webIfc.GetLineIDsWithType(0, o), d = u.size();
      let m = 0;
      for (let g = 0; g < d - t; g += t) {
        const v = {};
        for (let y = 0; y < t; y++) {
          m++;
          const x = u.get(g + y);
          try {
            const A = this.webIfc.GetLine(0, x, l);
            v[A.expressID] = A;
          } catch {
            console.log(`Could not get property: ${x}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: o, data: v });
      }
      if (m !== d) {
        const g = {};
        for (let v = m; v < d; v++) {
          const y = u.get(v);
          try {
            const x = this.webIfc.GetLine(0, y, l);
            g[x.expressID] = x;
          } catch {
            console.log(`Could not get property: ${y}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: o, data: g });
      }
      const f = i / e.size;
      f > s && (s += 0.01, s = Math.max(s, f), await this.onProgress.trigger(Math.round(s * 100) / 100));
    }
    const r = await this.components.get(Xr).processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(r);
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2();
  }
};
S(Mf, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var mh = class gh extends Fe {
  constructor(t) {
    super(t), S(this, "enabled", true), t.add(gh.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(t, e, n, s = false) {
    const i = new Line3(), r = new Vector3();
    return i.set(e, n), i.closestPointToPoint(t, s, r), r.distanceTo(t);
  }
  /**
   * Method to get the face of a mesh that contains a given triangle index.
   * It also returns the edges of the found face and their indices.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param triangleIndex - The index of the triangle within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the edges of the found face and their indices, or null if no face was found.
   */
  getFace(t, e, n) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const s = /* @__PURE__ */ new Map(), i = t.geometry.index.array, { plane: r } = this.getFaceData(
      e,
      n,
      t
    ), o = [];
    for (let m = 0; m < i.length / 3; m++) {
      const { plane: f, edges: g } = this.getFaceData(m, n, t);
      if (f.equals(r)) {
        o.push({ index: m, edges: g });
        for (const { id: v, points: y, distance: x } of g)
          s.set(v, { points: y, distance: x });
      }
    }
    let l = 0;
    const u = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
    for (const { index: m, edges: f } of o) {
      const g = /* @__PURE__ */ new Map();
      for (const { id: C } of f)
        if (u.has(C)) {
          const O = u.get(C);
          g.set(C, O);
        }
      const v = f.map((C) => C.id);
      if (!g.size) {
        const C = l++;
        for (const { id: O } of f)
          u.set(O, C);
        d.set(C, {
          edges: new Set(v),
          indices: /* @__PURE__ */ new Set([m])
        });
        continue;
      }
      let y = null;
      const x = /* @__PURE__ */ new Set(), A = new Set(v);
      for (const [C, O] of g) {
        y === null ? y = O : O !== y && x.add(O), u.delete(C);
        const { edges: B } = d.get(O);
        B.delete(C), A.delete(C);
      }
      if (y === null)
        throw new Error("Error computing face!");
      const R = d.get(y), { indices: P } = R;
      P.add(m);
      for (const C of A) {
        u.set(C, y);
        const { edges: O } = R;
        O.add(C);
      }
      for (const C of x) {
        const O = d.get(C), { edges: B, indices: Y } = O, H = d.get(y), { edges: K, indices: Z } = H;
        for (const q of B)
          K.add(q), u.set(q, y);
        for (const q of Y)
          Z.add(q);
        d.delete(C);
      }
    }
    for (const [m, { indices: f, edges: g }] of d)
      if (f.has(e)) {
        const v = [];
        for (const y of g) {
          const x = s.get(y);
          v.push(x);
        }
        return { edges: v, indices: f };
      }
    return null;
  }
  /**
   * Method to get the vertices and normal of a mesh face at a given index.
   * It also applies instance transformation if provided.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param faceIndex - The index of the face within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the vertices and normal of the face.
   * @throws Will throw an error if the geometry is not indexed.
   */
  getVerticesAndNormal(t, e, n) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const s = t.geometry.index.array, i = t.geometry.attributes.position.array, r = t.geometry.attributes.normal.array, o = s[e * 3] * 3, l = s[e * 3 + 1] * 3, u = s[e * 3 + 2] * 3, d = new Vector3(i[o], i[o + 1], i[o + 2]), m = new Vector3(i[l], i[l + 1], i[l + 2]), f = new Vector3(i[u], i[u + 1], i[u + 2]), g = new Vector3(r[o], r[o + 1], r[o + 2]), v = new Vector3(r[l], r[l + 1], r[l + 2]), y = new Vector3(r[u], r[u + 1], r[u + 2]), x = (g.x + v.x + y.x) / 3, A = (g.y + v.y + y.y) / 3, R = (g.z + v.z + y.z) / 3, P = new Vector3(x, A, R);
    if (n !== void 0 && t instanceof InstancedMesh) {
      const C = new Matrix4();
      t.getMatrixAt(n, C);
      const O = new Matrix4();
      O.extractRotation(C), P.applyMatrix4(O), d.applyMatrix4(C), m.applyMatrix4(C), f.applyMatrix4(C);
    }
    return { p1: d, p2: m, p3: f, faceNormal: P };
  }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(t) {
    t.x = Math.trunc(t.x * 1e3) / 1e3, t.y = Math.trunc(t.y * 1e3) / 1e3, t.z = Math.trunc(t.z * 1e3) / 1e3;
  }
  getFaceData(t, e, n) {
    const s = this.getVerticesAndNormal(n, t, e), { p1: i, p2: r, p3: o, faceNormal: l } = s;
    this.round(i), this.round(r), this.round(o), this.round(l);
    const u = [
      { id: `${i.x}|${i.y}|${i.z}`, value: i },
      { id: `${r.x}|${r.y}|${r.z}`, value: r },
      { id: `${o.x}|${o.y}|${o.z}`, value: o }
    ];
    u.sort((R, P) => R.id < P.id ? -1 : R.id > P.id ? 1 : 0);
    const [
      { id: d, value: m },
      { id: f, value: g },
      { id: v, value: y }
    ] = u, x = [
      {
        id: `${d}|${f}`,
        distance: m.distanceTo(g),
        points: [m, g]
      },
      {
        id: `${f}|${v}`,
        distance: g.distanceTo(y),
        points: [g, y]
      },
      {
        id: `${d}|${v}`,
        distance: m.distanceTo(y),
        points: [m, y]
      }
    ], A = new Plane();
    return A.setFromNormalAndCoplanarPoint(l, i), A.constant = Math.round(A.constant * 10) / 10, { plane: A, edges: x };
  }
};
S(mh, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
var Ar = mh;
var tc = new Box3();
var ur = new Vector3();
var Eh = class extends InstancedBufferGeometry {
  constructor() {
    super(), this.isLineSegmentsGeometry = true, this.type = "LineSegmentsGeometry";
    const t = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], e = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(t, 3)), this.setAttribute("uv", new Float32BufferAttribute(e, 2));
  }
  applyMatrix4(t) {
    const e = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return e !== void 0 && (e.applyMatrix4(t), n.applyMatrix4(t), e.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const n = new InstancedInterleavedBuffer(e, 6, 1);
    return this.setAttribute("instanceStart", new InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceEnd", new InterleavedBufferAttribute(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const n = new InstancedInterleavedBuffer(e, 6, 1);
    return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(n, 3, 3)), this;
  }
  fromWireframeGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  fromEdgesGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  fromMesh(t) {
    return this.fromWireframeGeometry(new WireframeGeometry(t.geometry)), this;
  }
  fromLineSegments(t) {
    const e = t.geometry;
    return this.setPositions(e.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    t !== void 0 && e !== void 0 && (this.boundingBox.setFromBufferAttribute(t), tc.setFromBufferAttribute(e), this.boundingBox.union(tc));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingBox === null && this.computeBoundingBox();
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    if (t !== void 0 && e !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let s = 0;
      for (let i = 0, r = t.count; i < r; i++)
        ur.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(ur)), ur.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(ur));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(t) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(t);
  }
};
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib.line = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var fi = class extends ShaderMaterial {
  constructor(t) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib.line.uniforms),
      vertexShader: ShaderLib.line.vertexShader,
      fragmentShader: ShaderLib.line.fragmentShader,
      clipping: true
      // required for clipping support
    }), this.isLineMaterial = true, this.setValues(t);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(t) {
    this.uniforms.diffuse.value = t;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(t) {
    t === true ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(t) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = t);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(t) {
    t === true !== this.dashed && (this.needsUpdate = true), t === true ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(t) {
    this.uniforms.dashScale.value = t;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(t) {
    this.uniforms.dashSize.value = t;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(t) {
    this.uniforms.dashOffset.value = t;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(t) {
    this.uniforms.gapSize.value = t;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(t) {
    this.uniforms && (this.uniforms.opacity.value = t);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(t) {
    this.defines && (t === true !== this.alphaToCoverage && (this.needsUpdate = true), t === true ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = true) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = false));
  }
};
var nc = new Vector3();
var sc = new Vector3();
var et = new Vector4();
var tt = new Vector4();
var Yt = new Vector4();
var sa = new Vector3();
var ia = new Matrix4();
var nt = new Line3();
var ic = new Vector3();
var dr = new Box3();
var fr = new Sphere();
var Ht = new Vector4();
var Xt;
var Un;
function rc(h, t, e) {
  return Ht.set(0, 0, -t, 1).applyMatrix4(h.projectionMatrix), Ht.multiplyScalar(1 / Ht.w), Ht.x = Un / e.width, Ht.y = Un / e.height, Ht.applyMatrix4(h.projectionMatrixInverse), Ht.multiplyScalar(1 / Ht.w), Math.abs(Math.max(Ht.x, Ht.y));
}
function Of(h, t) {
  const e = h.matrixWorld, n = h.geometry, s = n.attributes.instanceStart, i = n.attributes.instanceEnd, r = Math.min(n.instanceCount, s.count);
  for (let o = 0, l = r; o < l; o++) {
    nt.start.fromBufferAttribute(s, o), nt.end.fromBufferAttribute(i, o), nt.applyMatrix4(e);
    const u = new Vector3(), d = new Vector3();
    Xt.distanceSqToSegment(nt.start, nt.end, d, u), d.distanceTo(u) < Un * 0.5 && t.push({
      point: d,
      pointOnLine: u,
      distance: Xt.origin.distanceTo(d),
      object: h,
      face: null,
      faceIndex: o,
      uv: null,
      uv1: null
    });
  }
}
function Df(h, t, e) {
  const n = t.projectionMatrix, i = h.material.resolution, r = h.matrixWorld, o = h.geometry, l = o.attributes.instanceStart, u = o.attributes.instanceEnd, d = Math.min(o.instanceCount, l.count), m = -t.near;
  Xt.at(1, Yt), Yt.w = 1, Yt.applyMatrix4(t.matrixWorldInverse), Yt.applyMatrix4(n), Yt.multiplyScalar(1 / Yt.w), Yt.x *= i.x / 2, Yt.y *= i.y / 2, Yt.z = 0, sa.copy(Yt), ia.multiplyMatrices(t.matrixWorldInverse, r);
  for (let f = 0, g = d; f < g; f++) {
    if (et.fromBufferAttribute(l, f), tt.fromBufferAttribute(u, f), et.w = 1, tt.w = 1, et.applyMatrix4(ia), tt.applyMatrix4(ia), et.z > m && tt.z > m)
      continue;
    if (et.z > m) {
      const P = et.z - tt.z, C = (et.z - m) / P;
      et.lerp(tt, C);
    } else if (tt.z > m) {
      const P = tt.z - et.z, C = (tt.z - m) / P;
      tt.lerp(et, C);
    }
    et.applyMatrix4(n), tt.applyMatrix4(n), et.multiplyScalar(1 / et.w), tt.multiplyScalar(1 / tt.w), et.x *= i.x / 2, et.y *= i.y / 2, tt.x *= i.x / 2, tt.y *= i.y / 2, nt.start.copy(et), nt.start.z = 0, nt.end.copy(tt), nt.end.z = 0;
    const y = nt.closestPointToPointParameter(sa, true);
    nt.at(y, ic);
    const x = MathUtils.lerp(et.z, tt.z, y), A = x >= -1 && x <= 1, R = sa.distanceTo(ic) < Un * 0.5;
    if (A && R) {
      nt.start.fromBufferAttribute(l, f), nt.end.fromBufferAttribute(u, f), nt.start.applyMatrix4(r), nt.end.applyMatrix4(r);
      const P = new Vector3(), C = new Vector3();
      Xt.distanceSqToSegment(nt.start, nt.end, C, P), e.push({
        point: C,
        pointOnLine: P,
        distance: Xt.origin.distanceTo(C),
        object: h,
        face: null,
        faceIndex: f,
        uv: null,
        uv1: null
      });
    }
  }
}
var Lf = class extends Mesh {
  constructor(t = new Eh(), e = new fi({ color: Math.random() * 16777215 })) {
    super(t, e), this.isLineSegments2 = true, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const t = this.geometry, e = t.attributes.instanceStart, n = t.attributes.instanceEnd, s = new Float32Array(2 * e.count);
    for (let r = 0, o = 0, l = e.count; r < l; r++, o += 2)
      nc.fromBufferAttribute(e, r), sc.fromBufferAttribute(n, r), s[o] = o === 0 ? 0 : s[o - 1], s[o + 1] = s[o] + nc.distanceTo(sc);
    const i = new InstancedInterleavedBuffer(s, 2, 1);
    return t.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(i, 1, 0)), t.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(i, 1, 1)), this;
  }
  raycast(t, e) {
    const n = this.material.worldUnits, s = t.camera;
    s === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const i = t.params.Line2 !== void 0 && t.params.Line2.threshold || 0;
    Xt = t.ray;
    const r = this.matrixWorld, o = this.geometry, l = this.material;
    Un = l.linewidth + i, o.boundingSphere === null && o.computeBoundingSphere(), fr.copy(o.boundingSphere).applyMatrix4(r);
    let u;
    if (n)
      u = Un * 0.5;
    else {
      const m = Math.max(s.near, fr.distanceToPoint(Xt.origin));
      u = rc(s, m, l.resolution);
    }
    if (fr.radius += u, Xt.intersectsSphere(fr) === false)
      return;
    o.boundingBox === null && o.computeBoundingBox(), dr.copy(o.boundingBox).applyMatrix4(r);
    let d;
    if (n)
      d = Un * 0.5;
    else {
      const m = Math.max(s.near, dr.distanceToPoint(Xt.origin));
      d = rc(s, m, l.resolution);
    }
    dr.expandByScalar(d), Xt.intersectsBox(dr) !== false && (n ? Of(this, e) : Df(this, s, e));
  }
};
var Fr = class extends Eh {
  constructor() {
    super(), this.isLineGeometry = true, this.type = "LineGeometry";
  }
  setPositions(t) {
    const e = t.length - 3, n = new Float32Array(2 * e);
    for (let s = 0; s < e; s += 3)
      n[2 * s] = t[s], n[2 * s + 1] = t[s + 1], n[2 * s + 2] = t[s + 2], n[2 * s + 3] = t[s + 3], n[2 * s + 4] = t[s + 4], n[2 * s + 5] = t[s + 5];
    return super.setPositions(n), this;
  }
  setColors(t) {
    const e = t.length - 3, n = new Float32Array(2 * e);
    for (let s = 0; s < e; s += 3)
      n[2 * s] = t[s], n[2 * s + 1] = t[s + 1], n[2 * s + 2] = t[s + 2], n[2 * s + 3] = t[s + 3], n[2 * s + 4] = t[s + 4], n[2 * s + 5] = t[s + 5];
    return super.setColors(n), this;
  }
  fromLine(t) {
    const e = t.geometry;
    return this.setPositions(e.attributes.position.array), this;
  }
};
var vh = class extends Lf {
  constructor(t = new Fr(), e = new fi({ color: Math.random() * 16777215 })) {
    super(t, e), this.isLine2 = true, this.type = "Line2";
  }
};
var Pr = class Pr2 {
  constructor(t, e) {
    b(this, "scene");
    b(this, "onSelect", new $());
    b(this, "type");
    b(this, "selectCurve");
    b(this, "selectPoints");
    b(this, "hoverCurve");
    b(this, "hoverPoints");
    b(this, "caster", new Raycaster());
    this.scene = t, this.type = e, this.hoverCurve = this.newCurve(3e-3, 4473924, false), this.hoverPoints = this.newPoints(5, 4473924), this.selectCurve = this.newCurve(5e-3, 16777215, true), this.selectPoints = this.newPoints(7, 16777215);
  }
  dispose() {
    this.selectCurve && this.scene.remove(this.selectCurve), this.selectCurve.material.dispose(), this.selectCurve.geometry.dispose(), this.selectCurve = null, this.hoverCurve.material.dispose(), this.hoverCurve.geometry.dispose(), this.hoverCurve = null, this.hoverPoints.material.dispose(), this.hoverPoints.geometry.dispose(), this.selectPoints.material.dispose(), this.selectPoints.geometry.dispose(), this.scene = null;
  }
  castRay(t, e, n, s) {
    const i = new Vector2(), r = n.getBoundingClientRect();
    i.x = (t.clientX - r.left) / r.width * 2 - 1, i.y = -((t.clientY - r.top) / r.height) * 2 + 1, this.caster.setFromCamera(i, e);
    const o = this.caster.intersectObjects(s);
    return o.length ? o[0] : null;
  }
  select(t) {
    this.highlight(t, this.selectCurve, this.selectPoints, true), this.onSelect.trigger(t);
  }
  unSelect() {
    this.selectCurve.removeFromParent(), this.selectPoints.removeFromParent();
  }
  hover(t) {
    this.highlight(t, this.hoverCurve, this.hoverPoints, false);
  }
  unHover() {
    this.hoverCurve.removeFromParent(), this.hoverPoints.removeFromParent();
  }
  setResolution({ x: t, y: e }) {
    this.selectCurve.material.resolution.set(t / e, 1), this.hoverCurve.material.resolution.set(t / e, 1);
  }
  highlight(t, e, n, s) {
    const { alignment: i } = t.curve;
    this.scene.add(e), this.scene.add(n);
    const r = [], o = [], l = [];
    for (const f of i[this.type]) {
      const g = f.mesh.geometry.attributes.position;
      for (const A of g.array)
        r.push(A);
      if (s) {
        let A;
        if (this.type === "absolute") {
          const { horizontal: P } = f.alignment;
          A = P[f.index].data.TYPE;
        } else
          A = f.data.TYPE;
        const R = Pr2.settings.colors[A] || [1, 1, 1];
        for (let P = 0; P < g.count; P++)
          o.push(...R);
      }
      const [v, y, x] = g.array;
      l.push(new Vector3(v, y, x));
    }
    const u = r[r.length - 3], d = r[r.length - 2], m = r[r.length - 1];
    l.push(new Vector3(u, d, m)), r.length / 3 > e.geometry.attributes.position.count && (e.geometry.dispose(), e.geometry = new Fr()), e.geometry.setPositions(r), s && e.geometry.setColors(o), n.geometry.setFromPoints(l);
  }
  newCurve(t, e, n) {
    const s = new Fr(), i = new fi({
      color: e,
      linewidth: t,
      vertexColors: n,
      worldUnits: false,
      depthTest: false
    }), r = new vh(s, i);
    return this.scene.add(r), r;
  }
  newPoints(t, e) {
    const n = new BufferGeometry(), s = new BufferAttribute(new Float32Array(), 3);
    n.setAttribute("position", s);
    const i = new PointsMaterial({
      size: t,
      color: e,
      sizeAttenuation: false,
      depthTest: false
    }), r = new Points(n, i);
    return r.frustumCulled = false, this.scene.add(r), r;
  }
};
b(Pr, "settings", {
  colors: {
    LINE: [213 / 255, 0 / 255, 255 / 255],
    CIRCULARARC: [0 / 255, 46, 255 / 255],
    CLOTHOID: [0 / 255, 255 / 255, 0 / 255],
    PARABOLICARC: [0 / 255, 255 / 255, 72 / 255],
    CONSTANTGRADIENT: [213 / 255, 0 / 255, 255 / 255]
  }
});
var Rr = Pr;
var Nf = class extends Object3D {
  constructor(t = document.createElement("div")) {
    super(), this.isCSS2DObject = true, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.center = new Vector2(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e) {
        e.element instanceof Element && e.element.parentNode !== null && e.element.parentNode.removeChild(e.element);
      });
    });
  }
  copy(t, e) {
    return super.copy(t, e), this.element = t.element.cloneNode(true), this.center = t.center, this;
  }
};
var ls = new Vector3();
var oc = new Matrix4();
var ac = new Matrix4();
var lc = new Vector3();
var cc = new Vector3();
var _f = class {
  constructor(t = {}) {
    const e = this;
    let n, s, i, r;
    const o = {
      objects: /* @__PURE__ */ new WeakMap()
    }, l = t.element !== void 0 ? t.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l, this.getSize = function() {
      return {
        width: n,
        height: s
      };
    }, this.render = function(g, v) {
      g.matrixWorldAutoUpdate === true && g.updateMatrixWorld(), v.parent === null && v.matrixWorldAutoUpdate === true && v.updateMatrixWorld(), oc.copy(v.matrixWorldInverse), ac.multiplyMatrices(v.projectionMatrix, oc), u(g, g, v), f(g);
    }, this.setSize = function(g, v) {
      n = g, s = v, i = n / 2, r = s / 2, l.style.width = g + "px", l.style.height = v + "px";
    };
    function u(g, v, y) {
      if (g.isCSS2DObject) {
        ls.setFromMatrixPosition(g.matrixWorld), ls.applyMatrix4(ac);
        const x = g.visible === true && ls.z >= -1 && ls.z <= 1 && g.layers.test(y.layers) === true;
        if (g.element.style.display = x === true ? "" : "none", x === true) {
          g.onBeforeRender(e, v, y);
          const R = g.element;
          R.style.transform = "translate(" + -100 * g.center.x + "%," + -100 * g.center.y + "%)translate(" + (ls.x * i + i) + "px," + (-ls.y * r + r) + "px)", R.parentNode !== l && l.appendChild(R), g.onAfterRender(e, v, y);
        }
        const A = {
          distanceToCameraSquared: d(y, g)
        };
        o.objects.set(g, A);
      }
      for (let x = 0, A = g.children.length; x < A; x++)
        u(g.children[x], v, y);
    }
    function d(g, v) {
      return lc.setFromMatrixPosition(g.matrixWorld), cc.setFromMatrixPosition(v.matrixWorld), lc.distanceToSquared(cc);
    }
    function m(g) {
      const v = [];
      return g.traverse(function(y) {
        y.isCSS2DObject && v.push(y);
      }), v;
    }
    function f(g) {
      const v = m(g).sort(function(x, A) {
        if (x.renderOrder !== A.renderOrder)
          return A.renderOrder - x.renderOrder;
        const R = o.objects.get(x).distanceToCameraSquared, P = o.objects.get(A).distanceToCameraSquared;
        return R - P;
      }), y = v.length;
      for (let x = 0, A = v.length; x < A; x++)
        v[x].element.style.zIndex = y - x;
    }
  }
};
var ft = class {
  // Define marker as setup configuration?
  constructor(t, e, n) {
    b(this, "three");
    b(this, "world");
    b(this, "onDisposed", new $());
    this.world = t;
    let s;
    e ? s = e : (s = document.createElement("div"), s.style.width = "15px", s.style.height = "15px", s.style.border = "5px solid red"), this.three = new Nf(s), (n || t.scene.three).add(this.three), this.visible = true;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(t) {
    this.three.visible = t;
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /**
   * Toggles the visibility of the marker.
   *
   * This method changes the `visible` property of the marker to its opposite value.
   * If the marker is currently visible, it will be hidden, and vice versa.
   *
   * @returns {void}
   */
  toggleVisibility() {
    this.visible = !this.visible;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.three.removeFromParent(), this.three.element.remove(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var Uf = class extends Qd {
  constructor(e, n, s) {
    super(e, n, s);
    b(this, "three2D", new _f());
    this.onAfterUpdate.add(() => {
      if (this.onBeforeUpdate.trigger(this), !this.enabled || !this.currentWorld)
        return;
      const i = this.currentWorld.scene.three, r = this.currentWorld.camera.three;
      i instanceof Scene && this.three2D.render(i, r);
    }), this.onDisposed.add(() => {
      this.three2D.domElement.remove();
    }), this.onResize.add(({ x: i, y: r }) => {
      this.three2D.setSize(i, r);
    }), this.setupHtmlRenderer(), this.resize();
  }
  setupHtmlRenderer() {
    this.three2D.domElement.style.position = "absolute", this.three2D.domElement.style.top = "0px", this.three2D.domElement.style.pointerEvents = "none", this.container && this.container.appendChild(this.three2D.domElement);
  }
};
var Mr = class Mr2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "enabled", true);
    b(this, "threshold", 50);
    b(this, "autoCluster", true);
    b(this, "list", /* @__PURE__ */ new Map());
    b(this, "clusterLabels", /* @__PURE__ */ new Set());
    b(this, "currentKeys", /* @__PURE__ */ new Set());
    b(this, "_color", "white");
    b(this, "_markerKey", 0);
    b(this, "_clusterKey", 0);
    b(this, "_worldEvents", /* @__PURE__ */ new Map());
    b(this, "_setupWorlds", /* @__PURE__ */ new Set());
    e.add(Mr2.uuid, this);
  }
  /**
   * Getter for the color property.
   * Returns the current color of the markers.
   *
   * @returns {string} The current color of the markers.
   */
  get color() {
    return this._color;
  }
  /**
   * Setter for the color property.
   * Updates the color of all the markers to the new value.
   *
   * @param {string} value - The new color value for the markers.
   */
  set color(e) {
    this._color = e;
    for (const [n, s] of this.list)
      for (const [i, r] of s)
        r.label.three.element.style.color = e;
  }
  /**
   * Creates a new marker at the specified point in the world.
   *
   * @param world - The world where the marker will be created.
   * @param text - The text content of the marker.
   * @param point - The 3D position where the marker will be placed.
   * @param isStatic - Indicates whether the marker should be static and not clustered.
   * @returns The unique key of the created marker.
   */
  create(e, n, s, i = false) {
    this.setupEvents(e, true);
    const r = this._markerKey.toString(), o = this.getWorldMarkerList(e);
    if (o.has(r))
      return;
    const l = document.createElement("span");
    l.innerHTML = n, l.style.color = this._color;
    const u = new ft(e, l);
    return u.three.position.copy(s), o.set(r, {
      key: r,
      label: u,
      merged: false,
      static: i
    }), this._markerKey++, r;
  }
  /**
   * Deletes a marker with the specified ID from all worlds.
   *
   * @param id - The unique identifier of the marker to be deleted.
   *
   * @remarks
   * This method iterates through all the worlds and their respective markers.
   * If a marker with the specified ID is found, it disposes of the marker's label
   * and removes the marker from the world's marker list.
   *
   */
  delete(e) {
    for (const [n, s] of this.list) {
      const i = s.get(e);
      i && i.label.dispose(), s.delete(e);
    }
  }
  /**
   * Retrieves the list of markers associated with a specific world.
   * If the list does not exist for the given world, it creates a new one.
   *
   * @param world - The world for which the marker list is to be retrieved.
   * @returns A Map containing the markers associated with the given world.
   *
   * @remarks
   * This method is used to manage markers per world. It ensures that each world has its own set of markers.
   * If a marker list for the given world does not exist, it creates a new one and associates it with the world.
   */
  getWorldMarkerList(e) {
    return this.list.has(e.uuid) || this.list.set(e.uuid, /* @__PURE__ */ new Map()), this.list.get(e.uuid);
  }
  /** {@link OBC.Disposable.dispose} */
  dispose(e) {
    for (const [n, s] of this.list) {
      const i = [...s.keys()];
      for (const r of i) {
        const o = s.get(r);
        e && o.type !== e || (o.label.dispose(), s.delete(r));
      }
    }
    if (!e) {
      this.list.clear(), this._markerKey = 0;
      for (const n of this.clusterLabels)
        n.label.dispose();
      this.clusterLabels.clear(), this._clusterKey = 0, this.currentKeys.clear();
    }
    this.onDisposed.trigger();
  }
  /**
   * Sets up event listeners for clustering markers in the given world.
   *
   * @param world - The world where the event listeners will be set up.
   * @param enabled - Indicates whether the event listeners should be enabled or disabled.
   *
   * @remarks
   * This method checks if the event listeners are already set up for the given world.
   * If the event listeners are already set up and the `enabled` parameter is true, the method returns without doing anything.
   * If the world does not have camera controls, the method returns without doing anything.
   *
   * The method then retrieves the event listener for the given world using the `getWorldEvent` method.
   * It removes the existing event listeners for the "sleep" and "rest" events from the world's camera controls.
   *
   * If the `enabled` parameter is true, the method adds the event listener for the "sleep" and "rest" events to the world's camera controls.
   */
  setupEvents(e, n) {
    if (n && this._setupWorlds.has(e.uuid) || !e.camera.hasCameraControls())
      return;
    const s = this.getWorldEvent(e);
    e.camera.controls.removeEventListener("sleep", s), e.camera.controls.removeEventListener("rest", s), n && (e.camera.controls.addEventListener("sleep", s), e.camera.controls.addEventListener("rest", s));
  }
  /**
   * Performs clustering of markers in the given world.
   *
   * @param world - The world where clustering will be performed.
   *
   */
  cluster(e) {
    if (!this.autoCluster)
      return;
    this.resetMarkers();
    const n = this.list.get(e.uuid);
    if (n) {
      for (const [s, i] of n)
        if (!i.merged && !i.static) {
          this.currentKeys.clear();
          for (const [r, o] of n)
            o.static || i.key !== o.key && !o.merged && this.distance(i.label, o.label) < this.threshold && (this.currentKeys.add(o.key), o.merged = true);
          if (this.currentKeys.size > 0) {
            this.currentKeys.add(i.key), i.merged = true;
            const r = Array.from(this.currentKeys), o = this.getAveragePositionFromLabels(r), l = new ft(
              i.label.world,
              this.createClusterElement(this._clusterKey.toString())
            ), { element: u } = l.three;
            u.textContent = r.length.toString(), l.three.position.copy(o), this.clusterLabels.add({
              key: this._clusterKey.toString(),
              markerKeys: r,
              label: l
            }), this._clusterKey++;
          }
        }
      this.removeMergeMarkers(e);
    }
  }
  getWorldEvent(e) {
    if (!this._worldEvents.has(e.uuid)) {
      const n = () => {
        this.cluster(e);
      };
      this._worldEvents.set(e.uuid, n);
    }
    return this._worldEvents.get(e.uuid);
  }
  resetMarkers() {
    for (const [e, n] of this.list)
      for (const [s, i] of n)
        i.merged = false;
    for (const e of this.clusterLabels)
      e.label.dispose();
    this.clusterLabels.clear(), this._clusterKey = 0;
  }
  removeMergeMarkers(e) {
    const n = this.list.get(e.uuid);
    if (n) {
      for (const [s, i] of n)
        i.merged ? i.label.dispose() : i.label.world.scene.three.add(i.label.three);
      for (const s of this.clusterLabels)
        if (s.markerKeys.length === 1) {
          for (const [i, r] of this.list) {
            const o = r.get(s.markerKeys[0]);
            if (!o)
              continue;
            o.label.world.scene.three.add(o.label.three), o.merged = false;
          }
          s.label.dispose(), this.clusterLabels.delete(s);
        }
    }
  }
  getAveragePositionFromLabels(e) {
    const n = e.map((s) => {
      for (const [i, r] of this.list) {
        const o = r.get(s);
        if (o)
          return o.label.three.position;
      }
      return new Vector3();
    });
    return n.reduce((s, i) => s.add(i), new Vector3()).divideScalar(n.length);
  }
  createClusterElement(e) {
    const n = document.createElement("div");
    return n.textContent = e, n.style.color = "#000000", n.style.background = "#FFFFFF", n.style.fontSize = "1.2rem", n.style.fontWeight = "500", n.style.pointerEvents = "auto", n.style.borderRadius = "50%", n.style.padding = "5px 11px", n.style.textAlign = "center", n.style.cursor = "pointer", n.addEventListener("pointerdown", () => {
      this.navigateToCluster(e);
    }), n.addEventListener("pointerover", () => {
      n.style.background = "#BCF124";
    }), n.addEventListener("pointerout", () => {
      n.style.background = "#FFFFFF";
    }), n;
  }
  getScreenPosition(e) {
    const n = new Vector3();
    if (!e.world.renderer)
      throw new Error("Renderer not found!");
    const s = e.three.position.clone();
    s.project(e.world.camera.three);
    const i = e.world.renderer.getSize();
    return n.x = s.x * i.x / 2 + i.x / 2, n.y = -(s.y * i.y / 2) + i.y / 2, n;
  }
  distance(e, n) {
    const s = this.getScreenPosition(e), i = this.getScreenPosition(n), r = s.x - i.x, o = s.y - i.y, l = Math.sqrt(r * r + o * o) * 0.5;
    return l === 0 ? this.threshold + 1 : l;
  }
  navigateToCluster(e) {
    const n = [], s = Array.from(this.clusterLabels).find(
      (m) => m.key === e
    );
    if (!s)
      return;
    const i = s.label.world.camera;
    if (!i.hasCameraControls()) {
      console.warn("Zoom to clusters only supported with Camera Controls!");
      return;
    }
    for (const m of s.markerKeys)
      for (const [f, g] of this.list) {
        const v = g.get(m);
        if (v) {
          const { x: y, y: x, z: A } = v.label.three.position;
          n.push(y, x, A);
        }
      }
    s.label.dispose(), this.clusterLabels.delete(s);
    const r = new BufferGeometry(), o = new Float32Array(n), l = new BufferAttribute(o, 3);
    r.setAttribute("position", l);
    const u = new Mesh(r);
    u.geometry.computeBoundingSphere(), u.geometry.boundingSphere && i.controls.fitToSphere(u, true), r.dispose(), u.clear(), n.length = 0;
  }
};
b(Mr, "uuid", "4079eb91-79b0-4ede-bcf2-15b837129236");
var nn = Mr;
var hc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ih(h) {
  return h && h.__esModule && Object.prototype.hasOwnProperty.call(h, "default") ? h.default : h;
}
var _a = { exports: {} };
_a.exports = Zr;
_a.exports.default = Zr;
function Zr(h, t, e) {
  e = e || 2;
  var n = t && t.length, s = n ? t[0] * e : h.length, i = yh(h, 0, s, e, true), r = [];
  if (!i || i.next === i.prev)
    return r;
  var o, l, u, d, m, f, g;
  if (n && (i = Gf(h, t, i, e)), h.length > 80 * e) {
    o = u = h[0], l = d = h[1];
    for (var v = e; v < s; v += e)
      m = h[v], f = h[v + 1], m < o && (o = m), f < l && (l = f), m > u && (u = m), f > d && (d = f);
    g = Math.max(u - o, d - l), g = g !== 0 ? 32767 / g : 0;
  }
  return li(i, r, e, o, l, g, 0), r;
}
function yh(h, t, e, n, s) {
  var i, r;
  if (s === ba(h, t, e, n) > 0)
    for (i = t; i < e; i += n)
      r = uc(i, h[i], h[i + 1], r);
  else
    for (i = e - n; i >= t; i -= n)
      r = uc(i, h[i], h[i + 1], r);
  return r && Qr(r, r.next) && (hi(r), r = r.next), r;
}
function kn(h, t) {
  if (!h)
    return h;
  t || (t = h);
  var e = h, n;
  do
    if (n = false, !e.steiner && (Qr(e, e.next) || We(e.prev, e, e.next) === 0)) {
      if (hi(e), e = t = e.prev, e === e.next)
        break;
      n = true;
    } else
      e = e.next;
  while (n || e !== t);
  return t;
}
function li(h, t, e, n, s, i, r) {
  if (h) {
    !r && i && jf(h, n, s, i);
    for (var o = h, l, u; h.prev !== h.next; ) {
      if (l = h.prev, u = h.next, i ? kf(h, n, s, i) : Bf(h)) {
        t.push(l.i / e | 0), t.push(h.i / e | 0), t.push(u.i / e | 0), hi(h), h = u.next, o = u.next;
        continue;
      }
      if (h = u, h === o) {
        r ? r === 1 ? (h = zf(kn(h), t, e), li(h, t, e, n, s, i, 2)) : r === 2 && Vf(h, t, e, n, s, i) : li(kn(h), t, e, n, s, i, 1);
        break;
      }
    }
  }
}
function Bf(h) {
  var t = h.prev, e = h, n = h.next;
  if (We(t, e, n) >= 0)
    return false;
  for (var s = t.x, i = e.x, r = n.x, o = t.y, l = e.y, u = n.y, d = s < i ? s < r ? s : r : i < r ? i : r, m = o < l ? o < u ? o : u : l < u ? l : u, f = s > i ? s > r ? s : r : i > r ? i : r, g = o > l ? o > u ? o : u : l > u ? l : u, v = n.next; v !== t; ) {
    if (v.x >= d && v.x <= f && v.y >= m && v.y <= g && fs(s, o, i, l, r, u, v.x, v.y) && We(v.prev, v, v.next) >= 0)
      return false;
    v = v.next;
  }
  return true;
}
function kf(h, t, e, n) {
  var s = h.prev, i = h, r = h.next;
  if (We(s, i, r) >= 0)
    return false;
  for (var o = s.x, l = i.x, u = r.x, d = s.y, m = i.y, f = r.y, g = o < l ? o < u ? o : u : l < u ? l : u, v = d < m ? d < f ? d : f : m < f ? m : f, y = o > l ? o > u ? o : u : l > u ? l : u, x = d > m ? d > f ? d : f : m > f ? m : f, A = Ca(g, v, t, e, n), R = Ca(y, x, t, e, n), P = h.prevZ, C = h.nextZ; P && P.z >= A && C && C.z <= R; ) {
    if (P.x >= g && P.x <= y && P.y >= v && P.y <= x && P !== s && P !== r && fs(o, d, l, m, u, f, P.x, P.y) && We(P.prev, P, P.next) >= 0 || (P = P.prevZ, C.x >= g && C.x <= y && C.y >= v && C.y <= x && C !== s && C !== r && fs(o, d, l, m, u, f, C.x, C.y) && We(C.prev, C, C.next) >= 0))
      return false;
    C = C.nextZ;
  }
  for (; P && P.z >= A; ) {
    if (P.x >= g && P.x <= y && P.y >= v && P.y <= x && P !== s && P !== r && fs(o, d, l, m, u, f, P.x, P.y) && We(P.prev, P, P.next) >= 0)
      return false;
    P = P.prevZ;
  }
  for (; C && C.z <= R; ) {
    if (C.x >= g && C.x <= y && C.y >= v && C.y <= x && C !== s && C !== r && fs(o, d, l, m, u, f, C.x, C.y) && We(C.prev, C, C.next) >= 0)
      return false;
    C = C.nextZ;
  }
  return true;
}
function zf(h, t, e) {
  var n = h;
  do {
    var s = n.prev, i = n.next.next;
    !Qr(s, i) && wh(s, n, n.next, i) && ci(s, i) && ci(i, s) && (t.push(s.i / e | 0), t.push(n.i / e | 0), t.push(i.i / e | 0), hi(n), hi(n.next), n = h = i), n = n.next;
  } while (n !== h);
  return kn(n);
}
function Vf(h, t, e, n, s, i) {
  var r = h;
  do {
    for (var o = r.next.next; o !== r.prev; ) {
      if (r.i !== o.i && Qf(r, o)) {
        var l = Ch(r, o);
        r = kn(r, r.next), l = kn(l, l.next), li(r, t, e, n, s, i, 0), li(l, t, e, n, s, i, 0);
        return;
      }
      o = o.next;
    }
    r = r.next;
  } while (r !== h);
}
function Gf(h, t, e, n) {
  var s = [], i, r, o, l, u;
  for (i = 0, r = t.length; i < r; i++)
    o = t[i] * n, l = i < r - 1 ? t[i + 1] * n : h.length, u = yh(h, o, l, n, false), u === u.next && (u.steiner = true), s.push(Zf(u));
  for (s.sort(Yf), i = 0; i < s.length; i++)
    e = Hf(s[i], e);
  return e;
}
function Yf(h, t) {
  return h.x - t.x;
}
function Hf(h, t) {
  var e = Wf(h, t);
  if (!e)
    return t;
  var n = Ch(e, h);
  return kn(n, n.next), kn(e, e.next);
}
function Wf(h, t) {
  var e = t, n = h.x, s = h.y, i = -1 / 0, r;
  do {
    if (s <= e.y && s >= e.next.y && e.next.y !== e.y) {
      var o = e.x + (s - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (o <= n && o > i && (i = o, r = e.x < e.next.x ? e : e.next, o === n))
        return r;
    }
    e = e.next;
  } while (e !== t);
  if (!r)
    return null;
  var l = r, u = r.x, d = r.y, m = 1 / 0, f;
  e = r;
  do
    n >= e.x && e.x >= u && n !== e.x && fs(s < d ? n : i, s, u, d, s < d ? i : n, s, e.x, e.y) && (f = Math.abs(s - e.y) / (n - e.x), ci(e, h) && (f < m || f === m && (e.x > r.x || e.x === r.x && Kf(r, e))) && (r = e, m = f)), e = e.next;
  while (e !== l);
  return r;
}
function Kf(h, t) {
  return We(h.prev, h, t.prev) < 0 && We(t.next, h, h.next) < 0;
}
function jf(h, t, e, n) {
  var s = h;
  do
    s.z === 0 && (s.z = Ca(s.x, s.y, t, e, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== h);
  s.prevZ.nextZ = null, s.prevZ = null, Xf(s);
}
function Xf(h) {
  var t, e, n, s, i, r, o, l, u = 1;
  do {
    for (e = h, h = null, i = null, r = 0; e; ) {
      for (r++, n = e, o = 0, t = 0; t < u && (o++, n = n.nextZ, !!n); t++)
        ;
      for (l = u; o > 0 || l > 0 && n; )
        o !== 0 && (l === 0 || !n || e.z <= n.z) ? (s = e, e = e.nextZ, o--) : (s = n, n = n.nextZ, l--), i ? i.nextZ = s : h = s, s.prevZ = i, i = s;
      e = n;
    }
    i.nextZ = null, u *= 2;
  } while (r > 1);
  return h;
}
function Ca(h, t, e, n, s) {
  return h = (h - e) * s | 0, t = (t - n) * s | 0, h = (h | h << 8) & 16711935, h = (h | h << 4) & 252645135, h = (h | h << 2) & 858993459, h = (h | h << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, h | t << 1;
}
function Zf(h) {
  var t = h, e = h;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== h);
  return e;
}
function fs(h, t, e, n, s, i, r, o) {
  return (s - r) * (t - o) >= (h - r) * (i - o) && (h - r) * (n - o) >= (e - r) * (t - o) && (e - r) * (i - o) >= (s - r) * (n - o);
}
function Qf(h, t) {
  return h.next.i !== t.i && h.prev.i !== t.i && !qf(h, t) && // dones't intersect other edges
  (ci(h, t) && ci(t, h) && Jf(h, t) && // locally visible
  (We(h.prev, h, t.prev) || We(h, t.prev, t)) || // does not create opposite-facing sectors
  Qr(h, t) && We(h.prev, h, h.next) > 0 && We(t.prev, t, t.next) > 0);
}
function We(h, t, e) {
  return (t.y - h.y) * (e.x - t.x) - (t.x - h.x) * (e.y - t.y);
}
function Qr(h, t) {
  return h.x === t.x && h.y === t.y;
}
function wh(h, t, e, n) {
  var s = mr(We(h, t, e)), i = mr(We(h, t, n)), r = mr(We(e, n, h)), o = mr(We(e, n, t));
  return !!(s !== i && r !== o || s === 0 && pr(h, e, t) || i === 0 && pr(h, n, t) || r === 0 && pr(e, h, n) || o === 0 && pr(e, t, n));
}
function pr(h, t, e) {
  return t.x <= Math.max(h.x, e.x) && t.x >= Math.min(h.x, e.x) && t.y <= Math.max(h.y, e.y) && t.y >= Math.min(h.y, e.y);
}
function mr(h) {
  return h > 0 ? 1 : h < 0 ? -1 : 0;
}
function qf(h, t) {
  var e = h;
  do {
    if (e.i !== h.i && e.next.i !== h.i && e.i !== t.i && e.next.i !== t.i && wh(e, e.next, h, t))
      return true;
    e = e.next;
  } while (e !== h);
  return false;
}
function ci(h, t) {
  return We(h.prev, h, h.next) < 0 ? We(h, t, h.next) >= 0 && We(h, h.prev, t) >= 0 : We(h, t, h.prev) < 0 || We(h, h.next, t) < 0;
}
function Jf(h, t) {
  var e = h, n = false, s = (h.x + t.x) / 2, i = (h.y + t.y) / 2;
  do
    e.y > i != e.next.y > i && e.next.y !== e.y && s < (e.next.x - e.x) * (i - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next;
  while (e !== h);
  return n;
}
function Ch(h, t) {
  var e = new Ta(h.i, h.x, h.y), n = new Ta(t.i, t.x, t.y), s = h.next, i = t.prev;
  return h.next = t, t.prev = h, e.next = s, s.prev = e, n.next = e, e.prev = n, i.next = n, n.prev = i, n;
}
function uc(h, t, e, n) {
  var s = new Ta(h, t, e);
  return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s;
}
function hi(h) {
  h.next.prev = h.prev, h.prev.next = h.next, h.prevZ && (h.prevZ.nextZ = h.nextZ), h.nextZ && (h.nextZ.prevZ = h.prevZ);
}
function Ta(h, t, e) {
  this.i = h, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
Zr.deviation = function(h, t, e, n) {
  var s = t && t.length, i = s ? t[0] * e : h.length, r = Math.abs(ba(h, 0, i, e));
  if (s)
    for (var o = 0, l = t.length; o < l; o++) {
      var u = t[o] * e, d = o < l - 1 ? t[o + 1] * e : h.length;
      r -= Math.abs(ba(h, u, d, e));
    }
  var m = 0;
  for (o = 0; o < n.length; o += 3) {
    var f = n[o] * e, g = n[o + 1] * e, v = n[o + 2] * e;
    m += Math.abs(
      (h[f] - h[v]) * (h[g + 1] - h[f + 1]) - (h[f] - h[g]) * (h[v + 1] - h[f + 1])
    );
  }
  return r === 0 && m === 0 ? 0 : Math.abs((m - r) / r);
};
function ba(h, t, e, n) {
  for (var s = 0, i = t, r = e - n; i < e; i += n)
    s += (h[r] - h[i]) * (h[i + 1] + h[r + 1]), r = i;
  return s;
}
Zr.flatten = function(h) {
  for (var t = h[0][0].length, e = { vertices: [], holes: [], dimensions: t }, n = 0, s = 0; s < h.length; s++) {
    for (var i = 0; i < h[s].length; i++)
      for (var r = 0; r < t; r++)
        e.vertices.push(h[s][i][r]);
    s > 0 && (n += h[s - 1].length, e.holes.push(n));
  }
  return e;
};
var $f = _a.exports;
var ep = Ih($f);
var tp = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
var vs = class {
  constructor() {
    this.isPass = true, this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
};
var np = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var sp = class extends BufferGeometry {
  constructor() {
    super(), this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
};
var ip = new sp();
var Th = class {
  constructor(t) {
    this._mesh = new Mesh(ip, t);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(t) {
    t.render(this._mesh, np);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
};
var bh = class extends vs {
  constructor(t, e) {
    super(), this.textureID = e !== void 0 ? e : "tDiffuse", t instanceof ShaderMaterial ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = UniformsUtils.clone(t.uniforms), this.material = new ShaderMaterial({
      name: t.name !== void 0 ? t.name : "unspecified",
      defines: Object.assign({}, t.defines),
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader
    })), this.fsQuad = new Th(this.material);
  }
  render(t, e, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
};
var dc = class extends vs {
  constructor(t, e) {
    super(), this.scene = t, this.camera = e, this.clear = true, this.needsSwap = false, this.inverse = false;
  }
  render(t, e, n) {
    const s = t.getContext(), i = t.state;
    i.buffers.color.setMask(false), i.buffers.depth.setMask(false), i.buffers.color.setLocked(true), i.buffers.depth.setLocked(true);
    let r, o;
    this.inverse ? (r = 0, o = 1) : (r = 1, o = 0), i.buffers.stencil.setTest(true), i.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), i.buffers.stencil.setFunc(s.ALWAYS, r, 4294967295), i.buffers.stencil.setClear(o), i.buffers.stencil.setLocked(true), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), i.buffers.color.setLocked(false), i.buffers.depth.setLocked(false), i.buffers.color.setMask(true), i.buffers.depth.setMask(true), i.buffers.stencil.setLocked(false), i.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), i.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), i.buffers.stencil.setLocked(true);
  }
};
var rp = class extends vs {
  constructor() {
    super(), this.needsSwap = false;
  }
  render(t) {
    t.state.buffers.stencil.setLocked(false), t.state.buffers.stencil.setTest(false);
  }
};
var op = class {
  constructor(t, e) {
    if (this.renderer = t, this._pixelRatio = t.getPixelRatio(), e === void 0) {
      const n = t.getSize(new Vector2());
      this._width = n.width, this._height = n.height, e = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType }), e.texture.name = "EffectComposer.rt1";
    } else
      this._width = e.width, this._height = e.height;
    this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new bh(tp), this.copyPass.material.blending = NoBlending, this.clock = new Clock();
  }
  swapBuffers() {
    const t = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = t;
  }
  addPass(t) {
    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(t, e) {
    this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(t) {
    const e = this.passes.indexOf(t);
    e !== -1 && this.passes.splice(e, 1);
  }
  isLastEnabledPass(t) {
    for (let e = t + 1; e < this.passes.length; e++)
      if (this.passes[e].enabled)
        return false;
    return true;
  }
  render(t) {
    t === void 0 && (t = this.clock.getDelta());
    const e = this.renderer.getRenderTarget();
    let n = false;
    for (let s = 0, i = this.passes.length; s < i; s++) {
      const r = this.passes[s];
      if (r.enabled !== false) {
        if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), r.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), r.needsSwap) {
          if (n) {
            const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        dc !== void 0 && (r instanceof dc ? n = true : r instanceof rp && (n = false));
      }
    }
    this.renderer.setRenderTarget(e);
  }
  reset(t) {
    if (t === void 0) {
      const e = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, t = this.renderTarget1.clone(), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(t, e) {
    this._width = t, this._height = e;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, s), this.renderTarget2.setSize(n, s);
    for (let i = 0; i < this.passes.length; i++)
      this.passes[i].setSize(n, s);
  }
  setPixelRatio(t) {
    this._pixelRatio = t, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
};
var ap = class extends vs {
  constructor(t, e, n = null, s = null, i = null) {
    super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = s, this.clearAlpha = i, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new Color();
  }
  render(t, e, n) {
    const s = t.autoClear;
    t.autoClear = false;
    let i, r;
    this.overrideMaterial !== null && (r = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (t.getClearColor(this._oldClearColor), t.setClearColor(this.clearColor)), this.clearAlpha !== null && (i = t.getClearAlpha(), t.setClearAlpha(this.clearAlpha)), this.clearDepth == true && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear === true && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor !== null && t.setClearColor(this._oldClearColor), this.clearAlpha !== null && t.setClearAlpha(i), this.overrideMaterial !== null && (this.scene.overrideMaterial = r), t.autoClear = s;
  }
};
var pi = new BufferGeometry();
pi.setAttribute("position", new BufferAttribute(new Float32Array([
  -1,
  -1,
  3,
  -1,
  -1,
  3
]), 2));
pi.setAttribute("uv", new BufferAttribute(new Float32Array([
  0,
  0,
  2,
  0,
  0,
  2
]), 2));
pi.boundingSphere = new Sphere();
pi.computeBoundingSphere = function() {
};
var lp = new OrthographicCamera();
var gr = class {
  constructor(t) {
    this._mesh = new Mesh(pi, t), this._mesh.frustumCulled = false;
  }
  render(t) {
    t.render(this._mesh, lp);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
  dispose() {
    this._mesh.material.dispose(), this._mesh.geometry.dispose();
  }
};
var cp = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    sceneNormal: {
      value: null
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projViewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    time: {
      value: 0
    },
    samples: {
      value: []
    },
    samplesR: {
      value: []
    },
    bluenoise: {
      value: null
    },
    distanceFalloff: {
      value: 1
    },
    radius: {
      value: 5
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    logDepth: {
      value: false
    },
    ortho: {
      value: false
    },
    screenSpaceRadius: {
      value: false
    }
  },
  vertexShader: (
    /* glsl */
    `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1);
}`
  ),
  fragmentShader: (
    /* glsl */
    `
    #define SAMPLES 16
    #define FSAMPLES 16.0
uniform sampler2D sceneDiffuse;
uniform sampler2D sceneNormal;
uniform highp sampler2D sceneDepth;
uniform mat4 projectionMatrixInv;
uniform mat4 viewMatrixInv;
uniform mat4 projMat;
uniform mat4 viewMat;
uniform mat4 projViewMat;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform float time;
uniform vec3[SAMPLES] samples;
uniform float[SAMPLES] samplesR;
uniform float radius;
uniform float distanceFalloff;
uniform float near;
uniform float far;
uniform bool logDepth;
uniform bool ortho;
uniform bool screenSpaceRadius;
uniform sampler2D bluenoise;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }

    vec3 getWorldPosLog(vec3 posS) {
      vec2 uv = posS.xy;
      float z = posS.z;
      float nearZ =near;
      float farZ = far;
      float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
      vec4 wpos = viewMatrixInv * projectionMatrixInv * clipVec;
      return wpos.xyz / wpos.w;
    }
    vec3 getWorldPos(float depth, vec2 coord) {
      #ifdef LOGDEPTH
        return getWorldPosLog(vec3(coord, depth));
      #endif
      float z = depth * 2.0 - 1.0;
      vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
      vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
      // Perspective division
     vec4 worldSpacePosition = viewMatrixInv * viewSpacePosition;
     worldSpacePosition.xyz /= worldSpacePosition.w;
      return worldSpacePosition.xyz;
  }

  vec3 computeNormal(vec3 worldPos, vec2 vUv) {
    ivec2 p = ivec2(vUv * resolution);
    float c0 = texelFetch(sceneDepth, p, 0).x;
    float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getWorldPos(c0, vUv).xyz;

    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;

    return normalize(cross(dpdx, dpdy));
}

void main() {
      vec4 diffuse = texture2D(sceneDiffuse, vUv);
      float depth = texture2D(sceneDepth, vUv).x;
      if (depth == 1.0) {
        gl_FragColor = vec4(vec3(1.0), 1.0);
        return;
      }
      vec3 worldPos = getWorldPos(depth, vUv);
    //  vec3 normal = texture2D(sceneNormal, vUv).rgb;//computeNormal(worldPos, vUv);
      #ifdef HALFRES
        vec3 normal = texture2D(sceneNormal, vUv).rgb;
      #else
        vec3 normal = computeNormal(worldPos, vUv);
      #endif
      vec4 noise = texture2D(bluenoise, gl_FragCoord.xy / 128.0);
      vec3 randomVec = normalize(noise.rgb * 2.0 - 1.0);
      vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
      vec3 bitangent = cross(normal, tangent);
      mat3 tbn = mat3(tangent, bitangent, normal);
      float occluded = 0.0;
      float totalWeight = 0.0;
     /* float radiusScreen = distance(
        worldPos,
        getWorldPos(depth, vUv + 
          vec2(48.0, 0.0) / resolution)
      );/*vUv.x < 0.5 ? radius : min(distance(
        worldPos,
        getWorldPos(depth, vUv + 
          vec2(100.0, 0.0) / resolution)
      ), radius);
      float distanceFalloffScreen = radiusScreen * 0.2;*/
      float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
      float bias = (0.1 / near) * fwidth(distance(worldPos, cameraPos)) / radiusToUse;
      for(float i = 0.0; i < FSAMPLES; i++) {
        vec3 sampleDirection = 
        tbn * 
        samples[int(i)];
        ;
        float moveAmt = samplesR[int(mod(i + noise.a * FSAMPLES, FSAMPLES))];
        vec3 samplePos = worldPos + radiusToUse * moveAmt * sampleDirection;
        vec4 offset = projViewMat * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;
        float sampleDepth = textureLod(sceneDepth, offset.xy, 0.0).x;
        /*float distSample = logDepth ? linearize_depth_log(sampleDepth, near, far) 
         (ortho ?  linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far));*/
        #ifdef LOGDEPTH
        float distSample = linearize_depth_log(sampleDepth, near, far);
        #else
        float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);
        #endif
        float distWorld = ortho ? linearize_depth_ortho(offset.z, near, far) : linearize_depth(offset.z, near, far);
        float rangeCheck = smoothstep(0.0, 1.0, distanceFalloffToUse / (abs(distSample - distWorld)));
        vec2 diff = gl_FragCoord.xy - ( offset.xy * resolution);
        float weight = dot(sampleDirection, normal);
          occluded += rangeCheck * weight * 
            (distSample + bias
               < distWorld ? 1.0 : 0.0) * (
          (dot(
            diff,
            diff
             
            ) < 1.0 || (sampleDepth == depth) || (
              offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0
            ) ? 0.0 : 1.0)
          );
          totalWeight += weight;
      }
      float occ = clamp(1.0 - occluded / totalWeight, 0.0, 1.0);
      gl_FragColor = vec4(0.5 + 0.5 * normal, occ);
}`
  )
};
var hp = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    color: {
      value: new Vector3(0, 0, 0)
    },
    blueNoise: {
      value: null
    },
    downsampledDepth: {
      value: null
    },
    time: {
      value: 0
    },
    intensity: {
      value: 10
    },
    renderMode: {
      value: 0
    },
    gammaCorrection: {
      value: false
    },
    logDepth: {
      value: false
    },
    ortho: {
      value: false
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    screenSpaceRadius: {
      value: false
    },
    radius: {
      value: 0
    },
    distanceFalloff: {
      value: 1
    }
  },
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform sampler2D sceneDepth;
    uniform sampler2D downsampledDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform vec2 resolution;
    uniform vec3 color;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform float intensity;
    uniform float renderMode;
    uniform float near;
    uniform float far;
    uniform bool gammaCorrection;
    uniform bool logDepth;
    uniform bool ortho;
    uniform bool screenSpaceRadius;
    uniform float radius;
    uniform float distanceFalloff;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = viewMatrixInv * projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
       // if (logDepth) {
        #ifdef LOGDEPTH
          return getWorldPosLog(vec3(coord, depth));
        #endif
      //  }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewMatrixInv * viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }

    #include <common>
    #include <dithering_pars_fragment>
    void main() {
        //vec4 texel = texture2D(tDiffuse, vUv);//vec3(0.0);
        vec4 sceneTexel = texture2D(sceneDiffuse, vUv);

        #ifdef HALFRES 
        float depth = texture2D(
            sceneDepth,
            vUv
        ).x;
        vec4 texel;
        if (depth == 1.0) {
            texel = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
        vec3 worldPos = getWorldPos(depth, vUv);
        vec3 normal = computeNormal(getWorldPos(depth, vUv), vUv);
       // vec4 texel = texture2D(tDiffuse, vUv);
       // Find closest depth;
       float totalWeight = 0.0;
       float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
        for(float x = -1.0; x <= 1.0; x++) {
            for(float y = -1.0; y <= 1.0; y++) {
                vec2 offset = vec2(x, y);
                ivec2 p = ivec2(
                    (vUv * resolution * 0.5) + offset
                );
                vec2 pUv = vec2(p) / (resolution * 0.5);
                float sampleDepth = texelFetch(downsampledDepth,p, 0).x;
                vec4 sampleInfo = texelFetch(tDiffuse, p, 0);
                vec3 normalSample = sampleInfo.xyz * 2.0 - 1.0;
                vec3 worldPosSample = getWorldPos(sampleDepth, pUv);
                float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));
                float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0);
                float weight = rangeCheck;
                totalWeight += weight;
                texel += sampleInfo * weight;
            }
        }
        if (totalWeight == 0.0) {
            texel = texture2D(tDiffuse, vUv);
        } else {
            texel /= totalWeight;
        }
    }
        #else
        vec4 texel = texture2D(tDiffuse, vUv);
        #endif

     
        float finalAo = pow(texel.a, intensity);
        if (renderMode == 0.0) {
            gl_FragColor = vec4( mix(sceneTexel.rgb, color * sceneTexel.rgb, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 1.0) {
            gl_FragColor = vec4( mix(vec3(1.0), color * sceneTexel.rgb, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 2.0) {
            gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
        } else if (renderMode == 3.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(sceneTexel.rgb, color * sceneTexel.rgb, 1.0 - finalAo), sceneTexel.a);
            }
        } else if (renderMode == 4.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(vec3(1.0), color * sceneTexel.rgb, 1.0 - finalAo), sceneTexel.a);
            }
        }
        #include <dithering_fragment>
        if (gammaCorrection) {
            gl_FragColor = LinearTosRGB(gl_FragColor);
        }
    }
    `
  )
};
var up = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    time: {
      value: 0
    },
    r: {
      value: 5
    },
    blueNoise: {
      value: null
    },
    radius: {
      value: 12
    },
    worldRadius: {
      value: 5
    },
    index: {
      value: 0
    },
    poissonDisk: {
      value: []
    },
    distanceFalloff: {
      value: 1
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    logDepth: {
      value: false
    },
    screenSpaceRadius: {
      value: false
    }
  },
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1.0);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform vec2 resolution;
    uniform float r;
    uniform float radius;
     uniform float worldRadius;
    uniform float index;
     uniform float near;
     uniform float far;
     uniform float distanceFalloff;
     uniform bool logDepth;
     uniform bool screenSpaceRadius;
    varying vec2 vUv;

    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        highp float z_n = 2.0 * d - 1.0;
        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     return linearize_depth(linDepth, nearZ, farZ);
   }
   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
     return nearZ + (farZ - nearZ) * d;
   }
   vec3 getWorldPosLog(vec3 posS) {
     vec2 uv = posS.xy;
     float z = posS.z;
     float nearZ =near;
     float farZ = far;
     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
     vec4 wpos = viewMatrixInv * projectionMatrixInv * clipVec;
     return wpos.xyz / wpos.w;
   }
    vec3 getWorldPos(float depth, vec2 coord) {
     #ifdef LOGDEPTH
          return getWorldPosLog(vec3(coord, depth));
     #endif
        
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewMatrixInv * viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
    #include <common>
    #define NUM_SAMPLES 16
    uniform vec2 poissonDisk[NUM_SAMPLES];
    void main() {
        const float pi = 3.14159;
        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);
        vec2 uv = vUv;
        vec4 data = texture2D(tDiffuse, vUv);
        float occlusion = data.a;
        float baseOcc = data.a;
        vec3 normal = data.rgb * 2.0 - 1.0;
        float count = 1.0;
        float d = texture2D(sceneDepth, vUv).x;
        vec3 worldPos = getWorldPos(d, vUv);
        float size = radius;
        float angle;
        if (index == 0.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;
        } else if (index == 1.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;
        } else if (index == 2.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;
        } else {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;
        }

        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        float radiusToUse = screenSpaceRadius ? distance(
          worldPos,
          getWorldPos(d, vUv +
            vec2(worldRadius, 0.0) / resolution)
        ) : worldRadius;
        float distanceFalloffToUse =screenSpaceRadius ?
            radiusToUse * distanceFalloff
        : distanceFalloff;


        for(int i = 0; i < NUM_SAMPLES; i++) {
            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;
            vec4 dataSample = texture2D(tDiffuse, uv + offset);
            float occSample = dataSample.a;
            vec3 normalSample = dataSample.rgb * 2.0 - 1.0;
            float dSample = texture2D(sceneDepth, uv + offset).x;
            vec3 worldPosSample = getWorldPos(dSample, uv + offset);
            float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));
            float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0) * (1.0 - abs(occSample - baseOcc));
            occlusion += occSample * rangeCheck;
            count += rangeCheck;
        }
        occlusion /= count;
        gl_FragColor = vec4(0.5 + 0.5 * normal, occlusion);
    }
    `
  )
};
var dp = {
  uniforms: {
    sceneDepth: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    logDepth: {
      value: false
    }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1);
    }`
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D sceneDepth;
    uniform vec2 resolution;
    uniform float near;
    uniform float far;
    uniform bool logDepth;
    uniform mat4 viewMatrixInv;
    uniform mat4 projectionMatrixInv;
    varying vec2 vUv;
    layout(location = 1) out vec4 gNormal;
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = viewMatrixInv * projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
        if (logDepth) {
          return getWorldPosLog(vec3(coord, depth));
        }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewMatrixInv * viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }
    void main() {
        vec2 uv = vUv - vec2(0.5) / resolution;
        vec2 pixelSize = vec2(1.0) / resolution;
        vec2[] uvSamples = vec2[4](
            uv,
            uv + vec2(pixelSize.x, 0.0),
            uv + vec2(0.0, pixelSize.y),
            uv + pixelSize
        );
        float depth00 = texture2D(sceneDepth, uvSamples[0]).r;
        float depth10 = texture2D(sceneDepth, uvSamples[1]).r;
        float depth01 = texture2D(sceneDepth, uvSamples[2]).r;
        float depth11 = texture2D(sceneDepth, uvSamples[3]).r;
        float minDepth = min(min(depth00, depth10), min(depth01, depth11));
        float maxDepth = max(max(depth00, depth10), max(depth01, depth11));
        float targetDepth = minDepth;
        // Checkerboard pattern to avoid artifacts
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) > 0.5) { 
            targetDepth = maxDepth;
        }
        int chosenIndex = 0;
        float[] samples = float[4](depth00, depth10, depth01, depth11);
        for(int i = 0; i < 4; ++i) {
            if (samples[i] == targetDepth) {
                chosenIndex = i;
                break;
            }
        }
        gl_FragColor = vec4(samples[chosenIndex], 0.0, 0.0, 1.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[chosenIndex], uvSamples[chosenIndex]), uvSamples[chosenIndex]
        ), 0.0);
       /* float[] samples = float[4](depth00, depth10, depth01, depth11);
        float c = 0.25 * (depth00 + depth10 + depth01 + depth11);
        float[] distances = float[4](depth00, depth10, depth01, depth11);
        float maxDistance = max(max(distances[0], distances[1]), max(distances[2], distances[3]));

        int remaining[3];
        int rejected[3];
        int i, j, k;

        for(i = 0, j = 0, k = 0; i < 4; ++i) {
            if (distances[i] < maxDistance) {
                remaining[j++] = i;
            } else {
                rejected[k++] = i;
            }
        }
        for(;j < 3;++j) {
            remaining[j] = rejected[--k];
        }
        vec3 s = vec3(
            samples[remaining[0]],
            samples[remaining[1]],
            samples[remaining[2]]
        );
        c = (s.x + s.y + s.z) / 3.0;

        distances[0] = abs(c - s.x);
        distances[1] = abs(c - s.y);
        distances[2] = abs(c - s.z);

        float minDistance = min(min(distances[0], distances[1]), distances[2]);

        for(i = 0; i < 3; ++i) {
            if (distances[i] == minDistance) {
                break;
            }
        }*/
      /*  gl_FragColor = vec4(samples[remaining[i]], 0.0, 0.0, 0.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[remaining[i]], uvSamples[remaining[i]]), uvSamples[remaining[i]]
        ), 0.0);*/
    }`
  )
};
var xh = "5L7pP4UXrOIr/VZ1G3f6p89FIWU7lqc7J3DPxKjJUXODJoHQzf/aNVM+ABlvhXeBGN7iC0WkmTjEaAqOItBfBdaK5KSGV1ET5SOKl3x9JOX5w2sAl6+6KjDhVUHgbqq7DZ5EeYzbdSNxtrQLW/KkPJoOTG4u5CBUZkCKHniY9l7DUgjuz708zG1HIC8qfohi1vPjPH9Lq47ksjRrjwXD4MlVCjdAqYFGodQ8tRmHkOfq4wVRIAHvoavPHvN1lpk3X4Y1yzAPGe8S9KBs3crc4GwlU1dEOXiWol/mgQqxkNqB1xd04+0Bmpwj0GcCc4NUi+c731FUxjvaexCkCJ0qhrJJ++htWqetNC4NewClu8aFRSwrqiJEGe+qtTg4CYCHaF1wJI0sy/ZBQAI0qAMyBvVjWZlv2pdkCaro9eWDLK5I4mbb8E4d7hZr9dDJiTJm6Bmb5S+2F7yal/JPdeLUfwq7jmVLaQfhv4tWMJAt7V4sG9LuAv2oPJgSj1nnlBvPibfHM2TrlWHwGCLGxW/5Jm2TotaDL+pHDM5pn1r0UuTZ24N8S5k68bLHW9tfD+2k4zGev23ExJb4YTRKWrj82N5LjJ26lj1BkGZ0CsXLGGELoPaYQomjTqPxYqhfwOwDliNGVqux9ffuybqOKgsbB51B1GbZfG8vHDBE2JQGib1mnCmWOWAMJcHN0cKeDHYTflbDTVXajtr68mwfRje6WueQ/6yWqmZMLWNH7P27zGFhMFqaqfg11Q88g/9UA/FROe9yfq0yOO0pnNAxvepFy2BpEbcgG+mCyjCC01JWlOZlIPdf1TtlyOt7L94ToYGCukoFt4OqwOrofamjECpSgKLLmrRM+sNRAw12eaqk8KtdFk7pn2IcDQiPXCh16t1a+psi+w9towHTKPyQM0StKr61b2BnN1HU+aezFNBLfHTiXwhGTbdxLLmrsAGIVSiNAeCGE8GlB0iOv2v78kP0CTmAPUEqnHYRSDlP+L6m/rYjEK6Q85GRDJi2W20/7NLPpSOaMR++IFvpkcwRuc59j8hh9tYlc1xjdt2jmp9KJczB7U9P43inuxLOv11P5/HYH5d6gLB0CsbGC8APjh+EcCP0zFWqlaACZweLhVfv3yiyd8R3bdVg8sRKsxPvhDaPpiFp9+MN+0Ua0bsPr+lhxfZhMhlevkLbR4ZvcSRP6ApQLy3+eMh9ehCB3z5DVAaN3P6J8pi5Qa88ZQsOuCTWyH6q8yMfBw8y8nm6jaOxJhPH6Hf0I4jmALUBsWKH4gWBnyijHh7z3/1HhQzFLRDRrIQwUtu11yk7U0gDw/FatOIZOJaBx3UqbUxSZ6dboFPm5pAyyXC2wYdSWlpZx/D2C6hDO2sJM4HT9IKWWmDkZIO2si/6BKHruXIEDpfAtz3xDlIdKnnlqnkfCyy6vNOPyuoWsSWBeiN0mcfIrnOtp2j7bxjOkr25skfS/lwOC692cEp7TKSlymbsyzoWg/0AN66SvQYo6BqpNwPpTaUu25zMWlwVUdfu1EEdc0O06TI0JmHk4f6GZQbfOs//OdgtGPO6uLoadJycR8Z80rkd88QoNmimZd8vcpQKScCFkxH1RMTkPlN3K7CL/NSMOiXEvxrn9VyUPFee63uRflgaPMSsafvqMgzTt3T1RaHNLLFatQbD0Vha4YXZ/6Ake7onM65nC9cyLkteYkDfHoJtef7wCrWXTK0+vH38VUBcFJP0+uUXpkiK0gDXNA39HL/qdVcaOA16kd2gzq8aHpNSaKtgMLJC6fdLLS/I/4lUWV2+djY9Rc3QuJOUrlHFQERtXN4xJaAHZERCUQZ9ND2pEtZg8dsnilcnqmqYn3c1sRyK0ziKpHNytEyi2gmzxEFchvT1uBWxZUikkAlWuyqvvhteSG9kFhTLNM97s3X1iS2UbE6cvApgbmeJ/KqtP0NNT3bZiG9TURInCZtVsNZzYus6On0wcdMlVfqo8XLhT5ojaOk4DtCyeoQkBt1mf5luFNaLFjI/1cnPefyCQwcq5ia/4pN4NB+xE/3SEPsliJypS964SI6o5fDVa0IERR8DoeQ+1iyRLU1qGYexB61ph4pkG1rf3c2YD6By1pFCmww9B0r2VjFeaubkIdgWx4RKLQRPLENdGo8ezI5mkNtdCws19aP1uHhenD+HKa8GDeLulb2fiMRhU2xJzzz9e4yOMPvEnGEfbCiQ17nUDpcFDWthr68mhZ4WiHUkRpaVWJNExuULcGkuyVLsQj59pf6OHFR7tofhy9FMrWPCEvX1d5sCVJt8yBFiB6NoOuwMy4wlso9I2G4E5/5B2c6vIZUUY9fFujT3hpkdTuVhbhBwLCtnlIjBpN4cq+waZ0wXSrmebcl+dcrb7sPh9jKxFINkScDTBgjSUfLkC3huJJs/M4M8AOFxbbSIVpBUarYFmLpGsv+V6TJnWNTwI41tubwo7QSI1VOdRKT/Pp8U3oK2ciDbeuWnAGAANvQjGfcewdAdo6H83XzqlK/4yudtFHJSv9Y+qJskwnVToH1I0+tJ3vsLBXtlvMzLIxUj/8LcqZnrNHfVRgabFNXW0qpUvDgxnP3f54KooR3NI+2Q/VHAYFigMkQE5dLH6C6fGs/TKeE6E2jOhZQcP9/rrJjJKcLYdn5cw6XLCUe9F7quk5Yhac+nYL5HOXvp6Q/5qbiQHkuebanX77YSNx34YaWYpcEHuY1u/lEVTCQ7taPaw3oNcn/qJhMzGPZUs3XAq48wj/hCIO2d5aFdfXnS0yg57/jxzDJBwkdOgeVnyyh19Iz1UqiysT4J1eeKwUuWEYln23ydtP7g3R1BnvnxqFPAnOMgOIop2dkXPfUh/9ZKV3ZQbZNactPD4ql5Qg9CxSBnIwzlj/tseQKWRstwNbf17neGwDFFWdm/8f+nDWt/WlKV3MUiAm3ci6xXMDSL5ubPXBg/gKEE7TsZVGUcrIbdXILcMngvGs7unvlPJh6oadeBDqiAviIZ/iyiUMdQZAuf/YBAY0VP1hcgInuWoKbx31AOjyTN2OOHrlthB3ny9JKHOAc8BMvqopikPldcwIQoFxTccKKIeI815GcwaKDLsMbCsxegrzXl8E0bpic/xffU9y1DCgeKZoF2PIY77RIn6kSRdBiGd8NtNwT74dyeFBMkYraPkudN26x9NPuBt4iCOAnBFaNSKVgKiZQruw22kM1fgBKG7cPYAxdHJ8M4V/jzBn2jEJg+jk/jjV4oMmMNOpKB5oVpVh7tK529Z+5vKZ0NSY2A4YdcT0x4BdkoNEDrpsTmekSTjvx9ZBiTHrm9M/n/hGmgpjz4WEjttRfAEy5DYH5vCK/9GuVPa4hoApFaNlrFD/n2PpKOw24iKujKhVIz41p1E0HwsCd/c17OA0H0RjZi1V/rjJLexUzpmXTMIMuzaOBbU4dxvQMgyvxJvR6DyF3BaHkaqT4P3FRYlm+zh8EEGgmkNqD1WRUubDW62VqLoH8UEelIpL7C8CguWWGGCAIDPma9bnh+7IJSt0Cn6ACER2mYk8dLsrN70RUVLiE0ig+08yPY9IOtuqHf/KYsT84BwhMcVq7t8q1WVjpJGNyXdtIPIjhAzabtrX03Itn29QO3TCixE9WpkHIOdAoGvqCrw1D3x9g9Px8u0yZZuulZuGy0veSY34KDSlhsO1zx2ZMrpDBzCHPB4niwApk6NevIvmBxU3+4yaewDvgEQDJ6Of5iRxjAIpp9UO8EzNY4blj4qh8SCSZTqbe/lShE6tNU9Y5IoWHeJxPcHF9KwYQD7lFcIpcscHrcfkHJfL2lL1zczKywEF7BwkjXEirgBcvNWayatqdTVT5oLbzTmED3EOYBSXFyb2VIYk3t0dOZWJdG1nP+W7Qfyeb8MSIyUGKEA57ptPxrPHKYGZPHsuBqQuVSrn0i8KJX+rlzAqo8AawchsJ26FckxTf5+joTcw+2y8c8bushpRYEbgrdr64ltEYPV2AbVgKXV3XACoD1gbs01CExbJALkuItjfYN3+6I8kbiTYmdzBLaNC+xu9z/eXcRQV1Lo8cJoSsKyWJPuTncu5vcmfMUAWmuwhjymK1rhYR8pQMXNQg9X+5ha5fEnap+LhUL1d5SURZz9rGdOWLhrMcMKSaU3LhOQ/6a6qSCwgzQxCW2gFs53fpvfWxhH+xDHdKRV6w29nQ6rNqd9by+zm1OpzYyJwvFyOkrVXQUwt4HaapnweCa7Tj2Mp/tT4YcY3Q/tk1czgkzlV5mpDrdp1spOYB8ionAwxujjdhj5y9qEHu0uc36PAKAYsKLaEoiwPnob0pdluPWdv4sNSlG8GWViI+x/Z4DkW/kSs2iE3ADFjg4TCvgCbX3v0Hz0KZkerrpzEIukAusidDs2g/w0zgmLnZXvVr5kkpwQTLZ0L6uaTHl0LVikIuNIVPmL3fOQJqIdfzymUN0zucIrDintBn6ICl/inj5zteISv5hEMGMqtHc2ghcFJvmH3ZhIZi34vqqTFCb9pltTYz582Y3dwYaHb9khdfve1YryzEwEKbI8qm62qv+NyllC+WxLLAJjz0ZaEF2aTn35qeFmkbP6LDYcbwqWxA0WKsteB7vy8bRHE4r8LhubWDc0pbe90XckSDDAkRej0TQlmWsWwaz18Tx2phykVvwuIRzf4kt9srT8N7gsMjMs0NLAAldabFf2tiMoaaxHcZSX51WPc1BrwApMxih227qTZkcgtkdK1h314XvZKUKh/XysWYnk1ST4kiBI1B9OlfTjB3WHzTAReFLofsGtikwpIXzQBc/gOjz2Thlj36WN0sxyf4RmAFtrYt64fwm+ThjbhlmUTZzebLl4yAkAqzJSfjPBZS2H/IvkkTUdVh0qdB6EuiHEjEil5lk9BTPzxmoW4Jx543hiyy4ASdYA2DNoprsR9iwGFwFG3F2vIROy4L5CZrl230+k733JwboSNBKngsaFPtqo+q3mFFSjC1k0kIAFmKihaYSwaSF7konmYHZWmchuaq15TpneA2ADSRvA07I7US0lTOOfKrgxhzRl0uJihcEZhhYWxObjvNTJ/5sR4Aa5wOQhGClGLb746cJhQ2E6Jie1hbGgWxUH7YSKETptrTeR/xfcMNk2WM12S0XElC9klR8O7jLYekEOZdscP0ypSdoCVZAoK+2ju2PHE869Q9rxCs9DVQco4BriiPbCjN/8tBjsah4IuboR5QbmbyDpcdXVxGMxvWKIjocBuKbjb+B4HvkunbG0wX0IFCjQKoNMFIKcJSJXtkP3EO+J16uh4img0LQlBAOYwBLupu5r1NALMo0g3xkd9b4f7KoCBWHeyk24FmYUCy/PGLv0xErOTyORp8TJ5nnc2k1dOVBTJok7iHye9dwxwRVP3c7eAS8pMmJYHGpzIHz6ii2WJm8HMTPAZdA4q+ugj3PNCL/N45kyglqvQV4f/+ryDDG5RPy5HVoV9FVuJcq2dxF9Y0heVoipV6q1LyfAeuMzbsUV+rsSBmCSV+1CdKlxy0T0Y6Om0X6701URm2Ml6DIQgJ/3KO6kwcMYRrmKsY7TfxWhSXZll+1PfyRXe9HS0t1IKTQMZL7ZqQ8D/o+en57Y9XAQ9C+kZYykNr0xOMxEwu2+Cppm69mQyTm3H7QX6kHvXF201r+KVAf354qypJC5OHSeBU47bM1bTaVmdVEWQ+9CcvvHdu8Ue5UndHM+EeukmR82voQpetZ7WJjyXs+tPS60nk09gymuORoHNtbm0VuvyigiEvOsyHiRBW7V6FyTCppLPEHvesan91SlEh1/QEunq+qgREFXByDwNKcAH5s8/RFg8hP4wcPmFqX0xXGSKY087bqRLsBZe52jThx0XLkhKQUWPvI18WQQS3g2Ra1pzQ1oNFKdfJJjyaH5tJH6w0/upJobwB8KZ5cIs9LnVGxfBaHXBfvLkNpab7dpU6TdcbBIc+A4bqXE/Xt8/xsGQOdoXra4Us5nDAM6v2BNBQaGMmgMfQQV+ikTteSHvyl8wUxULiYRIEKaiDxpBJnyf9OoqQdZVJ8ahqOvuwqq5mnDUAUzUr/Lvs1wLu2F+r4eZMfJPL4gV5mKLkITmozRnTvA7VABaxZmFRtkhvU5iH9RQ1z26ku7aABokvptx7RKZBVL6dveLKOzg0NC7HAxcg5kE1wuyJiEQLOpO0ma3AtWD2Q2Wmn2oPZeDYAwVyEpxuwDy7ivmdUDSL95ol3h2JByTMovOCgxZ1q4E5nwwa7+4WtDAse6bDdr27XgAi5Px3IWbyZ/vRiECKwOMeJSuIl8A4Ds0emI3SgKVVWVO5uyiEUET+ucEq0casA+DQyhzRc8j+Plo0pxKynB/t0uXod1FVV4fX1sC4kDfwFaUDGQ4p9HYgaMqIWX3OF/S8+vcR0JS0bDapWKJwAIIQiRUzvh5YwtzkjccbbrT9Ky/qt5X7MAGA0lzh43mDF9EB6lCGuO/aFCMhdOqNryvd73KdJNy3mxtT8AqgmG4xq7eE1jKu6rV0g8UGyMatzyIMjiOCf4lIJFzAfwDbIfC72TJ/TK+cGsLR8blpjlEILjD8Mxr7IffhbFhgo12CzXRQ2O8JqBJ70+t12385tSmFC8Or+U8svOaoGoojT1/EmjRMT7x2iTUZ7Ny02VGeMZTtGy029tGN1/9k7x3mFu63lYnaWjfJT1m1zpWO3HSXpGkFqVd/m3kDMv4X9rmLOpwEeu8r6TI6C2zUG+MT6v90OU3y5hKqLhpyFLGtkZhDmUg/W1JGSmA8N1TapR4Kny+P6+DuMadZ9+xBbv06nfOjMwkoTsjG0zFmNbvlxEjw+Pl5QYK+V8Qyb+nknZ0Nb/Ofi9+V0eoNtTrtD1/0wzUGGG5u2D/J1ouO/PjXFJVx6LurVnPOyFVbZx7s3ZSjSq+7YN3wzTbFbUvP8GBh7cKieJt56SIowQ2I577+UEXrxUKMFO+XaLLCALuiJWB2vUdpsT+kQ+adoeTfwOulXhd/KZ7ygjj6PhvGT1xzfT7hTwd6dzSB4xV70CesHC0dsg2VyujlMGBKjg5snbrHHX/LNj3SsoLGSX+bZNTDDCNTXh+dCVPlj4K8+hJ/kVddrbtZw26Hx5qYiv3oNNg5blHRSPtmojhZmBQAz8sLC9nAuWNSz1dIofFtlryEKklbdkhBCcx5dhj7pinXDNlCeatCeTCEjYCpZ3HRf5QzUcRR1Tdb3gwtYtpPdgMxmWfJGoZSu1EsCJbIhS16Ed97+8br4Ar1mB1GcnZVx/HPtJl4CgbHXrrDPwlE4od8deRQYLt9IlsvCqgesMmLAVxB+igH7WGTcY/e3lLHJ4rkBgh2p1QpUBRb/cSQsJCbosFDkalbJigimldVK7TIHKSq2w8mezku9hgw8fXJxGdXoL1ggma52kXzjP78l0d0zMwtTVlt0FqnRyGLPGEjmICzgSp7XPFlUr7AeMclQ4opqwBFInziM5F8oJJ8qeuckGOnAcZZOLl1+ZhGF17pfIuujipwFJL7ChIIB2vlo0IQZGTJPNa2YjNcGUw+a/gWYLkCp+bOGIYhWr08UIE709ZEHlUoEbumzgpJv1D0+hWYNEpj+laoZIK5weO2DFwLL6UBYNrXTm9YvvxeN9U9oKsB3zKBwzFFwDgid5ESMhy68xBnVa55sCZd+l5AnzT8etYjIwF/BGwEx1jjzFv32bk6EeJulESARh8RZ48o7rKw67UZpudPa15SDnL8AL8xMV2SC0D1P53p190zhCFkMmEiir2olwxcJppl/kLm6/0QSUQLNaxi1AC3Pg1CTosX2YQr73PjEIxIlg4mJ62vP7ZyoHE55B0SX9YrrrCPtNsrJEwtn6KOSt7nLT3n3DLJTPbLulcqQ1kETP6Huts29oP+JLEqRGWgnrqMD+mhCl1XCZifjgQ39AeudE8pyu2DqnYU3PyPbJhStq1HbP+VxgseWL+hQ+4w1okADlA9WqoaRuoS7IY77Cm40cJiE6FLomUMltT+xO3Upcv5dzSh9F57hodSBnMHukcH1kd9tqlpprBQ/Ij9E+wMQXrZG5PlzwYJ6jmRdnQtRj64wC/7vsDaaMFteBOUDR4ebRrNZJHhwlNEK9Bz3k7jqOV5KJpL74p2sQnd7vLE374Jz+G7H3RUbX17SobYOe9wKkL/Ja/zeiKExOBmPo0X29bURQMxJkN4ddbrHnOkn6+M1zTZHo0efsB23WSSsByfmye2ZuTEZ12J3Y8ffT6Fcv8XVfA/k+p+xJGreKHJRVUIBqfEIlRt987/QXkssXuvLkECSpVEBs+gE1meB6Xn1RWISG6sV3+KOVjiE9wGdRHS8rmTERRnk0mDNU/+kOQYN/6jdeq0IHeh9c6xlSNICo9OcX1MmAiEuvGay43xCZgxHeZqD7etZMigoJI5V2q7xDcXcPort7AEjLwWlEf4ouzy2iPa3lxpcJWdIcHjhLZf1zg/Kv3/yN1voOmCLrI1Fe0MuFbB0TFSUt+t4Wqe2Mj1o2KS0TFQPGRlFm26IvVP9OXKIQkjfueRtMPoqLfVgDhplKvWWJA673+52FgEEgm+HwEgzOjaTuBz639XtCTwaQL/DrCeRdXun0VU3HDmNmTkc6YrNR6tTVWnbqHwykSBswchFLnvouR0KRhDhZiTYYYNWdvXzY+61Jz5IBcTJavGXr9BcHdk/3tqaLbwCbfpwjxCFSUs1xfFcRzRfMAl+QYuCpsYGz9H01poc1LyzhXwmODmUSg/xFq/RosgYikz4Om/ni9QCcr28ZPISaKrY7O+CspM/s+sHtnA9o9WgFWhcBX2LDN2/AL5uB6UxL/RaBp7EI+JHGz6MeLfvSNJnBgI9THFdUwmg1AXb9pvd7ccLqRdmcHLRT1I2VuEAghBduBm7pHNrZIjb2UVrijpZPlGL68hr+SDlC31mdis0BjP4aZFEOcw+uB17y5u7WOnho60Vcy7gRr7BZ9z5zY1uIwo+tW1YKpuQpdR0Vi7AxKmaIa4jXTjUh7MRlNM0W/Ut/CSD7atFd4soMsX7QbcrUZZaWuN0KOVCL9E09UcJlX+esWK56mre/s6UO9ks0owQ+foaVopkuKG+HZYbE1L1e0VwY2J53aCpwC77HqtpyNtoIlBVzOPtFvzBpDV9TjiP3CcTTGqLKh+m7urHvtHSB/+cGuRk4SsTma9sPCVJ19UPvaAv5WB8u57lNeUewwKpXmmKm5XZV91+FqCCT6nVrrrOgXfYmGFlVjqsSn3/yufkGIdtmdD0yVBcYFR3hDx43e3E4iuiEtP3Me9gcsBqveQdKojKR//qD2nEDY0IktMgFvH+SqVWi9mAorym92NEGbY8MeDjp553MiTXCRSASPt+Ga5q7pB9vwFQCTpaoevx0yEfrq9rMs3eU6wclBMJ9Ve8m6QuLYZ58J41YG3jW/khW92h6M/vbFIUPuopZ6VVtpciesU74Ef7ic8iSymDohGeUn4ubT0vRsXmbsjaJaYhL8f+8I5EiD5l680MJbxX/4GYrOg4iPQqpKp0qddSu/HKtznHeVyxgTwhfEORMCwnaqetVSzvidaWN9P+fXtGXfEP9cTdwx2gKVfDdICq7hecgRhIs0qlCt6+5pGlCc6kWoplHa/KjP+FJdXBU/IDoKMxRjFhSYkggIkhvRKiN/b2ud8URPF+lB87AGAwyMjr/Wju2Uj5IrppXZWjI3d14BdKE2fhALyQPmHqqA+AXd2LwvRHcBq4mhOQ4oNRWH7wpzc6Pggfcbv9kqhLxrJKEaJqA6Rxi+TDNOJstd5DoRVCDjmVspCVyHJsFEWPg9+NA8l1e4X2PDvOd5MPZAGw6LRhWqeZoSQcPf9/dGJYAyzCmttlRnx0BfrKQ/G9i5DVJft9fuJwMi3OD/0Dv1bRoxcXAyZ0wMJ6rwk9RjRTF4ZK8JviCCNuVt/BqQYiphOzWCpnbwOZt6qXuiAabQWrS4mNXQ7cEErXR/yJcbdFp5nWE1bPBjD0fmG3ovMxmOq5blpcOs0DtNQpci1t+9DKERWAO53IVV/S4yhMklvIp0j0FIQgwjdUptqmoMYGVWSI5YkTKLHZdXRDv9zs+HdFZt1QVcdlGOgATro3fg6ticCrDQKUJC7bYX50wdvetilEwVenHhlr85HMLRLTD6nDXWId4ORLwwe5IXiOhpuZTVTv+xdkTxJofqeCRM/jcZqQlU0gFVTlYlfwMi6HKR2YG4fQ8TOtgR+yV+BMZb6L5OwDc/28/xdfD7GXFaVA2ZSObiIxBwT2Zev637EuvpM6rxcogdM4FJFa0ZhF7nrqtNsqWg5M7hZMORpjd4szf/wS+Ahs1shY54Ct5J1dOBO4sdEtSnRc0P9PhgyOCt6aQW98R22DpAcNTDe72AHK40vutKTPfpokghRPuGvz0dulBPKfC3O4KVDCyWrJGO7Ikdu06A0keKlVfi0tGcpO0NhzXEh75NHyMysAMV19fq7//sPC0For1k2uFEvq8lwrMAfmP7afR69U2RqaILHe7glpc8HmVf87Qb2ohsw+Di9U+ePdHLecS66MhB/0OwdcXR5WBcWTZLGq/kiAaT+bzkjR8GIpWdv6pfIgQ+Q0xdiKvo+gNB7/Nf9knNJGxnh7LeZEFtMn517tNc74PPS0M4K3I6HHZqNPA+VZcBc/g5a2ARyqKrJ4Z3krsuA+VOJJz2KJpBMgCCWFln3u7k6/q3DETAubKG/pt3ObaNT0NI0Qug90L2ip5dHnZJUjPTvK5E96aX/4mRU2u8n8kh6MKbY7ANBro3huF06U+JvfyELQP25oIaj+n0ITQ4KT9rXZD4EtBIOj95fYNldDN3io/VMIvWNj9P/b95WEMq8UAVfG2XG0N6fSYdnBEC7sUEbatbDICH9qA8TTuW9kEt9DlFOZFP7bdfYLa/khSY8W5K/AkIIAPXtMvyVKyESjKx9nfragssxC0jFMVY94d8lOAwRocdS/l/P43cBGa3IqDa0ihGPcmwS8O8Vj16Uy55rOrnN0shhRJZdW8I7F0Q0KeHc35GFo4aJOFc25gNafBu1V/VO0qS4Qkb6wjRrnlepUWjtYyaDABZceValuOMtoDdeIITWKOJiwGPpB12lQgwkmXh9M86podb0D117mNQ8ElluFvbaS8RTKQ6lyj88dUwoJU/ofOeubhoXWBF8eNumkVJu+As3ED/AvLlrV91UowIWI2m8HBG+a3k247ZKAGYsOcWe7fTWqL8eqwM5ZFuoXbeugPKuMOAtOsN+4dSwkhrSAlfGNTzFwEmCNWtzpa9CgPbYNcmoHtO8pj8qMvlGET6nrkJoQ2lp5MEUV1E2A4ZH70JUlCLXvqTIpZlzyxdr5p/GZiD1/BuFOGbyfFzhuxaC/l3lC2jjt6GNRBa06AqqPlYtdA7kiidYa5Qi0/XpXiMDyMXNOj3kmJEaXufW0GO8+DF8OoMULX1vvjCePKNis4AmxQKLCF+cjf/wyilCJvuiyLVPSdsuRTPZ0AhpdDF/1uFmDwG7iP3qYwNsKzqd3sYdnMolCOuQOIHWy1eQpWhuV+jmSeAC5zCc0/KsOIXkZPdiw8vtB33jEBpezpGDBP4JLY2wH1J7Fzp8y8RICqVd25mDT2tDb/L1mh4fv9TOfDH5dTeATqu+diOZi+/sIt18hiTovPsVQVaqXLPRx/4R/uH/86tBMcF+WBkThKLfblcVCIECc8DgNRVX97KdrsCeIK+CvJZMfwrftcDZDZyp7G8HeKl7bPYnTKX88dXAwAyz66O2chkPDHy/2K2XcT/61XnlAKgPwtI8yP9Vu45yh55KHhJu93mL4nfo8szp/IyDjmFHtSMqqoWsj8WaVhbjXgzZxcqZcyOe7pUK6aXF/Y32LnBOt0WN28UmHRiOpL525C63I2JQPX8vvOU0fz2ij74OeJ1Apgu3JRObfdo9xGDpp7cv3TdULEfNS6Gu3EJu7drBsBsogUqUc6wAUW3ux0/1hLVI/JEKJrAGm8g72C2aJSsGAsKFW4CBvBXVlNIKa5r7HvT1BeGYBfxTR1vhNlFFNN8WQYwr39yT/13XzRGiF2IsfE8HcN0+lN1zN/OnzekVBKkFY11GgrK5CLxrE/2HCEMwQb9yOuP2rTXiZzTEETp/ismFGcTWmbM9G1Sn2D/x3G74uWYZY4rgKB2Zo2bTKS6QnM5x1Yee66Y1L7K44AyiY5K2MH5wrTwxMFh+S8LzNQ25z6sunWZyiRwFIIvSnioltUXNiOr+XMZ6O9h9HcHxZJkfF0tUm6QkU7iJ2ozXARitiL86aqVsMOpmvdIBROhUoanPtCjgft8up3hAaKpw9Qs9MzYtBA2ijHXotzarkV3zKEK0dFFQUwT74NgCmGGuSCEDmFCezXPC9BhyGhmzNa6rQeQQz+r9CmGUZjIQEPsHwe86oCOQhWaHERsv5ia9rZvJ//7UXO7B329YUkLLAiqpLRsVV5XpcfdawlJqi/BVcCqO6dr9YJTFFRMVGhfUbB9YWNvYPY6RyaydAFYq1YIBQxuNAGfYWLMAHtt2XRHoOKCLz+qf5HCVBDOPOktQ3SdJBfxUkaiD585bmTzMwU3oeXUHZ55EC99Kz9kk4ZXMIENwVVpqW2JmGIcUiutIMj2KkpjE2QD+dIZUCxcX57kH7hiuUPnKCTdaw4KN95XPeFRvMcvo5L8LexWqvaJPECzwXCs/4XPAlSMpWUzBBjK3pEnkbueMkMJQrYcnXf7PjbAoJra1VLX4YuscQLpaeYWbT+h24hCFrfcHjxxx6WTSe4AGY/KHRZCQKqTuFWt0D8RmGWmvXSdg1ptIefYPshuIVZT7CV4Ny67fvjJugy0TNYHqoCO45CB88kxrvIsih19DqjD0UqiJsTFPcGW3P/ULOG3nb8CjpgVTIoa5nO9ZYEX4uEHu8hLXrJPjV1lTQ5xTdZVagg+Wj8V0EE4yPsTc345KM6lVXqLiHtm+G6edC4GVEiPgd98g+twSYm18gCsPnjqlLcFm9e72CLJbYD+ocIZOxuVjrX6IKh9fh7WqdIZ66x9PWkDGOVVGkx7jM76Ywe16DX9ng205kg5eq+R2q2MguTJxYv/wWHliD9mOYpzZKNXYC3Wr4iBGkm54hBwkPzFhiX/VBHdVH/KJ1ZIMOHxIN6arKdxrm6EBsgwDt0mPe0MX1HRUMq8ctcmysU6xX0bzM1J07kAvq33jw1q0Pq2cyMWme8F7aVkfhzZEFdyi8fVBQav0YZqvAjZ83WKH726rBx5Bn7GHFthR6H4lFsltu+jWmsAibJ3kpWMG/QbncU7n9skIBL0MuXXtj9sJg+4Dl0XhKJ1LcrMydaIgyrgZgScP4k8YQvcsBmD26X1iYXKLzMYfZn2IfRjznsrJ1e5cnl/3a5xiNoI6n1x1U36FWckJbyx+hiSZg0QqAqeeSvzFYMlZ2REnO/a6yoQhu7PdHMYEPFIvfyGeyCU8e7rpju4DrlOhszj9rOIpNsvCkuD+TLyf5J7D/wsPkBpscFVI1q7oUSU9bN30vH5AqnO7bsf+9rGhtVjOJQ32H9hHSAzR2ape4L0Cz4WxaySm4jvuGXwkFp5NMMLrgZ8LdA+5uLuyxO5SMOmJNDBcbbLefv7z6LyxBwltnfQLd7qqpG1MmNcoLUcx73BkNF/xpdS0cKd6G646ntChXSeTZJJTFYGw39T7fqXDPKoG2cF7/ZcTvME42gXLVjTqzAER1Rt5m7GYsh0X0+XgOeW9MJqE5j/rpGzY6vUu6ACcCTzDMdZHiWELpDnvgE1hmztLcSYz0MtNyUBLqvylUJJnJu79Sku9NMHCTkgqozTnhMFfduV2NLCSYvAI5HUvQp1h/M02vKFD6eosIkGTg6mujUo1W8hy5Knf/erkBQC9LzNqPAYCgR+hczgevta88NNqSlBZryq9QNeUK7RpbvHjoNhUKAAeNYH55LeTW36KyFaXdAkBvyNP9xmRuBokPi2OhqDby6IZ61mwfzG+GmACkS+G80A4WGON5izgJWeeDK91jzusfOi0RmEsVJXwbVUr8u/J2LCQaMnHhi+wJTEPN9tS2b6W4GRGCNmtjAMgPsP357nOeD3H2tcDAPu5xQBKMHf/j4ZhXlkvvy3YmBJsjsd4pSOlfPZCnw5JvzxEXM5JIc+E2mU4CgB0mdJnH4NEsCHYNeVRDXFNuyZUE4nuvaJf1h+11AWLdAZ72D9XNRcxfb2+XHZN/SN48U7yl+sNZhg5gn/PD8wkBtnRj1zBUPIWnoMP6yGUEEzuT+VaX3x2jEIZAZsr3rs9wCfY1Ss0EdIFFzBbyruUup4EPanbSYew5tf16/ZWVup5iykttuqL4xoC/jdZWsAZeSfDSd3fP9kbyAFYXkf0Q2lmxaTkKRZrCo9XCoiUG4yP1URJ5G7+HSOhhJp0Anz0N07QZtyFUye6rcgiOFbtyoO1lkuV0iQ602MTyFK9xLqNHtNy4cJaTO6hjtiwNynVc34ZA6H7k8ai6S6eF6jIG0xJx+JfP97lzuCZr8vU5SIzImaNpiQhyvDbz23//PJcOk7hD4iIvJzfIgOGIR6ZPEJpWHZQoacbF+omeHw8aWHaNOfaIyGeG4lEryMfhtNmWh4RAIpn8dLs7ZE2eTVDwK++xDoSUgh47WDmKlZ/k6OosEUoQjk7Q+Kp7OxwgMFShAv6z4pTW8loVj2+qXLQ0T3hmIue8qHy1o/HXjm089m71t6mrrUyDftqMYtmfvQXKDlZ+K1HR/FkqPSqcjGlcPPIwbMw3wIFKBdVMJ4pFLt+oOIkWZMw8pkoYZ3byw4LmAF+7BdicGXFcb5PWtDw5XNNVc6eB9dv0rAEpgr5J+bLr010bpfGw+IkRoxDbkDFmQdEQUSElP5bViLo1ur/23KN0jEwl+rGC6AUMKxHcv+T9F1Ktpn8jSSrKxJnVkK8UD/tH5DN6nXB8mjUdFU539e9ywLtLYCwmHYVEVqnFmdubduaSd1ivIo4pTsX+mJcOAkrR1D60RIoocCBIdwJhCBM1rOE2XSlPo0U+khALvw+zfxYzwzd4roWlLJkZheFRR8QB8v4USwmAcDswUZ2P/7v7Xa51Fs7orYebYyww4YW5869Y/c6Kq2eTR9HLSjYuChTkXaDygoo8nz/yJ0KzfX8oowaNAwz8HvQdlLU9V9hjqYMURyYvPzZ60G0itmUdZwB+sY6rUkMAZZtWStbDFmnk/dQorhwr3121XQWffrK3as0g29ASwxbsZ3dZAq/96b7/XWckbjmo8+jwdE680DzoEUUivnBgowMuBQxHXoGyp+w/cSGY88rWtmwoyNNIvChs/QsZRnbdV7y8x7t2RkliJV/j8e6qfctrTsMV22zoqgQuTSNFh7U7p/Q49L0kygXNnEYXCBDgi5BeNWxu7VjULcUHI+lGj+OTCEATzWrDmaynq3wT9IAejtvh3esCu6sEu9JOsXxMDpqxm4Tzl+pt2Wa5Bq3TM5TKH4N7KLir8FGIPA569+uJ1VEL3fW8Jyigz/nEUjAVYrdCWq2MnS4hQVgcvXq9aF7Xke/k++rAtIQqckPNwjKrV2t7HCOrA1ps88Y5Rw1Zp+9itnB71j8tNiQc7mV1kUCQXkoi5fOsq1uC6hUPUL7Z69NAM6lg0c/aeiifHoi35v+pVBh7CDM1XfvYpiK5JIbIQFHafmnhHfRTnMagKcjdE7zzgtxkTPKVrObTySTT51g9bB5ro/dzn/sB24fNM2LGJuRQsmC49PLi1jTRfZaLpo8Txxxczij5Pl2vur+S1wQW3W5qyVcIUySZHtFDQHv+EYDoZG1T1J7D91vEIV8dHzUBzW1UyuxRbP+M/CM/vsas6RzmS5traXnQ0Jzv9hYXxKHcs15TQCP744XsLjzFjILYURXFnhM+nnV0iO6nwls9TR4tlz1J9/NvE8FGg5mgpZA4htS05AK0NnU2gxuqf2vjCyWlm3ypKvaX4vxh8Um1MHGB2NTeAFhbDyGm+5w2zqJAWxVlj6dVePb5yR+aMhuz05YubCQJ0BOtoYQ6PoDoW5fCwCtXj5SHvCgL/3B5z2mcXWaRTf8/GsFAfX/ntdWZWFc2xg8MJeenwZ4dZUToce43If4zVb1ex3BMAWGhgkPwR5EgktZhW3Yi+nsnZTUr9FYI160YhAraB0zMV+ouHz6hYm25/ETDM0MTmcypoGgZISSkfwYAQaHGY45yZ91K4A4Mm4fnbMk8GTc4orypT3NLBqAxYdcY/qCH82PpIkmVOEHi1NoYaUymuImLLcib5pmd2MHTB3JR+4rLdRc3gtQ9zeFdciciRiWviu3HkqaLSxJeI2rgc7OKQslItumACQow89elXmi4P3gTZeCauvMH5nF4VrBcLjjwGD+KlKqe/RWIEgT2wGqAgSuL6b+RTTPnQZzxZ5y5HQJkEEKJp5NfoB8hJBM8qn6xbOFtyzBjVBrwSS1zCJR3lEc9ODQ5Wu/xct9/2Q6qLHnmNx6XwZus/i8rEd6UsVxGtoDrm+Br0L5oUojlwdcqyVV4PIMsR60JhZwJtgX7izQWj+GOeF9DA8Wexdmv6DWjgR8LEBp9YuPAM8tJDu3uCumNqHnF2ATYX/tuVO55OgQuiUhmDmJbF9jJyifBRtxOVI9DCNLUY71IXZYTuiYcnILQ/XHuVJ8aHDStL0N+3eYNvXwHi2vEiTPnBqzsC4TsPnFVnYY042j5i7C11AVdBZ1pGSa52jM9dIL119rry0mgGxFzI8xPs+7bmMfYKh37A4HtA081olG1m9S4Zch2hoNCGVvVhd6UL7C2d5hKIBHoB+Uxarq/4aQXhh7IWjSj+ca7Vhqb4+ZwY3nHXh2S9JH4XZxQojbe/eINxYlozTYtT2rpU/xbj+W2hXjFQ+z+dQ8wh9751MP0UpjutQdxz3/FJYAEG5BF400JXWCBs7KrCRf/l+F+d9EuwVk6thOPDB+HNS9iWlLmDgXvY6K0vgiyoeA3An+jWufdAG1suUMBuJT+/w0FNJZbObUT8c5q5WtQxASQF6E+/u8UwVBs1eo8jTamCrcdhZJlADJbqn3crcDHQlBQNGq7btcGKiJXW6q0cn3F0xzf+k1JJS2testB3rx15ZPTDXm8QV5XE2qxBOdM2n6t5YbxyNOmEdsHx+hMp+y9pWkcgw1NikeXuafJvzcjaNwE1Ad6gG79S68aO7jWpKgBETYLmV4ONHhBk7Be8tjf2WVvWMDQvQdOnk448yeMv1tQKU1xev0L171e/qxkMZbmkfKnd29XRCK2hgNNJhwt1qiYWZGKz7Di6K3fGDT7DO2YQ7WU33svE/WKGbWQEvzUV2w+VNYDocI4yxQ6i3i4zU2TjmjCwu5Pk+Ja9HSwLpEoUswq3tFJ1jimthgMXd7KjSl6Qd0K+vxWT8G4/+xITHsWDGSfQTSdFQth5uVVfa8wrkDZHTGVgpJys2ik+3I0dSf6TNo6A/sVptyY/kx1hdAWKPI6t/xj6s+fPMU3hg1vkEB0RRHq/tCy3KUUhzU/d0JKxTyjvUms5iy1GbOFco0NA4t83SK9sBmtLWm4kOLLflyxqgQYP08iyXwYXzKnlQ6VTipuaspSJ9g5H5Lu3eLMnPKbhcwuEg0VZ80ppJWjUnhS3rL35erzysp+fJhxsUs86m28/UwW+IgrS5Y0zWaxlFJ8xML5wk8sg1ragF+eNajyI0Y4mwStxt1RZH2BjaAhvu+SnNNIK88thEgZEsoHv+ii+OMmXJL7dnAiINVDz3tCnqDgpQX9OguNGgZj3axcjq1UgxDw785yNIpqNiLgv57399jVmJ0/RStNswaFIs6FtnkilFZldxj6m562jL4p5g3Y9XCiXRJX6nq2PGJFifFR7EyPG4jDMnBM4t+O8ZpEp3th7TCxEw+ZG4afHl4sNFaqxyLh6+979tt0Aq9BrqI+CS2U7HJoKiGmyVU1lFa3/0O5mNC1bzRgNMy+GXyifLwJP7FwUSUmxmVRpn+gnXWoIuswPutsiciurvN6lsMG7yqEc2Y5ZI3jrPgPq0xEKPZpF7teJa0TQn8BQL4Th+hjv2ByfwKookyXEmj0d1KMcsmfKaeKK3cZZubiYqmSCrnGpYTwgPk5itKucVtjViuswQsDR6TuyGSIHYvlz7wkLg1Rr0K9kV1o8RgABlhbLrN74cVWJW6TnfXN0q12JFMpUbEa8t1+j440FA+17o8qa8PQ9igkctVROVIfB3jU5vtGm5pYYHYSDvU2TEc15pIz19ka1q6c/7WXfF8+POkApdOw7nn7Kqz6V4tru7NXgnA/u0g6+fPRT3hp/QrDQwMsjwNCZxdWrR6pgCBDJNc7/KAlwC0UZ4yWQs0KsuwbbOgcTxQPK54wiXr7s+221hzZ8RVxfoRUKM3e4lpxHC83JllxlrV760tl06f7/65qhE1jhMfivAUXIXfRMe3uY/G2TpWYzDrw5Cm5cS062Bx9lhHq9gtJp8xZwAtSdSuW/Kd7+orEAiswA76N8ezmVGYgNaYlQ/xk930LAWAtKVBC4U6R08L45IohB1kFia7XJs0TcaT2zBZoLFuOGu4iJaoAnfjL3uS6gnRH7G7A+aT6ETlmkYUfgrBuaSLLDJfhPJe01PfN0oqBTeQURasl3N8BZiQSgdr0aDv3hPTiog4NSyfAUyy98WP7dnTDWQTY+Qwzgk1uxwRqHl5MpC/84Cuw1TXfRlgJrwPop10kCHjmffnFdxCe2J3R3J5j+3H/sZn3IUu3Suy+I+dAOMWvzwExNR3RRPVelZAhtarKlXPWNjPRIVP4JsAFSRXs3o/fSYAPaV/zP8q6DltH47/rYhCLdy/LrpOsbaLf09eACcClJosNefetNElkSFSuCgeY7oTAAl+8Y2zOXJb/bgEDpoDXfQqc6lnlBr/WsmVznkBS1M7ufiqpxvKXjwvR4WxLbh5NbMNy8LsnX4UiuAi8XonbSUcVZKQOWBYUecSOMj6jMG8gHu7WNreBHY90lV7FocDprSrSbexkAtMW9KlXcnrOyLnZdodGYdxz8aw71HztIqLhRdCOB6NyzHPoS2hDy6wLk0I5Jr2t+U0A+A7EsgSn/Ih03A5CspHnVF4MOic+Lck3m61Um+GHDEe4DrHBhmgtDlRQl1XJ/V/VumCHtUDDcZCkgjVMBOmVOGYW0Rcdi1ahdjhBcFlfjA+5cRjBop1aNDvdrf7CxkLVgxiCxhRctW8wczM8+kVmIrGtkaHGlr8y2D098HXE23r7fnJFUU68zyeyM265igNOGPzFG0dIgUDWN6S3ZcfMERJdWVvpGhVEHXNLeWqHiTcF3wOt0FbJY4XHEpmkoG9MQPJJ4ueQ01+MB+SR0rCSGzlE8zod19q75LlLWgzogpnJoD4gPxUYcX+Gpc5Ly4nk+Zm8LDXcNR7SNVxLh6NAcx8ekjb/AC7ADlRnfuHaHJaBodZr7RBX9FLTvocY6kY8bavdAkQicE9bbwGLkZu6whTCJ56lOvM39ijehpTOFqR3V53nQx4hfOvwRPU2y2w7UU8yiRbcyaX6jGJ9CRvl9ybV1tebTp5MMuMnwLcx/lven0w9T0atJuiUE2WtYGiVMaP3EchABl5AsyaCpu/BKAWDFvU2vaCL2/fJBKCKLjxG6xzT4Mh4wHhH3/EqsGSoQAHu2wbHmXHj2LvoW19GXDa2oyeKRwGG1PU+S7mE/S+UmjHiDF1oqJ0R5QsdjAZYN1MzpNX5YDqWYfhfdjAXyFQaVyGKkp1oEGTR8MK6jaGfRDFd41u2Ex8ac8jKPYu3pXsk8gu+m9tr1RVzTTuDsACW4S1h32yFHX7qpXSmA0QVEcR8W9j2Juu0pcYqTmdis88VgT3gq7iYue5Hx/3K6hFQa9rZrNSDcjaSQlNn4LSqs20bypnKqpzvnnxjMdz5StbzvoAJKgVZa4DLCVoJW765/KyTF4s4YztmAT1c0pTmKJHTpa106FegDo8p2zD6uOnwpYi0vJlRMDe9wPT6964UfAf6lq3qWypUOx9q6BbKEYt7K3gWMXDNN6wAm1fNnSOnZ4JkbPq7jLQrl0wL1V7QwO/sXneKGfTgUL28I5iPVG9dA2gS7Ki005JUR7Vmw4gX4TJvy1WS74cIXD08LCF5obqcZwamuoZ+FPMJEck0TLHjyH1baPr55/Cy0ptDfRJ7d89pbP48tLMHG5dO11Z8xSSpPGQSgXDWmpsNsmm+MvxJjMCi7OFDHxxpmTtjgnOCq+c7Fi1DybfhAntviKccz+sj+OPKPYOKeYYPLvq6MpUx/chSvBccg9dfbeqetQNCs3eiCFZTU1mrDido/mib64STMgsa+IKLk9PyxGGbVSQB9GsHto6f5prAFIbRDSItDedz3t5+Nn69FFS0nEfmkF7hKBmNVce5xv65USKGBoHYxJyutSGnRIq7vMDsAMvirOEJOzNi5Kt7fypuSU2c2Npo6UH5jMOkePH0TwgpammO3Fb2FX6f11309z/mqRmQ949HHRj/wMzKNx95M9pwKf+UQkMEwisL3YVotvHhCv4y00Ui0Ql8dR7tGqFcSdYtmoAOuAodkBNs4PZSjAAF7S/szwLddFMdCyB/dWPgFUiUE+WmUUCjYrKfJLQfNNpQ4NKaF57w7Kp/isZVwQPUJyjJavN3fQNKU+F74jVBJYQEcEdw0Niinyea0l9PJ1/AcTm/LI91RZjDvLI81pnat7RKU2P4/TnIAa3hIEfeg4iGQ+wTDlURK6YjNpN5s5VkQW9w7sDYKU4XmjyZsCQLxztqd4SDQvLyuPDhURAJXKfR1c7tq3mRu4usFHPqz7HgS0X7kNxiWWR3fb3uVwbgKpmgLYkwKrXKt09COw4MjhxeZlDXKy7nNLHXAIKPtferWQnZLboonQXK81x+BB3oUidBehK1swSXxVbscj/LsfONu/xYEXYPM3aMqIYd+2hAnFvDHbdrJLhGEd3sG5PyxqhzejhQJo9wauFK3xmPYqxB99J8zYU9/yzrEZNzzbvPoR9vUlE3Ha4zspVDzHHffPZMJ1VLZkKqGCf8ZqupqMt6T+NRPfmPm2xeDgvzMrRJEL4/zzlu7Z35smvzbgeC25VP2CUrZkRxEi15A0769ojdO1d7C9OG+swj1ROMM3NgKdeBADoRMeJkRZcZ1FbQu6C0BS9NNSaoxtFzYT4lX7+PQ7BKa84yrN+ujVVef+SgnEie1G0N+eOtbZF/UU+wkeerWjloYqFiqo0vBnmxh+TwNMo9I/8lfU2XTCT0K4OoWE08ipyNHjxHvfhY6qa3x4HzdQ8+jkiO5+j91YkihS5memfpFREHP/2veN5XcRue2zCVuAub8V6vDlOvyP+PBm+owyRhMmng5wwGGIXsOkQekXrXpE/6dFjkHwwoFoj5bIFiqp+4wHpSWRbv2xGrRpd2c87FzMP6Hfj/3LWIBqFiNOAxBw+AAP1XqUBszdZhzOSQrQS4Ein4fyV7MaGsB0VsMF4bPb4lx/foTGQRJv45LpoxDd84xCawHaX7jpXUrOdkFxx2oUvY2xqpgIvcVufwd+zAnaaVTnEyDXD7S/o/xrrk4mgTjXhcjj5Rzrbr23NmuZQvpdNzny5MCR9bwvIRIqzOZZLsstZSCDYa56JTvzxgBs20dYTtTUbe21uljlWqGfSh2bYAzOpf6UguK30ZxNXgLHs6Y6urtxFA5iLYvlue5mDONW0MOtQjhqr8fRbCkYneiDkvzHkQVT4F9v9vxh2SIGPBH8bZb8ugo/BSgXojeSdNXbBAIDsB6DUNSXnwlu/bFLaCqSbvu4+YLplwO1JbtrMf9ZUfsxerAZjB7E/zl3qwgK27FswemUmSM4i37YAVhQSocuV8AcDI/CSeCDNPavESshDQ8A/lVIrAJAMdP/rHXouiNU8RL/TIvfQiuZEb6dkIKMGGOW5kT8vO8pivWnT4v7qmwuJo52AS1r/RyQ2g/7c9ZJgmMIzf0GvJJRfMNu1utRNuLWHOm9JIMcJK3qiDtVpGCDP45W1oTTMUnMC91kYhP0GHjhCW8V38xhjHgFFBfuWMsmSQ9MvNqKXiqtUhDAkIy0PW7YSKaKUv6zctAiIk+Jt17kG6LpNVOeMvJnlVBaJSkKe0HTJJUMvf8R2zna35/yh2wNlWLzIP3BJR5aRNxkV94ICOlycI1/JYRZtzvWMNoIpQrdNvyBuBydhSwhRwPo079Xk/XQZpbhzN/KK4NbdJQV0JIMP+Y5UBIM3TTYlFGYVjcvA5yVozkimco91Fx/eo+ydgAx1gMezTh+bYxCtXPYkMoPdtaElRusxlmdSV9zgF4Np+iylun3LVxCycAFxGCFsmARf6y4I6zXY0tx81aQyalr3/ih+ZjxGNWdhItgNLdEZ/BOIJpPoAveh2bKbEFxU/M0+4xqDo3Ox8MnNn8Lmv15NJigSvJV+y2W/ZogEXNiv0/nuFzZGr0pKujOShzcdkEVlMw8mNZXZCbtM9V+mfawtLxCTvo+enFWhJcFv8LVTFycDjPGBXRQKNN+z68HJtYdpH++g5WdhQpCO+DE7Qdu6TmZgtetrpU2ZlgpslOx+4hb3aXaqbdc92LCh51er8vm1GQ9uWD9+fAPRV50ixhgc5zi2Jsg1xQVxzlaELRWJ5biyF+eCwNV0oFnTbBHr3Glm9qlGVOpoOsQC8hlNG88fxeAekkCGnHFn6i5WzyO7ShDYbZ2KM4eqndyy01v+6TFhmkxgc0dndt7EzRCcEfBxSaWZwcev6MDZcuvSZQ9CNSd4Tx25TY6UAbrhikuP1vNFfPdZhCG1pe6vx4D6Ez3zIb0zDa42FPpxWvIpEeXb7YTcfZOahSpSYaWLH/vq0F3U1KO7ZxliZpoMBBYJs91IE0bOkrPNQ/USYY0qKCO3CU+AFbOYxzKWBkIglrX34377BZ18MKQCv1KWfIHEeguSpvrNH5RQOD4LeiH2gdx1MOAKphlL41F4RpxaU4dy8xERFgqoyICQq9XmQ8WJSokwqvhQM0fLtsvyCO2PAkJ3BZg5IqoR5q/GdTLgOWPFR53Nqw9Ma5vBzZcQ4+iZgetmKg5ZIn+/7Jbi+VlViXuD9CaAUtdEmnwWTS7wZWuskVvc/SDaaKV+Jz6HrZTHo3UrAu0IZDBkXWmL+mTTjdTb1A+MdhKkY/hvFNwXj1FzUngsN58u/kTdJ3Xi0hy7efR6faAOi4SKGaiOty8lxDFkiD9wq2GW1EZEsoWGw/WzxXhWDzYY8CC7WuLFHc+x19jhH+FiLXwDIARRtnkJPF2BUPZ9+grZ3tjqAWhhN3h74w5pooRQUNATy05A9HDLnILGSCtfESoSilqtqAIQ/TV2t3KhOc+teDf5t+DqZDdB8Ob9YXyklrSO73pR0QAxPvQj57c6FIR5dOciqeHZ2LRABMROo8Jk8V6JFewCL8TCd/A5MSbXLky1cW7mXobqgeEXdFDoEydKo5oCuyn+2JYI/7pIGFAzErlHZ5hOaiT17HC3zp2HpJwsIAb4/oIoZ8x8ak43Yp83Ermq55Dg8HxKGHXbXs47sh0PzQELTGFsf5eO3lYAuJjMneoYWk8W/3tW2WLntEKBZEW4hOFgo8K58Rj0vk5KLyezu1d8SO/JcuxpOJqFUM2sxBmbQ/9qqwb90R0WulpR/Ju84bQ5/fTh7po/pbBb7AQaYNdK3fatD3K4TLHAaa66MQzp/+ZGyCjzo5OXRzJ8UHyg/YpNHvvlOpwQIOjakpLHwGV4WsLDPjEIqG23ily3LL0dlkYQxj3Xx0ApCo35zYGoGOtIclYS83MnI5TwVdQ+Hg453WFQN694DaqhGaL/dm0KncXYqXLi5polgT4DOrzD4oSVhrkh8GW2PaXjOFDCLPcn4RQj8dRGIJuV81LxMPZ0UL6zpkaebhbFBxcRJe38UiTbUPDjFWk2jBqzrBvXcKmgdDcmRyJhIpuq+3DQY464AlY42z2EM0yIK0I6b+VgpanMfpdWo7OxKY8RM5tSJv340/qD8SxrYsybMuUkF8fHj7HcvxEPC5YYrH4LW1YKg6QaeFZLvPbrHZHvi4OXLKkN8cGQO8019OKqcv6QnBlj01e7qS5evoGm53rv+VmDxxCXDiOrDg+IaPeMPrn8TJ1oReXYI3yb+4HQbikxP5TQXHk4YXPUv95+KmkxGsRgTwP71YiMpqNXp0loHZeXRp9i3euKrVtxMM0e6XAoACwNtcc6sOuhZVb1htBLudzahrDFt5GkdlwHjZl5y0LbvSHwII+qYeDwRKTTzyXaInHIM+8rc5TrjUlPRVwB5LKFpQnV8e7vLv7T7V/iJTW9h9TnRtNCSGcofBWYm5P7wZcAq3AFamEW/GMbo27ldz0plt5HI53ddWkn9IuCZY+Iy0MATUh3YenRTbVgdLYtu893SuN6EL4e9V4NhlzUjI8nOS6B99ecyC1Ot8sDahQpWHbmt2YvWGyL3S9tEVLKYs+LnghBmmSl2uPWfqPobPwBHNLW21LUjfZb7jfLMTsMp3icGO1npK/rCsUgdBVKVg0Ys+/WKuTmVJoC8Oe5h3PK1TQhbpZ2ytP9nlutQPtLAEt+CVT90DfVkn7lHLOX8AfS6HLzfHeAhu1alnl19RHKV1LI0G7RPzYgVaSpX7th9f06uo2WpxjL86i/2uzK2qj/ClHbGDyQr3F9/axmq4kJ7zZFVXVVwfiFr5bhUGVZeQJHKFAcsnqPKsb8vHyB9SpFpT9U1U7D4aS9vYgqajxhC+hOkolJV2dKAxysCkWBo3SPiPUrSQYZxOWwWCoQzbV0oeaDEcgUtqI3nq9TSmpQ688/+wb26P2CHLY1H7q5lypXSrnwnnztq/jN1o9lyvLmLyGguV0VJnDCREkiUNrZqGG06MsyA+Phd9CuFoM5M1Pyk7S6TJaHdTw0ni3n5ysAup0kyxr65lFc81NcH8xSmpp+iOEtQZrH/y01k1rGMRJAGFhi+nDecpUlnrh+qBOCMZCcSCovOPJrxjZnZJDMLdpMVu+tBSVS1nKxsYjY9Dtq1/++riVfLUVhzofIcIgQQPOqHioELxU3EpCcZMoL9laa5YlOZAMEp5apx7CphrkL+fyKbBAf8ctwVd93FTo7F5Oc/alNsCgK6lHruPROtN2RybiLqx8P5LTUZXU+Aoyz08zYHasR3U8hPDKj+6arWXR9yWdJoMn45prCSURKKy3+JHgvs2Ot6v6GbEtdCumgCttv2VNoU3KOqUwqNIWHqYm4eMijTM9VWB7umEyp7UPOI8fduHJY0W9xSCZdvc2xMjo3Zdu2o/WZKDMOSh9UmLvo45IBppD2dG++HJu8kbfFdlwuIxk2KHhgHQeNKcHhFkYGRzL2VJVMOAb0Co64wvds5CaYl9ZmBm4zuGDeaO2eI1XM4+rD/HmZyRF62SabgAe8TF43VuMutigJJMfbW2UK0azGLFbOfujnHD+GGBYmSmOQbUCOY99HYvswBQA6r9hrc2jtsUUxLVjxnZ4JnIrTwIVdWCTPtpJpvlA7m01/4tbUMyz9mv1jdN1jkiHQCJXXKg8bJ+aqW6rbwbn5yDSHBTcFXIegrhHGAjJOZI1pyP83Z3vMYTAJoo8V9IwyS+U6OVg78+IhSYHDYjRs8FrF8smHQ9h4qAYxp49rRP2d5uxLAuP72GvZaYvfeLOkMrcg0PkPuq7NsXhMFmiZa6PKBH1l+oKHI5DBLdZCvCwTPdXqmnz8gLzVRb/ixLTSdit2nrzt0x+5rDeZT+ac31NKNskQs6noKlQccyD3UxzfVZFmcbpmrfPsZD0Ve34xpKWk/E9Khn4A5yVPVq+dwnv0EyYecPqXGU7R8suTW0A6NJWweLI3iSGDlQXzMYsSWkSMhFTfyA2vTDt/3wXk+mVU6bRNkZvNnyVHYiA4tmnNwdh/RVsk/EgSerfTIf5VBmuAc2IKSeL5Nbrg3acgFj80mI8SWsc3dNAGCBLLMP89gH5UnLTKq78d9SxQH/g7DVnBh/qnBdw5CDrw/uMzcdXSxWqGIFcnQZt/1aOHxUg88MN2w+FPx/V75gy2wzEVe6G51PQIR2tZsxbv62HhgjwtlzrVREw/yzlaAiuXC26cnpvQzWXp2mOgihyPCWqq38nEadX2T7f1Y5zGxEGBaT//IcL/BsquAJX5EDbX8X1p8nLWR2yyjFRvqC/jssoCJBCDJOsZvoBfXqQSEKhNARH1YfueeKBslAwLi24/wAO1BHptlf1kQFNsOPlDvlYednrEp3a4SAz/G7LIVEsZBu0EKWZu/euB/XKdkGonP6t6lgEcCOw8mceuzvEVzyoPnMyzrqoNQXJb9C8ZCXSiedKiCgNwfNkpVlHbUgE2Rb9WFScOeEad+T+jT8XlSc8rcvkIuhAv/gxRu2eb2GonLTyokjcGF1EBpCJbhy2H3lhL0rdZIw1okA5pBg2oRfQceXTPzhuNKorTEF7t1UIgDqIo7/loxyTgbtKu29o9K9KujvCqUGyPY7upcfiZLNBVKh5uXAAZjQjhlhBp0ukmO4Avxu4xAVhCtnsOIA/tAm94U3HEuSr3wq+ZLo8pyoC9EB/q3pOzQRyCTkozmJwo1Ln/2xEbtNnS2S0NUIS3yz3/mBIdxONHxqP9FW+uoGI1F415lI1nZwK0SoPA0+flaokBGEoXgZnO4GOExU7VOjdPns59ekmDxqNhEHeAF5i5N/3W2NC1XGFjTpqLrnCECiwVkOTrLtp2ehUIaejOG6+1336YQSKMSsL4zhUjw6SQKryVRz5Ldn3R5/r8AOi02RJkQXPdvPsl/FMg96E/cJmIFLmEDzr1Gkh9G3zisG4pqM/MV6XIz+CtDUh6hmJB97VzN8jaPSS90vgDjvnaNlKky2/zIhE9ObugwrftI+Oi2a4VVaB/Mwn3VmaWjsU9NOf2usbcN/GLQMjvfeU/YvyEERPKw1leXZWWk1HXzY3P9MUq6MZq1hkEgFzds51mv8mnp1i4pQprPwY0TId1szXwe5TG+R5mMD76nGPQr7/EhQWksjsgGs7Zy5QYvMcGV5tcXJR+6hlHFIAc/M6XjkKYtwm673Bi+K1tNO9i1YBePTur4I+gMsOK7f7980mcJXhgdWdhNzUN2JvFsvXq3zZRG2V30sJtJYxj0aUv1u4/ppVHi1iHnTY3gDHsrQS8YwMX5XwZ2gcFYYe2wd7ZO9swr0gb8zf/fXx8QWKPXcK1UdJk3760B/TMlpWLCbhkqVoSTsOqzgkmFmFteCCTGhNyvFhw1RrTIWzRxq8Tj5FirvKvtkp2GAVhnZ7vnr71pyI0rKwQbVxKZuqM7GAvn2mRBj5p8djlHUsh/r/eBECptpbbjP5nFyuN4mvQLZCaxeTkDUzd/kNGLIzBFv1CElQO+xmf7Dzt1f7GM1Bh+wLDCJZlhcVDXbtPuGssdEie3lZNiWcXMTjZtWAT5MCmpq6JCRuFSHZYGKcSFZ9kOYJfEqLIcWdzpTA+Hmu+ktgSUwXVSwkaa/aHdZXh7IOyrudCBalCZpgXGRNbhN2XpEY60DXXO1Ci5ayZSoxtG0WRCC50+XtgWz7qgX5MRA5S+jzXCYy7O7Nn0ljVxiBxQNCZKZMTqi6mPfy2LZx76uyRUXHjnpJJEimflHDUxyX7fFg7iJvSrsZMH6Uv2xbfQNx5eCbx3oKycUrBY22KPmgfg/w07CDVsw6tb5VxPg5/X38cQtXI47U7MAGGjO28II12T+PjaXHlstPtkUQNn0DKkCYis+kVAkA1wyAJgYKLGnKD3nlVCarYqCkNIZbiVwO2Ydjl7N6iOtvvbAfuq7VKZLo0jEdw1YdsRaHcuJQulgb51JyELzYBkP1hd03IDcZfPg5XmNvYQSOINsCSn3BuLtkCPZRalK7+S97zxvJHiJCZJM9XP785NZ8B8fqDe/Ot0BS3PH1ptErwxBtpgfOj4d/41nrSjJQf9bV1kfdBHJxYbHILxOsWkZvoP/Z4Sl0Yx3bDjTF96xf96+6uIoQ351Ce6DeTwTnkPr20YwATlnhskWIddUohklNITCq/07zkiEc3B58uiBG6d9YAc4h/7s44FN2RG1UuZWeojrOZIhElvDP4KqHcOYbqqS95o7ilQH5ONJfy+aYiB+sPpn35HfHG3duLpNvBjXc+Klf4IKrFHjeVty02xPTNnbdL4gtkqPqMLhSgR/fDXzxJbSScqewiF1wdVoJ/fGL/nGWZfVlDHOQKD+/i/mqwXqvNqxtZeRHwoe/bodk66B9soOnZp36gdzVMRRQsQiBFf+HXjRcrRf9FsGghw3+qoN0JeeMvDJrkSBPsESDai/uVOzn2Ohge+UVdi050fdWpsjP0D/QuTdYs6QyI9xnhU8WT2+KBKzoZ7Bq8fOdKPeLulUhJjT34/EOnUloqus8+pzqNh/UdUOhgTlrbkuTfsaIYDm87u/GNIl3N53uaU8bgaBjpz0jdu1f59K4KFDtwUUeEUoeYx6DEkWKHdi7dtHhQF44lbysk7PqERrsuAQu2D5tDMl7kFoGdI8r/s8rMytJzYBU40wqeFvTl0ZVLdOB6Ya9E/f8VPbGx5MdpYqYMLMyB0QxVdnoJ+tgAQVWfH+jtOHD3PsjuT8dOTSrupuvHWRHQoGI1Qj1Hc6k+Mg84FAZ/gzl3SEzuGWZKFwuo2D3EiG95D2Z1szTqAuFRmT1nEh20tkC4ysmXx6JtN0taK1iRR62s2uNW5rSAvMEJ8yotr3UhJe22brlQn8Gvcq1I0aODaHJucQKVe6SXyfcDWODMw8xf+2C7Zx5a4Qlh7pJs550DictL4OxcDXKvVmLgVWRwb3moxv4kcxzm89EERJXCl7X/BziBkGQWOHPGF+6K5NFJYOFVv4+NyFq+OPMaSWZKoydplufY+CYyL63T8MCMmwqLTmAE8h0prhi174wnx7DHZWYuRJSYZ63uz97AGOzyI3aebclnud77znbZetbWUripe+AadLQeZPtWsF+FNiaXCy/98km137lWewyc7Gamai1Hd3Ls+KMMVh0R3NKTQ08TIClDfMKwUGKy/7YZlJHU3uW60X0r74Afh02v5MJgVOYkjmors6GAaDU7yKHydfkXYd6nEjYc76xws1LDLWCNNKBtUHNyLseOyNDgmHiJ41lXvq638RzDGis8WIniOb/pbTs+HsQVGPi6mxG+CU+oflMR6/qx3pVP+GPgqa0U0lo8MVmI1cBgSnPGgrh+J+m9TVg8nivua0EQP7xai44ruC5gsAVOp9bLsDXfHQujo6IpBmpfbbU8PDavZpTuJtmflVQuOImnRQ5kKoQz2NBFjdiHH3cF9QLgDP5vz/W5trCy22Uk+TCjXjdbCCHB3rJhKYTwiyQUf8xu6yTKtIwrbw4tzFgXDODmWYEnnpDupk3b4AP3qz4AZ2En5wi6aZV287AgCF4vH8TlWLni1E5Hd93vLxSYLBWSuj3eXGFtWyWpBkIeKu+YsBh19VeakA8OePM0ILu6dYYl9DNIK3kU1ybH+A5xYhFI/EqSX3vtNs6V5eQgxYLvu0hYFjiG+n8JzqLQVROiVa8XNQDYJtDAetPFSuEtGI3B8rnbbrNo9TJn/z3lRYq0ecBIe7a03vLESwhKOm1bGTk2kPMv/Sh9wyCOmIore7JhSFT9HIjonBfi+gcdDLfFt7dpShJmW1gkcXmitWwm1cC480CraHm/or2MHphB9Q1bmt/SBXFqXJdcv5GTt3IS2fRgqThhInCjRkh7Dk1iS2vMBLSGtRPppb4FEu762JehUMQxxLQre365CKoJGvJwVde91XQ+bDp5ZsMu/QHmLgITmwGXSpQFQlQBajqquxlwIOe2cyfezaSHIoRNLcwjW+epnmAtmmWA9KU29v/cA2iuWbj9ZV7HR4anhHkjbxnzKPHnIZ7Mm5wAf2o/3xUhnfH++quS20TdhalHgNhusidPKWyKWV8ZjFLgb1fX2r7ifLyUtxuKHHIfCWXQJ/DKeU61vxmPT34MTi2Q9r7/sK1CYuHVqMBsgtfenn31bUzCoyPN89KiO5wHveqnk3uyHnJSUBVTQQ3NyRPmeRKTQvWEBZ4QWcSgMyZF0RQgvUXRcp6KflF056fwahSioP622TdcTVYi4cAwSZLWDvfjoKFLMowPQpzn6ogXHc93fFA5NZmnwslSuesOyNI1EE3RM8kzat6thkmpOiGmm69Yn8yNuxz1YuuPWekoybkee106T9WTPXo44ea9E5QH2Ig6FZn716DBa2FyXHG1B+YfnmhbEpANlOi61BoGO4+G3WMJDokJXj9GhNsFqdaLjA1pkhLP+/mGCZoYsxNI+A+sMvWyoj+PMWeR8koRz+r9pNVEWT70WhiAkNTrojdr0sBLwxIM7D4zT+cVy96ZE+ABi9CqkM9VK7iOfkJVp7AqCqQ9EZ9emn8rB8zfoQZUBrVd6YS2AqiTFt0nJ8HfPGmnBWf3Xi5CgyWoLAmHJp/AfTdHB0+Ns5DlhL6UJ+O/6xys+CWVKtL9S8fVHkpwZZMJn6jVtiUTtXjywmiVXw9a6f/G7Qd4tZtcoS3aytxXYA9aGGmEeBobjiammhUaMDicH3nlOkDvvz19NqWOvHC2SMv7OQHtDIykYerPuoLz6SQNOBtw6oX2Sj3ZLITBDcWNx9CuZYYVaE+vleXnATrwn+PnuQ34jL52tp85aIOk684SUlQ8uyO2t+eIOHndZ3oxD+BcMAba/JVxRYUAUZoEw3D80WWOz0/ul+fYbhFnffx3PgOy2LLiu82D5FMSpi+Pd4EkIFTgfv7p/0vnX1wp0VpNzyXs/5S/4z0RFS21vIF67k1ERTfFuhLM/8fdbKognohMqTNF/+oqvXXLuJB7IHeDdn1X2eParLBEpz8y9CAN2g5VdE7EimekAOhkw+tTzqeEsgyQL4iVDnWrP/RcBd6CDm16/5t+I1SAxCn9wo8knzmpg8DYP8V/vHw8Stu7cliAt+G/VR4XPNZXWF2rZBeQO75os2jFJrbtkfhN9BzHT4HGgXTjyTy8NGsiQdeOw12GjYKCyxP+34kRHZqYsn0pFvVubB0+/emKRgiGXNRWQwMSvAB1xvTprD0Zyt08BjP/4W9HGNfNBcA0Qb9qF5hdQ4dDqpKAFLoIW2gFEVKOganw3M9/4WP9ckP0/g6kaJDRurtxNgT+PjvWYEWlFa80wKYCkd/0ZChV94njjGyg0t98Pz3AL2AFAhvRRiJwdfRcQqqhWkv/o6X45d5w1YLJOye3v7rgta7Ya0jAl/an42ng5Wz4S5we7n2+1W94JnpoGyV8WW2HYjKLkKmp4hBKlNtb5y4W1MrsG/wfq2N5Xrz2kqhdPQL/YoxgCQd6Y2KNkADVu7TxugQRWVuNL0BUj3JRFyWNeCmB74Wsz54OPnbq0GFFxzSkoiJ3Rtq8yEJMKvOMMalFKH7YFHKjb2nwrKVfuUUuRtTfJDiBuaEHHoX+MUrM2bBaAsSdnY5PjqcMBn/wwojQxzt2MoOCC3OEArr09ghhsj2M0mue5ntQcmcC1R/sK3zfShGJuazS+mJUeKxk5u36CYj8+SJCq8ZEv7bNf1+BywGeDQoTDGq6Yh1xW3Suwo2O/ykazTPK/TdVOICyiwK8MuQpK+FX3mqSPzxfLwFJ/iYDjs0WgW2kqXYgm+gkNToB5+jYH83Xlt0cbtEmkkBaVGlHz61rVuWzrK1yjn5nYHKvKCrBPPRth3AKDQQB83fdrbgIeIfB3iHya5NPpEyxbzmtN5Dnk7GqrQ4uu4h3QSoHU+74zs31cWqIx4SZ2bwWLvIxUtR6gufZhNZoMcmSB5z1O9TKvHMORD+VmuiqzsyJKA1OaApB+b9x6u9FTvUkalgl0r7raV+wRqimc2D7B1z/OiSagdd5UME2igLGUcgPlMSX1VsKQp/9yDiYei87KTBA2NPCUmgaLwVdvQFFFxWp2vGCY/KCUvxt3FOu6xIgwS4Vybvbj6feUCkrQPpO/wPHJPhAobSj/aa5YrUvjHMcQkDZwfc9mvghrk/PIPvcJa5InhVBfjh3Xr9vIvA4ac+m+pywS/EqkSX55xgiyj0TB1EE0NT3W2CPFdVD88P72SpdFzHS/6XsmbGtM8JE/m8eojzd4PM1bNADliZ+XG/9hbcKg6PftVKyKKt/8Bz4lGsHyT0VKj2vDGp/qDGBajSHrqzmpEjW5LXsb5kTV6HgbMcnPW2dzQju9N1sI/gPVlgGmk0bHKOX2Ws1q4aPizhcM/XiJ5EZNUK6bZNUeFaUJVTvGxglRUY7vdnoVOe0Raho3huh1XDeTlHpk/2gBjjhUQXe8FN5A4zcRqkNtKpSVq0xyw9j3yQlQxq/Lnqklpz8lXmzHkz8sX9HJjHwyn8UAjblvN0ZFIk4liejx0lVACoKvpsT9+pQoLY4weMHRzcuVC60DUFkaqLfclS4UJti5WK4FE3dYcc0OilX50uscLJomlR6pXriD6ELNNBWOSMt50CJjPkyt3Zn/xj1dlPVP1t6XExK+b3jMoULLPOrEGvjELfAMM1qcuBb0AijkIuFca8f8xapUlkvLjmmJW7RK94r8HaPzvmHHSqX9MXdivNI4A+JHy0VCe79UZZJvzMGzpnsj+Q6k3EItDBiA12fTMlSbEOMAWCdQq9TtyUiAaAqJozMzryEg0k+yVHqCc/DyJcCE2V4WXIhEnsOc5c8f4ChWfUaONhPPWogpDs/lyVCvp3m0NSfrAJKNiVy5aNC9gZ6c9BqwYgj/cDO3kdam6gCjhR+akALFYmt4ixHkWxKhDTGs5K+CwRiKJnvxP9dbxRPCBHbiVa8gsd2GuiNHZD98MNwXMdMC0MubVodd7dnyk3UQFfCIIL1osPxY0ZJ6DvZXwtZ2I0th6aqlTMULVo+lhSIU/5qO63lTSa3MgPRJEOi0AJ8/UlZuvgqLw9dyEDQoHTKWOsq+6fzoAyvIpv14fLaY+braPd6NkSaq0RClMenK1QLH87NZriUaeuCo6SZ7/CfUt2K6VOt0AjIK2jR0vorf6R8+TVzxZb+QdLimH9pU5tQc73xW93QRPMGy/gCK+R+YzmV4fHK52GWBEBL05EEoTY6OYG1WWji66dWnVTg0uPNw839p/yjLxkCfdTaH+v6hVUCd6HlROj6W8Mil6AYGC7NI2+qkZvJh/dAw/iQspXQNwwWHr6slLIp0hBHYTDh/J7Ba7ZR6cp3iU4bSXdmzhTahYDev4yKiIHyN64EANhI5OHYv1G4KXfIOvQizYWchPhzQg5eVGNMxsqrvWVxjtIbkKuHzE+IcA2NZ83GKz0D8z5zmgRnoJGKigseP9TmMS7BgAqtqyixA/SLc1KEUWrhXOQ6kA5ZQRazp3wwSa404cppBnfsS8EsEpbr/gXyW36cZ9pt1RhzyxGxDUmnZeBz/Uf1AP+gyLIg9x04u1fThm2w/H1ZXGvVqsO1VqutV5gUhFkdkwoCjzz3F3FUr1v0njGYT2mSZYvoF/fSd1W11c5VIhkEO06US5wYRmHVPYXmZnbK5YHQ8pkIDJ0yqssqFK34CuHE8RWb+Dr4omk779QOOcYomAMYQ9ILt2KUk2uNlahW/IjGtenuGLxb/t3aFoVz4oNwMZ7iyp4td8mdzgJAfnCcYtklubGAUB9k6bGC5DSkf5VFarnGEBWz600VGR8QywZ+jIYFZbtKT2QdDOYP6k7D8qVgEZByGmRedZRWaQDTggLyNgDD6pQwEeSs82+hTxWypqwU3zuAWqfwil+mytzVnKztyvMFJyJwPFaPr4Z3mTjyxCR2Jv674JVGGMUSWb0l+GtcYtd+NBGChwr8mB2hlyccget9liJhQEb0XgXfgVRlHlbO+jlZ9CcAew0Nw+tRcWgNnz/GL9Kur7RohRhaYZBBmQA6JhvzkazHRcdZDn0zDkfBmYP1PfQjP3d6qqx6gE7vrb3lBKEfK3Y/nCe4COdpr23oZCoIpssGXmqE8CGpO2bEwkSN6uqeqR4UtWR+xsgOzNeR49PTLJpFEAkXha5YaecJ8t/KR+eG7/HKV23zPZAMvHDC1rdxQ0l+6wlIgZbUybjBe6yusL7isRuuYYwg4+8+4lia2ox8RCdvmXlt00ZshBnAIfLkSwIqUzCcsD/d1ZG6Az728L4FCIqBKpbA6bzkJ87lYQpbaHpwPpqu3S0UqNDCwgg3q9MEn02X16E4xibz/rLx7NMDtHcwMOt9r1dVU6Hws9TvJVH7THrnSFESgN5eBy53Nq2Fdb8mySTxz5CitvVE+ZjHaYS3hq9Bax+uS7TxMIT4qJE7HGdsHM1/9uPNBylhP04Lck39JMe8v2dPOSJzyQoy8m/8Fc6h+X+5/mBVA9jAsG4vmx/KdUW+NXxgRt//SS2Ib7aGILsjOz+ZZQu/NMeuAsP1pFRTN90rqIVULbJ20ZJlrjoZD1VxHEoDFFGVWCVOT3jGK+vFD06gc3yDUSnZ7ZHjGmw4ZiAglY2nm78aUpXxI4BfUHqL6YQKFDCazUIryLi53RczlaTh0ry7WN4WpWK9sPJ0J49fu6RGUMYZd3+NrRvEdOrS5n+EJOTkr4lNzo8vawcYnR/n1Dq0rCHu5o2BGBEHABJbsFLi/mlWFO1MjpvUu6UPJjXlXse6MtBROT/mQfyegWGmFRQ7Q/O+rJp471+tQF10+bvkExfBoTQrewd5UwhAUODpyeW+aK6vx2AroUo2bGBZ/ZjcsJFfMYEMsm47LdQSq7T7peI2Ex+4/9oIAJGfhidbXA9UYPNhxigFTg83CETNYfYVkoambj3vv4MZNtE/wrIfTguBNqkQk9ebLPTmY2U4UCzbYqPKO5vjaZXeVksobDAJzhVjoU7p9TdFmNMyLyCQJryBSOcm0hFk/pcwcV15KZ/+IIqeQGPkTbiY1haWSnuQYBeyW5uSPHGtYw28cQS/v3rToNAUGVBSQ6zpBt4CHvaOfEJhuDJYZCcxvPeOStdCzaoSQn9nDe8wDc1MXrJ0+9N9TAKcS6u8ANLCLY4UfHLGf884/LFIn4OLOlRcNl7FS1IJgu1/vLm4INkgHt5ISp2vC3MFJHz1zJnopnKS1AgJtCmhJRZDaW6wis8CJ0KAJW0Yy0+kWI3lJ9N8yqJht68FMNVgkgaAGi5LuKmkZWm+ztKvf9gT8hJrXZkM/QdHI6wy9BqVeWa7g7ZM1YLbUv37YSnLmGsCrl/UVi/tG+fZbzY4bGye0zH08VQpGmyd/v++fS9EtasmbkQEIYnmLZLxO+tNHp3myIGwYBZVXjlWvrCiQcsP/Fu9l0HWmLBu3gvuJ4phtJsXXllJdM8iZIQR8Z6zEMs+cqVL7+TYhxDd0c0l4sbyIEw6N+V0v3ZbUlidyekdcz/aIomGdZtmdI+1QUrrHw7eDXT+G3zbTZMXxpEgJc4zY5bH5az8eHzwoo8QUleUKpVRrsErGmSF6GPJ2OltKYL6/C4zx4rHdcfsrQTcWBmrBWMMiFiU4NGtpYeACqYafRyu8j8x7ltp3nxVbsPO0MSoaR8tv61/q+YCqHX3h4vy4HzjCYEl+4ZDtj2+mawuj4J0rBpcDw+spzuCQ2khFbks09lPGxK8HYJl0Y/lNLUxGLZ+2h6+EFSaD22bYzF7dk/EhCWh6u/v1HUVKC/r/Wl6JHtd1V68J9zdOTgbvJuQug4r4vUV3JJolQQ5tecHKqcNoYjOIs6BZTlfB+yHGfGdxTKsGxbU/4taKuH8Qpd/M7fIG5zebrpiDHV97T4jiUNt7K64/u1e/+erXV34aOjfddcKNO76EzIf1pfD+KivBsRlzlsjj17aDPq/lnKHQCLsD+3TK021HNzhZyuwpLRKS3KE0XH/0TqUOr3VqLMcsSZM6349QJDznPG+sUqeS6wwMWp28TAoDKdmjzW6f+2au71HsOzLIeWencRa5JapKkVTYpvwMIC8u2L+/hYGJmk0588rq6Nnqe041NMzU6lj1K5KmSj0ZRiVpzu2FSTl4PBYHAuhe5dtwnRQwvvNqIELVxKMFWedxxB7UO4zpYRe2x0zH4X6pI2m4g6YdCs08vR9B7omy/goQUYbUZA+wJamq7/c0FhkNm74Mp05NSCK1Dcy1+9qp82p8XVkUB4+SsVRJ/Tqtn8v2esmemr7zjCfjLicMb05JqNoL6zzz0KaYkXeStBrF9+T7EbZTo2Fa/wS5NhJvRoZc8QUfS46HX8HIZ8A6LK8zKtROnakAnEEFoonVlvYR71xYuBAXbjtxfu/bteN8WkArB3//qp+3btpi2SIMyK6rX03iCLnzOd2OrPnD6xqgVT35e6NUMpN7EJSz0DRRzyze1J+Dx3cfx0M577W84qifD51mZG8VNbBf+5PxmGGrGOmkO+Q41YnCkx51D+X3CXsNAjaz/XfcPJUXJ00vaQyfYDtmFq4kU1ZHdnep48T4IskzPsYT9or3rd/ubiYLqeBqjnGbuNWb9ZdPDxkeBmJwYTjsTU+VugQmtz5+C3QBX0piVh3d7BK+Hk4mO3q8qJVQXeIqs4hKuRvBfIwwUyKg9W1x8dv+EwESuk2Bgs1+Zc3wzx4eGasynWs3V360wH3fKXZFTckeHZdgtzTqcQPC2hCHhSXyFMyljvrneLE+c+b/YQ0XcDBam1oAPzvKmmcgER6AqnyC32Ic4HMP4FQN2rh4Y2ntrawByV+9oq/Z8hdwQEPYRYiELBCnuGGXDQbl3ZLuUo0vfKU/AuMwYfNXmNM2vkn/GRrpc5WDP+MEL80tbJDZfDNBRfpfcvVpf75u0LrkIIjnU4adaolZWzB2yjIVwNrF7zF//n4N5xHeaGc7Vh1EYRdc0h2l23qFvLBNQ5kHbmX8Yta2Vj4DU6eBN3XyJBvJf9iL4x+hw1hx/7Ej5U8EZr/Qhgoni5r9PxBfU3fdvXICGW9DzST7GV141bvyMDXblFG5PizNjJUVAWNSxIAStz6+eDAbkYeAKTj6DIR6ysFvZAloBLCgSdMFd3ol/WXDQh3BbBtLqO9hp08BfumZjLpTJGRAIHzDizXZfhbgqejNSS27BIXQLV0muwzgXGqYt9McSvtLWo1Fos3k6Nu2qGyFftqQyDz0/bmgvtZyiFce/SLYnjt2Q9BnlmUVBWOtbDPvUgOSizvJDhdiSkbLLP96MJ7dKO3eUK2nZnpb4s4b2XGF4T6gC4qo9TDv9z2SY4Rffb/RjPs76P0YiWADpPB/nQjC2tDRlxt4sdNCIjmMsLgU+cr8cpyaMSYI9maP4HHww2jTPkGKvF6H6+DFAF+jAZKT9oi23gpZ2zavE0xXPkF7a2FTNJ3bwxvsJV+o0fXZAkmouYq6B2+6ccHhnUIeL10QtZaPoZPJB7/Xry/2Nv+JJFmQ/p2NSiO5bYGA8ej1vh5QlWhaX3JMs5gMBnyyIfXIMf4im0WEUnCPAJzq9q04Tmxzy7nGKKEf31kAp6IFk95aj0AogL7iljLVJlOXNvV7BwZn4dKfuZweSEZBqy+Mvual0TVDHiwHuIuXbvaw+OkU7aeAfck0Hc6H0jgt9g6Rxb6dAuaiKEN1cUYtD88y0b9Arq1q6ML9B20/FunTnZNF+IHgsg641FfllDFpQ+dqrIPKQ8IkLx/2ppx0ivQSrehNaf5dwtBjnPHroRGzG/RWOdiW0COPzepxIqcsWjhfmBXSUD7YCvPm/qTGcSnhcriFKew6a5s0AgK03I1gEifX6y90cJBY9REbQ7yW/XB+zAXN1XZQVEs7r+0ajtx8KvVBKJksKj5YFGdhEennMbwgCJJIMdt/pJD6FIcNVegt2LiQS70DAJeiNNG86dQVNYNZmYEfo8oa002xKLh1+rHlBX40iY8Wlv7FqswQFktpyLn5oSdo1jBRz8V3aRIOmhSnrs2wxGwGBEVEXvRm8RZVvSQ0xlKMVWs9Y7nnmJ9jEVuDL08D2ES3plzvCNP3FpKQeSknFeVBXv5T1Yk0/X5vdj1J1LYa6Ffxxrv90ObLHARkCI+tz6+0i5cZTinvgIYLMVnV/OL+m4RCsTy/+9VQPsYv6X2qSSlVdQ3KM1SOntMNUBpb4C0MsDh10xHQ0cbJK0gsR6X93ru63BDYbRZmPISt1casVwVVE7+u3l55XJGJ0Ev6S+2zpNqOAH66RuzpVskXE6X8x6wHOfp5PAI/7YG3Zozh1U27IXGEEKIm13Rt/nTE3pKWA7i1NFdVQKQ0CNdqEsBkjiuM41dd5rIbR4DMnoDva07v1esxYBGU4JWJUJQyejYbI9p7pqjrpHZUNlz2exX1lTAks+WxY6CExoPlSlNNv6AIsE0VdPmHOj4m0a8bigDelTpIL1WoePLhblmhRlkPDKiZvkzz6eG8vLeJjCGJL1+VFa4QREBVyuhcpZm1ygJm9kuQ+8v4yEMw0VO+TKee6sMFRVc/kS4IirJupnw48LoR2aRk+GuDBZ25xnKFxdSYqZqvWlEcemsbzl7wvQg5z2xKxEUsquyGziyzd/X+XFl/ct9KRLzyyb6ComIL8Wam9x6LPNZXvhO0QQZmQ8T2MFjmRJ42WyRzfyLGkJKft94uO0Yy6Fflo3AoIEon3XBygpi3Je932ToU5EKoikvqkeLFACpsBN5dseemiMdHxOJKrVJDdTS0qCcTzPCyz506oyENFdelskwdghmUnWyXK2WeJX2CBXudNUBON/i8kMdtJm52REvmGqVmxe5aricuTCGLbgZtYvigT++E7xltEh/ZgUoMP+d8vaPU/HdhZaUjsgQ8OoqZeezvNR2JFm2on+IliVyYQ/58LmZ2stgKoBbs4SllwiTpNRw7ecL2WR8bbg05aTN00C8aGWtReWSsYsirJ0K0I97flI2gJRRN717wESryWahXUAFZAdyD08j9SIZQm+wq5GkoUkK5cQ3wk1x01x4fKLPgPIj6D6lZiylqvWGtl6KxCfoSQXlNZIHeDsrIRqhINxdrCinM0iMMkveNxhqrEzhnBn8F6nXVY5zUDLzOXpp338I2HycFa2pueObEof3HQgFEMnHS3/CDKwJAyYl3HyA4X5vXUE8MMa79gYELseTf0IEUJRsfSa873vl6n29lFq+GCqF1I+mB5PSyLFvgHv6hG5Hd14PAHTKhY+xzCgOwwRZxygPwNET0UiO9ynH0p3j7GAFEs+VSjl4ArhHJbySohRLfm6B7FxxYJLJxJlQr5UdD+5Vs0nM6CehSZZNYw4FzcpYoL6nS+wGGSNKLVLXgbgvzAbT4B1J4GMS16IKMlo5S/dzM/NM4NI+a1Fuk4qwaewoHqGp78vgp+SkuhLyAVhI2Or50Id4LlHwRon9o7JT3D2pibchFvFi2VTEx6cLX/qorW2YGSSmnu9+M8teW9DIRH1TfabuDIuLk16NFz3kNr5QLPGAd0JzN2IYFA140yqfi9LfBcZI3aUK/Gt2bfMMk8eqttN8c92OmUYKUaHbB9C9cpEwaOYs49MztuGtI0VMqDDHN8HiRP55BpRIJtIWbSyi0/LOC94XhzqGVyuzaVaBfg0f++sV8wy7ytxlQYA9w1ejE0XaCkpM9zbOrymf4OrEaIyQX84Z9e6wQ1czIvOihnSaq/fcFdkxJcMzE2kWcARwWT1U80dW6B+v6HdclWMyMWLYr49iKWrhm7o1yumJKxVGiv1Rx3Tw61jrh+vuNjikpFRxa0F9G7ZWs57nuhaIeT8ZRjYzuyq4WZBEXs4CyfvmZxGcS4/G2aWon2O/UkjqrfdbBUF0yavSPdNJacaaZxFQNejGDPK7SCF82XxiahbNpwFs/t07gbCJkDUvvKjqaYv1SNJBa21RKsOuGJNKO/F6HTjc1Q5t8lqLL4e83gWTT4aubYGtE+D4e9zdPPo2R3dvG7bDrCQosp62YhTaV3B/kEQGqtzvu59fbgA6lFyGe7urhYr3TWCBFYBmrEpB78fWnXUEd1z0LSzMcWL6vuh4CJYR0tg1jX4H0wkw9mkbM07MXopLJ2Rt7/aL3Hl3MjO8h/1lqNlK74QTbgkurmgd23XflEcMhjO52Y/Wsz+CqwkBCDN8SUcd0hvJ6srikURdDKw75ZZMyms8NdzvzfsXreeCzpVaPKbkgWo0BlD+qWqaXziVa7YTSezNkCD1UBphMwE3IFwG3+Oja0AILbwR+VMjirrIkRPt+DMtp+OKLpkiE15AVv3jn19brZGZkhhAsuT2sTiWSjLvxJkMICAGdQY6CcJ1bmQsycrXCCxoxrME8B5k7aYQkl31h4kmnvmUA1Uo5bGEJkzebQNuMeVIRwKr7shM3Y3iowzuO8Jm833ALhjeDbR9i+ajGdiv5nuQcBDW0PZ0CB/GHvnmE702e3iEmWKin/StmkbfvsVh9mXnjLzZCRfht3g5Fu6OpDSsq1DSVUie4hNThGTSTWkOhTKbARv54Bxp1m/BqW0CfvfUJMQYci+HzQBrAw7lHJI8klNzq1wbwtxf0zzTFIpYQcsU3ddDWDMuciKmN+BHJ47B6FkgX4uR5QSWzLqgN2wQK1aLp2hgMJGqMII4rLK56VcDk89QQhw6cy8PCM19olNpuDwdrQFvP+77wiyyKx8Z4MVJNxV5vJWOwvF+aDouZMW5HNno5d960qcPPO89qYm6Zh6UO7MyFx272aWYtu/0+UZ6eThOP3s/uMGRarrYNGVN2bkl0VbM7ZArP2AnCQLuPoIbkry4nTS/RsIdFmPg98zeYI4R0RY41FQsBym1OXnJcHtmKPjfEXuujVQGfCPrCZsaT+vFbMFWIvUy7OxquIvdi2DVp3+q3E3NGG06d/cz77wgHGWrfcy5LJIzCMZHkk6m2QnZCXYVXwMsVhJI9nJcgG/CrU5lgDb/DlVEsXG06BHIuqVfnTyLdAQZYmJlEEk43pdgF69V12XC+sB9W5Tfm3jPwiHn/VmGszkYx+Er49CLbyk3hDBSKuzDj+nzCo77ZO40EIP4ZROdSwWlf5S8wfYcAzjNdj/aZ8uknw3tur126RfCzMA+cUo5mPaZL9cVp33X0mRTUIS2vgtwDRgsSSX5xcJUWR8gZbdeqyqQEEAeDu3+BMlrgYP2SH/le2u1yfVFn5JX9VQ04X9mmABR/KOd3rAYqR+OQwLWao9MXVS1y+0OKo0FlXuirKuPaY1BQbY3Vo05Gf/+N+u4rDcFBQqiCrYhgRAEjvVW9eNCaOsukcJWEaDuo/pWCYGJLadm4ssTCPvVVEJNBfVXAcTIxH4EFtWFMJUy5of50QNXNZBl+oRuFIkdbt04DeU6j2A3vzzP+IkMahLD6zBVJv+xRBIc5fODvnJMmJRMI8kcyMFqxpeWZAHxC68tGFNyl6yyGN95SwNYXwDSIQCPlL9bzjZaWNWvs5puiP2lbEBlDw5vCHtVmb/sD8QBgOhRassChwM5o5g4lhlD4u86wmdmVmhmEXnCyLeQJ0rRtqYIWRhg72ieDnqmPvOkDTWtKR38TeJwrK/7IRYfbNspygrU6yV9YtJyw3I3uEkDgbPrpcNUpISYvzv3beFg3ZN+swedqf3IVKkcdiAezu/KpHGHPyvX9oT6qzTS342/DenW9ctM197UfFl4rk21KxSma1KnLIWlGGasMF4+G3dxTnqBscul4CqNda6Qy8ita7HCzKlYa86yljm+HQA2B5ArJoZy4LNxeT9izFuQhEoEhUTNJQj2pCc/O44h8GpQX6XgpaAvAQJLVNq0yXGFbzb3O54XQ6sm557+lT3A+VWPyCJn1MLbsssHIdFhJcMtBFQYi0bS+exQ4Rq74xNE2CIRSzi3nj5TNy2AoO0gdyBC0/2iH67UB581jmM92OHqgD4EzAzyxDauPnlIdZu0nWwB4dtxWN+meq/faIuQpK2hoRP/ULwIJ9r3xyxtXxfFwJ3YquXldSEnxoPiYD85u0OAHvKOG6+3eBraUiOgvdfp1EjiroeSLLFutuPPV9XqhAReYPaRy87OAkV5tzSqvyfufCvOMTtkpxApWsJ9n+cNM2uBWu4lj1oDjGasCfCt6cfgCzh6UbZanbL/qCgf/iHjKYaavIiRLJrU2BuzdsP97XHkXLYbbfsHVTlXSohKOXOJ+3LiR6ix9UFLo9qieejYk+P4e5wC64jGQLSxJzYt3cErx1Rtc2+xlJaEBynLN4hLl/qOrgBM7a+yswC0Mh2OieA4SR6MfM9WK/FOWbVyoUBIUAKOhhIZp2LOgukk0/DInn7sF7dRP6Nw77MaAcYg6k0gdjQN9/1wtGVSBm+6LwkI+xfcK9l+JiWepXul+/EEdV7XXp/9lUsW4RQmIkda9H38FJj3EYJTrG4hEU9YWtNd2lKI1683cXFVzSMkh+2nuu9K0JUBoAnrYkKVZpAKF9G7y5n/KMZrP2xPuUFSOaruqriffSEX9Euj/k5dgewEyQCFTif83LhkIjt5qJ1LyI4ynIznWl1SoAdecEp+I5WmKBB2fr5yw33NX94q6HIP0jW3Np2E0r1f7fUjqdxV+iCRULU+yAwPXFvTL7HqfFLj+wCfIbOg+nsW03rGTf1haLvAZA/nC52pSDnC4f0qOiA6WtK20BldZUaA6GO3m5ZOCGyemGK4a12hM3BXnbladA/yTRV+pH7IiT/9WOijGGNXzV+K4wmdmRjU3It+QwUCRat2mGkEHhOcQY06pWeQqBGjHkWcceX8/drkk+tYysHMXVk8hLhLGjUVgivK1Ra4K+RtUcZO5fkVkWQ4W8fyo2tafhGEDSsflUH7yj8wsATBE9YpskR+r7Ac8xqdxtEAfRioGXSprjbLI2DAZZz9HAYR7rUHzvh/UPpFvrLbd/hFf7sF3RimWNpiGsQRZ11RqfZkck9IJu/FPU2DYr/HWUdskJHuLufXCvDbKn0F9sM31Hn3zIuAMTUc+tQsO9ll6jnNnW9Ulo7d32jEQMqJIrWQL5+Se0a8lKRp+XhYp4IfyUaTRC58vFEjKupeFEpU4EOp1AjeALc7vZV0ovza8QSl3ru6xFpY0/ckElMOChkhLWSDHLCKaFK/qC/SIfT50GJZnkCr5SgXZRddXq8Gc6XNjIzSdCF+9YlUFKMiri/sn1Gp/dEMhARah97GidLqitLNBlF+H8XoQmdrM3GXBSCN6izNn2ON0OzpCxOuM917OZCw2ZC0DSvNuTOFCGGYf1TYgUbgK2KKc4zm/25dz3GhVpFqs6x4yhZBbiy/6FD1vXW/aIcDiSUoIhwrUtxuGGZijb47Jz8JfUTblzx4eNPbXeYpygkQo1xXonjeouTuJvAH/zH+FK50zOLAtbN9AO6xjfX09CsjKitMVlHWmmQybLoBHBPkC5IbAZxvs3cH1VAcy2X90WL6y/0SXNsGeLBdr1OWVuYg+/wUNiR7QnP2ec7jNrZZOosT6Olwn02Dh6zSwKoDnMFLfk7lBO0p9mWjex7gEFXNfxFO19qmaoISUZEgdTuy7sHgrD/36o3XeFdzLFoFnOJa4yaENBXdTSmVZacz+5IGdVkEgjQt/TxuhNGHGtQuzNDfM4iNZ28Ly9S9WkUGMNAfDRLr4ipZkJxUA6HnlOi4Yb04/Ze8rB+HEXpDGC5Jpr4fN62LQh8o6kxknE1P5/rNmz43jehFlRUvCyNi3Y5St7lC7a2ogCt3Za6M7AshQdbVV2+R2DuuiLEJz0MLhnn/1/F2Z2U3h560PrnhR0Gc/5GW5DwO/DGrR/4PvL046BKjUp1lfrtKfE4osRTS9/oB0GrNW3cYgvhU8ld61sHhKOf4P94t4n7h9zdRXDaFv4ORPHokkY+NA9QA49RmsGMfJLu1/RXuluq0J4fsUUBoa9dL9T0yDJXvGtuoln8aYrNzoapa7E8cR73/wX6KwBPpwCUUlxsBtOj0rnca7zu5FqJC5W0U8Yt529SAI0S6nmWnS8zguQLRzf/gRLaqSQ6E9T6Q84u1cs56dzBMv2eBG+zAKw2V0x1NJX1gC8M2MYZpScdXEKPG1442UFWTEUlkM9OjbR4FurtJNV4IqEu1htlgltESO0SeZMHZ1JM7bNtYegevwPSCmW+S8uEGj7FTSSV0HbDg1rOnt4Ws8DxqN2T/HOXNd5NGboZ8VTSD6g6rLWcoWOwsyeG08GPG6KHPiLRunEdTPNmY74ObRGT1VCHP7nmBYmjnH+kqK6rDyrEoNjdqc8uG8yZrHWBXU9weqD5rpQ6S/annq7P/GiYepA2ZDdJA/GbdxpHYatPgkXt5sop564gVHZamW6cq/cdADaLCXWt1WgK7y11WaQR90YOen8BECQ56pmJbLvzzfWBhUUJP+dAEEK4o4wZv2+IBAFEdNkNF3mKntsLE5PDLA/IEiV0rziyORzLJsoxRMCQV/HlpCkXsaizcHT/vxU9iadf2hOkKehGum3973fFs7uRlqxz/oDerFL0617PqG+VYIxjeRb2IRLZJGH8vp8ITzF7U7HUg8Crs3WpVY5r8wxn8tzGvUUwY5csVu15Vmm1xcs0UL/lUCkrOXdLtlaa4pHLeQgpd/vu1ZzjMOcgzfQaIwiZK+fMZjRLAHUf83TSCOkovb3xPkD0jElmb4TBqFrwn8G4KWr+RM58qhCnlVimQ390m8YLz+fNHbBRDs7GJgHSK+v5Z9cwZq4glnR2eTjnqTy8Wo7BEg24CL/RT1AKzOIE7muo8oegzn8R6qab08LzTcbb0ippsScfjQoJhsr4jKG2pMVczpCYqptZcGD5rxTHFbL3+NDnEUptRMyARhF2FMiM7pgaB/IpAna1AHa5EPt7oBdzMGg7kOdSOpxrPXbdP3l/+QCfCLMpCsxFd3VAxA/IPVvK8JaenCYCadhyZ6rJeGxTUh11+OOAjrXIJxb/EbIy8rv6h7hywPp9ZhPCcgt9BN808JhGIaKwtL85jO5nipQyAF690xJ9A2DMuCx55TSG88fN6rqBMYDI+I+DtFmoAqJB27B/xxN9xMLnQwLcLCHOx4GIFCq3/6i7gwJePjoG/HKNb0XjhuEQmYFzTgtt/uIo1bBX4C+y1jrb+R0mRj+RyaDkRus8W4WW73qbcjpjIh2tGUY6KJyhEaKiK+LHG5euQeYZO4zXoKbZOWiJTvJNNVrWugpXkIIIE4zK/g4JKATQjtaC1qbJ6khaJHxOTS2goU5zGyjmaPKvVPrBh27E7E2iZ/6omwpBARV/9EKeU1m4Msz8Q7y3MzEF0C8VIIqAxB+Fk8qG970lhV/ZIX6CsxiHqybemqil3Qv/cWKm96fPoMJWSA1dcF03dSwSyNMdvKKBCYVYLuqr2pISKPaNRJJw2R43RNE6avh/TNA1tGJ/ilW/e4LbOvIh7cS2OsbjyXcD6WS0DYaDa+og0lSxehZQiDSt2fVdtF+DO7/cEUAM3uju47Fl17rUPkRPaheA+6/jpSYK5Nh6rSwO8Pbi1y4/L0L5SStva0NcscpH0pw/3Y9+Eqw1SDVvRn2r2d8vRC6YhQywdhKWraKGBMILqjiU2l5d3jb1tnQIwi95QiTJW7MAjJD4Plr9FGRGlM4NQyAiG8wSAKUbRCpmxE+zk9YhXjiC/Rbt983pV0VzovJW+90dH65IOb2VS+Wk+MpsRgZ86uEuxeGPyB++07HlAwqFjq0sm5Lvom/rcHSaLduJrDdabujYJRWbbY2QZptvGwTHAiaqsAafE9NQa2oq6hV8+E2YRbdEcrirxyx9JVWpti7CsFfA/egMevH0MR40/X1jQzMYbw6mr01MI833RiE3EuU79cpspC8tuN6QxFB7ExHF8yrFQ4vRniEkTgKc8kT2tC2HgNJJ+l/FwYXky6qbHj1cMtBGVOw3SFMHn5l5odYVrLqhL6R4DujKq/CEsEj742QjUogvrSb9DOh1Mm5Z7n6MI+YHii3bWp2abi25FJIiX3GM/137MQVr4wwQ5IQETnYx0CoXX1nLeqLjQ2VlOulhy58iVxN5d0Q2TEV6MPr+wA6lluGEC5890db42elDUvTbbMcjHGrT7WA4eEhNLqVT35NhLruSPkwg1UCAUz94Dj23i6dqS1MPh40Oyi0W+wfoWYXIw+siweU3qKdQM/IWLUwDjgMQuiK+CTyRgR/Cg+XmfazCLiF1JChK7C2x+ROCl4t2WjYngGRxBWRQqqrNqx1EesLx8Z8GOimBJK3Ip3O0TWp1z6fhibUBvCtBpCBH7Wz0MrsYEtW/6gd/rLbB2IcMxOrxgW5u+/ZBOjd+9Zg9SRf7ln5tqXgM7wZE2rj4u7BOezWvuyca2TpJkQOR8U/bR+LRjmN6RAS7MCfYSPtJWSbZYnQL8vGmJb39SyiYiER2Via1nlShjJEe3JgCwTOTiIQJ5h+NQeEs7qWkpIDJiQHb7VwcR7T1gLGhKAqUT5DPO5zvGPny/DOh+Lo+Xhxf5wTkF5p5yY0vM1gw2UZQ2nhCedQ+PBxACaAeuBYTyBs9aNWvYATPBLUtXJ3H/+rMIUQ3Xz5MJKdV6OhLEEK73rb9hfjPlA0gKO4j120U6VHh4AJvL3WqjaY/KCbwpCzUCADZmnJdpD4p4U5ry6/YuhcWXcVV4dFm5J8qADBWw9jPITjUtkf0lhIJkzhXLTcXQBZaaunvCCxyWh6ifYzNTTCGJcUD6DyfGam2zj4qdBy7DwBaL2S2IxicF7F2ubPDvx0+DEQVydAIF4Utn+/niyxDQpGlaaG5eRQcfYEHaZeHBOfZ8x6KnSsZnB8YZbLVBcEF3Mv/87cj4r/BYDYAaUWrrm/rWPImSVpvPlB3xQvVG305B+bCj4kIW4ZWzFnX7/nApDibPZxncAV04laDsD872g54z55DZylkUKHXF7Y5iFwsc0HDovYpJ1P+XIAb4pKZnw/e2BrTZn6jCeAAvAt6Z8EdXqS/KoRwK37xhZL7w17n2PYpqnoCtRAvnU/CocUq+el+PFEwM2GkhLBAJXvVbqxBMfPWlA8XMNY1+dfsV9Uy0C+WgSzcXw/ylN23DlELK9DPZ1nzFCvyDWygh1ABv0LXhuVuDEraYOrX0J/NpbYoxjl/mfncXN1DorfumMjOo/dWEk/OvdZ8w/66CtISpGM2htGRpT929qEz+kRM+2XpAqcSS9GOrLWVVUVIm3Ez/yIqAWm019Td/ytbE6eeYJaY+mJpelcp0h+4Y1hmcF9J6cZQEJi7foY8n1psVTCzE0QYMX+ScYxKxb/bU9eproUaSNTxHeNhomtba4y/CfLAZYXndn5ndeIjFIsRWRpwX3HwrIsKxRgd52tRs/iun5uy44w8u2wZgayiPbOTWGXUn/BDqak5EZebXbdQHyE0yEhUO5HcDnE6xlAuZFDSKLDTTZz9bWcfe1wy8KhSOwh15cBRibt+faUQgl7/5na6Nl5d1o7iUWTjOhjQa4z2Pha1PNGSn0hZFeICMKGtHJ6EGQbB+HF6+M2e8YSQjJ2cnG2SVpdzXlnkzxYqwXv0s0WM8nggSh7Viq5joXNiF3RJ0A9637p1HFJd2I7GrQ4ZTOWRi8jcZaL/25Pox9feMT7VDPV6TT++0Ri3a1aLS8IABZh2dWfxnBmXDWPdvrxmBiF3eePVqd2ZM5bI9YAN23/3qVLElDeD61xvgRdjkXkl2tqif3zsX1gGp9mzEm6suh1kWL75XC2kXlrCreiNi2pfI+iWVFJDXPd3MBNp7VSAZRp1jpt3ug1pQEM470lZXwotpDljklvGxuNeKwTuKNJw0EK74nc0d851QXL9P4pxZdM7pkmbA7IU2S2Xa/AJRP2VOz3Kyp9oW6FgoQi4noNkoHeNnprbQod8n+dQSSbMzNRZIuL/riHaxoOHkaGYwROCZwqcbK1tUnU2Qt1J+3UTvklj6wOD/d8lrZG7ucjZiCyHxK5XVtzq9lDJ4N1FvARCTUfnLeOLc5bmrtGvb8mmsr0lDDyR5607k41wzglZH1fExfmsXrEjiNLSzSKGb7FVusl07/BgeCclDsQkds2G654GVeUpX7UHaqQBEmJsIyvfxvz85+WyRaoYuQfSH9WpJLeUoXpUt7+Crnl1Jqz+eARyCmzL59OUUBwBuoQAl5VddIrfG6xvDA/RZBOV5AfwjOrJ2xRo4N42rCSFCcnOY7xfewl6tVLetiM2tGLqRLc9k/owyHriX1A9BnluzfDc5xdEUKyuwzWPG+tZGNDV0WLl1JyHPflzcBpj92G0AR0lGaMSZuKui5/LUMn69X9wPKc6FVkNEHEjHjQKPQjuFCokjN+N/6DlMscpE48IhHIa0Ghrc36GwGEiPRymXWKD/di92yfjZjDM3fdHBdwSxJRSBVKHSwh6Ey1/zWZRZ4kk+KMS8HuroIw1UPa+PDVpsSIKvmqZnZisbfHFWNW/dl9n5+wM4VIzhmrETz3k9WU3s+z84SHh2f7dGT/G5WvoisBYAgwm+pqFS0A8xyhy4PiKfgS+6TgnQD5hDEerpzgFSaMcw3yvDZ0+xfL0yznf0uY8N6APiqHdoJZOWqTPnTIbeBLc5dvFdh+mvD+sDtl8BAWzYR7QkSgnx30Ru7TH5a/g4byacurCNvG0lTgpkj9w42uqBp1zMsKr2riOCQwfCRKkuSX9CGADOYGqCHh1JUsk6RwvI9OvM9fCJoL7Sap8NUQ7mAvdB2ougA01NdqxVo8NeGta0R9C7QybiN4uAtDxw2zLTG9+0we68JkqZrj9tJilUV/f4wOLc83GfstXOVF2bAJ6zf56YworQQEDj6QnC+lqyMkGAr0QuAikm0jqS7fy9bYSBz5hekPILc94b8aUau3Kt69QI1kFEmcb19aFQA4bSegA9/hFi61RDIVQ7iOBqViYdGaK8d3zH5qWIjed0hR9e6o4zELdXWhOVOcPCmZIYYXvgUsAyGUoCszsCiTdwOaPEL2kRnYh0mNSZGb6/kr8XfbyUdbEZ7mDBYy0yTDxhkrpIoJmVutN6FHk/E4cTEolaGnv7x+QxQIKZus8IEygpdtBDxj+lC5M6HaJ313pLDYbjpCA+oYl11ISRJ/fB2oIdDBHFLefQmF1uHk7vtSmIyI7Q9HG0qxu8QRWecP8ipKR1o4bGrAhR2KcGEDE6k8r2F7N9lNUZCswXi/EXaOlPb9fdsaw1Sspku1xrmyADIImEs//XiPqI3Jl8BlrsHf1mAVCBmlqE7usMbDEpilt45ia5CXzVqlIZ95Fesu48LEATS3dyXVEjwQAqVbFBttbLfXvX4LhaGKv6P3XBsKWvqEFfq1rPYdohHtQH03ehlVMpZ/BRCBFV6dffGCrIa7OngRAbORd6wsIcR/gQSxhfrfHFmb9Ws3Pk/SikwIvAIYljNbXbvIpKTROSiPcmBDp4hxLkrjR+MfBFZLV5I4usLY6WYmjhT2kzW9XAxxLYCELLIf6lg6p/GFgpoRTm+yQ6PYtmKVvdTHyBxv28y3vTiy+reYBZqmC7x0TDasiMCcA+TxdKgDY4s61MpZyI1+RUzeMfx1qh9MBXg1tI/HSKpcUj7+qTrwp35J3ezefo6UZiEWMPBtx0/tJyaej7NUmUHVRBJfB1q0bsw4yHfui2ZOPNh/6R2/I0j09t9QGeRxpuJzB6DNbaPTOmER6WTXYEGXq7DhzkvCP247uSz6r7MfaasDs419fVF4RAt4XoxkFRmk3sjrhpNSeuDoG5RpjE4pI3rH/ESPaF6RIIJBiAbVU/ct/nKrDmBQPBYlNob0WmW07GhOvvz0m/BXTsPB8qA8Iesm6PsDuOLEEm5+jbniDFyXfndwIXHgWBB1GCyGV52MU+5iXguncQS8T+WyxaPDqCCXMjwPJxGObdF8mBkG2+SpqaBQkeN+1IL8Cbb72d3ySQUR/uO+N9v36KAiKVEPx8EERU0vfKi53JWN50+LSYqgHmF0UrnnHCNpcwfX8ezokGL4sK/rgFZlXnIqg6a8EJh7DfMOwMgTwRjjZ+TrXsj7SA6EaMRroFgxXRIOGDPYZgkadllrCosfuVZqNQwAY1cDJzuD4ocR7PgZYXbCA3g9Jd1PRx7PyRTNad56qFMVIv/9AYYd32opL/KQOuEa2LIoyMUHWsHVeJEgDnTAizkdfigKSmZVUDrztoGXA+B+9B+MYT2q5BETXJUKRLiEw3upTpXnlh7hkEk8/0D3rV1lUxxSlnDzLfFArxdnXRhBNu085RxiTwTISjItGPuj0MQknBfLTi9AeLTT9QUKRG7bxHm7P2Kei6fVAeNBP31q/OVsTuBJZfKaxLodsCxObxFdyJNLV2tAt+2SCAO5/VWcDOd7Or0wzbVGwbXJr73+/PYn3VfNQ4CSxdqgXNPWDqh9ZFVRQbSeb+bFmOpdkO7C70y6dTSHVuHlIY33/KV1QHDJ226atG4ltS4fk0ZNDrmPZ2Lps6qyMYO+Wkmsyw/ECuxfXcZ0zM7vmLjkk/LsX/XG0vaL3KZb2C51I5TVf8fBJmMxHHzKvaXDwSTGiya0f8ZZ3olqbqcd2cjXM0jicXlX0cJsaB81POyuItwEiYZwsHn4gymrnlD0mfAro2YoSC7KxDdL1DQVO+0a7fN1fLkv8ElaXx46Z8EGJ/W6akIr6uEuiFIQB9fHujgNzIzAgaDEYVITJJO5XQkyimdgaTBvra1hUbw4jb8imqVpd7G9dSoQVNPatqBlbm7NLsdI/einfpw6HdFlo9bpLb/wBxf2BGK/YWhn6LhzEvBuRuBZJTDv7HV9WfnA2SyT3HV/F6f+23aOYC8rxO7QQ1FI4/0m/OAHdCwYedzx6F6TIlSh668B+Id3ZxNP3V+Z82Tt/AHYSzDsxyYC8mxyk+Za4Q6u8y70AKpUm1NPP2WMeSHfqCc5mUcG67RR+sJWZg7P5iG4FPnFmWKv1nwwk+fM0IIA5p7xmHnj1zbj89sN0hc81tzI6enBjIyPd6P5GXzsmp9IRHKS506SAEK7IxfjQLxkNK1x+M8YAYLrD1qWXqo03kTvXgYllmtbguZX1FQGpXYjbZzgqSLxcXTKqQ/GhYqBJzZtvPaYGODBTozt0Rw6/vP+hTUJGOAYcEWWr5Mqy4792lLWmElkf2k2HiF5268DSkEL2oQl+VXl2NXgbfa8xxQoI7lpuNkURcA/pNz/go3LD+w41q4eQy20ecjCwekr0XfODump0XPUm2vvNfk4P/tAVA2PLhl21zoFOrSKjd6D1AiMtz/f41uWlBWCDDY4tDRMhyGsls4GW7P8b0/dGx6VTgC6oCCWxMyJyOgl5RPaFDE/EzGGGL9XUm5X9L3crn0DvEELm/Vx6HwlGWtnfZK7dA8/zJkr9b7PBgLeFlmXyfUBxZHF8kxgW5tcxvkEz0roS70jNLvk3QNCTUIwCHnqk5NRDEaewDCzjTR5lKzNzx1RHHJNiZZJ0lXrAsSM03iKPyYNdJfMwUAvRlKP49yIx7XS9cvseBWVvGNAc2I0PmR6Xc9KjqauqjgG/Q8i16OIPtQ2Ll3qDkunTNq2O65AEFG5qycHaB2/159N4n67iMEpyNowNdkq/ZlDxsX4dRKNvBUJaYqhID70qa2Rgq8+AzqTaJhuYrqrDDO1n/0rWggrBcFsYwo7ujJZblKGamFf+3B5MTAXNUOKn5PW91Gx56gtqTqz1dYMML1dFR/KZUZom7Wky7v9EfKnYbBseAvDuBFBFFCuXnhvWc/JS4ipUIe59Ls/kL+W5lteo1xt5bkJYfug17vGw6cqrOjTG4nQXZ+RbEDCMTf5JZ4DBcuVv+tGPyucc3B6R9NMF/lc4ubulrqcBPhRUjGBILbQ+4uBJ9eUHMAj2ijfMskRMLcV5FdgqIWhiEvxNVlZSRrzTzySfBUjZHCJQtbgDZ8nRWLwk6rQKWD5aSHuJh0vBgvlNTP+a4P7p59l0FYBPtoNpiFl/dOo05KHesQCueTxj7IB6io9sqTWxTu2PK2C3ACiXWNyxs52441hxg3eco87pSRV1NUvQeac35o3tgUpXtmtl2yHh3QO1mQ55wSqIri3PtVxJ57l0nOuyav/0ixzLEq3QlLZmLb8Y2JVlrdQMjhpcC1j0DS+VHrYIB4JgyXacVu9PCRoC5Y2+p8qfeJA3OFreaabxWxz5omyn/l55+ufQkO5e9iODCdLWl2crwLrUpaMCi8EUcVXGb3Z8oBCUdwuuohn1sivwQp1O+DaRFYXIbHQibdPfq4dU8WeiYJ4WKMlNEuQr/BRIGwOrAIM3Ppjmzvh27Lyx6xK14sUHgNy2ggNG57CBbXznFP/0NVrUQef5mMdso3AJ33SJxInqYebzcZ2pEVYHYczXE/+mcptBHb4ANtGohwQabL1xmFHav/wFH/al8TKjzGnYiFLEifJHL7OJD0x/rtzWuCrDToEWPBNtRKXFZqz/kBH6gsxzy/TUzP6R+C/A456FbGm8soK/uYyafgNmX0re6fgXeehUvtDCXdAUJElJt7AMv+VMdIrrOK7TAaHo6E8Khx1rq48yOqMqtC08so9cQh/AV760CiEtSm6PBL7JKCZBV4m7t8Gbbc4TQRawpuwTFyS/vt1JBnAQUBDPdEddlJlVAfbGy+OKkohOw9BB/JY9rDZQK1o/kpfl82umHijUnj0gVqhJCsrzUxYl+ygkRPDEPZqUIo/+AtsGplmBSxL8bUE1iBc8lCtShF2iqMC1DdHIH1DcucbSNtxOF9LY4IMng4T9eTYzDr+gnOPVxWBYMambJUexTzxyvFOneFg3r4FBEHqG3QZRgnKISYUQKv9B23A8vhFRe8uNZpBtiMtXqOQlVEbO/HzkRbqVaGj4s2XRVlhO+ewkvEaTp4pNLXG1OVF6ncxf3Fq94KmGuG29LLsFI1fuX35J0TsRNGo+TCioyTrXLVEjPztNVQL1/q5tGSrMPhfJEaQxHcrnqhVVqN1gfF+JK9Pgcud/lGa+Ig7eKQpJuUN+PYhBYQ/b6ahi4nLNe5+d8rQlfK/gl3OQ3WDGWuUMOt1YlBKoX+99JWlZr6tTAVgDF0NSHs5fqbU0euO7cXKnvVB3taBFHP6/KKZCBfGqzNo6DgZgiAELh1EYOni64dmOWUuwAQCKu+L8tnTFLlL6uKkaNtO8YGlOBVU9mQFYx4aGPgGEI/HTycxYXBClfKbmSErtcsuhalOh73FnzRz/thPjvRJcRwPtZmCHs1nYjivLMWWGprl4fRUOlrCDiwNU+9TZuaVsuCxj/4DzKfcla139igH7Z+0uskWkEq/c0mrsRLlVpl8ln0G77hwK9rLKc+RLeI6KLKy3Um5C6Of3qiKNoY/7ad3EFvdP4VICsuTMTii/bee9efmKAiym0A+l3hS7SofuEJ46In7BEO+Kf597wnd6s5mL1d5zNRBdOEmfNKyPdUuCW3u/SfFQes7nYlfV/B1DOE9p/pmgK+bx+eZdZUMu44uBGlaPvej5wxU9aumiyt/uCCZ4PyO0OYfFAMMqTaYcI8GxYeHO/3tDJsJisLleLpS/gvPLbEksIm3R4OCJ21S4P//uyzQ4EJZyYmWZjtknKJbz0vFEi0zDWnZHl4kvpMSPlVI8cEAG5r0JoNN59joEsMhUcPZ1YtIDYX9cnR711x6SQEnBGgTz6d3b1iebIdotlgqE03w87xlD0+qEykcVizaOB3Z+ocaMGWybZTIdpR4niV9mDm65EzKK8VQq59iMlABk54A7zAlMdkYNmaRuWJN+bLJ7RqEZf8vrpM0+3cwD0NctuwJJA13JIJVFlPStNIXzAW4pp1OnTx3rMZQfF+o4p92WDkF2tx1MUdC14Er9l1RlYsEYnOubj2IotL4tkgKwnE219ZsjXb8PJFkzakaWhRBJAkgbR6myiYFsJgC/lellsN9g1ML0j4HX4rwIzHbq20FDkBdfqN9SUnIbJf0QQr+QxHx4f0kRekXaqKZYUXYMbRKa6OObLPOaKGft7xFAgT2pHuSw7kdfloER91zsJPWQJbkAzyDFkkgUg80kW7n7n+WBN3CMXA3lU6QR23Ipx/98577h2OGkpcp5YiTX/TikBkcza+iwBGNBi/j+GwW8tGbKxpiSNEQqUDdqfscbVMQ+OSYGoeQKSLwREfUGDjR/emc+ZAJsy3sraTZkpHFZAI69dwO1dvsOw/Q+O/2lgghmEsk6NKzmfI+OYuOG2UoagP9Le/y9UABk4VHk54+6fW891qe1yVDT2KUc5hNeePBaQwVb5BQYPt/+2xEpqsHC4GY37hXyRSGvfwYa7DGUDbMKd8vud28h67mpOl7fe4uFRe/HOKf3TFs+9RX+QpL0+C2b4R/8VfkUQOABt4tcaDV34nU/UFXBUDvPYMYe0F24AZPIWphY9bLwt+tWvmuWwhvAgPN1rxvo3hpXvQNSPsVKgFUKENrmSCjWPYCUoQfJFpepI6oqpsVwJt6IlBFGO4soABNOS2KtnF9P7E9sSLK1WWOdGvYNhxKO5/D5ACMSM3oLy6XvjzPe57hP26DKKsIbhLZqcz8tJOcm1zlVKV87cVqDh5iOgGkNIKp7JU8eBp4VRPvv6peu3DR+ROhro3GOnpo6Cdltkq395hUi+pDXzwcONA2YjC4BKvX3JGZi77wJboSzwwPelRCe5297Gau3hHdjkNfDMaoCdfo4BX1IthlFNEHUm2nTsuiPe/rOux7FSlxIwT09NqnvyBmWQYcleqlPEreuoCZRFvXL07v84AxlxNdJM/atDmCjpmzumIoYOf4uVqV/8ZnSwV78WW0S0R7AwI0EDq4B6IaI6AUBwPrNLY0eeSw24zQ6qVAgBGW5aK79Mg+Skj4XxdPl8axMl4x6nwmnAfEBIju1ssp4yr/gdi9kl+ScGW3r5NVqJ1fXRkW9O0A6JBottvWGypQioSH2C46bepNpt5dXRK28XY0hseEnW9fDBaUMHziavWy8Q7jttulrsjOd5WunqGz20rPiwX/3fdKuQgv0g4CDqGBMamo9htCyKqN0qTOxWP5MmZG0lur+eIMwtcrfYqJujT19J3dps8mrCySt1MRdmlNIykG8cIMszw/nMlRV1DmpxNn2zf3gflXm1sXSH00EqrICj29dnyNSbIteQOqjPLqBf2QDDVVCAgcCz7vER9m5X4XkTIeB4ppqaFa2UHE05QSkAhs7FkyPf40UFGlKG8GnrdKq0ZLUk9m5jleTBwhdDsYP8HCDKRE6LS48qLHD4pvSl3XFvmH8KBEmyeyNwwJzAJQd8MqhmKsdandB6Ec1bHOw8agmVGP/vvY2C60X8AnR2r2HhdkUbclW9+ozjmxmipA1AJIZnqxg4aa1Le0RHfU2vkpf68y/rFMYgCXue7eNqxoS0NkOw9a9/WcDFJOh0Grb8zYjPgaSDENIFMCM0H5OlIqq2r2FKGkaQSMzVm87r9L7fysa4xxVMD0h7CIExLBVbCe1/r/WavK3yPhHVe3XBjyVTDOqI4/90N/Cm5KnqxFrVYOHbwMIXa3GwNwVME+38OpXvNwD6l+jN8BDCRDEjGDFC+WObTdm+5/tfm0QeEfVUYFtA7gTobiCnl8rywroMyBHNClofz+W7OhssrGuos+fRhh8kBA+Ni0fYdhKK+qCZaY0LUDpn17UUKCX6dOZccCYzSsD2iSQP74pFnhlkOzACsapdT20zbjF6ZqLgELUPT8IglaX38zP6zfdyBF+NjNf247XNtmIz4QCO5iRy/GcS8jjaWMfTxI3EbUvzrprtgRQDOz/eMnyVQVbbFiTMZfhfQLeu+j6iY0Qs/QYGFdHefwzAYuVpPhVZK/tXsy6DAioLlmNDzAu1eQ5ihCnobO+MOZtSD0+uTpiOAvPwGWf52xDUHj4zbdFtZULPV4c1TmWflDGMkg/Ia6kPHprHErwFTGoBg+1D6oX8lSPdz5srAF0RbktUTmq44+USAYYowZQOVbM3BWMc603Oy9SQD3buNTgzJ7yaMBbo/pjkzVrpW5xYH0Ra11ykiz32vo4nBg9Zvm92KHWhJm7uQJV5DMPA1JHBWBMcjz/uZupwXqjoTffeHZ17N3waXUaR7cZDs94ewlhsbQrmI7/A4zJDUZj0qKiVQhn3f3AneEhDwl6GUdCBdKY14q9n6ay58twW2PRXXPJ6UE6TUs6oqH/0xgDpP3bx/mfcCUy5oo91agCPtpTfowGZ0tyw5mIOsUqvdURDhjuWLX/WIqaPlYx3zmJ3ahTcxtC5xQgKWrQskF57LaOvwYN0lzIwz/joNYkiZwLyB7Joi0CsWWRC6SapEN5TClIisNQtNPmfwKaKYb+Hguo76RtcQMXdRZWjEJNHq8KZKeg/uWWDOW6aygLP9JDrNNW7JfWDyHPR8GL+29zBAD5FY1WZXsmYfdKU1VTLLzAHERJJGTpwKZH5k0uZrDYM8zG9WX+RVDM8bsmN8cI2wKz0Td8GEq9T4DvY6FuhMsqPGHC1tkLdxuwBYP0Lu2RvjXaxodrZhKfkkIwGcfm+lFS4WMFPCz3FwWwuvNLNqv7c85xnk3aXWl49yCW0YTzTqwyKuKWSIFJum5G8BBjvxx2yDOZMh18M2WhRGX5VA0p3eAilBsGa54P+iEat2c0lLnTrXg7fzDLJrjO/213hRmT/92zHwHShntUiR+9KUWKWRcx9OrMWfefEo/p2FR7dbNWoP/P/se7JJUfBzJixcPvTzMvSTQrccDAmpwoLnh6pnsAF37U9Cakvwb0EZzywhYhfUyAZ4oAu4R1X55yrbJifKRbLIC6NaYqZxbpzV9ec4/SFSjJKEvmVGa9tHfUJayAvrPPbVHNaxlbdJOOn7f43GTTdGGufXu/daAhuYtol2y5rFVUxlDpyKCfYRz3fOyJZEjhxizetlF5kpK8kUuEpKNWnSG9VEdmcn7Tu0/U9Pho+IZiTincXepD9zQXGusmr6j19TKRCe4dmbGmRl1cDDNABYeOKT51fHc6+d1Q9T2n1UMmkd+aiSUgNIrogqtnInezaEs7HmtmpjKttWg7ulLhPvEEnGE5TqPY3iCItPzYojGET4V755b+cNmqdG6OBTlbYjDs4AAp+ho1Iq8R/eWa0/FOyB4K5JLQ/WqwpaNPuaoufHcJMEld4peiw/7uIRZ9U4otV2lACBY2PfSUUu7vJ/iZUtvPoJmd8K/BmbnNo2iumTtQxEeARnjsHdzf1JrE1L6NGFsI7t81c5GCgmWILKM5pWDA5HO53I6aju6916JkUl1YcYyk9Hwwf/waKzGbNaeXD2d1jBd+rriDyPgR5p32kxAb41vjMM5QjUrVztISMmbVDBnx2qArnLJ6ECRGZcfK4U6LCAMxRtE+Y32MobWIYqbeJLCsaF4pCXyZjPABVmN36NRAavX8RXO80JuF2m/Snmg2NL0dSW67EVH9I4fcFSjpL73r6ohLh/V+uK3786Tpz4u9p1byZEEFVjn4eK4wBNeQ7DGhdbFbRTt6/9b55EBMfJGakrqZ4U+Fgnh2uIpidUcG+iBjHE5HMRX2ZKkKLyYQElkw/Kbj2w8OvDaxd8rzWoSUnwkiP9DB4L1FBdrrf9anTqNfPehHTBlyG9cgcQLrR8tQEZN9zuxs8BV1Zf+cIk9kSStcCODphQCbZP7NYhgTuqPh967gyo6DhJVEeM/gq2arEo3NkVtX7D7mzM4zzsjwEazeZbygY6xwP5F5NLqPJ0Hxncni2XMn/GdHQmTbQF1zee4LOhZaDlBzMZLsKXcJ3sJsBmPODcSW/FKYiVgzz7wLdz0C3bFpTwedWpIZzG+H0kpS6hOFF5yNj/xUGHEQK75qxYUFuXq2vFITPVf7aaAWUF+eBV5VbBqFcUccHNaTmGaDdRTdXTurKJ8ATxX0DHWz2qNhGP4nrYJRCKI12hvvahdfR6RlR+zca42mjybVuHEEGrU2KvnHy9+mmlQDH4jYHZKC6knkne5Q28ldgrISAF0p2u8YVTy2bGLZqUkIV6zWDXi0DuZMiQhOJwUgZQNnrjzpboxif7CaCAFdxHukA5fPTubF6aLOTWCnS/EP8ZSOIyNGpkn86BVLEgxNoCo5XDdJHdnSB0Zy+5O4NQSsoKdZzikwg0eSvXAE6j6WW27irlXjNHHxiuOY/LaFsSgXv62JfK2/O09r1DMjpxv32Y457Wd8wFBf9V6i6CdLP2Z9qNFsxcP88S7N6b5FAkZAkO78T3f4mpUVnXed/QQC1AAudBr+gg118i202+jHf4m1tBvD2iwt/8PqoAWQSajReU2kDJ91lZ9cqfgKVbzge5mUlKDSh7aeClFOoVz9UEdTQyNyjj+u7JaX9DWyqtt6955fcvBJF1aKEjjPQjYV4+FQr9Fnd8NqWavBRL91OUcILzXVselzvLQtPmmvtdhkUNi8G+O+b/qcVyHvls9lJjRGbe0YWtuq9zXA02yIjtBjoQd1vY0EmEFvb3u3xiPt9Wix6NZ7ljWQVbw229SAPrh/hsIECHTLmxKxWD3/K6TUieQeqJIfpcIoOQcgmvHDyyRUevzKImeikRzg+ly1+qSicz7hh/DCm/39Fyk6M86XNkhcEgJKANNt1matUHBPuMmqkqR0Irsee0uIofjg8efSzC4Ml6OzAV1PuydANODV+SaVqKrg8qTvT2ROpiQHqoOAq3EdFRo1QW+1ak/AYmGEVA4cF99A82GRm5mLHhLHqOSqBVNF5d+tjFko2morW+bAtWqE3Mhi2uYPJEeL+puWOoJaLV9uHtQIj2GvjqEnPiF3gSNk2kq1rb+v31DDwcalu1nsmfE1n7J39uQgliDyyoBoudkZrUtnIUrDsC6iGs/DA1YU+EpC8VYQ4iw91D0O8kJIRK0Zo3YzUzYnm6vxq+9EDAP5SWf+Eyupwlhcyq7rgfu0UcsS/cyy18bZBvpooyg1q0GNkTJ+MwtXBtDoaChHEqMdF/a7GjUgboSb8jHDJrfqRhQ/bbI62r8nHoOa6UgOaJLxxg1EhXpXmkd3Rch7uNxgpPzxP/mBdrGsygnoth1z7Q/YLYJb7LwpuGREdhP+ef4imi3CBmJrq9pWR8/s43S4uxqNYHUv9ha9RBACBhuz+S4xTQTZaCKSoDHnxC8CxGhiHczvJUTlt4rrWQpu9+AvsrR2wMvwqpTTd2ETTsO/P3JJiLBUvcs0TXCPCRY2h9Nx8ZqMz8XSEqa9ByDLoNM8PxxK/62v/Wkztb9dlxfHsl4u4UjIZo5lD7knNDevOZvFRYHhwFE22lXrX+Sffrt3y9R1DKaG/GlAPLQQX/Hetzpmce0TT69U3cFZSUWj1hcJa25OoCXx3O5jXSizjPu68eF6JRu4ly0GPmihJAcdY54LAu+PeTtHdGWaRfb6RVp9zxwP+2PoTSQm+qFhD5LkhsYuT1IwWLIAUjU9P0z7IOUj2QP4sYABt2vX5hJCVUnjOBPVGQTmwyR8LSRc2WvhlmD4DMitovW8AmruHvsuxxMnY/ybXB0f6jgvY+7tMu0sJN5r4DBEBXa37SH5PepbiAlY5L6+09qF9dbg57qZdXr+Lkj+9ODwIdoY9Ogs9QXAMPBK9sNLNDM1mFaODMVpqeBBx3+/X8BkyPofOmxl+kYJsG1PP50FDBXj0A4uVUwSXOnyDvjHd5pupMiy5DyOMVDjPDi22YVTeKKPxtGz5/wLm/x/DzHO4PBKlriUyR2fdazZ8MZwZO2yzm40RwLqezNhsNT7aqhOqWBMfTbYcyVtVzrROKLQ/cw8h9MBYgLQZ5m7RtajLhjAmwWRubbOysVY9+MbTxulvSqQymjxTj0/yGmowXOk8LorLHbyciHZbi5Wipq5e028xOnXPq0SO1Ei/BmXFCr+iw4toQwld1d5KXZJaq1eDPduqLEuVRpKA9CzB7KJsTTpdrYpMaOsIFM7Wgr9Oh/caoRAohQN6A6HSrmbUuxffYlS4ymc4W40QYfauuqpQ/JTXe2l3gW1vBU3Q0CQWi+YnGMAlM7QCe806vIrrgQmejgYb3z21bFn0KNZj8qMbtk0fubcrDYYwmBhjZezZtAK7N3MQKKCODWwtmN/WYEGctudKJzRB3xrBGIXPbh2oyOsQ4psvw2packPl36ulG2AlW5rvS3xsDrZG0jPgcLNOBZVquBKudvtx5EyYnivmLREWPn30cbkfL4RsfTwuJVSFZZJFh6UkofGq/bkz/WqbPwyDk8xppCVNz7JQstijvxEWrb40THMQJebLnzyY2q2jx2SLecaR7/0b676f5ddR3aDQqQxzS6YlPvFcYbw+8vic5SAk75H9CSsEorQCVlJSk7DU5HBRkzDnV2QtTJe9fsfqy1sQNBXqUXzv+3HDVDSjlHNPKEmNGm5+zlEP/Pa0mLR8hxOG5PeuHfsO4YAaC+btxGwKVWC9Se7tv8fBJBx1n+Kox6GyPB1SVukkNQkjh9dl8s6dR8uwRo6Ep3zrpyoDHwNvpGU0zV5/27gpveUjCyrt2ZF4TOPsS/WygLkfE2dbNXsNDXjU0kggbh+REnbrOGVNbeYAoc4ZX0aRdyTYOFzlRKaGo4MoHLkMH9FMwYlY+jItBYVbIzsByLIUmu7xM7N3q4VtOAzdBtYpwYx/5yTIIJ9yh2VZWg/uPZimDRgASUeaIeF/TU+n3NBLOkQvsf4CKuJi9s4FqpE2p0HLaw6yIcFU8mcl8Jx6XPWv+eL9Uv+Eyr1QVYQfaJcVwJ6kjFn9GSZ3uvbIxaZMwi7x+nNLp60sgdzogotqc5oVT+LDsygUDk+S361me7L2BWYFkcDER/Rx+J0tgDZ6wwKRu7kFtxCpqtt19WgsF6LzpqmDlLORvOsY68JnuZgBdo7ozFmFR6uGXxbySNeCvPKl92vkVsYEYjZ70nSsNQz9WiIy0pcd4Cjnd16gHVj3X+IIr+ZH/gTnYy0JQvVtpoQKA3yqTH8ZK5WAWFLSXjNeHCwtYmaan6uJoOWW3ktmR0n9j0uxSEniCHfobcaa4adhh6U65iKCHer9DsvpoFJxkj5jhGLhPSjJ+hLddzatV/1Ocn1CE5uZoZAMtgkhUYN5zk9+VUjJxOTjDsX8kQFan+fCSw0rK8IhXNp3dynfHXSYCNq076Pn60lpsgbLC41pl75UNjAtdkXJ0OFBP9SOFxYd/qxoACmCf2c4BNjgll3P8P77ikGQPLbKe6Bprf5RR7SLTcoLj+WEriYD+XvlnCQ6gwN09MIkc6PH+xS8JfJD7iyBoSsLx/L/1AzaxG7e0eIP2dxroERhpC6jg8arrg7XQBksDHIJZIPRhy16WjWaucMUOLtxrgBU9rezETjoCtMnBYdaOAagkVHdueRkp+p0+SRoZ4ejQaCwhOiYRYYJC7NsV73oO8dwYLioC3qILoo9B/eMud5uERJdTB+L3gaZcXObntZ43fegezhpmSwHyw4dM10xfsXF1MY5XAR1XmGR9Qz8Yrc2BSBiUUf1wSye1tGQLKtmsheBI0zWEKzJu8/tdWQ84lcWgnXo9INPwDU5XiJi0OyBQbwRH1ahR14L10g9kAYWlDK/0N3VzcgYYursjTtw/2wSHmfTGJsx5NOXmMmVliBLLHGu6G0jFBLZtUkH7EzFzorhlKhKRrLqXXlXpO8crQ3CHEcZLu9XzwCc9SvkPe94gxwonijdizLHtGfLLKLF1cdtXMFa7Mf4P/JQHiBZIRXBzCKoqPaIuvh7X4/SQdEJnxbsIECUF90ZnrLUpBjTXiX4XAc3Mse7eTXKyZp8Q3Sf1S3esZyDQl+BBER4PmbGOeQ+K1112FbEeyqQZg56WiQ0jRCUmP+Kew9A1ZxSjutLVOfkpuBwoSkP4RGNoe7WrmyTXKI6nk1Tnz0oe2Vm3PjBDf8Gwhe+fwAYSAjlPra1TtCj1uu1GcdIAm6ViQn9Srqf1ym9fPIxInLxt48mCIl6DSTi4ZJ+XkJrz2dXWQqhpSF4nNWapdIjJH+p1Opedufkw0xHlr4vORb9BCJ3W8vAPdZSqI7VxbNaaOfqhI/8w7L9horVKv7MLnEr2l2XgUM6+i5Ix58xgRlYVxa+ltEdaupD5yktPEOlldMIatEHTM9j7h7hxVvQPEbtQP6BmDdVaPz2u/o7+Aiy4lsXGE+Km2ss6828uqY4y28croxcwQBaemP2+4hEA88WmmXnQTmIMFje/i5qVzP/dynhApy5GEB55hU7+jPdveexxyrULupZB1hjyqISvKscuKXOXZUnp8dPLlTkOIlOhMu9t4Vx5PLPIDK0SdUiZ95AlS0+/1macnq6hXYYejgXigt9NePxN2PY9CC0HftH0q8httvBeLZ48ootbmSIZgK7/Wm1zqq/lUDZBL6CYC5KDyLg/WfRKIQMNyN2X432uLr/f/9AoV132hvDNWvIbdgJKmzFwnqjd8+MjwrCINW480Y/0ve7EpvtXHg4WzJv5MuILg89gjdMk86QRO9Q/YKdmb+HV6eMqRTq/oudO/E6zvH3NzGgHNz/zI4Clc1kXUMDTrnDpBI2KbWe//7iI6d1A8nhX4F+4tGki7hfsA4VOK83fdLmcdAGqQRjtItVXa3J7vhE+x0h3K+fVJpM2FZDdY7gVF9ME1rtQmyQOE+F7b6vQAUregqMnIegpxtIKRhyTvfx+DFWZLf+VUZHUO+CicH8sE+9LpldACFUpG+WMfE56X+8xIB5l+Eu4ij2kBUNYythq4o1kyIEuD1kt9XQ97gS9+waaIHokWae6jm/Y8Govgmk31Z2M0SBZAIeudbA/y6RkBys3zsWVHoPxD73jIs92cougppJ3Uxf/pQcoOw/qt20epdVJgHhT5/Rg5mNf+bvQ4LJnwSxs7VE9Qc/myZF4IFBUAom49bMTIghVW6RJ2gfXkP6ovc0THTEpxZWx4zTkARVTfH75vftaIkZptS+h3ERciwL+zFBfxojqrdRqqdkYWAVmXpf+ueckOfXPrN5b9eEwl8OJWgoXwyPM73RDn5ix09+qYTUbhIRquBAIHnO03H3q5TFdSXzP+sPDF+FV61ALiJwLttts7/NF2qhFJI57p4sixeZfoEtm0Dg5wGwPCH6tc6aqO8oe5R+IkDR8TuyFEN2w2kBdTxxvejaSoap3bQlCW4svakUIjVrpe7zCbbcGL0xSe/T3hysCfb20Xj0oFitmmY1Q+1QAbHJj3MfeeZfxuvYYoF7mLnb9sF2SPQEFrRwt08qapY0ODw4ReEM3TamVg4j3BvgKWWLIeWrMXPSM+I3hBzjUn6TbqMNWIPDWj5FBYrWBwXYB71BOpmX+5iYomjHoQ7LUcQ867QRS3qZXYnBbLy/FO2tEGfzE/rGyNxED2nvMySIIs4Fx3fZIsIZn/tCkocG9krZ5TWha4eDI3zmyCQeBMYsXlRDNsMfjEEBFh6/Qhq12c9IUp606kEY5bwbG/QnU+IAyJhlftn2f8iRL5A7v4R9oAJGU2GYjNHqZUGg2z6az4YMtQyXcV9X9WBRlaYnfVIRsmuVGDhDBIoG6C8AkCK6LdXd0NgeShgVCNpx7iacd6L5r4rVi1Gco6rCBwBfwyIJs4Fhnq8IZrURn9zhkJ2FenUPijnbIom4cDNJT3zqMfvySGt4ko2KqwoGDH25QLfuWMbcuRhuQwYKgCX9VgClxETR6DM5DNjTv7F3ysG0kI8NKZ5AZDzjJnJD4VVPwVR/fNKHpzgM8QQGSapVEbQCuiSw0xjHphp0eDxZeames1Mp9WwQ2puhmhj5ql1Lv0eYJEpN8RFa01yfNY0KZkTpYzcO/Ckhbb36k9esVXSMPl1G/K7/sR9Mcqvz7tEmdFwGaO02c6azfLxlRg6byx5y5aqHXBgH+N8X+0pGSjHsaENs0tEcJU4XtLrRLBJGIFVEe3TvIYkvc3siaU1d3xi9t7TPq1L/+hMRqojqmp8jBLyo7KEuYZeOKHFM3mUkV+XkyhiFhmwxtLgSsGMbh8fE6hCR2rTOIinlmsF74yj7IpViQkLbyCbrvDt5/yX6I7Y1abrFs7QBI3D9QnlxlwbgZHvFTKeaFKcI3NvUQFQURMimQ5M+eF6vwSlYff+7/cWpYmvPrIh9BVONzVYOe2tQdAWWT5fJSYL5Upt0L6Dl/pZObBEdo+FPC4b2+iU09eJ6vb/kc2/uq9CvCUV9KB+C/CPAJdOu7vq8wf/Yxy8081PEnm7VGsIzzoFYnDvfYTUyPhdXV2yICWljxWqkyEe4e1n+SZCRACDyiLTdzj5Dq5ThMdA+CNJhV09iM2iW1Pgf2XiLDkIpNo8ugDtNdVTMEBsO+uHzrqEI+EwMOFr2gevD8TkmyjvrYH9Bw6rkARUFwc7DRpOCIaACn2Edjv7bmiS3MFeVgdj1y0Rv+v1DYqY6EwHst3CNlpq6XBW7Q/fu+F1R20aHUR5Z1LIZ7wvY0E/w99bKzAyUjG7671ZUYF6F5+Ynv4Cm0twLZ+GTrBp8VL/LMeq8XYgzYldrklMglyWJS7iWBhdA5GraO3m3rO2AorN4N62bHcpIhG8kbvIkybnRVTEWt5a5f7iIYJN61OO1gLp+lMKa9CuaUR/y9eoF3/jHgqh6iPSadglFYQ/GTsLkzIXMTFtBelXwJHtvmQtoXItuOsLGvL2IK/M295YD8SaNfSND8zTfgUXGYQRyrzsPYC1cxWOto+YkW9R3EinZBFUy/5HWXF6WeqLcPADGeJH3U642mjV9hMqA/GY+7DcN2bpls25VizlGv+FyH0qhDmmd0gUS8y90rDX+Xk6y6McJ6S7gM/DYcoTHv/2NeKg4rjMw8TqrlL9LBcLKWQxtuJxVX7ObKDCs6fNlfUj6iRrGPFdJD+ziFknCJKgixZ5RJQEQZi2MefRmUYi5crYu3Oh50a5Jf+upvNzFAo7KhxO8WRvoqnLO0wvvdcPsaVUOIcvfZoUierdTyFyoxwnJI91KCBroEodybtBGshuLseewOL8RJP+H2Oqsca/SYdeeRtivXY+FFQeTQ33eeX3DdtS0+wgHXVCCQk/CkG/az4aY+ExO9eyJRmpeKAXose57USPZEoRKo6m3uIY0rsGhjw0xAS7X1DuBTFVuo29v3dChgu70cPjpl5/xQmrPdA36PXNZRWOszr9FtTYYxG7dHUooremnYo1QnUGWsN/xygLq9TDGLLhVH/pc4pD+15uGiALFzU4PINmfD25G8LAsJea1dQlpC1s7rkYJUQqIwFNDY4Eh0dawLn8fCol/rhUCEbEHM1dJlCBpXxKfm7zt/ZpsbXgy68nEkEoLjs9rk0E9GFFZoYLZv/4qZR7nl7qBbeALu0FWvdWoNb4hCvlkME+i5nbMafn9uVxxXlpXBlOxHA7IKvKJLMXQanWkuK9A+2VI1JSDoY06+R0/g5TPJIHfO3roljfhM9ncx6Qrk66xY1H0+2UgF+oQgm28A27u9+T4rGo0sT6suA8Jdwthg1T9gojZro33dFb5pubkZ5ZHchLzsKkibaR3DHxf769V4iImNuKKrpgMMK8vcvF4YgFx9Asca63MVyNPtp5+zXPASns3bwdmsxnn1S54GTdkB4DwX4L7JXMnQGqIaS+mPgWxbIZbFcDNIrMilEIEGFczfvcACtmReTyzqnpITyfsh5QK4RKX9ZWtvUy4bWXjsLYbNV7MrrZsT82c9cmf4f8I0sSYqVIlcUYgI782imxBuEKs3OWcogWDmwlr9TGLtVSSTlyzHUW4PU9f7Wv06gLioBSoAf5esTj3FD9kKtTKQZfTKEIOcCYWcfIk4IkcfoFGKSLqsHhBpBOTfEJ6dxkBJXCSlknDrb8XJYO4/96XFd4ThAg4/Heg3u5p1kP3QG2yMuUrty2cFQaT3cWMABIB2diEu/1KfFFSKbfjTp8aUhb99C/ZA5m7h8JWsGwT5Ml9Uhw6CmNHyRA15TyVwIsOH0I1tFeVqQaoqT7wGjyqrJ9bI+WtpjMv5CAGQfj+k2aPOJZ/zLvxAtkd/Bzh9BZPEwVE0I0DI82uWK72P5+mHKig5zbXYrQE5bSNA9/gHvSND2qLV3hLPnoJp5q/NeZX7mhb2aWf7qkF8iM4HEHQ6YiYA+E+kPmfMGabHq62QBi8sSJ3yb68iTcA4YT6f+gJb6G3adGkY9eeu7XQZiQEi2fXRSKUOj/zLkyh4R3hOAX6xhT1yCvCHT2Jb9tAzSMxe0RFbM3g6b/VHgP8nyZkt45j1ZYBTwOpQIaFU7nU5focNbiclNOds9b6I+FOnBXwyAf1ViJPMKBBofmR8wg+77g5o3CiYUzQ+KdNxUo14XQc58/GKrIq3XSIefM9azql5sX7KlTsU8DGT1HlHIYnd10cJYsAEHoN0mLKcHTySHsjTFesKWsmK+siZFXhlavE6F44mweXOrX6FBoELRrvIrsst4OH+O47VaML4CK/cNrjlTodfRr3u2XZsHCcw9kXLGX/15sm10DYmP3G3387x7LDyVoplrs0pzIvfcy41eb2Ob/wM6tQNLxQKnfSbL0eyYL+RWR09qeHT/lWpCFvcISYlmdF/jMaIWDyxE/LA1tguYOSiQtSqHfgqHr1n/k5nFhnUBnU1J1eys/8qySmWwIplgfD3uNcFHlg6trf2B11Om/f7E9onO53sWHhas4nNuhBJsUn2OjOnOAFZi2dcAvexHytVxIdybjHcEdXUcp0jkab19hwZ0RddTUGjtyulBmpbfGD+4d+oynTEjmMlYS/pfoCyhEk9XbgbBf7wtFs5qleFrCmB0NrUYZLxmw+2wFqYEUy2hYP3ZxY8uhRZeFXZfhOD58zGBx7lo4yMjiBc0zvOGqVQm8d4tk1CRpyGJOGJWVU4EpHPxqgMP6hV7f0IxJugziIEJHavrZauRXe0/THYEOKpl/a4jm/fah+oAzHRBqwetjJBSjNp5LaZ3ZUNQElZJBDOF1e4muumSHF6da394Cvppq45QN1B2wYBfbx4Y9fnq5b+heTNTCmP9XhMQGniDhmdhGzfPUY5YPvTUhEcaaA2ucNDUO/xvaUVhXDIodrM/05R31bnFkjUjn34N7Aiuagl9VB9SjYsu83Ws9eoevaZVwZMC4uiZko2GtNzZCyMHRq6GKhvEGBiM1gLyvMZk3eR2dGcn19YX72JnDBY6RWncG7lGAg0YZR9lyoCyQ13gtnyBi05gPlO9yOeIYGqQrhgRpR+pAvx4czdaBMpVI7SgZMAhMSsdPUEQ9stTtwSabBmrln0uHsOMhDvi0bNRUWUmqnu3eiLgzk2XKGyTaHCe59vZZcmDkk8aOO6pTw5H+DWALBPMcCOmfIz4cF9E5zesXbQkQNDFk7vlnAcetbpid+Ce9MnTb3Clhv0lL7lyusJYCpLpalVXmQ67YNR+IIDh9vW7XeWnU3FFfdnO0yqCON1josSLVMTTaH/T3Q7Y+gOUofDwwXaGyGRB+4GRC2kk7zANlgd7PmE5kXda4IpmTbP2OqUJ/O9EXW4aslQR5PtYy3tNMamtk4Lwzb6WIFll7MVBneG5vPfEGslblvK4unzLLIvceI6WxhiZNc/nr10k9nn8ikKPz5jmA9oC+lWIE8QR4XYTcO6WZ7VMORykmWLBbTE1NQc8/TBpYSaYjlsyOK50EEwZC6/hyMiltFDU/OcVfSs/4s0Rk68qJkU5mIFxzQcySQSzLKmqQzkbb2ZlC8MLMP8Tt/ui2UK3r3IoyOWjDNfAV+2/iYAbaU/gcEuC9PqZbBCpHpobrsMSJpIpAbdk+lZArMaQfdQP2kY9Krk6TsjNb/ad7Ghc/HTlJyxRISEoijGyuLhUJB5Ch35PrR1oibmRE3vvhC5cWj/AFFMlliT5ELHoj9ieMLEG0BOkVRUXKuv2bfaF8AdXORnzTtMfXYqB8UVY5TvybX4Mkg9YXaiDDrp7KV8wVHpmx3MIlmRkznG4Q7DbYNTZBEi2yxQfQW37NrAOyCP8AXP/EHi/BLLFg/ip1tleZLojlnpdzKgSmJyi4IRDWNifCtFxTRjzh2z9DNa3KUZLZnixrksQWHwp2gRkmuu7HYPHYIQrdjih0WnNb7CL7hFDLjbfGaVLQh5Fu7SHtZTqDYzgY4QnM/x2PC8v6+qmCAMbOvWxZOIxjgpUF1ud2/e41K1bJAXPTZ0ctJLsigJDqNH6fNsXGGXNx7cwJPgP6INK3Qxc3ylfv0L1e9m37k+CqkJJTN6MvvQuae8WjO1l0JvBh6yHIrZgf/Bt/DNS1QULgHfUCLdwH6GVXxn8JChzrTEJL4dTZGD6nCwPWD+eeU/jxNc/wph/HYngIZcSTOnA7ZoHemc7pUYXx0Nr45Sbce9CyAvFnCzoIYbXxoDXYVwt/7sf509VEfvoLzjbFrRKr4vntb5dgeDiwRX6neO0yQZsOSoVjVvOOSAuP4PT+ezKgOTL5CMeBFh5fTyCTneXHNexLrs1pBpLHH3kmt/Gi6938ByjJyGR1wM7/rvRQQoS1drQjQ0vefqIJKlavxUAyi0PuILAyGGfaeCzz00DKjY1cowpRuwwf7rYPEZOByjttnqj6EUZ84F5gZp+4HJmTpMjNq0q/lyKFhwHKG0wkVp5h+gESx82VKGR+mbao8YOh23JnEy+eNJ45yos7d1gFc6GC67dt+OzE5TpAYicEpe2YtuuIHNt0hQpdLBdS8eqx9D9RSrya3h16jYIp9Ogfv58USTrQa6bOJgC6Fuw3VSohoUOQpQ/XY+PVKw2eV8Q1N6yxzymT6QIiLizm3kcA+jtFVJVj/IlTTGr7Tj6P8fQmh0ag3AJfRbLs8nmEQ1QHGUtaUv9djTgKNG5hVLyiujHLL77tNlHcYLwqquU6Z2V+WMoDwfBiMDqK39/tNhs7dXQhQTHYkold5VgNmV+WJr8ETyoKTHTS8g1RZL+KCbZw1LZoGTgR6eNleq+XGRggG9pbw1+WcW0jzJpvQle+pDWTA3yPaJogeuohg7EijR/48Se6kjwNpGStelAHWNOtzrfgmNxtH9r1eSRWLz79nRNF5th43Vy+rZ9FcwK7PlfJojQmk6yDIgDVpS2IJtFflHkl2pdrA/ZK4Grks9dfURGUNk54HimplKaYEZX5dE2M9W/60vxTLBE6XeIZ01h4YiHBHGMX+eAHZAHpSk2dFZUbQL/ylbq8VdzyOCnwzB532xAsz2XqmJFNJCZ6YuvEpyZtLa07GuhPki8MeZUI63KN4jC30SSX7/bWpsMyfpqrzmMI+cCYlmRUB0Mu4kG/untuIlFzWG2JnuSThOvNB87WuxDF4K9MPLtApA2nPV+2yMqZtQu/5eBgMzg8/6FBhddJz3kV0onK4Jbo71w6dhI4czF3ksh7/wVe0vAH8B/pVGb1v7xscPIhg6KL+hvTtq6g1+kCPpBURUhkj6yrfPgZ3/Xtc22MaQJp0ouI8smF0IW7P8ZfkCNRlxyoz5rOlXJ2YoBYf+hZJACLpIW6Ecg7s2fptIWtvuAgGvGV7dSNLkYv17ghjkJQx6tLucnApd6V56PAKNj/7Yyi6MOC9uwvXC4HnQSolMT49c6/5ZRIfWauOyw+arQBxET3gqjgZPldHDuhPDdYxffuJ1ityuwa75OUwVzCfQ3DhhKAfuieBFYqqN1i5usxjNFwKad4V39gjt2wLjcS1yX59qz0LCyVW9KbSYU9A28hy5DC7hdtdQxRU9PX4vfg8R4KZzpT7OhJe4Rwnuob88KsYJT3Xdb5uQj/iI2b9k+IAL2RazReg2nxwi3ia771jH8mWcStAs1NJu+cMgx6oarFqLe8b1HSRxQ7za0WtQhVKdhOSo+l5MyUbO7l4rtMf8vOidRDYSBoESyiDirZR/lirb7mNwOHR9B00U3KDHjR+/6/p0FjHCVpWNOzJcWfIRQkZ6XmbdXoGNbYi+/6K31kVQSpEiFHlf0XTAzQKDh03BJv6aoldSXInQfAEINY34mN7TGvaILI1iq1F8qQD9LdUyM1y1GkmIcoViAyaqPmTF6srtanuyTM4L1D0wyuj0tEVAfuycGdwEON4fnsCqlt5T6S1obgnUutprS4s5WpzQgzd4U9TRXJErli2+o2bS7A/uISBZhgh/679K/zLda6gWtuZwAvTGNdCbAN9uwZti3Hk9kKWrIq/zDHz00+fSYLcc5sgjgY5sWd/F9nGirgGojICMTxUzGmVVyjsC+0iZ7i++UKuLA2KCekIgylXj+DAZVKUFgBgXYW5+1bwyASMUltB5MhCcaMuivyyhZw3MJ7OjjmJyH+sH7zwWOwFaztw+KQpl6ETunGZ4wgXDkkep9RDpXHKdERy5R1KfOfi61l4kXklOVi+UvIPbGuKxTqSuKxjgg5aUU0X3V/EKdOugbYyeYKlYTyfe6Py6u2Z+A0k4k2giHiUVqkoC8MKxTXxmChSs68WryAMhUxyo84ORdwTONcLdmrVJbnyH+ugmyyx9iKEPADsMijuo2U3uJDa7Wnfr9gcycQq006VxIwrhk0FV/BDjqzquNOsEJXdrimGw0G+JVU4/5BNk+lE5kSCYz9cOOfNBtbtPUoVHnu1jfPwwGlaTc7GUxPcDFnEgwaHh5znVnSwPAAdXz5o6vI34Epz0NKfx11wmUjfW8nTAn60/CwPV4XjHM2yzXbq/EA9hUimpPyH+gMWQc8fiEpaTtk7l1iADxvDO8EMdlaQ0nXdXnhCuCrsoC+Uvlb9IaXpTbhDyzTzYYUPRsJ1khYU6+UMPk1YHn7mE5V3/F28Yia/wrwDdF+R6TmVzsqudzix7NyUGk46wXs0WaHIURcZDicGiV7SEhoVNTU0zgBoaSd49LNnCcmSgWRMUa0JKdpcVnfovdDcIyEcqOXD4VeP1baW1O5XKi8DuZzNuEL/drafxlkHz2RIla0Jp8ILNn7S3fdeg9UhAx9q0+SKtkZq2KsJrdjjyAjr3GfTjVIDAz98414NxYOtS7EWs2ZaFK7+4WBYoC5Hkeq4b/TVXen2W5sxGUXGVbea0PfIOieEzqtacY9iZH8JBwrLvaO9mQx8S8Xs1qoQA5mRuhLUFIcDGMj1wJK/K+vclB5Bl071Plrpq5+L4WJ77f/haemR3QBDVN+DYo/NMMFkqokI7b1nRwuzDmI5dEx4XMlGANd6UtZZVQ12+CHjwiLfAM9yPWaei6wRjGbxBRZUWxyt/lA3BanlqVbrdSdMBG5p3j4Pa9sSfYjUr77zB9h2qpnC6V8u1+XFmGBTP3y97KCCHykGfB6mbCNng2OYcDfFxSp12MaqtqOwry+xB9gUkHlnfW9DENAGqcYOxFOWwZHAJEeIuPuyLr3pc8euQGkJA6K1rmHJDoeAl370hmHY+Wk02WBNr6bOj8owlbEPXZobBQ/xU4JVN9l2GH0nnIedokXyCvBiq+jOf90wECFhhyXgaKiOos+J5t5i72+cySCooSeyr88ULT2mwUuMCLDw9Pty72PByiEtatpiqNeZF8Kladg4jD+8iY+w8ru/PveAVmrABMft/YevFyzmyB1LNidUz8yrnolKmitwK2bPJrQzSfyMg7RCZtnj801QmxB2Hh1RdODJ04NYCR84mkyeVmLrySQsPfWBiZawIPusj3W803YTrCIFZh55a7RhYSAh5uolGsv0TMC+pfZ8CJFMfhrjIkPX4iPlpoVij0m+1EDPaObMhssohxiQLjAb8un88eH/6Z8SnJxoDDY9JjIkM28xe9G9BMqE8CdRizNqXF+yzFoq+i0JXmGCunk6mGwVz7dw0Aht2yZLXL1jgrrUpP84ikBVljLiJmABWcOUt5aq4e2FLPP4IYwNw6/6kBGhUw92jqGvzzSz2IXFoSGkFThCZ6Hdi95k3hbTR+UyOtNXxKf3qOHtoG1+tO5u2H6XvCe4OZ0IsSdV2C22f4X0XRjnoLI9dkAJcmaPzyLbgrWgj/dizWHsrNz5PzGCCZ7zywhZMyk6RrEJ5ucZ5k4Fosm8+U94ZyJFHYaHthMhJSLgoHd9plpggxNFeaBMx2BdSg8d0qM1P9s3xHTr7n+uvFsfU5qJafAkyfAi/gC+OLxCw0uMl/XJ+id3bpdG4VxQwyKvZaxCWrPaRHIy9KcdR43jv9jfykGUTzB9KjyF1G0SkyMHMeY5wgAmcEp9B8ffD92GR4FQExXAD/Rm70xyf9mrg0HowJ+Y5o1trz3gJx6Em+pGPt0PvCVSXsmyA7BLMqIiL8iKyvmFzR0O7FJPoUD5dZJ1eKn4tDUJJ4Umb72XTHqR1qs8KsHPpu1Bas2jM6FoTMyoX5aScTz2RVJH0xso6SkxxuMBg3uUblz4fj83SnK1GADX8ZJtrY6l5lrbF1/ZuSi1BShVAdFnfBB3Sh1SW4KQz2mL+Y4svWwspzeGp4W6pTFKdMDjOxHzkJHkAfLjLjqf+T1Axa9og+Cl7gRTi70bSWjsQM9F19HqH1IdJOoerLMQTLpuVpFU//G6/hsxG6sFsnzMJ7n73SbIizBrcriqJQot6sKe+uP1gONUVuBIPlDJA49atkvafSdkS4NR+zciAFrwoHjdIsVSJKqDxAVrM15uFJb4cUI1Z5j3Wgo4gLqLZDMdNtYKJ1P7oBTGSBKZGTqguAYXj9FtcQ4sSbuwAvEKj0iSHfGzNYpAzMhIVEl+O5tVLe4s/3uEd9Gsrl6bogS5HKQwX3XK8Vnj7lf+5qIQiTSzRnfkEpdxxgU0LAZG7OSxjiHkVD2gFaZ1GjKhIedce7dFUwac8qA8Ut250wwH7O4rKHFECWEhhPfyyNNFFWeFrcIjCB9QkpXuz0U80DXFirexggv6bCvxlzrpYL2A02HykHogeIIum14ATyzZnKSfKNZqYUHkFr6qN2/mPO1WK01C9CpwXcl3fLEficn+qMiFNH5a/JFJBAF2ZZWJ5EP8mGzPCF9CDlr0z0YHruP+6bAUG47CNw5yDdR0WDTjq/DqDE8W+/fc6iTB4r9945YbHjR76ZqoOFAkp3KnRniRLdWK5iKvLCCH/Jf9vzHnX4LfdHlAiEucOADd6aaTJnMDTB0DnLoW9pvA/TvJPoH2GYOwUyBgDkGv7VLqRPzjz9nIWylnnWqIlm7L9YRAuucHIleKaTQCeUrXP0Wnyp2nmBxzeDiVOPsap6l6MYLHO4xg8HBAK3J1dgvBpIjcYDKZexJV5mf8c0hpw5ODKTwdkKCeeTezcPXh/9nI/FlRcIYy8sH3nKCQ0EEucVi+uinLNXGTmZXSuB5jYC2k1R6X8FYDLSs7G3qg+Wa30/SZZVsN+vbIWPDRqs9HMz/V2eXRrxClGwzMRZTnpwuqrD1GTjLUluOf9uPygJGxe+/EB6Ak5UCCsCWe2GLD5iZX8ywqGyaP9CGKOOsQ504tSVjAMPPpKo7Ex8LT3xYdh4QReijfasLvMKd8/bu689y+WY+S8IO9LXV7KYzmOOycnb7imsjeiBPCZgNd2Hd2fLIQOaLorPkKjFZcGRaNO6lp+pBPTMvw9QIbYuQZBlhu48VmV3i/3Y0m71BChUWR3cdNSS4D96YC5J0Y7ZFqMHBW6G9p9pf1EMvsoq2dzX2wSvNYXqdP47zyePLrk+nreb97cBNao7U34lHDXeFQ+HqT8XvcE26g42SyQZmHFRlH2UZ0kohpcgm7Li2wAo0IHMre/0XfRV0HtarB6og11KC3Z7/RUcqKzEPA7ZEJQgZNgBZE02MFT702HN67p516Nvqkm0Gjx83wQdQMeqxlml8LDK0V5SdTdnatEK7C+bhiQ3CLRBupVuTeGYhJY/BbrqiE1SY1vdXZ2SFuvNbcrI6ErGJV8/qH1acDEtu58Cm9IYXlR4R//8FS+sjKjiIPcuzVQ+9bV25MODrRYTzxFJYbLhp2Um/HKOncgLdKHj7tOrMZfxR6CrV1qRAGh+vD5dMMDkqvh3RtFI8M/B+95gOm4879zLjARkfVycAOqjJdoBfgWjWNsJnafTkmc7B3nIQv/Doeol9zaGW/DlpeEHHLSCVAFpPcoRFbXqIB0NIfCnsKcK8GmaNVe1S1WmDjR9kV2WjYdDpu3d+gX3edjZ363f9jQEbUhFXtuRXOQv+gmYCubqBrqUoagUdP7xj0HIFEZg93/KZ2CrZfN9t0A6WcpUJBI5WLyoLnqf11jJxzi7XP7icTGifXh8HPdPwOvmb7A1BFcfY2H1yrgpQ9LL1WPc8f4dqfuE91BNq8DtcEql3/06rGk4gsNyWI77GnH9IKwUsAFlrpUmA3zzUPojorig8/2Cbd3TjsCKM9wxliCLyKPngKsM1KFkqM6bMFtyxYYrU2eewcxYM6RkLIzuCbt2tjjkrWkSVoIS5lGaeH9ACsgsCD8uBJTg2FG+jOXwTTSCvGIWOiSPmrIKKcqEISVvUcMWhHEeUKjXTMdtBmPl8s4WipwTYa2j7rmaa0RNf7IXAOT77NGep/q0h0KdWRo5UPERTufgAqHgtum1dZEPq6OH8ILA+nokd8MXPhCko+zgkNqNlrLQew5ugiVBI+TSaF0+Nh/0lIpsCoBQWlDacVD+Vx3x3aSXTbkp6URafBo7r4W0YMJYL0MnwFM5mzSBvH459mHAZ0yzT09dEXgjVW9/ggg2LxRO6yGo5FTpGQS5EwMSjG3crtd3U4X4CO+KX5W46TC5B/X/DpEipFhWLaE6rpYO0r44KwsS9Ge9H2dfFY3QNvXA1sWHN6WR25HgQ091u/FmxcmTXpvXerH0b5xRi1MwmGmrK4ZAT1TapoD8+smzXuW4xfFWkVDOL7zk9xNtB53A3+dJrIzc5OTB601UXSFtQkX3hWaSnhB0fIWaxp9w7vGQDYtDAeTTDigrLMhVNfLUpJcIxhrMjO0Amicb+Ubauev6gApJbByzVQRTWq047GGRSYgxukHnlk5+xWTYTi31cQQCJ9ILZRJ3tV05M1AIgNeeDW2H8IBJqkzSl9nnKSajGYOD7eMyjHHWbG4SEV8CvAH8Iew6SodPSlX4spOyb4O8XdYQ2bne98jMMolgBIbc8j1VfPhmdPcqVcmf5qMjZcC2VzGSMF9s4863hYPVGq86Huy5cmg6zBz+qDU3yje9vmEr3yJ6kZhF5z8UdlkJdjq/581O9VuCR2B3lyEAfQoUZot9HdVILawreyRxAy11JlpE3UoO/fi5/5omkUs0A7Gvb5+bsteFVIW+9l+qR2dINow47smAidv0bLLEr/yqKcUanjvixyzAQCM5CVzq0r7rDR9M7wjLxBq9eBWRVmyK9TfSJqXHjL8T3l8phqzWGZrkRC5oiPO6C5Wf59fFDP+ituUaiEqytebX0Feyu7U5Leql5gBMTdDPsmK7KUOyA5TuWxjGc7dN7kJKEYpro0VWRhjMArMIGbutu6vN2OSHb6nvd508S4Q34uCRKu96bSAD7YHASNVhzXv8N8jroYf5Y7E9s4wTpkvo3BZkkWqpF0M1vka3jjUC/JuZvw9V8avX+D9bciICl12vr/bQJxDe+TN9MQwDJwOe5HRWZKtCtH/1/2brHVDE381FF3JIILjZf20UTFL4MLwmZtFv3M88Bv1x6hEyoaAlZ5p5QEWzlw8bJBt8orARhiododtduYtJBSF7octT9JzbeKdozaif0LBWL/u9RjbeVNLZ8UV44Ye6Sz56Vn8QlwftWL01WoPryii3ZZ930Zx6Ins/HGvGQmHAD+2qvuKQAs8Y6ublb+Dvhp3Y2NNMjsuzOvb6m4YtkPzbhlctKadex8tBQuo0zhmSxfDIZm5VnEDdG2vZ6kcykYFxgAz3wrkVyXQnwxyQIeYMIHQYT+257jBWD0yJIiC3PqmohMzTC/65XVgSsowG2kgnlR7pYY18nBQ8aVfJ64D79rH2pymM4xMU1Zk/OS14XiDcldhO0c0RhQxiPSY72XYxpiaKVYmzOcEvI1PzQa7+LVZ6pBIwn8ffWvhqa38b3IskTs4RBkYs9i+i9/AqdAQg2IOeWv2fuo5tEcFyefI9nATJXQchbBEQO2Cj3kaBe2X+81o97B22kYSwjOkgZybf53qZFQ6p/N0dL/VnuL1cYTGi8k6rMpkKGx4j+Mc/fcHUVNXTKhyO10FkvHiN+qSbJGepJ/aLXoLZ8RET0Bshv/4hAQgzeS7yl0n74cedqdnmAeHmQ2CyXvMM0MWpEvA2ezZIKU+WvUSaGpTt1kvMloerqnqxHLfT01Yh2n3iD29EWnrQsyjedi1I5SUgvQKBM9G+oAai15cO1con2QFz3UK7w7ZgzM+vPmbk2QqR87fzlbdTSAhrLXzqVfLnWBA/4+5aC+0BRMZ6iX9lH3QXtKU9D01K3HprdilL456y5lsl38VQaMbz9hk0LgquziMY01Znz2WE4ClHG9cF/e7stVmn89oNFUE9NZ1RAc97KzDEWHLoKwlCG6L20/2Gj7/M6PDhsvhY+FMzYRg+v/0jo2gPT0UTCfaLBDRVvKQgUSYPMG1dr6ox7ohepBUS0msHq/V7A6Y9WfKDgSLatqTzwhOXnuXAoFc1LsdlV/Nv7XHqg5TAohZGa1mOn44SyY1fyPMCxL1QmxvhBC7mxDyj9DUnBpbjdAzrBW0mUzZ51brDVW3f0A8oKL6FYBf0mwK6YxDMJogq94OPgpZyKHKBYvJXMfs6u0pYnEn/jPeTVQMK6uY9Egww5setjqwdQmwi1ea0/uoNw7QKPorCWZohFt4VB+HUy/ObjCDdxryIg/y0wXGMwFyftSyf0v/ESOVaUNOHg1aA0SQ0KOwx/oqBneMvSoxZc7SqvQaHcx3ZLg7I0FQgQ9799KuVGTfGNgWvzIMnHqMNnCyCLJMNoNQK9XA4Wkq+6tVuCUREehKj+szE6KlaSwgAPfb6JeGqIyBrjJK/wNw2yPaYB9wHia3A56M5r4OplAvdVjO1vrsc4I8LAy1zqqpo0yM1hfixHeLNDG6ufXaX/4mWxYpqL3hBHpPbnox49P3jj/wGgdZFaJe1JTer036xd0Xak5qCI6SV86xqAdAChv6sj7ESw0SU7w0leCi/08lfYfucRQHdzjO3JkA7lvHw0ouMCSCweP+ms5HlStT1HLlgQ/pkLQ0HiDkuoPtTY6fDW0UPlH3ebKJKJsiIlEwAnWQ1ExfQhfs1IRdbEO6sgyC7u2YqSye9WFoH3s0+d4P2X78UPcUsRitbiSflMds3+5ixk47wEAbwHOouv3l0AUb9zZIP32hh+8n3fJx3LXT4wqErJXRmufydvyJuKW5IkA+rD7B5y3hJGUFrf+je8x2WEZ93MMZZjKF3R4hY4E82J7y0z9znWEXqtnGce0dejOBkrf6CbP1VCh4ixhRvmOXO9yA0A2XQqeWYNfk1eUkRWlybRDBiE5SOOtjudxOpqC6Hv0XRqdL58/dsrEItVoppvb13l9MrZRKzOe/vtw9JP9aAkOa7ra6MbT/3YE4LlEJ5ticKWKe+rOGibg+N20Vx6Vg7J3byZG9+hIpULnZWH4Tq3LmlMA+oUfgAbbzPl3twbDuQozSElI95KSsXaBWevUxIWPQdY+4eolMlTtLwn+51SP6BWFEiioYy+r2Rza4OqKJPMbx7t0CZCtpMKxYQ5JCowbAH7J4Y3Eh3C04j1H/2a7qH3cVo01mg0KjVVR59qENmLLCnQ4LNMS3i2XshEK7QAIvi4D+egZPpMUywog3s+tqRiaGXIEMFp3rd3TuvLXVT9tpJGxjgQLGMKXmGL1MVjoN97by2NaOn0JoIbOQqeBIHTVbBYNON5DD3XP+rStPIfVbuHd+90TJpGh8BlfV0dLneK2wDMnndVGVvQLhvaQxu6sL3XsvtxmQzeFWUSHLeAlmTc9yNQKkXtOJWS9faewS8yotiXdJQ6EI1vpVOHgh46gljSllVDRx9qlH7i2QFU/dKpaQEbpAFUBI/eSUGbpgT2ORGcUGXXDWjQJQo+nCkQVnIMRUCP367os5Iw4Rb3LDvOi+/mwcBozzUa4WkjVcSIURKO3RTFCiY9j3O6C5MBS6Y0WbBooC0nOzhKxL8xMIIaM/tnyEzIdlABrz3f9XlCiQ0hh+C7/bNp14eUvnjcHWjBOSw8E7BjzeXkRQkpIuZSOriwZ8PiOLZxCkXFOQ4hbXa4Tu69lccJ9Hd0F1lxkg5QnAhhfx5WdcTkBH3SibBUMCLPb/cYypz6s4GGDMV5smYibldp//j9gbCEhqanpxLsoexOMik4SOt879z21iz+8V3wgG8CicQsmxcsqCc5QUqOZhnpO4qAFgzHF+noxN835P4xf5EsOcPvYWwtzK3WEYVGy5tuvxE5WZB246SGIDgeC4sMge0B4p70Tse4b6NjlPHW+90GmqnySqY83r0ilaew46qmwi4RzmOcPehbn4YPCoISjQ44RURV++dfU53vcKhkSj6cWuh75tdSSUNMysFwoP+lN2gGTwxOfrha9wWxDPpimhEBVrt6dcBIvdoUbCLTDQDZuUOVVhZP4sATqq8z7Ai0STnGxzKmAHG+3I+/tvrDN/OOTHwR6W5aWSRj+M5wmS5hfdvimlus2z4pE6RV+l6scSEX3XjFUVgbSuuufln4qZfmgBxNvIZmkPtMh4WHAtuqRVdgDOLksqdhjqc9jrNVpRsYL4L5fXaKhNXYNJfTorxbaoSpoqj6ZEp05xsc4y4Qryx7BRs3iYvuHRbCUsiCPmmGdUPXDn6H7woEjiz1YeriH6NPF5au5aVrtcw0DvEgLLKMuVq6QvzE1mu+x9AFhhIEE3jVvzGWs7x+IBGJ2hfG8Kb57q5sDsPmddrc0s2doavGt3j59SpKkbETAVxcSwwHbpAEsYTNPM1KhVl7EPpQp+gNotyPx7hI11xG47CrYE7+4xlCFpaDwvf9FWescjE9qNrcgCXvSeme0GAOo6QjsttWQcRguwWZb6OG1VPN2xZcfyUeEGLHhPkrziDDf4SHNaCcXXJ9CtFdyRMVueZNWqaoSKhpFI91MMLSXju3pGbSzJlM8FPf/oxZbRADvlZZCyb8fbb4mQVBZZ3GWV4hj4PCrLA1qQvEqs9XLsRnoal9WaSQhWRzLJmCurnGGRc6wxyAAejp0pAR70k0M8R+ziXphTbSz5jU2xp2cFe1EhegrqPqjFAtYWbYwsm9X969oYf76RSVpD5DfI8iDfFILBkfvnZaZtHikQ2tfNY1T0QOYafZ+dfiQjWZxqrDxXDWbc/jYZSbOzpgJ0HvC9wodOgTk5d5d9dmNrnM0LH8bvtI4zgktUZdf/DkYM10EF8yMhbFqvpMTi+TaLBUNd9aLSzSGAqu41xsKxsEYHFPhxozYZMPCafc4U5t8Ja7k34czb9pTsN2JFnwl8AmZSpI39KzBoEcD8fz0CAcio2KlaDIhPF8V0HkEbwc2c0mkpBazhOMI1d4cxnKG15nlJ+haP4D9g/H1z7jIEHS7enL9st+r19iJpqLFuJiKD2NT7LXyBzaAcFxIJ/fo4roeZSvHUyfgqUjSVcPiszEAuk4Fgqjxih+ln6TZW8b5sbDIvrB1Ul++c1B63XbFgHdVJTaRPzIXeh5f5u+QYvfa7pHyQV0ZUIv4SnfFMvTC0g0/fdaaBd9rcpxu/CBpbobKZgCIyVRDZGdPlZs8UGyu7+Hxb64E/k0YIIyG0d7ZSIcU1dOwyAQt25Ow5B4W/oUhgU+Gf+qB/Eqf+V11+GylEkiyGag2sSabnAwgaqTr549u7USX8FH6EnKLv1g9jl2zIU7C6GM3aeDn8kP+9aBM0Agrl165RV4/UHaXPnrBjs3YOHlrMK9jziNkwwt6+rC5FPPvSm2uVuOQouD4+Rk/8X2VoT+8bijB9PNpfsOsNhiSOVgntu7dzfzJItraFExs2ylPt0vanTgZJP3SIxPvZsgaDSBNmxIh0KPLS+EZkJ1Xy0gY8WVOZDbYF9v0GJta6+GUy7ek8lisYumJ1nyw90NF5n7L6H1aFMYqA/WI2COJA7pWaf9Ugf5pniETIJNyNXtonwZOLeCG380p2a2m5Fs4WDJIbVCtkJ77ah+h3HMvJJ0fzW8OXfnZDuzbWB935lP5zr2+vOc7CL44LjNt8p2deJJKd+d8n1mwKwxWxUjkxJRVlpIqwq1a+Sfeu1oNGDaOXyS/LVoiWAi4/RFFK77j8sVBWyTeqc13DCYWKdEbHTgEcIdtBewm3fvU99V8J4gYLJijdis2O/D+3FBz8kG/SwAXwjzKgO1TmXuA3syLPxxfnEUxttkUPpzQJgAzcN6o79tpHr3QWX3TVy4USKZJPX/G7/sFv7TB2RKaM9LvG8518UTl/oNK6/mqMpSOqsv0xRVzNjumgamqz/e3LG3e1lkrW5SquqlrDJIrN90AProjO2hsva2vAv1ZNPbHVfvH6K8KnMmDbXcZImS+YAXafdXLVILS/Q0MSKuRaLPQABT6AsH1SpBlkiSLXyhT/gT5IbfD6Z1Jx0n7l33o2uGW4lgd8BRn8WUeEHBHEn2SCXVQwlREQtvN7iSC2y8qSngF4ytc3vgOucrGccauebyUn9sdKmkhMom+XHRGLg4yr7NW/ZAq8UDCTjimw0unj204NYoihtZTNdXwgmCpqzA6Y4a3S/braI7FEXELgpjVSnB+dqkyFq3Tny2G8lAz1OtN0TZdE3wgbqL8XtsE5Ut1NayTqmPNmEhJVC0f6ZfMop0HP5VawTxA+lq1XoeRAoIGH0ojuV+9O13sh2V2zoxj5jVyNGuZDtqZVlEeSIRI05PVi7nZfKw+EuT5YTkdX/qnx/AmQXABJR8mEbt5A8Oab2RqMdG+P0zvDI0gODnGDSO2w4ZOrD1zi5LnYaIljibbOMhpDWcwsd6Ry5eUmiLQ24OpaErO6a3/sYLybm9xOJLqfn7DNg/5SKBxEfKNyyUYP4KtkSMQI5Xo7dHcIhqH4l3CRK/gB7WtFU6bj0mReNJIitL8grYbUyZpqDuMDT5s5WQsWjOEmRSbMiH7HIkEIPvRu0WxMnRCJKjGFWdlKGqK96T7jlsEHCjsPjk/9VEQ4W5qB2tRAFGJ5YGgbmyYxqxGxduvkNdd3IZKcIbvtEtH4X7aHeyV4Dcn4wkEzUNRRhISM51Av5I1mwi2lj3DP8d6K9iFzNVDCSb+eb9pBu+SEqYrvFC8WKSi8OcZDj50KV871120hgz6n6OZy1KOh8OzKNuCKFt9mVlUfJKzD9gcuL53q+oTHGGIKFz4+4/zLC13N3l3y4Fn9dzM02uGyBGoJXmF3jrwW9OguOsh1FVykE1suM6kC/e005VRngkgcn29tixbfGSx7k8JzTId+5wTXE1HgKXCtGlwA7L6FxS+RUGGP2az1Em91D7THACjjqlVdoDOltQ7Yb4S8n4kG/m/CvtFfQB0e/e/JMgICLGKds6v5THENB7WYOdJ0P5s3GQzdbeXjUAG5Y2WCUBs5LZ6xDZzv1L7jfUHqBbmnHW7U4g+UTYB/tW7B0Ya0JAbpzWFSoVQH6CbY6q9fM8ccelwWdxeWdjZm+TcmBAHpje+emw8T5mUgl7Omvks7D2xk04/HjynzVyBN2dI3dBgxTkB1keL9tMN0WgyjY0ddKI8pigHP9lOa8hb7F2bZIa/FqS6JJPPHnlyPbVl+weIG7j4ocmWH/OkvaT4qtcbnafk2ocwOkjSqUob66ehit1UDMwKXreD2R92MZugTHNe/PWAZesANg9eBbm2p+4kqK52j8MW3AhqaffDN+kK195DUM4FLVYm8BQhOF+OWoM5tTD8LImCNRenutbU6qRxpaMDXCBU37/K3Y7eobcg/IaZaBuw44FteI67Hdgufk5VqCDjlK7jDBUtVq07hpPI9ymWW/m3nNLQlusNGDSBNYXOUBDRWNnHira/1eo9GEwVgpXn2tG1PUUxT15p/fbfGXCvpsj0QlzwErC0ge/Oqlsh7E0QhpqDAcvlBJOiXDD/bv01SkM269rmghWHJPUbmpq4trj7H6cCMXMIwWgOLaTXR0w3tamzJpReC8FXDNwkxSCbmg/ag17JdPyptz7mR3k6KvXor6tFCfEv85TW7CDWLEap1AC12Ym+LK9/CxdKPnXz9Qz4xNXGn3sG1wAfthifQfjDyiCnLo2uhuMzI9yKxH4PUTt52mReMLmnHFrrLpDYcPC+cU7ge55guYhGv/ANB92YzoXrI+Hs6gdXnnfE8GGhfydGwvKBKCtpDecGnu41Mz28j9/LTVtSV9WZEoxANMgPGo4BDbY2p69ixYGQWATdyg9TRDAK7f/Lrlubat60yuVZ9wcwqZ7NBP71mX6NEgdvfK1EgMnkZzsDQl/wWDHdAoOYCo4pKwY5I/V26cKTO4aMYcV/YDdgglOtas2KtIXBJAcgotsV4YfF+CDN4T5WdX808VdXh3/UXLrAdcMDF3QIXj1HyUHIOkXBH7DXICbJt9eNiowRXiuB0d1J/FqjPFe2IlNdXnwFwpRusB5PLSv0Lk/AdI1gQmao8wwLmnoh/L9riMbMMsWAOI+5B71d+lGTKlxx4hQn4ixRfedyZUUsRcpGrgAS1XqCKzggl0/LFuyQpe9BsgvZGkEHQ4ELkl6bcLtiHZ+7uFxmRjnV7v8PP1Whug1igIT3OTMnmb/dGJPuGKY5fRdvWoatxfNU3ABi+fY7eHiPqC0gQDpAC19twVfWBtBur+ST+y7fzmSE5Q0C3mcp8/31XIdqm7sEZJHtFnXBgaTyG+fWRGAY70K10IBvKH2TE6IMzm1k92/Cn2payTupKTtojgP3uaWIgFVgV0lD0WGR0PanqiKtrBFwqznvb/rz2PgpSjWd2BESLQpxY+6tmKXZnjvY9xfR12CQ8o/aKz1t+XxCSzy0uE5f/kaFUCrwxjL8gT7SEUJshp//5/yvPFJHgJlgsvXp+gRQCSzz+vS6rl3BhMsbj/HzwJYz8GsWppOQDGVswlOHEaFE/qhImhDrt2DUfNxtt21GW7KwJRn9/mtYIjlnnwgESPEpwoLyTru3SsVGzRxnZG6x+BiseUs57lTdb3H8KG7UPeH1SSjy9wZHELnar9x5cOtOR7lOvyjWm4Ab18Q+qoMxxLCFit0V8SmOu7AU8XGY3eSXb6Ly+kaQmDkRlOstgmcj+rD34KNz7LTvLL0O1Z9J/nCjp+1flOFgtbd7Yg0t5eNrPuppxYxJfSpnJRNL4S3YTffnV+x+zVsuioseET/On2wNi/TnL2rAQIKswi7Er3Sv48D/+PLsa2WJOSk6DqcCLmusILDiz0FwKEhMewrxtNyM2IAE0/6hiopIQoUgC6U8CLirhWbfVibSnCGZlF5uywIcaUlcEaYP/evokbi1NSquO62XNnWR4+fB3M1N7LaI5pwdHYOKEjg9OaSiTtEDypKGOVxZhdQS0jEvZ46foNS4SBpwZfPn60p6pQldNUmimhWeU5LUnEpZYjPJU6hmAsh4AKaLFfJANrZ9ou428yoEIFuiY9UgOYkqtSUocWxyijxK+NTtuDdbh7NJcyLIl6CUBWQjZiL34Bk0Qe3vmT9tpIKus3r5CvEdEu5Va2Wxm8CQJT9bESzuFBeH0QIRybKFAUVqNa9tCXukd1jwLXYKWsuMuFda8R1UjVG2cvAZ+R3lBV+nLksL4Ti6lubX3hKFcSyFsG5rK9pJt5nlSGIkBLP/HFqLL/KX0S96NdOo4CS+GYPBk+lBZxz6Yie12vvUj8l4t1ik/5PmvbLOTPCcaoPeZ7APUQIKIcxcNUDin3R1okbeAUGwt7Ja3G0ntQokBhlajisyXeqbfPLrTTKpTauclKp+DGdyBsbzFHEYtIqZnlLe5wjluF/UID6EgwWPGj0FVKM59Jom3+0Y1QTb+IKqHZv/0FIEEuVItlJHSixdza2w0UN80Hyc/eUGv6SBybC/EEs9cOcLBR1eeQXXe7p7hfIhtxxBrGhk9n7jom/4LXF125WzPmMCUiNyE8iO7sVSmRf/iSNFBveZWGPeCirfJ8a43fk5jCfA3NPEJyMAamu3Q5im0DKo8aonWXtye9iE8vraixlVTAGSXFMjP3+XiOE9jrnXTDzARnt7+9gvHctQpaAI0za6N7bq9R1lb55jILwmx4Ih4OA0K1/Xx7B9jytPFBRhEO8xqXLhxotsIRjnGRvnkMK/KJ1YhE9T2mNmclLYgMSn+7dzik8BzoHt+EcXstV8yNpTspqsnS96ATq3A66NbF449w9JqViBt4gWi7yVzt3kR4XSJ8iEB5anMqG+EsSyrMQVv0sMeEysGx+yYs6G2xPJw3zqTq4RzDQXPhYra/VMlt7E8zzl4D7L3HS3kkWf4ZkmFmnjcENPQdkmohl6p/gqkOg+8McyzNxxb5Fl19DsSr3MTuSMqhSKDn95ibzYCEdrZXJiKaqu7BFBuju+jSObOPchog2IsE/u/3U/UK2mntvSnD0qNkPYoRTskBnLJ3NJamL0V4sEbryX8NMr7MKMJ0+h2+xMKY4KERpvUrd0c6ABXWHqLdY1QTugC/5dhdoLy3+KwgG5FnL0MZw6qvOvHkKQRoQrcKLuwUld15s05QxurH67A9eAr02a/vUWNBIgP6vOa69ZZuZKElWttIerRDGIAkZ54fw7HBctSZtfspPxaliwbOEH/Laxot3ZQonzvXknSVodzZHA1Jw7BcNRsYvl+KJ0Y6pMRPpIbaN/QSuHtnjUoej+vlVhq5021xMUPKxCK/D8rSRbOmduHG85/JrIimgo5wXWP83lLvRaxwCxeTGVt44fTUqsfUARmQcS3f5DbHR9SZ4nJYIEvcCjIqLezJ3I6S7xBop57j3ZyMQX0Xxr5mc6IUmrlOXM9fJG5iDZQQ9rWsGZ0Y26GzTAEsD6pjPuDa1XAT1MRpxyZ8zN53sl1YEV0E0EHvZqcnBnqMTXRh6zC9PwDXEk3OHs2zLLIjBhY5+7lDxp1X0qcm8XtWorat33mUx+kEDDgaDUdpclQq/ZM6mMYoF433nKbCKDxCozugSPVaRjNPosMDy8FujvIJSb763XuBGBIYLS9x+HZhYiUa9xod0xKV9aRt7yczWWlLgfK8qn4fULHMBSP48m/wTWfDBdTH8uDAKt5WM033+2bCpxDhmZtE+d7XP65yBTOf9/EWaCG+Gs9/5kVbWS0JlfoDH6Si2tVCzCRGfV0XZAUWfXOMJ5F9dkMagbwaeqVqqbVONDQGg8zID5MUV7IkazdAz4JLOXsn1RuZnoZNIGV2Na15+dRKYUAmXFmkWBJpPMBwT8N4bd8VZwBnhm3WzH9S0sbpoP0sgf2OmPvQ6smMyfkVK+OLjXYubmtioAhdwDb5/pLRg3PGwfHEz6v9OOe4AK8iw2cma49tV44In8Rc9jGcqSQlFXPdlC8366ke4U/ITFy0/SQBl1vWvGk40KycwWGaLf8cCtEi/4X2W8961i6lYnpfNQhGcQyC8s2oIOW+Pw545Thq3ZBEyNC8YDr/pzCEmBI8U3A4IiQJoHiD9kUMNd8wfzysC2Kqc4OGeWYsJxmDev4Jn4HV+vqpgN6xxSEMABhRMdTteHiJAgnQEX9BR2V1sNqh5EcMvQNYYa5+bblQn7Rli1UFCtQkP6ECmGkxmPNkg2CGS2mmf0/WEuTZSyPMtbbrnftPgleOmJ3jSm0m1EU9fQHQo1NZti+KczpJ8mSYIVtXzXh4rNJcL3Fm7Bbftpjmj5UnuDpPk8HvqKOj2DGJyk4R0Md1x7umiH0DTOXaLwO0EI94k7n6R8nfqiwekgUQZ1rRek0HViM5YN0JLWp4f4NRE8ErcGNSHZd58+9Kx8lmkc9ogfQmX0rX1kB8QQzNbH+eVDee0jOQNUgQcew3y+0QbifXrtLHXDIxsqsej41Kz7vfcQRE1zUnY2phYNILK8a657zyHNMzPiRhxs28s1JX2kiCMEloubOXnc8BzU+n7LM9wztf63eFWN/eWHXVivSdCWg5DfWsk2CF8aFJrOP277QEPdkWlOlewCVEkLjyd5wUn9ZzaKOJKnDQDLfliiRLTKlU8TOeQj8jOU8FfpM9tayJTDpxw6sVlZuJRAILfxn+QAGIB/W1FGDjuuVu62hFDBdvzVSfge95Ebf9pclp0GrpV3S+gwBWn5J7aGiim/fRyIN7YVVXJsnAnVeq90vDdAV0XearTqjT2Ck/AMkBW6T/ls/6VUVnFWs01wxkahKR0tRwyLRKgHefm3RWie/pTVQpUMZw+/7ozQSW+7vuZd8lsvT1iX5rwlpiaFnOnDbHsr1As6vLETd5HVbcBCGbJHcS7ax9Byd50jdYyagUtjAaHYX8ryyuR/bDkw1o4j8+hXMfbzy+CVmgrfRDyl4dn+5LxrqRAXLoDKpQREAHqdLSsVSJh1s8KnZ/SsUVq27cq+O6LMSBmhT4X3E750rmWwCsoCre6bT//oFWYALjp2SbcxnULBaTvnYDHtfEbO1m/3c9nJk8ZO5KHQTV88ivTWN/S2EXwmisTPdcupMrvI8e48QZdkZu9WHyKron7MKhGFJw6Z0KZ3tleVrvvJo89siUwByPY+Hs4gkKPBQbLQOaedcv/xeM+Ih8rl1eHEC/C65xWVciToVqSGp9HfbhVzFSrO6kBnv7mJwnRLvMEwqiNankVdJJMw4icU3lKyw/ecNSWIUddqlbThYMiq8nHjRRufs+28cq0OI9zhpvxFvFgSZE/eAYvm0x+9lZO+EH9NkBngaqU1NMYhdombNuy3awUN9p0mJQ//e9L65YbShgoc+ZUlNy+c6F6gDEHXV0JrzevPIZFAe2RyRa2dNqzLvihAAMCszYueqszzXRkSyobx5+LTLK2V3lfg3wbS9DzP3QW7VHdHbjZcttQRvtjrGveJnNn2DE2ZDIbvkCrT0H8RzbGDdmIq4P1ey+hoY/W6NuZKOz4dv4HUNznxdKV1Wf3MvqUv35r2jTKvpPWBUWNm5fytX/QJwp6qkIOsSx7Y67BSCbCDVLM8/VcMG+T0j+INrgL9sfT1ICtACH8BI0G6ViUZPVzzCmQHW2oVIwZjAoFl6+meO/pD8teO1E+1y03mCpYfW9S8qhtH2GhlFlebPf4NbezVv9xbXKWz0xezRNQWqUqtYRTUbuzK7KTvjG4rQHfzBpVmK4wDLnSIwdSzTSk1fPNeY0WOpPZTLlvQ59xwgfFrb326vT2hS1JAZ9E6sujFtKTiJ7bxI6o4cBhDaX+adXREThhR+MwA4TqD7rga/o9iY7d6TVRe14CS2S3iSQsD0R6ApnhG/2Wa0A0AY2NtWTjmabdKU+KgIRDP9RQYVjXiF1qC+xyNVG03I9vpmEpY/G/zC4nLOKgXAZ/uTikHI9Afbkhfgfgo9arWbix5eH7WUo9RQygDzwCnVSjbXc7MihEufVj6WGbK963pw8VjY3RS8IH1cy2yZbIcKLO5CgAUcXJfF2+McnDLKtXxyZaf7SPA6KJq+zF2NHyfoeTOwHhGqNcnHVr1hT73pcoyXyfvCYBnG1Bp/aR9t8hoI7CXM3UZOisWGA1SHZ2jf7k9GlRnp3mF/c1AV+JjvUsnZrsybEOQJg/dn/9eJkyykQHjbF56zgcPX6DdMG03WKUMlYz+uOZ+5DZy9E9MZOZ9GMoLFdrIPPQQLjv+GlCMpoyHPXkzIODjHAID2PrnaRpqWVHh0rnieDILKq+Emrd5RnjgE9pDUXWTmHaKuqqYlcgEz4zbi46dbWrAAFBjsQq1rLHIiPJEcwFLCOY4JNlXRXQJqCUKXk2d1RSBGzDP6HDSpo863BhVRFFF6uIpjQV7j5ebFe3UkkO/+coIo2BTAcgBqOtQ134s9a4QJvofuqBYMGOBMsWZ+sn/2AOxDx6SfAnDFGw==";
Uint8Array.from(atob(xh), (h) => h.charCodeAt(0));
var fp = Uint8Array.from(atob(xh), (h) => h.charCodeAt(0));
function Sh(h, t, e) {
  if (t.getQueryParameter(h, t.QUERY_RESULT_AVAILABLE)) {
    const i = t.getQueryParameter(h, t.QUERY_RESULT) / 1e6;
    e.lastTime = i;
  } else
    setTimeout(() => {
      Sh(h, t, e);
    }, 1);
}
var pp = class extends vs {
  /**
   * 
   * @param {THREE.Scene} scene
   * @param {THREE.Camera} camera 
   * @param {number} width 
   * @param {number} height
   *  
   * @property {THREE.Scene} scene
   * @property {THREE.Camera} camera
   * @property {number} width
   * @property {number} height
   */
  constructor(t, e, n = 512, s = 512) {
    super(), this.width = n, this.height = s, this.clear = true, this.camera = e, this.scene = t, this.configuration = new Proxy({
      aoSamples: 16,
      aoRadius: 5,
      denoiseSamples: 8,
      denoiseRadius: 12,
      distanceFalloff: 1,
      intensity: 5,
      denoiseIterations: 2,
      renderMode: 0,
      color: new Color(0, 0, 0),
      gammaCorrection: true,
      logarithmicDepthBuffer: false,
      screenSpaceRadius: false,
      halfRes: false,
      depthAwareUpsampling: true
    }, {
      set: (i, r, o) => {
        const l = i[r];
        return i[r] = o, r === "aoSamples" && l !== o && this.configureAOPass(this.configuration.logarithmicDepthBuffer), r === "denoiseSamples" && l !== o && this.configureDenoisePass(this.configuration.logarithmicDepthBuffer), r === "halfRes" && l !== o && (this.configureAOPass(this.configuration.logarithmicDepthBuffer), this.configureHalfResTargets(), this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer), this.setSize(this.width, this.height)), r === "depthAwareUpsampling" && l !== o && this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer), true;
      }
    }), this.samples = [], this.samplesR = [], this.samplesDenoise = [], this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer), this.configureSampleDependentPasses(), this.configureHalfResTargets(), this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: NearestFilter
    }), this.beautyRenderTarget.depthTexture = new DepthTexture(this.width, this.height, UnsignedIntType), this.beautyRenderTarget.depthTexture.format = DepthFormat, this.writeTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false
    }), this.readTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false
    }), this.bluenoise = new DataTexture(fp, 128, 128), this.bluenoise.colorSpace = NoColorSpace, this.bluenoise.wrapS = RepeatWrapping, this.bluenoise.wrapT = RepeatWrapping, this.bluenoise.minFilter = NearestFilter, this.bluenoise.magFilter = NearestFilter, this.bluenoise.needsUpdate = true, this.lastTime = 0, this._r = new Vector2(), this._c = new Color();
  }
  configureHalfResTargets() {
    this.configuration.halfRes ? (this.depthDownsampleTarget = /*new THREE.WebGLRenderTarget(this.width / 2, this.height / 2, {
        minFilter: THREE.NearestFilter,
        magFilter: THREE.NearestFilter,
        depthBuffer: false,
        format: THREE.RedFormat,
        type: THREE.FloatType
    });*/
    new WebGLMultipleRenderTargets(this.width / 2, this.height / 2, 2), this.depthDownsampleTarget.texture[0].format = RedFormat, this.depthDownsampleTarget.texture[0].type = FloatType, this.depthDownsampleTarget.texture[0].minFilter = NearestFilter, this.depthDownsampleTarget.texture[0].magFilter = NearestFilter, this.depthDownsampleTarget.texture[0].depthBuffer = false, this.depthDownsampleTarget.texture[1].format = RGBAFormat, this.depthDownsampleTarget.texture[1].type = HalfFloatType, this.depthDownsampleTarget.texture[1].minFilter = NearestFilter, this.depthDownsampleTarget.texture[1].magFilter = NearestFilter, this.depthDownsampleTarget.texture[1].depthBuffer = false, this.depthDownsampleQuad = new gr(new ShaderMaterial(dp))) : (this.depthDownsampleTarget && (this.depthDownsampleTarget.dispose(), this.depthDownsampleTarget = null), this.depthDownsampleQuad && (this.depthDownsampleQuad.dispose(), this.depthDownsampleQuad = null));
  }
  configureSampleDependentPasses() {
    this.configureAOPass(this.configuration.logarithmicDepthBuffer), this.configureDenoisePass(this.configuration.logarithmicDepthBuffer);
  }
  configureAOPass(t = false) {
    this.samples = this.generateHemisphereSamples(this.configuration.aoSamples), this.samplesR = this.generateHemisphereSamplesR(this.configuration.aoSamples);
    const e = {
      ...cp
    };
    e.fragmentShader = e.fragmentShader.replace("16", this.configuration.aoSamples).replace("16.0", this.configuration.aoSamples + ".0"), t && (e.fragmentShader = `#define LOGDEPTH
` + e.fragmentShader), this.configuration.halfRes && (e.fragmentShader = `#define HALFRES
` + e.fragmentShader), this.effectShaderQuad ? (this.effectShaderQuad.material.dispose(), this.effectShaderQuad.material = new ShaderMaterial(e)) : this.effectShaderQuad = new gr(new ShaderMaterial(e));
  }
  configureDenoisePass(t = false) {
    this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);
    const e = {
      ...up
    };
    e.fragmentShader = e.fragmentShader.replace("16", this.configuration.denoiseSamples), t && (e.fragmentShader = `#define LOGDEPTH
` + e.fragmentShader), this.poissonBlurQuad ? (this.poissonBlurQuad.material.dispose(), this.poissonBlurQuad.material = new ShaderMaterial(e)) : this.poissonBlurQuad = new gr(new ShaderMaterial(e));
  }
  configureEffectCompositer(t = false) {
    const e = {
      ...hp
    };
    t && (e.fragmentShader = `#define LOGDEPTH
` + e.fragmentShader), this.configuration.halfRes && this.configuration.depthAwareUpsampling && (e.fragmentShader = `#define HALFRES
` + e.fragmentShader), this.effectCompositerQuad ? (this.effectCompositerQuad.material.dispose(), this.effectCompositerQuad.material = new ShaderMaterial(e)) : this.effectCompositerQuad = new gr(new ShaderMaterial(e));
  }
  /**
       * 
       * @param {Number} n 
       * @returns {THREE.Vector3[]}
       */
  generateHemisphereSamples(t) {
    const e = [];
    for (let n = 0; n < t; n++) {
      const s = 2.399963 * n, i = Math.sqrt(n + 0.5) / Math.sqrt(t), r = i * Math.cos(s), o = i * Math.sin(s), l = Math.sqrt(1 - (r * r + o * o));
      e.push(new Vector3(r, o, l));
    }
    return e;
  }
  /**
       * 
       * @param {number} n 
       * @returns {number[]}
       */
  generateHemisphereSamplesR(t) {
    let e = [];
    for (let n = 0; n < t; n++)
      e.push((n + 1) / t);
    return e;
  }
  /**
       * 
       * @param {number} numSamples 
       * @param {number} numRings 
       * @returns {THREE.Vector2[]}
       */
  generateDenoiseSamples(t, e) {
    const n = 2 * Math.PI * e / t, s = 1 / t, i = s, r = [];
    let o = s, l = 0;
    for (let u = 0; u < t; u++)
      r.push(new Vector2(Math.cos(l), Math.sin(l)).multiplyScalar(Math.pow(o, 0.75))), o += i, l += n;
    return r;
  }
  setSize(t, e) {
    this.width = t, this.height = e;
    const n = this.configuration.halfRes ? 0.5 : 1;
    this.beautyRenderTarget.setSize(t, e), this.writeTargetInternal.setSize(t * n, e * n), this.readTargetInternal.setSize(t * n, e * n), this.configuration.halfRes && this.depthDownsampleTarget.setSize(t * n, e * n);
  }
  render(t, e, n, s, i) {
    t.capabilities.logarithmicDepthBuffer !== this.configuration.logarithmicDepthBuffer && (this.configuration.logarithmicDepthBuffer = t.capabilities.logarithmicDepthBuffer, this.configureAOPass(this.configuration.logarithmicDepthBuffer), this.configureDenoisePass(this.configuration.logarithmicDepthBuffer), this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer));
    let r, o, l;
    this.debugMode && (r = t.getContext(), o = r.getExtension("EXT_disjoint_timer_query_webgl2"), o === null && (console.error("EXT_disjoint_timer_query_webgl2 not available, disabling debug mode."), this.debugMode = false)), t.setRenderTarget(this.beautyRenderTarget), t.render(this.scene, this.camera), this.debugMode && (l = r.createQuery(), r.beginQuery(o.TIME_ELAPSED_EXT, l));
    const u = t.xr.enabled;
    t.xr.enabled = false, this.camera.updateMatrixWorld(), this._r.set(this.width, this.height);
    let d = this.configuration.aoRadius;
    this.configuration.halfRes && this.configuration.screenSpaceRadius && (d *= 0.5), this.configuration.halfRes && (t.setRenderTarget(this.depthDownsampleTarget), this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture, this.depthDownsampleQuad.material.uniforms.resolution.value = this._r, this.depthDownsampleQuad.material.uniforms.near.value = this.camera.near, this.depthDownsampleQuad.material.uniforms.far.value = this.camera.far, this.depthDownsampleQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.depthDownsampleQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.depthDownsampleQuad.material.uniforms.logDepth.value = this.configuration.logarithmicDepthBuffer, this.depthDownsampleQuad.render(t)), this.effectShaderQuad.material.uniforms.sceneDiffuse.value = this.beautyRenderTarget.texture, this.effectShaderQuad.material.uniforms.sceneDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture, this.effectShaderQuad.material.uniforms.sceneNormal.value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[1] : null, this.effectShaderQuad.material.uniforms.projMat.value = this.camera.projectionMatrix, this.effectShaderQuad.material.uniforms.viewMat.value = this.camera.matrixWorldInverse, this.effectShaderQuad.material.uniforms.projViewMat.value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone()), this.effectShaderQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.effectShaderQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.effectShaderQuad.material.uniforms.cameraPos.value = this.camera.position, this.effectShaderQuad.material.uniforms.resolution.value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r, this.effectShaderQuad.material.uniforms.time.value = performance.now() / 1e3, this.effectShaderQuad.material.uniforms.samples.value = this.samples, this.effectShaderQuad.material.uniforms.samplesR.value = this.samplesR, this.effectShaderQuad.material.uniforms.bluenoise.value = this.bluenoise, this.effectShaderQuad.material.uniforms.radius.value = d, this.effectShaderQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.effectShaderQuad.material.uniforms.near.value = this.camera.near, this.effectShaderQuad.material.uniforms.far.value = this.camera.far, this.effectShaderQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.effectShaderQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.effectShaderQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, t.setRenderTarget(this.writeTargetInternal), this.effectShaderQuad.render(t);
    for (let m = 0; m < this.configuration.denoiseIterations; m++)
      [this.writeTargetInternal, this.readTargetInternal] = [
        this.readTargetInternal,
        this.writeTargetInternal
      ], this.poissonBlurQuad.material.uniforms.tDiffuse.value = this.readTargetInternal.texture, this.poissonBlurQuad.material.uniforms.sceneDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture, this.poissonBlurQuad.material.uniforms.projMat.value = this.camera.projectionMatrix, this.poissonBlurQuad.material.uniforms.viewMat.value = this.camera.matrixWorldInverse, this.poissonBlurQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.poissonBlurQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.poissonBlurQuad.material.uniforms.cameraPos.value = this.camera.position, this.poissonBlurQuad.material.uniforms.resolution.value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r, this.poissonBlurQuad.material.uniforms.time.value = performance.now() / 1e3, this.poissonBlurQuad.material.uniforms.blueNoise.value = this.bluenoise, this.poissonBlurQuad.material.uniforms.radius.value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1), this.poissonBlurQuad.material.uniforms.worldRadius.value = d, this.poissonBlurQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.poissonBlurQuad.material.uniforms.index.value = m, this.poissonBlurQuad.material.uniforms.poissonDisk.value = this.samplesDenoise, this.poissonBlurQuad.material.uniforms.near.value = this.camera.near, this.poissonBlurQuad.material.uniforms.far.value = this.camera.far, this.poissonBlurQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.poissonBlurQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, t.setRenderTarget(this.writeTargetInternal), this.poissonBlurQuad.render(t);
    this.effectCompositerQuad.material.uniforms.sceneDiffuse.value = this.beautyRenderTarget.texture, this.effectCompositerQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture, this.effectCompositerQuad.material.uniforms.near.value = this.camera.near, this.effectCompositerQuad.material.uniforms.far.value = this.camera.far, this.effectCompositerQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.effectCompositerQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.effectCompositerQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.effectCompositerQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.effectCompositerQuad.material.uniforms.downsampledDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture, this.effectCompositerQuad.material.uniforms.resolution.value = this._r, this.effectCompositerQuad.material.uniforms.blueNoise.value = this.bluenoise, this.effectCompositerQuad.material.uniforms.intensity.value = this.configuration.intensity, this.effectCompositerQuad.material.uniforms.renderMode.value = this.configuration.renderMode, this.effectCompositerQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, this.effectCompositerQuad.material.uniforms.radius.value = d, this.effectCompositerQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.effectCompositerQuad.material.uniforms.gammaCorrection.value = this.configuration.gammaCorrection, this.effectCompositerQuad.material.uniforms.tDiffuse.value = this.writeTargetInternal.texture, this.effectCompositerQuad.material.uniforms.color.value = this._c.copy(this.configuration.color).convertSRGBToLinear(), t.setRenderTarget(this.renderToScreen ? null : e), this.effectCompositerQuad.render(t), this.debugMode && (r.endQuery(o.TIME_ELAPSED_EXT), Sh(l, r, this)), t.xr.enabled = u;
  }
  /**
       * Enables the debug mode of the AO, meaning the lastTime value will be updated.
       */
  enableDebugMode() {
    this.debugMode = true;
  }
  /**
       * Disables the debug mode of the AO, meaning the lastTime value will not be updated.
       */
  disableDebugMode() {
    this.debugMode = false;
  }
  /**
       * Sets the display mode of the AO
       * @param {"Combined" | "AO" | "No AO" | "Split" | "Split AO"} mode - The display mode. 
       */
  setDisplayMode(t) {
    this.configuration.renderMode = [
      "Combined",
      "AO",
      "No AO",
      "Split",
      "Split AO"
    ].indexOf(t);
  }
  /**
       * 
       * @param {"Performance" | "Low" | "Medium" | "High" | "Ultra"} mode 
       */
  setQualityMode(t) {
    t === "Performance" ? (this.configuration.aoSamples = 8, this.configuration.denoiseSamples = 4, this.configuration.denoiseRadius = 12) : t === "Low" ? (this.configuration.aoSamples = 16, this.configuration.denoiseSamples = 4, this.configuration.denoiseRadius = 12) : t === "Medium" ? (this.configuration.aoSamples = 16, this.configuration.denoiseSamples = 8, this.configuration.denoiseRadius = 12) : t === "High" ? (this.configuration.aoSamples = 64, this.configuration.denoiseSamples = 8, this.configuration.denoiseRadius = 6) : t === "Ultra" && (this.configuration.aoSamples = 64, this.configuration.denoiseSamples = 16, this.configuration.denoiseRadius = 6);
  }
};
var mp = {
  name: "GammaCorrectionShader",
  uniforms: {
    tDiffuse: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = sRGBTransferOETF( tex );

		}`
  )
};
function gp() {
  return new ShaderMaterial({
    side: 2,
    clipping: true,
    uniforms: {},
    vertexShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
    
       vec4 absPosition = vec4(position, 1.0);
       vec3 trueNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          trueNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       trueNormal = (normalize(modelMatrix * vec4(trueNormal, 0.))).xyz;
       
       vec3 planePosition = absPosition.xyz / 40.;
       float d = abs(dot(trueNormal, planePosition));
       vColor = vec4(abs(trueNormal), d);
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      gl_FragColor = vColor;
    }
    `
  });
}
function Ep() {
  return new ShaderMaterial({
    side: 2,
    clipping: true,
    uniforms: {},
    vertexShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
       
       vec4 absPosition = vec4(position, 1.0);
       vNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          vNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       vNormal = (normalize(modelMatrix * vec4(vNormal, 0.))).xyz;
       
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       vCameraPosition = cameraPosition;
       vPosition = absPosition.xyz;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      vec3 cameraPixelVec = normalize(vCameraPosition - vPosition);
      float difference = abs(dot(vNormal, cameraPixelVec));
      
      // This achieves a double gloss effect: when the surface is perpendicular and when it's parallel
      difference = abs((difference * 2.) - 1.);
      
      gl_FragColor = vec4(difference, difference, difference, 1.);
    }
    `
  });
}
var vp = class extends vs {
  constructor(e, n, s, i, r) {
    super();
    b(this, "components");
    b(this, "resolution");
    b(this, "renderScene");
    b(this, "renderCamera");
    b(this, "fsQuad");
    b(this, "normalOverrideMaterial");
    b(this, "glossOverrideMaterial");
    b(this, "planeBuffer");
    b(this, "glossBuffer");
    b(this, "outlineBuffer");
    b(this, "excludedMeshes", []);
    b(this, "outlinedMeshes", {});
    b(this, "_outlineScene", new Scene());
    b(this, "_outlineEnabled", false);
    b(this, "_lineColor", 10066329);
    b(this, "_opacity", 0.4);
    b(this, "_tolerance", 3);
    b(this, "_glossEnabled", true);
    b(this, "_glossExponent", 1.9);
    b(this, "_minGloss", -0.1);
    b(this, "_maxGloss", 0.1);
    b(this, "_outlinesNeedsUpdate", false);
    if (!s.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = n, this.renderScene = i, this.renderCamera = r, this.resolution = new Vector2(e.x, e.y), this.fsQuad = new Th(), this.fsQuad.material = this.createOutlinePostProcessMaterial(), this.planeBuffer = this.newRenderTarget(), this.glossBuffer = this.newRenderTarget(), this.outlineBuffer = this.newRenderTarget();
    const o = gp();
    o.clippingPlanes = s.renderer.clippingPlanes, this.normalOverrideMaterial = o;
    const l = Ep();
    l.clippingPlanes = s.renderer.clippingPlanes, this.glossOverrideMaterial = l;
  }
  get lineColor() {
    return this._lineColor;
  }
  set lineColor(e) {
    this._lineColor = e, this.fsQuad.material.uniforms.lineColor.value.set(e);
  }
  get tolerance() {
    return this._tolerance;
  }
  set tolerance(e) {
    this._tolerance = e;
    const n = this.fsQuad.material;
    n.uniforms.tolerance.value = e;
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e) {
    this._opacity = e;
    const n = this.fsQuad.material;
    n.uniforms.opacity.value = e;
  }
  get glossEnabled() {
    return this._glossEnabled;
  }
  set glossEnabled(e) {
    if (e === this._glossEnabled)
      return;
    this._glossEnabled = e;
    const n = this.fsQuad.material;
    n.uniforms.glossEnabled.value = e ? 1 : 0;
  }
  get glossExponent() {
    return this._glossExponent;
  }
  set glossExponent(e) {
    this._glossExponent = e;
    const n = this.fsQuad.material;
    n.uniforms.glossExponent.value = e;
  }
  get minGloss() {
    return this._minGloss;
  }
  set minGloss(e) {
    this._minGloss = e;
    const n = this.fsQuad.material;
    n.uniforms.minGloss.value = e;
  }
  get maxGloss() {
    return new MeshBasicMaterial().color.convertLinearToSRGB(), this._maxGloss;
  }
  set maxGloss(e) {
    this._maxGloss = e;
    const n = this.fsQuad.material;
    n.uniforms.maxGloss.value = e;
  }
  get outlineEnabled() {
    return this._outlineEnabled;
  }
  set outlineEnabled(e) {
    if (e === this._outlineEnabled)
      return;
    this._outlineEnabled = e;
    const n = this.fsQuad.material;
    n.uniforms.outlineEnabled.value = e ? 1 : 0;
  }
  async dispose() {
    this.planeBuffer.dispose(), this.glossBuffer.dispose(), this.outlineBuffer.dispose(), this.normalOverrideMaterial.dispose(), this.glossOverrideMaterial.dispose(), this.fsQuad.material.dispose(), this.fsQuad.dispose(), this.excludedMeshes = [], this._outlineScene.children = [];
    const e = this.components.get(rn);
    for (const n in this.outlinedMeshes) {
      const s = this.outlinedMeshes[n];
      for (const i of s.meshes)
        e.destroy(i, true, true);
      s.material.dispose();
    }
  }
  setSize(e, n) {
    this.planeBuffer.setSize(e, n), this.glossBuffer.setSize(e, n), this.outlineBuffer.setSize(e, n), this.resolution.set(e, n);
    const s = this.fsQuad.material;
    s.uniforms.screenSize.value.set(
      this.resolution.x,
      this.resolution.y,
      1 / this.resolution.x,
      1 / this.resolution.y
    ), s.uniformsNeedUpdate = true;
  }
  render(e, n, s) {
    const i = n.depthBuffer;
    n.depthBuffer = false;
    const r = this.renderScene.overrideMaterial, o = this.renderScene.background;
    this.renderScene.background = null;
    for (const u of this.excludedMeshes)
      u.visible = false;
    if (e.setRenderTarget(this.planeBuffer), this.renderScene.overrideMaterial = this.normalOverrideMaterial, e.render(this.renderScene, this.renderCamera), this._glossEnabled && (e.setRenderTarget(this.glossBuffer), this.renderScene.overrideMaterial = this.glossOverrideMaterial, e.render(this.renderScene, this.renderCamera)), this.renderScene.overrideMaterial = r, this._outlineEnabled) {
      let u = false;
      for (const d in this.outlinedMeshes) {
        const m = this.outlinedMeshes[d];
        for (const f of m.meshes)
          u = true, f.userData.materialPreOutline = f.material, f.material = m.material, f.userData.groupsPreOutline = f.geometry.groups, f.geometry.groups = [], f instanceof InstancedMesh && (f.userData.colorPreOutline = f.instanceColor, f.instanceColor = null), f.userData.parentPreOutline = f.parent, this._outlineScene.add(f);
      }
      (u || this._outlinesNeedsUpdate) && (e.setRenderTarget(this.outlineBuffer), e.render(this._outlineScene, this.renderCamera), this._outlinesNeedsUpdate = u);
      for (const d in this.outlinedMeshes) {
        const m = this.outlinedMeshes[d];
        for (const f of m.meshes)
          f.material = f.userData.materialPreOutline, f.geometry.groups = f.userData.groupsPreOutline, f instanceof InstancedMesh && (f.instanceColor = f.userData.colorPreOutline), f.userData.parentPreOutline && f.userData.parentPreOutline.add(f), f.userData.materialPreOutline = void 0, f.userData.groupsPreOutline = void 0, f.userData.colorPreOutline = void 0, f.userData.parentPreOutline = void 0;
      }
    }
    for (const u of this.excludedMeshes)
      u.visible = true;
    this.renderScene.background = o;
    const l = this.fsQuad.material;
    l.uniforms.planeBuffer.value = this.planeBuffer.texture, l.uniforms.glossBuffer.value = this.glossBuffer.texture, l.uniforms.outlineBuffer.value = this.outlineBuffer.texture, l.uniforms.sceneColorBuffer.value = s.texture, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.fsQuad.render(e)), n.depthBuffer = i;
  }
  get vertexShader() {
    return `
	  varying vec2 vUv;
	  void main() {
	  	vUv = uv;
	  	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	  }
	`;
  }
  get fragmentShader() {
    return `
	  uniform sampler2D sceneColorBuffer;
	  uniform sampler2D planeBuffer;
	  uniform sampler2D glossBuffer;
	  uniform sampler2D outlineBuffer;
	  uniform vec4 screenSize;
	  uniform vec3 lineColor;
	  
	  uniform float outlineEnabled;
	  
      uniform int width;
	  uniform float opacity;
      uniform float tolerance;
      uniform float glossExponent;
      uniform float minGloss;
      uniform float maxGloss;
      uniform float glossEnabled;

	  varying vec2 vUv;

	  vec4 getValue(sampler2D buffer, int x, int y) {
	  	return texture2D(buffer, vUv + screenSize.zw * vec2(x, y));
	  }

      float normalDiff(vec3 normal1, vec3 normal2) {
        return ((dot(normal1, normal2) - 1.) * -1.) / 2.;
      }

      // Returns 0 if it's background, 1 if it's not
      float getIsBackground(vec3 normal) {
        float background = 1.0;
        background *= step(normal.x, 0.);
        background *= step(normal.y, 0.);
        background *= step(normal.z, 0.);
        background = (background - 1.) * -1.;
        return background;
      }

	  void main() {
	  
	    vec4 sceneColor = getValue(sceneColorBuffer, 0, 0);
	    vec3 normSceneColor = normalize(sceneColor.rgb);
  
        vec4 plane = getValue(planeBuffer, 0, 0);
	    vec3 normal = plane.xyz;
        float distance = plane.w;
  
        vec3 normalTop = getValue(planeBuffer, 0, width).rgb;
        vec3 normalBottom = getValue(planeBuffer, 0, -width).rgb;
        vec3 normalRight = getValue(planeBuffer, width, 0).rgb;
        vec3 normalLeft = getValue(planeBuffer, -width, 0).rgb;
        vec3 normalTopRight = getValue(planeBuffer, width, width).rgb;
        vec3 normalTopLeft = getValue(planeBuffer, -width, width).rgb;
        vec3 normalBottomRight = getValue(planeBuffer, width, -width).rgb;
        vec3 normalBottomLeft = getValue(planeBuffer, -width, -width).rgb;
  
        float distanceTop = getValue(planeBuffer, 0, width).a;
        float distanceBottom = getValue(planeBuffer, 0, -width).a;
        float distanceRight = getValue(planeBuffer, width, 0).a;
        float distanceLeft = getValue(planeBuffer, -width, 0).a;
        float distanceTopRight = getValue(planeBuffer, width, width).a;
        float distanceTopLeft = getValue(planeBuffer, -width, width).a;
        float distanceBottomRight = getValue(planeBuffer, width, -width).a;
        float distanceBottomLeft = getValue(planeBuffer, -width, -width).a;
        
        vec3 sceneColorTop = normalize(getValue(sceneColorBuffer, 1, 0).rgb);
        vec3 sceneColorBottom = normalize(getValue(sceneColorBuffer, -1, 0).rgb);
        vec3 sceneColorLeft = normalize(getValue(sceneColorBuffer, 0, -1).rgb);
        vec3 sceneColorRight = normalize(getValue(sceneColorBuffer, 0, 1).rgb);
        vec3 sceneColorTopRight = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomRight = normalize(getValue(sceneColorBuffer, -1, 1).rgb);
        vec3 sceneColorTopLeft = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomLeft = normalize(getValue(sceneColorBuffer, -1, 1).rgb);

        // Checks if the planes of this texel and the neighbour texels are different

        float planeDiff = 0.0;

        planeDiff += step(0.001, normalDiff(normal, normalTop));
        planeDiff += step(0.001, normalDiff(normal, normalBottom));
        planeDiff += step(0.001, normalDiff(normal, normalLeft));
        planeDiff += step(0.001, normalDiff(normal, normalRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopLeft));
        planeDiff += step(0.001, normalDiff(normal, normalBottomRight));
        planeDiff += step(0.001, normalDiff(normal, normalBottomLeft));
        
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTop));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottom));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorRight));
       	planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomLeft));

        planeDiff += step(0.001, abs(distance - distanceTop));
        planeDiff += step(0.001, abs(distance - distanceBottom));
        planeDiff += step(0.001, abs(distance - distanceLeft));
        planeDiff += step(0.001, abs(distance - distanceRight));
        planeDiff += step(0.001, abs(distance - distanceTopRight));
        planeDiff += step(0.001, abs(distance - distanceTopLeft));
        planeDiff += step(0.001, abs(distance - distanceBottomRight));
        planeDiff += step(0.001, abs(distance - distanceBottomLeft));

        // Add extra background outline

        int width2 = width + 1;
        vec3 normalTop2 = getValue(planeBuffer, 0, width2).rgb;
        vec3 normalBottom2 = getValue(planeBuffer, 0, -width2).rgb;
        vec3 normalRight2 = getValue(planeBuffer, width2, 0).rgb;
        vec3 normalLeft2 = getValue(planeBuffer, -width2, 0).rgb;
        vec3 normalTopRight2 = getValue(planeBuffer, width2, width2).rgb;
        vec3 normalTopLeft2 = getValue(planeBuffer, -width2, width2).rgb;
        vec3 normalBottomRight2 = getValue(planeBuffer, width2, -width2).rgb;
        vec3 normalBottomLeft2 = getValue(planeBuffer, -width2, -width2).rgb;

        planeDiff += -(getIsBackground(normalTop2) - 1.);
        planeDiff += -(getIsBackground(normalBottom2) - 1.);
        planeDiff += -(getIsBackground(normalRight2) - 1.);
        planeDiff += -(getIsBackground(normalLeft2) - 1.);
        planeDiff += -(getIsBackground(normalTopRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomLeft2) - 1.);

        // Tolerance sets the minimum amount of differences to consider
        // this texel an edge

        float line = step(tolerance, planeDiff);

        // Exclude background and apply opacity

        float background = getIsBackground(normal);
        line *= background;
        line *= opacity;
        
        // Add gloss
        
        vec3 gloss = getValue(glossBuffer, 0, 0).xyz;
        float diffGloss = abs(maxGloss - minGloss);
        vec3 glossExpVector = vec3(glossExponent,glossExponent,glossExponent);
        gloss = min(pow(gloss, glossExpVector), vec3(1.,1.,1.));
        gloss *= diffGloss;
        gloss += minGloss;
        vec4 glossedColor = sceneColor + vec4(gloss, 1.) * glossEnabled;
        
        vec4 corrected = mix(sceneColor, glossedColor, background);
        
        // Draw lines
        
        corrected = mix(corrected, vec4(lineColor, 1.), line);
        
        // Add outline
        
        vec4 outlinePreview =getValue(outlineBuffer, 0, 0);
        float outlineColorCorrection = 1. / max(0.2, outlinePreview.a);
        vec3 outlineColor = outlinePreview.rgb * outlineColorCorrection;
        
        // thickness between 10 and 2, opacity between 1 and 0.2
	    int outlineThickness = int(outlinePreview.a * 10.);
	    
	    float outlineDiff = 0.;
        
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, -outlineThickness).a);
        
        float outLine = step(4., outlineDiff) * step(outlineDiff, 12.) * outlineEnabled;
        corrected = mix(corrected, vec4(outlineColor, 1.), outLine);
        
        gl_FragColor = corrected;
	}
			`;
  }
  createOutlinePostProcessMaterial() {
    return new ShaderMaterial({
      uniforms: {
        opacity: { value: this._opacity },
        debugVisualize: { value: 0 },
        sceneColorBuffer: { value: null },
        tolerance: { value: this._tolerance },
        planeBuffer: { value: null },
        glossBuffer: { value: null },
        outlineBuffer: { value: null },
        glossEnabled: { value: 1 },
        minGloss: { value: this._minGloss },
        maxGloss: { value: this._maxGloss },
        outlineEnabled: { value: 0 },
        glossExponent: { value: this._glossExponent },
        width: { value: 1 },
        lineColor: { value: new Color(this._lineColor) },
        screenSize: {
          value: new Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          )
        }
      },
      vertexShader: this.vertexShader,
      fragmentShader: this.fragmentShader
    });
  }
  newRenderTarget() {
    const e = new WebGLRenderTarget(
      this.resolution.x,
      this.resolution.y
    );
    return e.texture.colorSpace = "srgb-linear", e.texture.format = RGBAFormat, e.texture.type = HalfFloatType, e.texture.minFilter = NearestFilter, e.texture.magFilter = NearestFilter, e.texture.generateMipmaps = false, e.stencilBuffer = false, e;
  }
};
var Ip = class {
  constructor(t, e, n) {
    b(this, "composer");
    b(this, "overrideClippingPlanes", false);
    b(this, "_components");
    b(this, "_world");
    b(this, "_renderTarget");
    b(this, "_enabled", false);
    b(this, "_initialized", false);
    b(this, "_n8ao");
    b(this, "_customEffects");
    b(this, "_basePass");
    b(this, "_gammaPass");
    b(this, "_depthTexture");
    b(this, "_renderer");
    b(this, "_settings", {
      gamma: true,
      custom: true,
      ao: false
    });
    if (!n.renderer)
      throw new Error("The given world must have a renderer!");
    this._components = t, this._renderer = e, this._world = n, this._renderTarget = new WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight
    ), this._renderTarget.texture.colorSpace = "srgb-linear", this.composer = new op(e, this._renderTarget), this.composer.setSize(window.innerWidth, window.innerHeight);
  }
  /**
   * Getter for the base pass. Throws an error if the custom effects are not initialized.
   */
  get basePass() {
    if (!this._basePass)
      throw new Error("Custom effects not initialized!");
    return this._basePass;
  }
  /**
   * Getter for the gamma pass. Throws an error if the custom effects are not initialized.
   */
  get gammaPass() {
    if (!this._gammaPass)
      throw new Error("Custom effects not initialized!");
    return this._gammaPass;
  }
  /**
   * Getter for the custom effects pass. Throws an error if the custom effects are not initialized.
   */
  get customEffects() {
    if (!this._customEffects)
      throw new Error("Custom effects not initialized!");
    return this._customEffects;
  }
  /**
   * Getter for the N8AO pass. Throws an error if the custom effects are not initialized.
   */
  get n8ao() {
    if (!this._n8ao)
      throw new Error("Custom effects not initialized!");
    return this._n8ao;
  }
  /**
   * Getter for the enabled state of the post-processing effects.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the post-processing effects.
   * If the custom effects are not initialized, it calls the initialize method.
   * @param {boolean} active - The new enabled state.
   */
  set enabled(t) {
    this._initialized || this.initialize(), this._enabled = t;
  }
  /**
   * Getter for the current post-processing settings.
   */
  get settings() {
    return { ...this._settings };
  }
  /**
   * Disposes of the resources held by the post-processing manager.
   * This method should be called when the post-processing manager is no longer needed.
   * It releases the memory occupied by the render target, depth texture, custom effects pass, gamma pass, and N8AO pass.
   */
  dispose() {
    var t, e, n, s;
    this._renderTarget.dispose(), (t = this._depthTexture) == null || t.dispose(), (e = this._customEffects) == null || e.dispose(), (n = this._gammaPass) == null || n.dispose(), (s = this._n8ao) == null || s.dispose();
  }
  /**
   * Sets the post-processing settings and updates the passes accordingly.
   * This method checks if the settings have changed before updating the passes.
   *
   * @param settings - The new post-processing settings.
   * @returns {void}
   */
  setPasses(t) {
    let e = false;
    for (const n in t) {
      const s = n;
      if (this.settings[s] !== t[s]) {
        e = true;
        break;
      }
    }
    if (e) {
      for (const n in t) {
        const s = n;
        this._settings[s] !== void 0 && (this._settings[s] = t[s]);
      }
      this.updatePasses();
    }
  }
  /**
   * Sets the size of the render target and all related passes.
   * This method should be called when the window size changes to ensure that the post-processing effects are rendered correctly.
   *
   * @param width - The new width of the render target.
   * @param height - The new height of the render target.
   * @returns {void}
   */
  setSize(t, e) {
    if (this._initialized) {
      const n = this._settings.custom;
      n && this.setPasses({ custom: false }), this.setPasses({ custom: false }), this.composer.setSize(t, e), this.basePass.setSize(t, e), this.n8ao.setSize(t, e), this.customEffects.setSize(t, e), this.gammaPass.setSize(t, e), n && this.setPasses({ custom: true });
    }
  }
  /**
   * Updates the post-processing effects.
   * This method checks if the post-processing effects are enabled before rendering.
   * If the effects are enabled, it calls the `composer.render()` method to apply the effects.
   */
  update() {
    this._enabled && this.composer.render();
  }
  /**
   * Updates the camera settings for the post-processing effects.
   * This method is called whenever the camera settings change.
   * It updates the camera settings for the N8AO pass, custom effects pass, and base pass.
   */
  updateCamera() {
    const t = this._world.camera.three;
    this._n8ao && (this._n8ao.camera = t), this._customEffects && (this._customEffects.renderCamera = t), this._basePass && (this._basePass.camera = t);
  }
  /**
   * Updates the projection of the camera for the post-processing effects.
   * This method iterates over all passes in the EffectComposer and updates the camera property of each pass.
   * After updating the camera, it calls the update method to apply the changes.
   *
   * @param camera - The new camera to use for the post-processing effects.
   * @returns {void}
   */
  updateProjection(t) {
    this.composer.passes.forEach((e) => {
      e.camera = t;
    }), this.update();
  }
  initialize() {
    if (!this._world.renderer)
      throw new Error("The given world must have a renderer!");
    const t = this._world.scene.three, e = this._world.camera.three;
    if (!(t instanceof Scene))
      throw new Error("The given scene must have a THREE.Scene as core!");
    const n = this._world.camera;
    n.projection && n.projection.onChanged.add(() => {
      this.updateCamera();
    });
    const s = this._world.renderer;
    this.overrideClippingPlanes || (this._renderer.clippingPlanes = s.clippingPlanes), this._renderer.outputColorSpace = "srgb", this._renderer.toneMapping = NoToneMapping, this.newBasePass(t, e), this.newSaoPass(t, e), this.newGammaPass(), this.newCustomPass(t, e), this._initialized = true, this.updatePasses();
  }
  updatePasses() {
    for (const t of this.composer.passes)
      this.composer.removePass(t);
    this._basePass && this.composer.addPass(this.basePass), this._settings.gamma && this.composer.addPass(this.gammaPass), this._settings.ao && this.composer.addPass(this.n8ao), this._settings.custom && this.composer.addPass(this.customEffects);
  }
  newCustomPass(t, e) {
    this._customEffects = new vp(
      new Vector2(window.innerWidth, window.innerHeight),
      this._components,
      this._world,
      t,
      e
    );
  }
  newGammaPass() {
    this._gammaPass = new bh(mp);
  }
  newSaoPass(t, e) {
    if (!this._world.renderer)
      throw new Error("The given world must have a renderer!");
    const { width: n, height: s } = this._world.renderer.getSize();
    this._n8ao = new pp(t, e, n, s);
    const { configuration: i } = this._n8ao;
    i.aoSamples = 16, i.denoiseSamples = 1, i.denoiseRadius = 13, i.aoRadius = 1, i.distanceFalloff = 4, i.aoRadius = 1, i.intensity = 4, i.halfRes = true, i.color = new Color().setHex(13421772, "srgb-linear");
  }
  newBasePass(t, e) {
    this._basePass = new ap(t, e);
  }
};
var xa = class extends Uf {
  constructor(e, n, s) {
    super(e, n, s);
    b(this, "_postproduction");
    this.onResize.add((i) => this.resizePostproduction(i)), this.onWorldChanged.add(() => {
      this.currentWorld && (this._postproduction && this._postproduction.dispose(), this._postproduction = new Ip(
        e,
        this.three,
        this.currentWorld
      ), this.setPostproductionSize());
    });
  }
  /**
   * Getter for the postproduction instance.
   * Throws an error if the postproduction instance is not yet initialized.
   *
   * @returns The initialized Postproduction instance.
   */
  get postproduction() {
    if (!this._postproduction)
      throw new Error("Renderer not initialized yet with a world!");
    return this._postproduction;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger();
    const e = this.currentWorld.scene.three, n = this.currentWorld.camera.three;
    this.postproduction.enabled ? this.postproduction.composer.render() : this.three.render(e, n), e instanceof Scene && this.three2D.render(e, n), this.onAfterUpdate.trigger();
  }
  /** {@link OBC.Disposable.dispose}. */
  dispose() {
    super.dispose(), this.postproduction.dispose();
  }
  resizePostproduction(e) {
    this.postproduction && this.setPostproductionSize(e);
  }
  setPostproductionSize(e) {
    if (!this.container)
      return;
    const n = e ? e.x : this.container.clientWidth, s = e ? e.y : this.container.clientHeight;
    this.postproduction.setSize(n, s);
  }
};
var yp = class {
  constructor(t, e, n, s, i) {
    b(this, "mesh", new Mesh(new BufferGeometry()));
    b(this, "components");
    b(this, "world");
    b(this, "styleName");
    b(this, "_precission", 1e4);
    b(this, "_tempVector", new Vector3());
    b(this, "_plane");
    b(this, "_geometry");
    b(this, "_plane2DCoordinateSystem", new Matrix4());
    b(this, "_planeAxis");
    this.components = t, this.world = e, this.mesh.material = i, this.mesh.frustumCulled = false, this.mesh.userData.indexFragmentMap = /* @__PURE__ */ new Map(), this._plane = n;
    const { x: r, y: o, z: l } = n.normal;
    Math.abs(r) === 1 ? this._planeAxis = "x" : Math.abs(o) === 1 ? this._planeAxis = "y" : Math.abs(l) === 1 && (this._planeAxis = "z"), this._geometry = s, this.mesh.geometry.attributes.position = s.attributes.position;
    const u = n.normal.clone().multiplyScalar(0.01);
    this.mesh.position.copy(u), this.visible = true;
  }
  /**
   * Gets the visibility of the clipping fills mesh.
   * @returns {boolean} Returns true if the mesh is visible, false otherwise.
   */
  get visible() {
    return this.mesh.parent !== null;
  }
  /**
   * Sets the visibility of the clipping fills mesh.
   * @param {boolean} value - The new visibility state. If true, the mesh will be added to the scene and the style's meshes set. If false, the mesh will be removed from the scene and the style's meshes set.
   */
  set visible(t) {
    const e = this.getStyle();
    t ? (this.world.scene.three.add(this.mesh), e && e.meshes.add(this.mesh)) : (this.mesh.removeFromParent(), e && e.meshes.delete(this.mesh));
  }
  /**
   * Sets the geometry of the clipping fills mesh.
   * @param {THREE.BufferGeometry} geometry - The new geometry for the mesh. The position attribute of the geometry will be assigned to the mesh's geometry.
   */
  set geometry(t) {
    this._geometry = t, this.mesh.geometry.attributes.position = t.attributes.position;
  }
  /**
   * Disposes of the clipping fills mesh and its associated resources.
   * This method should be called when the clipping fills are no longer needed to free up memory.
   */
  dispose() {
    const t = this.getStyle();
    t && t.meshes.delete(this.mesh), this.mesh.userData.indexFragmentMap.clear(), this.mesh.userData = {}, this.mesh.geometry.dispose(), this.mesh.removeFromParent(), this.mesh.geometry = null, this.mesh = null, this._plane = null, this._geometry = null, this.components = null;
  }
  /**
   * Updates the clipping fills mesh with new indices.
   *
   * @param trianglesIndices - An array of indices representing triangles in the geometry.
   * @param indexFragMap - A map that allows to trace back the original fragment and id from each triangle of the fill mesh.
   *
   */
  update(t, e) {
    const n = this._geometry.attributes.position.array;
    if (!n)
      return;
    this.updatePlane2DCoordinateSystem();
    const { userData: s } = this.mesh, i = s.indexFragmentMap;
    i.clear();
    let r = 0;
    const o = [];
    let l = 0;
    const u = this.components.get(He);
    for (const [d, m] of e)
      for (const f in m) {
        const g = u.list.get(f);
        g && (g.mesh.userData.fills || (g.mesh.userData.fills = /* @__PURE__ */ new Set()), g.mesh.userData.fills.add(this.mesh));
      }
    for (let d = 0; d < t.length; d++) {
      const m = t[d], f = [];
      for (let x = l; x < m; x += 2)
        f.push(x * 3);
      const g = this.computeFill(f, n), v = e.get(m);
      let y = 0;
      for (const x of g)
        o.push(x), v && y % 3 === 0 && i.set(r++, v), y++;
      l = m;
    }
    this.mesh.geometry.setIndex(o);
  }
  computeFill(t, e) {
    const n = /* @__PURE__ */ new Map(), s = {}, i = /* @__PURE__ */ new Map();
    let r = 0;
    const o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Set(), d = this._precission;
    for (let f = 0; f < t.length; f++) {
      const g = t[f];
      let v = 0, y = 0, x = 0, A = 0;
      const R = e[g], P = e[g + 1], C = e[g + 2], O = e[g + 3], B = e[g + 4], Y = e[g + 5];
      if (this._tempVector.set(R, P, C), this._tempVector.applyMatrix4(this._plane2DCoordinateSystem), v = Math.trunc(this._tempVector.x * d) / d, y = Math.trunc(this._tempVector.y * d) / d, this._tempVector.set(O, B, Y), this._tempVector.applyMatrix4(this._plane2DCoordinateSystem), x = Math.trunc(this._tempVector.x * d) / d, A = Math.trunc(this._tempVector.y * d) / d, v === x && y === A)
        continue;
      const H = `${v}|${y}`, K = `${x}|${A}`;
      n.has(H) || n.set(H, g / 3), n.has(K) || n.set(K, g / 3 + 1);
      const Z = n.get(H), q = n.get(K);
      s[Z] = [v, y], s[q] = [x, A];
      const ne = l.has(Z), se = o.has(Z), he = l.has(q), me = o.has(q);
      if (!ne && !se && !he && !me)
        l.set(Z, r), o.set(q, r), u.add(r), i.set(r, [Z, q]), r++;
      else if (ne && me) {
        const Ee = l.get(Z), ue = o.get(q);
        if (Ee !== ue) {
          const we = i.get(ue), Ke = i.get(Ee);
          if (!we || !Ke)
            continue;
          i.delete(Ee), u.delete(Ee), o.set(Ke[Ke.length - 1], ue), o.delete(we[we.length - 1]);
          for (const Nt of Ke)
            we.push(Nt);
        } else
          u.delete(ue);
        l.delete(Z), o.delete(q);
      } else if (se && he) {
        const Ee = l.get(q), ue = o.get(Z);
        if (Ee !== ue) {
          const we = i.get(ue), Ke = i.get(Ee);
          if (!we || !Ke)
            continue;
          i.delete(Ee), u.delete(Ee), o.set(Ke[Ke.length - 1], ue), o.delete(we[we.length - 1]);
          for (const Nt of Ke)
            we.push(Nt);
        } else
          u.delete(ue);
        l.delete(q), o.delete(Z);
      } else if (ne && he) {
        const Ee = l.get(q), ue = l.get(Z), Le = i.get(ue), we = i.get(Ee);
        if (!Le || !we)
          continue;
        i.delete(Ee), u.delete(Ee), l.delete(Le[0]), l.delete(we[0]), o.delete(we[we.length - 1]), l.set(we[we.length - 1], ue), we.reverse(), Le.splice(0, 0, ...we);
      } else if (se && me) {
        const Ee = o.get(q), ue = o.get(Z), Le = i.get(ue), we = i.get(Ee);
        if (!Le || !we)
          continue;
        i.delete(Ee), u.delete(Ee), o.delete(Le[Le.length - 1]), o.delete(we[we.length - 1]), l.delete(we[0]), o.set(we[0], ue), we.reverse(), Le.push(...we);
      } else if (ne) {
        const Ee = l.get(Z), ue = i.get(Ee);
        if (!ue)
          continue;
        ue.unshift(q), l.delete(Z), l.set(q, Ee);
      } else if (se) {
        const Ee = o.get(Z), ue = i.get(Ee);
        if (!ue)
          continue;
        ue.push(q), o.delete(Z), o.set(q, Ee);
      } else if (he) {
        const Ee = l.get(q), ue = i.get(Ee);
        if (!ue)
          continue;
        ue.unshift(Z), l.delete(q), l.set(Z, Ee);
      } else if (me) {
        const Ee = o.get(q), ue = i.get(Ee);
        if (!ue)
          continue;
        ue.push(Z), o.delete(q), o.set(Z, Ee);
      }
    }
    const m = [];
    for (const [f, g] of i) {
      if (u.has(f))
        continue;
      const v = [], y = /* @__PURE__ */ new Map();
      let x = 0;
      for (const R of g) {
        const P = s[R];
        v.push(P[0], P[1]), y.set(x++, R);
      }
      const A = ep(v);
      for (const R of A) {
        const P = y.get(R);
        if (P === void 0)
          throw new Error("Map error!");
        m.push(P);
      }
    }
    return m;
  }
  updatePlane2DCoordinateSystem() {
    this._plane2DCoordinateSystem = new Matrix4();
    const t = new Vector3(1, 0, 0), e = new Vector3(0, 1, 0), n = this._plane.normal, s = new Vector3();
    this._plane.coplanarPoint(s), this._planeAxis === "x" ? t.crossVectors(e, n) : this._planeAxis === "y" ? e.crossVectors(n, t) : this._planeAxis === "z" || (t.crossVectors(e, n).normalize(), e.crossVectors(n, t)), this._plane2DCoordinateSystem.fromArray([
      t.x,
      t.y,
      t.z,
      0,
      e.x,
      e.y,
      e.z,
      0,
      n.x,
      n.y,
      n.z,
      0,
      s.x,
      s.y,
      s.z,
      1
    ]), this._plane2DCoordinateSystem.invert();
  }
  getStyle() {
    if (!this.world.renderer)
      return null;
    const t = this.world.renderer instanceof xa;
    return this.styleName && t ? this.world.renderer.postproduction.customEffects.outlinedMeshes[this.styleName] : null;
  }
};
var wp = class {
  constructor(t, e, n) {
    b(this, "onDisposed", new $());
    b(this, "onAfterUpdate", new $());
    b(this, "onBeforeUpdate", new $());
    b(this, "enabled", true);
    b(this, "fillNeedsUpdate", false);
    b(this, "components");
    b(this, "world");
    b(this, "_edges", {});
    b(this, "_visible", true);
    b(this, "_inverseMatrix", new Matrix4());
    b(this, "_localPlane", new Plane());
    b(this, "_tempLine", new Line3());
    b(this, "_tempVector", new Vector3());
    b(this, "_plane");
    this.components = t, this.world = e, this._plane = n;
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this._visible;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(t) {
    for (const e in this._edges) {
      const n = this._edges[e];
      t ? this.world.scene.three.add(n.mesh) : n.mesh.removeFromParent(), n.fill && (n.fill.visible = t);
    }
  }
  /**
   * Getter that returns an array of THREE.Mesh instances representing the fills of the edges.
   *
   * @returns An array of THREE.Mesh instances representing the fills of the edges.
   */
  get fillMeshes() {
    const t = [];
    for (const e in this._edges) {
      const n = this._edges[e];
      n.fill && t.push(n.fill.mesh);
    }
    return t;
  }
  /** {@link OBC.Updateable.update} */
  update() {
    const e = this.components.get(ps).styles.list;
    this.updateDeletedEdges(e);
    for (const n in e)
      this.drawEdges(n);
    this.fillNeedsUpdate = false;
  }
  // TODO: Remove?
  get() {
    return this._edges;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    const t = Object.keys(this._edges);
    for (const e of t)
      this.disposeEdge(e);
    this.onDisposed.trigger(), this.onDisposed.reset();
  }
  newEdgesMesh(t) {
    const s = this.components.get(ps).styles.list[t].lineMaterial, i = new BufferGeometry(), r = new Float32Array(3e5), o = new BufferAttribute(r, 3, false);
    o.setUsage(DynamicDrawUsage), i.setAttribute("position", o);
    const l = new LineSegments(i, s);
    return l.frustumCulled = false, l;
  }
  newFillMesh(t, e) {
    const i = this.components.get(ps).styles.list[t], r = i.fillMaterial;
    if (r) {
      const o = new yp(
        this.components,
        this.world,
        this._plane,
        e,
        r
      );
      return this.newFillOutline(t, o, i), o;
    }
  }
  newFillOutline(t, e, n) {
    if (!n.outlineMaterial || !this.world.renderer)
      return;
    const s = this.world.renderer;
    if (s instanceof xa) {
      const r = s.postproduction.customEffects.outlinedMeshes;
      r[t] || (r[t] = {
        meshes: /* @__PURE__ */ new Set(),
        material: n.outlineMaterial
      }), e.styleName = t;
    }
  }
  // Source: https://gkjohnson.github.io/three-mesh-bvh/example/bundle/clippedEdges.html
  drawEdges(t) {
    const n = this.components.get(ps).styles.list[t];
    this._edges[t] || this.initializeStyle(t);
    const s = this._edges[t];
    let i = 0;
    const r = s.mesh.geometry.attributes.position;
    r.array.fill(0);
    const o = [];
    let l = 0;
    const u = /* @__PURE__ */ new Map();
    for (const f of n.meshes)
      if (f.geometry) {
        if (!f.geometry.boundsTree)
          throw new Error("Bounds tree not found for clipping edges subset.");
        if (f instanceof InstancedMesh) {
          if (f.count === 0)
            continue;
          const g = f;
          for (let v = 0; v < g.count; v++) {
            const y = g instanceof ae, x = g, A = n.fragments[x.fragment.id];
            if (y && A) {
              const C = x.fragment.getItemID(v);
              if (C === null || !A.has(C))
                continue;
            }
            const R = new Mesh(f.geometry);
            R.matrix.copy(f.matrix);
            const P = new Matrix4();
            if (g.getMatrixAt(v, P), R.applyMatrix4(P), R.applyMatrix4(f.matrix), R.updateMatrix(), R.updateMatrixWorld(), this._inverseMatrix.copy(R.matrixWorld).invert(), this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix), i = this.shapecast(R, r, i), i !== l) {
              if (y && A) {
                const C = x.fragment.getItemID(v);
                C !== null && u.set(i, {
                  [x.fragment.id]: /* @__PURE__ */ new Set([C])
                });
              }
              o.push(i), l = i;
            }
          }
        } else
          this._inverseMatrix.copy(f.matrixWorld).invert(), this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix), i = this.shapecast(f, r, i), i !== l && (o.push(i), l = i);
      }
    s.mesh.geometry.setDrawRange(0, i), s.mesh.position.copy(this._plane.normal).multiplyScalar(1e-4), r.needsUpdate = true;
    const m = s.mesh.geometry.attributes.position;
    Number.isNaN(m.array[0]) || (s.mesh.parent || this.world.scene.three.add(s.mesh), this.fillNeedsUpdate && s.fill && (s.fill.geometry = s.mesh.geometry, s.fill.update(o, u)));
  }
  initializeStyle(t) {
    const e = this.newEdgesMesh(t), n = e.geometry, s = this.newFillMesh(t, n);
    this._edges[t] = { mesh: e, name: t, fill: s };
  }
  shapecast(t, e, n) {
    return t.geometry.boundsTree.shapecast({
      intersectsBounds: (s) => this._localPlane.intersectsBox(s),
      // @ts-ignore
      intersectsTriangle: (s) => {
        let i = 0;
        if (this._tempLine.start.copy(s.a), this._tempLine.end.copy(s.b), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(n, r.x, r.y, r.z), i++, n++;
        }
        if (this._tempLine.start.copy(s.b), this._tempLine.end.copy(s.c), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(n, r.x, r.y, r.z), i++, n++;
        }
        if (this._tempLine.start.copy(s.c), this._tempLine.end.copy(s.a), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(n, r.x, r.y, r.z), i++, n++;
        }
        i !== 2 && (n -= i);
      }
    }), n;
  }
  updateDeletedEdges(t) {
    const e = Object.keys(this._edges);
    for (const n of e)
      t[n] === void 0 && (this.disposeEdge(n), this.disposeOutline(n));
  }
  disposeOutline(t) {
    if (!this.world.renderer)
      return;
    const e = this.world.renderer;
    if (e instanceof xa) {
      const n = e.postproduction.customEffects.outlinedMeshes;
      delete n[t];
    }
  }
  disposeEdge(t) {
    const e = this.components.get(rn), n = this._edges[t];
    n.fill && n.fill.dispose(), e.destroy(n.mesh, false), delete this._edges[t];
  }
};
var ui = class extends jr {
  constructor(e, n, s, i, r, o = 5, l = true) {
    super(e, n, s, i, r, o, l);
    b(this, "edges");
    b(this, "edgesMaxUpdateRate", 50);
    b(this, "_visible", true);
    b(this, "_edgesVisible", true);
    b(this, "updateFill", () => {
      this.edges.fillNeedsUpdate = true, this.edges.update(), this.edges.visible = this._visible;
    });
    this.edges = new wp(e, n, this.three), this.toggleControls(true), this.edges.visible = true, this.onDraggingEnded.add(() => {
      this.updateFill();
    }), this.onDraggingStarted.add(() => this.edges.visible = false);
  }
  /**
   * Getter for the visibility state of the plane.
   * @returns {boolean} The current visibility state.
   */
  get visible() {
    return this._visible;
  }
  /**
   * Setter for the visibility state of the plane.
   * Also toggles the visibility of the controls.
   * @param {boolean} state - The new visibility state.
   */
  set visible(e) {
    super.visible = e, this.toggleControls(e);
  }
  /**
   * Setter for the enabled state of the plane.
   * Also sets the enabled state in the renderer.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(e) {
    this._enabled = e, this.world.renderer && this.world.renderer.setPlane(e, this.three);
  }
  /**
   * Getter for the enabled state of the plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return super.enabled;
  }
  /**
   * Disposes of the EdgesPlane and its associated ClippingEdges.
   * This method should be called when the EdgesPlane is no longer needed to free up resources.
   * After calling this method, the EdgesPlane and its ClippingEdges should not be used anymore.
   */
  dispose() {
    super.dispose(), this.edges.dispose();
  }
};
var Cp = class {
  constructor() {
    b(this, "onDisposed", new $());
    b(this, "enabled", true);
    b(this, "list", {});
    b(this, "_defaultLineMaterial", new LineBasicMaterial({
      color: 0,
      linewidth: 1e-3
    }));
    b(this, "onAfterUpdate", new $());
    b(this, "onBeforeUpdate", new $());
  }
  /** {@link OBC.Updateable.update} */
  update(t) {
    this.onBeforeUpdate.trigger(this.list), this.onAfterUpdate.trigger(this.list);
  }
  // Creates a new style that applies to all clipping edges for generic models
  /**
   * Creates a new style that applies to all clipping edges for generic models.
   *
   * @param name - The name of the style.
   * @param meshes - A set of meshes to apply the style to.
   * @param world - The world where the meshes are located.
   * @param lineMaterial - The material for the lines of the style. If not provided, the default material is used.
   * @param fillMaterial - The material for the fill of the style.
   * @param outlineMaterial - The material for the outline of the style.
   *
   * @returns The newly created style.
   *
   * @throws Will throw an error if the given world doesn't have a renderer.
   */
  create(t, e, n, s, i, r) {
    if (!n.renderer)
      throw new Error("The given world doesn't have a renderer!");
    s || (s = this._defaultLineMaterial);
    for (const u of e)
      u.geometry.boundsTree || u.geometry.computeBoundsTree();
    const o = n.renderer;
    s.clippingPlanes = o.clippingPlanes;
    const l = {
      name: t,
      lineMaterial: s,
      meshes: e,
      fillMaterial: i,
      outlineMaterial: r,
      fragments: {}
    };
    return this.list[t] = l, l;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    const t = Object.keys(this.list);
    for (const e of t)
      this.deleteStyle(e);
    this.list = {}, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Deletes a style from the list and optionally disposes of its materials.
   *
   * @param id - The id of the style to delete.
   * @param disposeMaterials - A boolean indicating whether to dispose of the materials associated with the style.
   *                           Default value is `true`.
   *
   * @throws Will throw an error if the style with the given id doesn't exist in the list.
   */
  deleteStyle(t, e = true) {
    var s, i;
    const n = this.list[t];
    n && (n.meshes.clear(), e && (n.lineMaterial.dispose(), (s = n.fillMaterial) == null || s.dispose(), (i = n.outlineMaterial) == null || i.dispose())), delete this.list[t];
  }
};
var Or = class Or2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "enabled", true);
    b(this, "styles");
    b(this, "fillsNeedUpdate", false);
    b(this, "_visible", true);
    this.components.list.set(Or2.uuid, this), this.styles = new Cp();
  }
  /**
   * Gets the visibility state of the edges.
   * @returns {boolean} The current visibility state.
   */
  get visible() {
    return this._visible;
  }
  /**
   * Sets the visibility state of the edges.
   * Updates the visibility of the associated {@link EdgesPlane} instances.
   * @param {boolean} active - The new visibility state.
   */
  set visible(e) {
    this._visible = e;
    const n = this.components.get(ai);
    for (const s of n.list)
      s instanceof ui && (s.edges.visible = e);
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.styles.dispose(), this.onDisposed.trigger();
  }
  /**
   * Updates all the lines of the component.
   *
   * @param {boolean} [updateFills=false] - If true, the fills will be updated regardless of the `fillsNeedUpdate` flag.
   * @returns {Promise<void>} - A promise that resolves when the update is complete.
   *
   * @remarks
   * This method iterates through all the {@link EdgesPlane} instances associated with the {@link Clipper} component.
   */
  async update(e = false) {
    if (!this.enabled)
      return;
    const n = this.components.get(ai);
    for (const s of n.list)
      s instanceof ui && (e || this.fillsNeedUpdate ? s.updateFill() : s.update());
    this.fillsNeedUpdate = false;
  }
};
b(Or, "uuid", "24dfc306-a3c4-410f-8071-babc4afa5e4d");
var ps = Or;
var Tp = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};
var bp = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};
var vn = class vn2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "enabled", true);
    b(this, "cameraHeight", 10);
    b(this, "darkness", 1.2);
    b(this, "opacity", 1);
    b(this, "resolution", 512);
    b(this, "amount", 3.5);
    b(this, "planeColor", 16777215);
    b(this, "shadowOffset", 0);
    b(this, "shadowExtraScaleFactor", 1.5);
    b(this, "list", {});
    b(this, "tempMaterial", new MeshBasicMaterial({ visible: false }));
    b(this, "depthMaterial", new MeshDepthMaterial());
    this.components.add(vn2.uuid, this), this.initializeDepthMaterial();
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    for (const e in this.list)
      this.deleteShadow(e);
    this.tempMaterial.dispose(), this.depthMaterial.dispose(), this.components = null, this.onDisposed.trigger(vn2.uuid), this.onDisposed.reset();
  }
  /**
   * Creates a blurred dropped shadow of the given mesh.
   *
   * @param model - the mesh whose shadow to generate.
   * @param id - the name of this shadow.
   */
  create(e, n, s) {
    if (this.list[n])
      throw new Error(`There is already a shadow with ID ${n}`);
    const { size: i, center: r, min: o } = this.getSizeCenterMin(e), l = this.createShadow(n, i, s);
    return this.initializeShadow(l, r, o), this.createPlanes(l, i), this.bakeShadow(e, l), l.root;
  }
  /**
   * Deletes the specified shadow (if it exists).
   *
   * @param id - the name of this shadow.
   */
  deleteShadow(e) {
    const n = this.components.get(rn), s = this.list[e];
    if (delete this.list[e], !s)
      throw new Error(`No shadow with ID ${e} was found.`);
    n.destroy(s.root), n.destroy(s.blurPlane), s.rt.dispose(), s.rtBlur.dispose();
  }
  createPlanes(e, n) {
    const s = new PlaneGeometry(n.x, n.z).rotateX(
      Math.PI / 2
    );
    this.createBasePlane(e, s), vn2.createBlurPlane(e, s);
  }
  initializeShadow(e, n, s) {
    this.initializeRoot(e, n, s), vn2.initializeRenderTargets(e), vn2.initializeCamera(e);
  }
  bakeShadow(e, n) {
    const s = n.world.scene.three;
    if (!(s instanceof Scene))
      throw new Error("The core of the scene of the world must be a scene!");
    if (!n.world.renderer)
      throw new Error("The given world must have a renderer!");
    const i = n.world.renderer.three, r = e.map((d) => !!d.parent);
    for (let d = 0; d < e.length; d++)
      r[d] || s.add(e[d]);
    const o = s.children.filter(
      (d) => !e.includes(d) && d !== n.root
    );
    for (let d = o.length - 1; d >= 0; d--)
      s.remove(o[d]);
    const l = s.background;
    s.background = null, s.overrideMaterial = this.depthMaterial;
    const u = [];
    for (const d of e)
      u.push(d.visible), d.visible = true;
    i.setRenderTarget(n.rt), i.render(s, n.camera), s.overrideMaterial = null, this.blurShadow(n, this.amount), this.blurShadow(n, this.amount * 0.4), i.setRenderTarget(null), s.background = l;
    for (let d = 0; d < e.length; d++)
      e[d].visible = u[d];
    for (let d = o.length - 1; d >= 0; d--)
      s.add(o[d]);
    for (let d = 0; d < e.length; d++)
      r[d] || s.remove(e[d]);
  }
  static initializeCamera(e) {
    e.camera.rotation.x = Math.PI / 2, e.root.add(e.camera);
  }
  static initializeRenderTargets(e) {
    e.rt.texture.generateMipmaps = false, e.rtBlur.texture.generateMipmaps = false;
  }
  initializeRoot(e, n, s) {
    const i = e.world.scene.three;
    e.root.position.set(n.x, s.y - this.shadowOffset, n.z), i.add(e.root);
  }
  // Plane simulating the "ground". This is not needed for BIM models generally
  // private createGroundColorPlane(_shadow: Shadow, planeGeometry: BufferGeometry) {
  //   const fillPlaneMaterial = new MeshBasicMaterial({
  //     color: this.planeColor,
  //     opacity: this.opacity,
  //     transparent: true,
  //     depthWrite: false,
  //     clippingPlanes: this.context.getClippingPlanes()
  //   });
  //   const fillPlane = new Mesh(planeGeometry, fillPlaneMaterial);
  //   fillPlane.rotateX(Math.PI);
  //   fillPlane.renderOrder = -1;
  //   shadow.root.add(fillPlane);
  // }
  createBasePlane(e, n) {
    const s = this.createPlaneMaterial(e), i = new Mesh(n, s);
    i.renderOrder = 2, e.root.add(i), i.scale.y = -1;
  }
  static createBlurPlane(e, n) {
    e.blurPlane.geometry = n, e.blurPlane.visible = false, e.root.add(e.blurPlane);
  }
  createPlaneMaterial(e) {
    if (!e.world.renderer)
      throw new Error("The given world must have a renderer!");
    const n = e.world.renderer.three;
    return new MeshBasicMaterial({
      map: e.rt.texture,
      opacity: this.opacity,
      transparent: true,
      depthWrite: false,
      clippingPlanes: n.clippingPlanes
    });
  }
  // like MeshDepthMaterial, but goes from black to transparent
  initializeDepthMaterial() {
    this.depthMaterial.depthTest = false, this.depthMaterial.depthWrite = false;
    const e = "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", n = "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );";
    this.depthMaterial.userData.darkness = { value: this.darkness }, this.depthMaterial.onBeforeCompile = (s) => {
      s.uniforms.darkness = this.depthMaterial.userData.darkness, s.fragmentShader = /* glsl */
      `
						uniform float darkness;
						${s.fragmentShader.replace(e, n)}
					`;
    };
  }
  createShadow(e, n, s) {
    return this.list[e] = {
      root: new Group(),
      world: s,
      rt: new WebGLRenderTarget(this.resolution, this.resolution),
      rtBlur: new WebGLRenderTarget(this.resolution, this.resolution),
      blurPlane: new Mesh(),
      camera: this.createCamera(n)
    }, this.list[e];
  }
  createCamera(e) {
    return new OrthographicCamera(
      -e.x / 2,
      e.x / 2,
      e.z / 2,
      -e.z / 2,
      0,
      this.cameraHeight
    );
  }
  getSizeCenterMin(e) {
    const n = e[0].parent, s = new Group();
    s.children = e;
    const i = new Box3().setFromObject(s);
    n == null || n.add(...e);
    const r = new Vector3();
    i.getSize(r), r.x *= this.shadowExtraScaleFactor, r.z *= this.shadowExtraScaleFactor;
    const o = new Vector3();
    i.getCenter(o);
    const l = i.min;
    return { size: r, center: o, min: l };
  }
  blurShadow(e, n) {
    if (!e.world.renderer)
      throw new Error("The given world must have a renderer!");
    const s = new ShaderMaterial(
      Tp
    );
    s.depthTest = false;
    const i = new ShaderMaterial(bp);
    i.depthTest = false, e.blurPlane.visible = true, e.blurPlane.material = s, e.blurPlane.material.uniforms.tDiffuse.value = e.rt.texture, s.uniforms.h.value = n * 1 / 256;
    const r = e.world.renderer.three;
    r.setRenderTarget(e.rtBlur), r.render(e.blurPlane, e.camera), e.blurPlane.material = i, e.blurPlane.material.uniforms.tDiffuse.value = e.rtBlur.texture, i.uniforms.v.value = n * 1 / 256, r.setRenderTarget(e.rt), r.render(e.blurPlane, e.camera), e.blurPlane.visible = false;
  }
};
b(vn, "uuid", "f833a09a-a3ab-4c58-b03e-da5298c7a1b6");
var fc = vn;
var xp = [
  "Station",
  "Radius",
  "Length",
  "InitialKP",
  "FinalKP",
  "KP",
  "Slope",
  "Height",
  "InitialKPV",
  "FinalKPV"
];
var Dr = class Dr2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "enabled", true);
    b(this, "world", null);
    b(this, "_markerKey", 0);
    b(this, "_list", /* @__PURE__ */ new Map());
    b(this, "type", "horizontal");
    b(this, "divisionLength", 100);
    e.add(Dr2.uuid, this);
  }
  /**
   * Adds a KP station marker to the world.
   *
   * @param world - The world to add the marker to.
   * @param text - The text to display on the marker.
   * @param mesh - The line representing the KP station.
   *
   * @returns {void}
   */
  addKPStation(e, n, s) {
    const i = this.components.get(nn), r = document.createElement("div"), o = document.createElement("div");
    r.appendChild(o), o.innerHTML = n, o.style.color = i.color, o.style.borderBottom = "1px dotted white", o.style.width = "160px", o.style.textAlign = "left";
    const l = new ft(e, r), u = new Vector3();
    u.x = s.geometry.attributes.position.getX(
      s.geometry.attributes.position.count - 1
    ), u.y = s.geometry.attributes.position.getY(
      s.geometry.attributes.position.count - 1
    ), u.z = s.geometry.attributes.position.getZ(
      s.geometry.attributes.position.count - 1
    );
    const d = new Vector3();
    d.x = s.geometry.attributes.position.getX(
      s.geometry.attributes.position.count - 2
    ), d.y = s.geometry.attributes.position.getY(
      s.geometry.attributes.position.count - 2
    ), d.z = s.geometry.attributes.position.getZ(
      s.geometry.attributes.position.count - 2
    );
    const m = new Vector3();
    m.x = (u.x + d.x) / 2, m.y = (u.y + d.y) / 2, m.z = (u.z + d.z) / 2, l.three.position.copy(m);
    const f = new Vector3();
    f.subVectors(u, d).normalize();
    const g = new Quaternion();
    g.setFromUnitVectors(new Vector3(0, 1, 0), f);
    const v = new Euler().setFromQuaternion(g).z, y = MathUtils.radToDeg(v);
    o.style.transform = `rotate(${-y - 90}deg) translate(-35%, -50%)`;
    const x = this._markerKey.toString();
    i.setupEvents(e, true), i.getWorldMarkerList(e).set(x, {
      label: l,
      key: x,
      merged: false,
      static: false
    }), this._markerKey++, this.save(x, "KP");
  }
  /**
   * Adds a vertical marker to the 3D world based on the given parameters.
   *
   * @param world - The 3D world where the marker will be added.
   * @param text - The text to be displayed on the marker.
   * @param mesh - The mesh data related to the marker.
   * @param type - The type of the marker.
   * @param root - The root object for the marker.
   *
   * @returns The created and added marker.
   */
  addVerticalMarker(e, n, s, i, r) {
    const o = this.components.get(nn), l = document.createElement("span");
    l.innerHTML = n, l.style.color = o.color;
    const u = new ft(e, l, r);
    if (i === "Height") {
      const f = document.createElement("span");
      f.innerHTML = n, f.style.color = o.color;
      const { position: g } = s.geometry.attributes, y = (g.array.length / 3 - 1) * 3, x = g.array.slice(y, y + 3);
      u.three.position.set(x[0], x[1] + 10, x[2]);
    } else if (i === "InitialKPV") {
      const { position: f } = s.geometry.attributes, g = f.getX(0), v = f.getY(0), y = f.getZ(0);
      u.three.position.set(g - 20, v, y);
    } else if (i === "FinalKPV") {
      const { position: f } = s.geometry.attributes, g = f.getX(s.geometry.attributes.position.count - 1), v = f.getY(s.geometry.attributes.position.count - 1), y = f.getZ(s.geometry.attributes.position.count - 1);
      u.three.position.set(g + 20, v, y);
    } else if (i === "Slope") {
      l.style.color = "grey";
      const { position: f } = s.geometry.attributes, g = new Vector3();
      g.x = f.getX(0), g.y = f.getY(0), g.z = f.getZ(0);
      const v = new Vector3();
      v.x = f.getX(f.count - 1), v.y = f.getY(f.count - 1), v.z = f.getZ(f.count - 1);
      const y = new Vector3();
      y.addVectors(g, v).multiplyScalar(0.5), u.three.position.set(y.x, y.y - 10, y.z);
    }
    const d = this._markerKey.toString();
    return o.setupEvents(e, true), o.getWorldMarkerList(e).set(d, {
      label: u,
      key: d,
      type: i,
      merged: false,
      static: false
    }), this._markerKey++, this.save(d, i), u;
  }
  /**
   * Adds a civil engineering marker to the world based on the given type.
   *
   * @param world - The world to add the marker to.
   * @param text - The text to display on the marker.
   * @param mesh - The mesh related to the marker.
   * @param type - The type of the marker.
   *
   * @returns The created marker.
   */
  addCivilMarker(e, n, s, i) {
    const r = this.components.get(nn), o = document.createElement("span");
    o.innerHTML = n, o.style.color = r.color;
    const l = new ft(e, o);
    if (i === "InitialKP") {
      const m = s.geometry.attributes.position.getX(0), f = s.geometry.attributes.position.getY(0), g = s.geometry.attributes.position.getZ(0);
      l.three.position.set(m + 2, f + 2, g);
    } else if (i === "FinalKP") {
      const m = s.geometry.attributes.position.getX(
        s.geometry.attributes.position.count - 1
      ), f = s.geometry.attributes.position.getY(
        s.geometry.attributes.position.count - 1
      ), g = s.geometry.attributes.position.getZ(
        s.geometry.attributes.position.count - 1
      );
      l.three.position.set(m + 2, f - 2, g);
    } else if (i === "Length") {
      const m = new Vector3();
      m.x = s.geometry.attributes.position.getX(0), m.y = s.geometry.attributes.position.getY(0), m.z = s.geometry.attributes.position.getZ(0);
      const f = new Vector3();
      f.x = s.geometry.attributes.position.getX(
        s.geometry.attributes.position.count - 1
      ), f.y = s.geometry.attributes.position.getY(
        s.geometry.attributes.position.count - 1
      ), f.z = s.geometry.attributes.position.getZ(
        s.geometry.attributes.position.count - 1
      );
      const g = m.distanceTo(f);
      l.three.element.innerText = g.toFixed(2);
      const v = f.clone().add(m).divideScalar(2);
      l.three.position.copy(v);
    }
    const u = this._markerKey.toString();
    return r.setupEvents(e, true), r.getWorldMarkerList(e).set(u, {
      label: l,
      key: u,
      type: i,
      merged: false,
      static: false
    }), this._markerKey++, this.save(u, i), l;
  }
  /**
   * Shows the KP stations on the given mesh.
   *
   * @param mesh - The mesh to show the KP stations on.
   * @throws Will throw an error if a world is not set for this component.
   * @throws Will throw an error if the type is not set to "horizontal".
   */
  showKPStations(e) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    if (this.type === "horizontal") {
      const n = this.generateStartAndEndKP(e);
      for (const [, i] of n)
        this.addKPStation(this.world, i.value, i.normal);
      const s = this.generateConstantKP(e);
      for (const [, i] of s)
        this.addKPStation(this.world, i.value, i.normal);
    }
  }
  /**
   * Shows the length of a curve on the world.
   *
   * @param points - The points that make up the curve.
   * @param length - The length of the curve.
   * @throws Will throw an error if a world is not set for this component.
   */
  showCurveLength(e, n) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const s = this.components.get(nn), i = e.length, r = `${n.toFixed(2)} m`, o = Math.round(i / 2), l = e[o], u = s.create(this.world, r, l, true);
    u !== void 0 && this.save(u, "Radius");
  }
  /**
   * Shows the length of a line on the world.
   *
   * @param line - The line to show the length on.
   * @param length - The length of the line.
   * @throws Will throw an error if a world is not set for this component.
   */
  showLineLength(e, n) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const s = this.components.get(nn), i = new Vector3();
    i.x = e.geometry.getAttribute("position").getX(0), i.y = e.geometry.getAttribute("position").getY(0), i.z = e.geometry.getAttribute("position").getZ(0);
    const r = new Vector3();
    r.x = e.geometry.getAttribute("position").getX(1), r.y = e.geometry.getAttribute("position").getY(1), r.z = e.geometry.getAttribute("position").getZ(1);
    const o = `${n.toFixed(2)} m`, l = new Vector3();
    l.addVectors(i, r).multiplyScalar(0.5);
    const u = s.create(this.world, o, l, true);
    u !== void 0 && this.save(u, "Radius");
  }
  /**
   * Shows the radius of a curve on the world.
   *
   * @param line - The line to show the radius on.
   * @param radius - The radius of the curve.
   * @throws Will throw an error if a world is not set for this component.
   */
  showCurveRadius(e, n) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const s = this.components.get(nn), i = new Vector3();
    i.x = e.geometry.getAttribute("position").getX(0), i.y = e.geometry.getAttribute("position").getY(0), i.z = e.geometry.getAttribute("position").getZ(0);
    const r = new Vector3();
    r.x = e.geometry.getAttribute("position").getX(1), r.y = e.geometry.getAttribute("position").getY(1), r.z = e.geometry.getAttribute("position").getZ(1);
    const o = `R = ${n.toFixed(2)} m`, l = new Vector3();
    l.addVectors(i, r).multiplyScalar(0.5);
    const u = s.create(this.world, o, l, true);
    u !== void 0 && this.save(u, "Radius");
  }
  /**
   * Deletes civil engineering markers of the specified types from the world.
   *
   * @param types - The types of markers to delete. If not provided, all types will be deleted.
   * @returns {void}
   */
  deleteByType(e = xp) {
    const n = this.components.get(nn);
    for (const s of e) {
      const i = this._list.get(s);
      if (i) {
        for (const r of i)
          n.delete(r);
        this._list.delete(s);
      }
    }
  }
  generateStartAndEndKP(e) {
    const { alignment: n } = e.curve, s = /* @__PURE__ */ new Map();
    for (const i of n.horizontal) {
      const r = i.getLength();
      if (s.size > 0) {
        const o = i.index - 1, u = s.get(o).distance + r, d = i.mesh.geometry.getAttribute("position"), m = d.count - 1, f = new Vector3();
        f.x = d.getX(m), f.y = d.getY(m), f.z = d.getZ(m);
        const g = this.createNormalLine(i.mesh);
        s.set(i.index, {
          value: this.getShortendKPValue(u),
          distance: u,
          point: f,
          normal: g
        });
      } else {
        const o = i.mesh.geometry.getAttribute("position"), l = o.count - 1, u = new Vector3();
        u.x = o.getX(l), u.y = o.getY(l), u.z = o.getZ(l);
        const d = this.createNormalLine(i.mesh);
        s.set(i.index, {
          value: this.getShortendKPValue(r),
          distance: r,
          point: u,
          normal: d
        });
      }
    }
    return s;
  }
  createNormalLine(e) {
    const n = e.geometry.attributes.position.count - 1, s = n - 1, i = new Vector3();
    i.x = e.geometry.attributes.position.getX(n), i.y = e.geometry.attributes.position.getY(n), i.z = e.geometry.attributes.position.getZ(n);
    const r = new Vector3();
    r.x = e.geometry.attributes.position.getX(s), r.y = e.geometry.attributes.position.getY(s), r.z = e.geometry.attributes.position.getZ(s);
    const l = new Vector3().subVectors(
      i,
      r
    ).clone().applyAxisAngle(new Vector3(0, 0, 1), Math.PI * 0.5).normalize(), u = new BufferGeometry().setFromPoints([
      l.clone().setLength(10).add(i),
      l.clone().setLength(-10).add(i)
    ]);
    return new Line(u);
  }
  generateConstantKP(e) {
    const { alignment: n } = e.curve, s = /* @__PURE__ */ new Map(), i = n.getLength("horizontal"), r = Math.floor(i / this.divisionLength);
    for (let o = 0; o < r; o++) {
      const l = o / r, u = n.getPointAt(l, "horizontal"), d = i * l, m = this.getNormal(n, u);
      s.set(o, {
        value: this.getShortendKPValue(d),
        distance: d,
        point: u,
        normal: m
      });
    }
    return s;
  }
  // TODO: Move Generation of Points to Previous Method Call
  getNormal(e, n) {
    const s = [], i = {
      start: new Vector3(),
      end: new Vector3()
    };
    for (let d = 0; d < e.horizontal.length; d++) {
      const f = e.horizontal[d].mesh.geometry.attributes.position, g = f.count;
      for (let v = 0; v < g; v++) {
        const y = f.getX(v), x = f.getY(v), A = f.getZ(v);
        s.push(new Vector3(y, x, A));
      }
    }
    for (let d = 0; d < s.length - 1; d++) {
      const m = s[d], f = s[d + 1], g = m.distanceTo(n), v = f.distanceTo(n), y = m.distanceTo(f);
      Math.abs(g + v - y) < 1e-5 && (i.start = m, i.end = f);
    }
    const o = new Vector3().subVectors(
      i.end,
      i.start
    ).clone().applyAxisAngle(new Vector3(0, 0, 1), Math.PI * 0.5).normalize(), l = new BufferGeometry().setFromPoints([
      o.clone().setLength(10).add(n),
      o.clone().setLength(-10).add(n)
    ]);
    return new Line(
      l,
      new LineBasicMaterial({ color: 16711680 })
    );
  }
  getShortendKPValue(e) {
    const n = e.toFixed(2), [s, i] = n.toString().split("."), r = i || "00";
    if (parseInt(s, 10) > 1e3 && parseInt(s, 10) < 1e4) {
      const [o, ...l] = s;
      return `${o}+${l.join("")}.${r}`;
    }
    if (parseInt(s, 10) > 1e4) {
      const [o, l, ...u] = s;
      return `${o}${l}+${u.join("")}.${r}`;
    }
    return `0+${s.padStart(3, "0")}.${r}`;
  }
  save(e, n) {
    this._list.has(n) || this._list.set(n, /* @__PURE__ */ new Set()), this._list.get(n).add(e);
  }
};
b(Dr, "uuid", "0af12c32-81ee-4100-a030-e9ae546f6170");
var Bn = Dr;
var Ah = class extends Fe {
  constructor(e) {
    super(e);
    b(this, "onHighlight", new $());
    b(this, "onMarkerChange", new $());
    b(this, "onMarkerHidden", new $());
    b(this, "onDisposed", new $());
    b(this, "enabled", true);
    b(this, "mouseMarkers");
    b(this, "_curves", []);
    b(this, "_previousAlignment", null);
    b(this, "_highlighter");
    b(this, "_world", null);
    b(this, "updateLinesResolution", (e2) => {
      var n;
      (n = this._highlighter) == null || n.setResolution(e2);
    });
    b(this, "onMouseMove", (e2) => {
      var o, l, u;
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!this._world.renderer)
        return;
      const s = this._world.renderer.three.domElement.parentElement, i = this._world.camera.three, r = (o = this._highlighter) == null ? void 0 : o.castRay(e2, i, s, this._curves);
      if (r) {
        const { object: d } = r;
        (l = this._highlighter) == null || l.hover(d), this.updateMarker(r, "hover");
        return;
      }
      this.mouseMarkers && (this.mouseMarkers.hover.visible = false), (u = this._highlighter) == null || u.unHover(), this.onMarkerHidden.trigger({ type: "hover" });
    });
    b(this, "onClick", (e2) => {
      var o, l;
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!this._world.renderer)
        return;
      const s = this._world.renderer.three.domElement.parentElement, i = this._world.camera.three, r = (o = this._highlighter) == null ? void 0 : o.castRay(e2, i, s, this._curves);
      if (r) {
        const u = r, d = u.object;
        if ((l = this._highlighter) == null || l.select(d), this.updateMarker(u, "select"), this._world.camera.hasCameraControls() && (d.geometry.boundingBox || d.geometry.computeBoundingBox(), d.geometry.boundingBox)) {
          const m = this.getScaledBox(d.geometry.boundingBox, 2);
          this._world.camera.controls.fitToBox(m, true);
        }
        this.onHighlight.trigger({ mesh: d, point: u.point }), this._previousAlignment !== d.curve.alignment && (this.components.get(Bn).showKPStations(d), this._previousAlignment = d.curve.alignment);
      }
    });
    b(this, "onControlsUpdated", () => {
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!(this._world.camera.three instanceof OrthographicCamera) || !this._highlighter)
        return;
      const { zoom: e2, left: n, right: s, top: i, bottom: r } = this._world.camera.three, o = n - s, l = i - r, d = Math.max(o, l) / e2, m = 40, { caster: f } = this._highlighter;
      f.params.Line.threshold = d / m;
    });
  }
  /**
   * Getter for the highlighter instance.
   * Throws an error if the highlighter is not initialized.
   *
   * @returns {CurveHighlighter} The initialized highlighter instance.
   */
  get highlighter() {
    if (!this._highlighter)
      throw new Error(
        "Highlighter not initialized. You must set a world first!"
      );
    return this._highlighter;
  }
  /**
   * Getter for the world instance.
   *
   * @returns {OBC.World | null} The current world instance or null if not set.
   */
  get world() {
    return this._world;
  }
  /**
   * Setter for the world instance.
   * If the new world is the same as the current one, it does nothing.
   * If the current world is set, it removes the event listeners.
   * If the new world is not set, it does nothing.
   *
   * @param {OBC.World | null} world - The new world instance or null to unset.
   */
  set world(e) {
    var s, i, r;
    if (e === this._world || (this._world && this.setupEvents(false), this._world = e, (s = this._highlighter) == null || s.dispose(), (i = this.mouseMarkers) == null || i.hover.dispose(), (r = this.mouseMarkers) == null || r.select.dispose(), !e))
      return;
    const n = e.scene.three;
    this._highlighter = new Rr(n, this.view), this.mouseMarkers = {
      select: this.newMouseMarker("#ffffff", e),
      hover: this.newMouseMarker("#575757", e)
    }, this.setupEvents(true);
  }
  /**
   * Draws the civil curves from the provided model onto the scene.
   *
   * @param model - The FragmentsGroup containing the civil data to be drawn.
   * @param filter - An optional Iterable of alignments to filter the curves to be drawn.
   *
   * @throws Will throw an error if the provided model doesn't have civil data or if no world was given for this navigator.
   *
   * @returns {Promise<void>} - A promise that resolves when the curves have been drawn onto the scene.
   */
  async draw(e, n) {
    if (!e.civilData)
      throw new Error("The provided model doesn't have civil data!");
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    const { alignments: s } = e.civilData, i = n || s.values(), r = this._world.scene.three, o = new Box3();
    o.makeEmpty(), o.min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), o.max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (const u of i) {
      if (!u)
        throw new Error("Alignment not found!");
      for (const d of u[this.view])
        if (r.add(d.mesh), this._curves.push(d.mesh), !o.isEmpty())
          o.expandByObject(d.mesh);
        else {
          d.mesh.geometry.computeBoundingBox();
          const m = d.mesh.geometry.boundingBox;
          m instanceof Box3 && o.copy(m).applyMatrix4(d.mesh.matrixWorld);
        }
    }
    const l = this.getScaledBox(o, 1.2);
    this._world.camera.hasCameraControls() && await this._world.camera.controls.fitToBox(l, false);
  }
  /** {@link OBC.Disposable.dispose} */
  async dispose() {
    var e;
    (e = this._highlighter) == null || e.dispose(), this.clear(), this.onHighlight.reset(), this._curves = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Clears the civil curves from the scene.
   * Removes all the curve meshes from the scene and clears the internal array of curve meshes.
   * Also unselects and unhovers the highlighter.
   */
  clear() {
    var e, n;
    (e = this._highlighter) == null || e.unSelect(), (n = this._highlighter) == null || n.unHover();
    for (const s of this._curves)
      s.removeFromParent();
    this._curves = [];
  }
  /**
   * Sets a marker on a specific curve at a given percentage.
   *
   * @param alignment - The alignment where the marker should be placed.
   * @param percentage - The percentage along the alignment where the marker should be placed.
   * @param type - The type of marker to be placed (hover or select).
   *
   * @throws Will throw an error if there are no curves to place the marker on.
   */
  setMarker(e, n, s) {
    if (!this._curves.length)
      return;
    const i = e.getCurveAt(n, this.view), r = e.getPointAt(n, this.view), { index: o } = i.curve.getSegmentAt(i.percentage);
    this.setMouseMarker(r, i.curve.mesh, o, s);
  }
  /**
   * Sets the definition segments and slope from the provided segments array.
   *
   * @param segmentsArray - An array of segments, where each segment is an array of numbers representing points.
   *
   * @returns An object containing the definition segments and slope.
   *
   * @throws Will throw an error if the segments array is empty or if the points in the segments array are not in the expected format.
   */
  setDefSegments(e) {
    const n = [], s = [], i = (r, o) => {
      const l = o[1] - r[1], u = o[0] - r[0];
      return l / u;
    };
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      let l, u, d, m;
      for (let v = 0; v < Object.keys(o).length / 3; v++)
        if (o[v * 3] !== void 0 && o[v * 3 + 1] !== void 0) {
          l = o[v * 3], u = o[v * 3 + 1];
          break;
        }
      for (let v = Object.keys(o).length / 3 - 1; v >= 0; v--)
        if (o[v * 3] !== void 0 && o[v * 3 + 1] !== void 0) {
          d = o[v * 3], m = o[v * 3 + 1];
          break;
        }
      const g = (i(
        // @ts-ignore
        [l, u],
        // @ts-ignore
        [d, m]
      ) * 100).toFixed(2);
      s.push({ slope: g });
    }
    for (const r of e)
      for (let o = 0; o < r.length - 3; o += 3) {
        const l = r[o], u = r[o + 1], d = r[o + 2], m = r[o + 3], f = r[o + 4], g = r[o + 5];
        n.push({
          start: new Vector3(l, u, d),
          end: new Vector3(m, f, g)
        });
      }
    return { defSegments: n, slope: s };
  }
  /**
   * Hides the marker of the specified type.
   *
   * @param type - The type of marker to hide. It can be either "hover" or "select".
   *
   * @throws Will throw an error if the mouse markers are not initialized.
   */
  hideMarker(e) {
    this.mouseMarkers && (this.mouseMarkers[e].visible = false);
  }
  setupEvents(e) {
    var i, r;
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    if (this._world.isDisposing || !this._world.renderer)
      return;
    const s = this._world.renderer.three.domElement.parentElement;
    (i = this._world.renderer) == null || i.onResize.remove(this.updateLinesResolution), s.removeEventListener("pointermove", this.onMouseMove), s.removeEventListener("click", this.onClick), this._world.camera.hasCameraControls() && this._world.camera.controls.removeEventListener("update", this.onControlsUpdated), e && (s.addEventListener("pointermove", this.onMouseMove), s.addEventListener("click", this.onClick), (r = this._world.renderer) == null || r.onResize.add(this.updateLinesResolution), this._world.camera.hasCameraControls() && this._world.camera.controls.addEventListener("update", this.onControlsUpdated));
  }
  newMouseMarker(e, n) {
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    const s = n.scene.three, i = document.createElement("div"), r = document.createElement("div");
    i.appendChild(r), r.style.backgroundColor = e, r.style.width = "3rem", r.style.height = "3px";
    const o = new ft(this._world, i, s);
    return o.visible = false, o;
  }
  setMouseMarker(e, n, s, i) {
    if (s === void 0 || !this.mouseMarkers)
      return;
    this.mouseMarkers[i].visible = true;
    const r = this.mouseMarkers[i].three;
    r.position.copy(e);
    const o = n, { startPoint: l, endPoint: u } = o.curve.getSegment(s), d = Math.atan2(
      u.y - l.y,
      u.x - l.x
    ), m = r.element.children[0], f = 90 - d / Math.PI * 180;
    m.style.transform = `rotate(${f}deg)`;
  }
  updateMarker(e, n) {
    const { point: s, index: i, object: r } = e, o = r, l = o.curve, u = o.curve.alignment, d = u.getPercentageAt(s, this.view), m = s.clone();
    this.setMouseMarker(m, o, i, n), d !== null && this.onMarkerChange.trigger({ alignment: u, percentage: d, type: n, curve: l });
  }
  getScaledBox(e, n) {
    const s = new Box3(), i = new Vector3(), r = new Vector3();
    return e.getCenter(r), e.getSize(i), i.multiplyScalar(n), s.setFromCenterAndSize(r, i), s;
  }
};
var Sp = class {
  constructor(t, e, n) {
    b(this, "components");
    b(this, "_scene");
    b(this, "_world");
    b(this, "offset", 10);
    b(this, "markupLines", []);
    b(this, "currentCurveMesh");
    b(this, "markupMaterial", new LineBasicMaterial({
      color: 6842472
    }));
    this.components = t, this._scene = e, this._world = n;
  }
  showCurveInfo(t) {
    switch (this.disposeMarkups(), this.currentCurveMesh = t, t.curve.data.TYPE) {
      case "LINE":
        this.showLineInfo(t, this.offset);
        break;
      case "CIRCULARARC":
        this.showCircularArcInfo(t, this.offset);
        break;
      case "CLOTHOID":
        this.showClothoidInfo(t, this.offset);
        break;
      default:
        console.log("Unknown curve type:", t.curve.data.TYPE);
        break;
    }
  }
  updateOffset(t, e, n) {
    const i = Math.max(t.height, t.width) / (e * 150);
    i !== this.offset && (this.offset = i, n && this.currentCurveMesh && this.showCurveInfo(this.currentCurveMesh));
  }
  dispose() {
    for (const t of this.markupLines)
      t.removeFromParent();
    this.disposeMarkups(), this.markupMaterial.dispose();
  }
  disposeMarkups() {
    for (const t of this.markupLines)
      t.geometry.dispose(), t.removeFromParent();
    this.markupLines = [];
  }
  unSelect() {
    this.disposeMarkups();
  }
  calculateTangent(t, e) {
    const s = e * 3, i = Math.max(0, s - 3), r = Math.min(
      t.length - 3,
      s + 3
    ), o = new Vector3().fromArray(t, i);
    return new Vector3().fromArray(t, r).clone().sub(o).normalize();
  }
  calculateParallelCurve(t, e, n) {
    const s = [];
    for (let i = 0; i < e; i++) {
      const o = this.calculateTangent(t, i).clone().applyAxisAngle(new Vector3(0, 0, 1), Math.PI / 2);
      o.normalize();
      const l = o.clone().multiplyScalar(n), u = i * 3, d = new Vector3().fromArray(t, u).add(l);
      s.push(d);
    }
    return s;
  }
  calculateDimensionLines(t, e) {
    const n = [], s = t.geometry.attributes.position.array, i = e.geometry.attributes.position.array;
    if (s.length < 6 && i.length < 6)
      throw new Error("Line must have at least two vertices");
    const r = new Vector3(
      s[0],
      s[1],
      s[2]
    ), o = new Vector3(
      i[0],
      i[1],
      i[2]
    ), l = [], u = s.length - 3, d = new Vector3(
      s[u],
      s[u + 1],
      s[u + 2]
    ), m = i.length - 3, f = new Vector3(
      i[m],
      i[m + 1],
      i[m + 2]
    );
    return n.push(r, o), l.push(d, f), { startDimensionPoints: n, endDimensionPoints: l };
  }
  offsetDimensionLine(t, e) {
    const s = new Vector3().copy(t[t.length - 1]).sub(t[0]).normalize().clone().multiplyScalar(e);
    return t.map((r) => r.clone().add(s));
  }
  showLineInfo(t, e) {
    const n = this.components.get(Bn);
    n.world = this._world, n.deleteByType(["Length", "Radius"]);
    const s = t.geometry.attributes.position.array, i = this.calculateParallelCurve(
      s,
      s.length / 3,
      e
    ), r = new BufferGeometry().setFromPoints(
      i
    ), o = new Line(
      r,
      this.markupMaterial
    );
    n.showLineLength(o, t.curve.getLength()), this._scene.add(o), this.markupLines.push(o);
    const { startDimensionPoints: l, endDimensionPoints: u } = this.calculateDimensionLines(t, o), d = this.offsetDimensionLine(
      l,
      e * 0.1
    ), m = this.offsetDimensionLine(
      u,
      e * 0.1
    ), f = new BufferGeometry().setFromPoints(
      d
    ), g = new BufferGeometry().setFromPoints(
      m
    ), v = new Line(
      f,
      this.markupMaterial
    );
    this._scene.add(v), this.markupLines.push(v);
    const y = new Line(
      g,
      this.markupMaterial
    );
    this._scene.add(y), this.markupLines.push(y);
  }
  showClothoidInfo(t, e) {
    const n = this.components.get(Bn);
    n.world = this._world, n.deleteByType(["Length", "Radius"]);
    const s = t.geometry.attributes.position.array, i = this.calculateParallelCurve(
      s,
      s.length / 3,
      e
    ), r = new BufferGeometry().setFromPoints(
      i
    );
    n.showCurveLength(i, t.curve.getLength());
    const o = new Line(
      r,
      this.markupMaterial
    );
    this._scene.add(o), this.markupLines.push(o);
    const { startDimensionPoints: l, endDimensionPoints: u } = this.calculateDimensionLines(t, o), d = this.offsetDimensionLine(
      l,
      e * 0.1
    ), m = this.offsetDimensionLine(
      u,
      e * 0.1
    ), f = new BufferGeometry().setFromPoints(
      d
    ), g = new BufferGeometry().setFromPoints(
      m
    ), v = new Line(
      f,
      this.markupMaterial
    );
    this._scene.add(v), this.markupLines.push(v);
    const y = new Line(
      g,
      this.markupMaterial
    );
    this._scene.add(y), this.markupLines.push(y);
  }
  showCircularArcInfo(t, e) {
    const n = this.components.get(Bn);
    n.world = this._world, n.deleteByType(["Length", "Radius"]);
    const s = t.curve.data.RADIUS, i = t.geometry.attributes.position.array, r = t.geometry.attributes.position.count, o = [], l = new Vector3(
      i[0],
      i[1],
      i[2]
    ), u = (r - 1) * 3, d = new Vector3(
      i[u],
      i[u + 1],
      i[u + 2]
    ), m = r / 2 * 3, f = new Vector3(
      i[m],
      i[m + 1],
      i[m + 2]
    ), g = d.clone().sub(l).normalize(), v = new Vector3(
      -g.y,
      g.x,
      0
    );
    v.multiplyScalar(s);
    const y = f.clone().add(v);
    o.push(f), o.push(y);
    const x = new BufferGeometry().setFromPoints(o), A = new Line(x, this.markupMaterial);
    n.showCurveRadius(A, Math.abs(s)), this._scene.add(A), this.markupLines.push(A);
    const R = [];
    for (let se = 0; se < r; se++) {
      const he = this.calculateTangent(i, se), me = t.curve.data.RADIUS, Ie = new Vector3(
        he.y,
        -he.x,
        0
      );
      Ie.normalize(), me < 0 && Ie.negate();
      const Ee = Ie.clone().multiplyScalar(e), ue = se * 3, Le = new Vector3(
        i[ue] + Ee.x,
        i[ue + 1] + Ee.y,
        i[ue + 2] + Ee.z
      );
      R.push(Le);
    }
    const P = new BufferGeometry().setFromPoints(
      R
    );
    n.showCurveLength(R, t.curve.getLength());
    const C = new Line(
      P,
      this.markupMaterial
    );
    this._scene.add(C), this.markupLines.push(C);
    const { startDimensionPoints: O, endDimensionPoints: B } = this.calculateDimensionLines(t, C), Y = this.offsetDimensionLine(
      O,
      e * 0.1
    ), H = this.offsetDimensionLine(
      B,
      e * 0.1
    ), K = new BufferGeometry().setFromPoints(
      Y
    ), Z = new BufferGeometry().setFromPoints(
      H
    ), q = new Line(
      K,
      this.markupMaterial
    );
    this._scene.add(q), this.markupLines.push(q);
    const ne = new Line(
      Z,
      this.markupMaterial
    );
    this._scene.add(ne), this.markupLines.push(ne);
  }
};
var Lr = class Lr2 extends Ah {
  constructor(e) {
    super(e);
    b(this, "view", "horizontal");
    b(this, "planHighlighter");
    this.components.add(Lr2.uuid, this), this.onHighlight.add(({ mesh: n }) => {
      !this._highlighter || !this.planHighlighter || this.planHighlighter.showCurveInfo(n);
    });
  }
  /**
   * Getter for the world property.
   * Returns the world associated with the CivilPlanNavigator instance.
   */
  get world() {
    return super.world;
  }
  /**
   * Setter for the world property.
   * Sets the world associated with the CivilPlanNavigator instance.
   * If a new world is provided, the existing PlanHighlighter instance is disposed and a new one is created.
   * @param world - The new world to be associated with the CivilPlanNavigator instance.
   */
  set world(e) {
    var n;
    super.world = e, e && ((n = this.planHighlighter) == null || n.dispose(), this.planHighlighter = new Sp(
      this.components,
      e.scene.three,
      e
    ));
  }
};
b(Lr, "uuid", "3096dea0-5bc2-41c7-abce-9089b6c9431b");
var pc = Lr;
var Nr = class Nr2 extends Ah {
  constructor(e) {
    super(e);
    b(this, "enabled", true);
    b(this, "view", "vertical");
    this.components.add(Nr2.uuid, this);
  }
  /**
   * Getter for the world property.
   * This property is used to retrieve the world context for the component.
   *
   * @returns {OBC.World | null} - The current world context for the component.
   * If null, it means the world has not been set yet.
   */
  get world() {
    return super.world;
  }
  /**
   * Sets the world for the CivilElevationNavigator.
   * This property is used to manage the world context for the component.
   * When the world is set, it triggers the addition of elevation markers to the scene.
   *
   * @param world - The world to set for the component. If null, it will not update the world.
   */
  set world(e) {
    this.world !== e && (super.world = e, this._highlighter && this._highlighter.onSelect.add((n) => {
      if (!this.world)
        throw new Error("A world is needed to work with this component!");
      const s = this.components.get(Bn);
      s.deleteByType(["Slope", "Height", "InitialKPV", "FinalKPV"]);
      const { alignment: i } = n.curve, r = [];
      for (const d of i.vertical) {
        const m = d.mesh.geometry.attributes.position.array;
        r.push(m);
      }
      const { defSegments: o, slope: l } = this.setDefSegments(r), u = this.world.scene.three;
      for (let d = 0; d < i.vertical.length; d++) {
        const m = i.vertical[d];
        s.addVerticalMarker(
          this.world,
          `S: ${l[d].slope}%`,
          m.mesh,
          "Slope",
          u
        ), s.addVerticalMarker(
          this.world,
          `H: ${o[d].end.y.toFixed(2)}`,
          m.mesh,
          "Height",
          u
        );
      }
      s.addVerticalMarker(
        this.world,
        "KP: 0",
        i.vertical[0].mesh,
        "InitialKPV",
        u
      ), s.addVerticalMarker(
        this.world,
        `KP: ${i.vertical.length}`,
        i.vertical[i.vertical.length - 1].mesh,
        "FinalKPV",
        u
      );
    }));
  }
};
b(Nr, "uuid", "097eea29-2d5a-431a-a247-204d44670621");
var mc = Nr;
var _r = class _r2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onHighlight", new $());
    b(this, "onMarkerChange", new $());
    b(this, "onMarkerHidden", new $());
    b(this, "enabled", true);
    b(this, "mouseMarkers");
    b(this, "_highlighter");
    b(this, "_curves", []);
    b(this, "_world", null);
    b(this, "updateLinesResolution", (e2) => {
      var n;
      (n = this.highlighter) == null || n.setResolution(e2);
    });
    b(this, "onClick", (e2) => {
      if (!this.enabled || !this._highlighter)
        return;
      if (!this.world)
        throw new Error("No world found!");
      if (!this.world.renderer)
        return;
      const n = this.world.renderer.three.domElement, s = this.world.camera.three, i = this._highlighter.castRay(e2, s, n, this._curves);
      if (i) {
        const r = i.object;
        this._highlighter.select(r), this.updateMarker(i, "select");
        const { point: o, index: l } = i;
        l !== void 0 && this.onHighlight.trigger({ curve: r, point: o, index: l });
        return;
      }
      this._highlighter.unSelect(), this.mouseMarkers && (this.mouseMarkers.hover.visible = false), this.onMarkerHidden.trigger({ type: "hover" });
    });
    b(this, "onMouseMove", async (e2) => {
      if (!this.enabled || !this._highlighter)
        return;
      if (!this.world)
        throw new Error("No world found!");
      if (!this.world.renderer)
        return;
      const n = this.world.renderer.three.domElement, s = this.world.camera.three, i = this._highlighter.castRay(e2, s, n, this._curves);
      if (i) {
        this._highlighter.hover(i.object), this.updateMarker(i, "hover");
        return;
      }
      this._highlighter.unHover();
    });
    this.components.add(_r2.uuid, this);
  }
  /**
   * Getter for the world property.
   * Returns the current world instance.
   * @returns {OBC.World | null} The current world instance or null if not set.
   */
  get world() {
    return this._world;
  }
  /**
   * Setter for the world property.
   * Sets the world instance and initializes the component.
   * @param {OBC.World | null} world - The new world instance or null to clear the current world.
   */
  set world(e) {
    var s, i, r;
    if (e === this._world || (this._world && this.setupEvents(false), this._world = e, (s = this._highlighter) == null || s.dispose(), (i = this.mouseMarkers) == null || i.hover.dispose(), (r = this.mouseMarkers) == null || r.select.dispose(), !e))
      return;
    const n = e.scene.three;
    this._highlighter = new Rr(n, "absolute"), this.mouseMarkers = {
      select: this.newMouseMarker("#ffffff", e),
      hover: this.newMouseMarker("#575757", e)
    }, this.setupEvents(true);
  }
  /**
   * Getter for the highlighter property.
   * Returns the curve highlighter instance.
   * @returns {CurveHighlighter} The curve highlighter instance.
   * @throws {Error} If the navigator is not initialized.
   */
  get highlighter() {
    if (!this._highlighter)
      throw new Error("Navigator not initialized!");
    return this._highlighter;
  }
  /**
   * Draws the civil engineering data onto the 3D scene.
   *
   * @param model - The FragmentsGroup containing the civil data to be drawn.
   * @throws Will throw an error if the model does not have civil data or if the world is not set.
   */
  draw(e) {
    if (!e.civilData)
      throw new Error("Model must have civil data!");
    if (!this.world)
      throw new Error("A world must be given before drawing an alignment!");
    const n = this.world.scene.three;
    for (const [s, i] of e.civilData.alignments)
      for (const { mesh: r } of i.absolute)
        n.add(r), this._curves.push(r);
  }
  /**
   * Sets a marker at a specific percentage along the given alignment.
   *
   * @param alignment - The alignment on which to place the marker.
   * @param percentage - The percentage along the alignment where the marker should be placed.
   * @param type - The type of marker to be set.
   *
   * @throws Will throw an error if the mouse markers have not been initialized.
   *         This can happen if the world has not been set before using this method.
   *
   * @remarks
   * This method calculates the 3D point at the given percentage along the alignment,
   * sets the marker at that point, and makes the marker visible.
   *
   * @example
   * ```typescript
   * const navigator = new Civil3DNavigator(components);
   * navigator.world = world; // Initialize the world
   * const alignment = model.civilData.alignments.get(alignmentId);
   * if (alignment) {
   *   navigator.setMarker(alignment, 0.5, "select");
   * }
   * ```
   */
  setMarker(e, n, s) {
    if (!this.mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    const i = e.getPointAt(n, "absolute");
    this.mouseMarkers[s].visible = true, this.mouseMarkers[s].three.position.copy(i);
  }
  /**
   * Hides the marker of the specified type.
   *
   * @param type - The type of marker to hide.
   *
   * @throws Will throw an error if the mouse markers have not been initialized.
   *         This can happen if the world has not been set before using this method.
   *
   * @remarks
   * This method hides the marker of the specified type by setting its visibility to false.
   *
   * @example
   * ```typescript
   * const navigator = new Civil3DNavigator(components);
   * navigator.world = world; // Initialize the world
   * navigator.hideMarker("select");
   * ```
   */
  hideMarker(e) {
    if (!this.mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    const n = this.mouseMarkers[e].three;
    n.visible = false;
  }
  newMouseMarker(e, n) {
    const s = n.scene.three, i = document.createElement("div");
    i.style.backgroundColor = e, i.style.width = "1rem", i.style.height = "1rem", i.style.borderRadius = "1rem";
    const r = new ft(n, i, s);
    return r.visible = false, r;
  }
  setupEvents(e) {
    var s, i;
    if (!this.world)
      throw new Error("No world found!");
    if (this.world.isDisposing || !this.world.renderer)
      return;
    const n = this.world.renderer.three.domElement;
    (s = this.world.renderer) == null || s.onResize.remove(this.updateLinesResolution), n.removeEventListener("click", this.onClick), n.removeEventListener("pointermove", this.onMouseMove), e && (n.addEventListener("click", this.onClick), n.addEventListener("pointermove", this.onMouseMove), (i = this.world.renderer) == null || i.onResize.add(this.updateLinesResolution));
  }
  updateMarker(e, n) {
    if (!this.mouseMarkers)
      return;
    const { point: s, object: i } = e, r = i, o = r.curve, l = r.curve.alignment, u = l.getPercentageAt(s, "absolute");
    this.mouseMarkers[n].visible = true, this.mouseMarkers[n].three.position.copy(s), u !== null && this.onMarkerChange.trigger({ alignment: l, percentage: u, type: n, curve: o });
  }
};
b(_r, "uuid", "0a59c09e-2b49-474a-9320-99f51f40f182");
var gc = _r;
var Ur = class Ur2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "enabled", true);
    b(this, "world", null);
    b(this, "plane");
    b(this, "_world3D", null);
    this.components.add(Ur2.uuid, this);
  }
  /**
   * A getter for the 3D world.
   * @returns The 3D world.
   */
  get world3D() {
    return this._world3D;
  }
  /**
   * A setter for the 3D world.
   * @param world - The new 3D world.
   */
  set world3D(e) {
    var i;
    if (this._world3D = e, (i = this.plane) == null || i.dispose(), !e)
      return;
    const n = this.components.get(ai), s = n.Type;
    n.Type = ui, this.plane = n.createFromNormalAndCoplanarPoint(
      e,
      new Vector3(1, 0, 0),
      new Vector3()
    ), n.Type = s, this.plane.visible = false, this.plane.enabled = false;
  }
  /**
   * Sets the cross section plane based on the given curve mesh and point.
   *
   * @param curveMesh - The curve mesh to create the cross section from.
   * @param point - The point on the curve mesh where the cross section should be created.
   *
   * @throws Will throw an error if the world or plane is not set before calling this method.
   * @throws Will throw an error if the geometry is not indexed.
   *
   * @returns {Promise<void>}
   */
  async set(e, n) {
    if (!this.world || !this.plane)
      throw new Error("You must set a world before using this component");
    this.plane.enabled = true;
    const s = e.curve.getPercentageAt(n);
    if (s === null)
      return;
    const { startPoint: i, endPoint: r } = e.curve.getSegmentAt(s);
    if (e.geometry.index === null)
      throw new Error("Geometry must be indexed!");
    const o = new Vector3();
    o.subVectors(r, i), o.normalize(), this.plane.setFromNormalAndCoplanarPoint(o, n), this.plane.edges.update();
    const l = this.plane.helper.matrix.clone();
    l.invert();
    const u = this.world.scene.three, d = this.plane.edges.get();
    for (const m in d) {
      const { mesh: f } = d[m];
      f.position.set(0, 0, 0), f.rotation.set(0, 0, 0), f.updateMatrix(), f.applyMatrix4(l), f.parent !== u && u.add(f);
    }
    this.plane.enabled = false;
  }
};
b(Ur, "uuid", "96b2c87e-d90b-4639-8257-8f01136fe324");
var Ec = Ur;
function zn() {
  const h = document.createElement("div");
  return h.style.backgroundColor = "black", h.style.color = "white", h.style.padding = "8px", h.style.borderRadius = "8px", h.style.fontFamily = "sans-serif", h;
}
var ms = class ms2 {
  constructor(t, e, n) {
    b(this, "label");
    b(this, "boundingBox", new Mesh());
    b(this, "world");
    b(this, "components");
    b(this, "_length");
    b(this, "_visible", true);
    b(this, "_start");
    b(this, "_end");
    b(this, "_root", new Group());
    b(this, "_endpoints", []);
    b(this, "_line");
    this.components = t, this.world = e, this._start = n.start, this._end = n.end, this._length = this.getLength(), this._line = this.createLine(n), this.newEndpointElement(n.endpointElement), this.newEndpointElement(n.endpointElement.cloneNode(true)), this.label = this.newText(), this._root.renderOrder = 2, this.world.scene.three.add(this._root);
  }
  /**
   * Getter for the visibility of the dimension line.
   * @returns {boolean} The current visibility state.
   */
  get visible() {
    return this._visible;
  }
  /**
   * Setter for the visibility of the dimension line.
   * @param {boolean} value - The new visibility state.
   */
  set visible(t) {
    this._visible = t, this.label.visible = t, this._endpoints[0].visible = t, this._endpoints[1].visible = t;
    const [e, n] = this._endpoints, s = e.three, i = n.three, r = this.label.three;
    t ? (this.world.scene.three.add(this._root), this._root.add(r, s, i)) : (r.removeFromParent(), s.removeFromParent(), i.removeFromParent(), this._root.removeFromParent());
  }
  /**
   * Getter for the end point of the dimension line.
   * @returns {THREE.Vector3} The current end point.
   */
  get endPoint() {
    return this._end;
  }
  /**
   * Setter for the end point of the dimension line.
   * Updates the line geometry and position of the end point marker.
   * @param {THREE.Vector3} point - The new end point.
   */
  set endPoint(t) {
    this._end = t;
    const e = this._line.geometry.attributes.position;
    e.setXYZ(1, t.x, t.y, t.z), e.needsUpdate = true, this._endpoints[1].three.position.copy(t), this.updateLabel();
  }
  /**
   * Getter for the start point of the dimension line.
   * @returns {THREE.Vector3} The current start point.
   */
  get startPoint() {
    return this._start;
  }
  /**
   * Setter for the start point of the dimension line.
   * Updates the line geometry and position of the start point marker.
   * @param {THREE.Vector3} point - The new start point.
   */
  set startPoint(t) {
    this._start = t;
    const e = this._line.geometry.attributes.position;
    e.setXYZ(0, t.x, t.y, t.z), e.needsUpdate = true, this._endpoints[0].three.position.copy(t), this.updateLabel();
  }
  get _center() {
    let t = this._end.clone().sub(this._start);
    const e = t.length() * 0.5;
    return t = t.normalize().multiplyScalar(e), this._start.clone().add(t);
  }
  /**
   * Disposes of the dimension line and its associated resources.
   * This method should be called when the dimension line is no longer needed.
   * It removes the dimension line from the world, destroys its components, and frees up memory.
   */
  dispose() {
    const t = this.components.get(rn);
    this.visible = false, t.destroy(this._root), t.destroy(this._line);
    for (const e of this._endpoints)
      e.dispose();
    this._endpoints.length = 0, this.label.dispose(), this.boundingBox && t.destroy(this.boundingBox), this.components = null;
  }
  /**
   * Creates a bounding box for the dimension line.
   * The bounding box is a 3D box that encloses the dimension line.
   * It is used for collision detection and visibility culling.
   * The bounding box is initially invisible and can be toggled using the `toggleBoundingBox` method.
   */
  createBoundingBox() {
    this.boundingBox.geometry = new BoxGeometry(1, 1, this._length), this.boundingBox.position.copy(this._center), this.boundingBox.lookAt(this._end), this.boundingBox.visible = false, this._root.add(this.boundingBox);
  }
  /**
   * Toggles the visibility of the dimension line's label.
   * The label is a text element that displays the length of the dimension line.
   * This method is used to show or hide the label when needed.
   */
  toggleLabel() {
    this.label.toggleVisibility();
  }
  newEndpointElement(t) {
    const n = this._endpoints.length === 0 ? this._start : this._end, s = new ft(this.world, t);
    s.three.position.copy(n), this._endpoints.push(s), this._root.add(s.three);
  }
  updateLabel() {
    this._length = this.getLength(), this.label.three.element.textContent = this.getTextContent(), this.label.three.position.copy(this._center), this._line.computeLineDistances();
  }
  createLine(t) {
    const e = new BufferGeometry();
    e.setFromPoints([t.start, t.end]);
    const n = new Line(e, t.lineMaterial);
    return this._root.add(n), n;
  }
  newText() {
    const t = zn();
    t.textContent = this.getTextContent();
    const e = new ft(this.world, t);
    return e.three.position.copy(this._center), this._root.add(e.three), e;
  }
  getTextContent() {
    return `${this._length / ms2.scale} ${ms2.units}`;
  }
  getLength() {
    return parseFloat(this._start.distanceTo(this._end).toFixed(2));
  }
};
b(ms, "scale", 1), /**
* The units used for the dimension line.
*/
b(ms, "units", "m");
var di = ms;
var Ap = class {
  constructor(t, e, n) {
    b(this, "enabled", true);
    b(this, "visible", true);
    b(this, "points", []);
    b(this, "workingPlane", null);
    b(this, "labelMarker");
    b(this, "world");
    b(this, "components");
    b(this, "onDisposed", new $());
    b(this, "_rotationMatrix", null);
    b(this, "_dimensionLines", []);
    b(this, "_defaultLineMaterial", new LineBasicMaterial({ color: "red" }));
    b(this, "onAreaComputed", new $());
    b(this, "onWorkingPlaneComputed", new $());
    b(this, "onPointAdded", new $());
    b(this, "onPointRemoved", new $());
    this.world = e, this.components = t;
    const s = zn();
    this.labelMarker = new ft(e, s), this.labelMarker.visible = false, this.onPointAdded.add((i) => {
      this.points.length === 3 && !this._dimensionLines[2] && (this.addDimensionLine(i, this.points[0]), this.labelMarker.visible = true);
    }), n == null || n.forEach((i) => this.setPoint(i));
  }
  setPoint(t, e) {
    let n;
    if (e ? n = e : n = this.points.length === 0 ? 0 : this.points.length, n === 0) {
      this.points[0] = t;
      return;
    }
    if (n < 0 || n > this.points.length)
      return;
    const s = this.points.length > n;
    this.points[n] = t, this.onPointAdded.trigger(t), s || this.addDimensionLine(this.points[n - 1], t);
    const { previousLine: i, nextLine: r } = this.getLinesBetweenIndex(n);
    i && (i.endPoint = t), r && (r.startPoint = t);
  }
  removePoint(t) {
    if (this.points.length === 3)
      return;
    this.points.splice(t, 1);
    const { previousLine: e, nextLine: n } = this.getLinesBetweenIndex(t);
    n && (e.endPoint = n.endPoint), n == null || n.dispose(), this._dimensionLines.splice(t, 1), this.onPointRemoved.trigger();
  }
  toggleLabel() {
    this.labelMarker.toggleVisibility();
  }
  addDimensionLine(t, e) {
    const n = document.createElement("div");
    n.className = "w-2 h-2 bg-red-600 rounded-full";
    const s = new di(this.components, this.world, {
      start: t,
      end: e,
      lineMaterial: this._defaultLineMaterial,
      endpointElement: n
    });
    return s.toggleLabel(), this._dimensionLines.length > 1 ? this._dimensionLines.splice(
      this._dimensionLines.length - 1,
      0,
      s
    ) : this._dimensionLines.push(s), s;
  }
  getLinesBetweenIndex(t) {
    const e = t === 0 ? this._dimensionLines.length - 1 : t - 1, n = this._dimensionLines[e], s = this._dimensionLines[t];
    return { previousLine: n, nextLine: s };
  }
  computeWorkingPlane() {
    this.workingPlane = new Plane().setFromCoplanarPoints(
      this.points[0],
      this.points[1],
      this.points[2]
    );
    const t = new Vector3(0, 1, 0), e = this.workingPlane.normal.angleTo(t), n = new Vector3().crossVectors(this.workingPlane.normal, t).normalize();
    this._rotationMatrix = new Matrix4().makeRotationAxis(
      n,
      e
    ), this.onWorkingPlaneComputed.trigger(this.workingPlane);
  }
  computeArea() {
    if (!(this._rotationMatrix && this.workingPlane))
      return this.onAreaComputed.trigger(0), 0;
    let t = 0, e = 0;
    const n = this._rotationMatrix, s = this.points.map((r) => {
      const o = r.clone().applyMatrix4(n), l = new Vector2(
        o.x,
        o.z
      );
      return t += l.x, e += l.y, l;
    }), i = Math.abs(ShapeUtils.area(s));
    return this.labelMarker.three.element.textContent = `${i.toFixed(2)} m`, this.labelMarker.three.position.set(
      t / s.length,
      -this.workingPlane.constant,
      e / s.length
    ).applyMatrix4(n.clone().invert()), this.onAreaComputed.trigger(i), i;
  }
  dispose() {
    this.onAreaComputed.reset(), this.onWorkingPlaneComputed.reset(), this.onPointAdded.reset(), this.onPointRemoved.reset();
    for (const t of this._dimensionLines)
      t.dispose();
    this.labelMarker.dispose(), this._dimensionLines = [], this.points = [], this._rotationMatrix = null, this.workingPlane = null, this._defaultLineMaterial.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  get() {
    return {
      points: this.points,
      workingPlane: this.workingPlane,
      area: this.computeArea()
    };
  }
};
var Ua = class extends Wd {
  constructor() {
    super(...arguments);
    b(this, "onDisposed", new $());
    b(this, "marker", null);
  }
  /** {@link OBC.Disposable.onDisposed} */
  dispose() {
    this.marker && this.marker.dispose(), super.dispose();
  }
  /**
   * Retrieves the picked vertex from the world and updates the marker's position.
   * If no vertex is picked, the marker is hidden.
   *
   * @param world - The world in which to pick the vertex.
   * @returns The picked vertex, or null if no vertex was picked.
   */
  get(e) {
    const n = super.get(e);
    return n ? (this.marker || (this.marker = new ft(e)), this.marker.world !== e && (this.marker.world = e, this.marker.three.removeFromParent(), e.scene.three.add(this.marker.three)), this.marker.visible = true, this.marker.three.position.copy(n)) : this.marker && (this.marker.visible = false), n;
  }
};
var ti = class ti2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "list", []);
    b(this, "world");
    b(this, "_enabled", false);
    b(this, "_vertexPicker");
    b(this, "_currentAreaElement", null);
    b(this, "_clickCount", 0);
    b(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world)
        throw new Error("World not defined for the area measurement!");
      const e2 = this._vertexPicker.get(this.world);
      if (e2) {
        if (!this._currentAreaElement) {
          const n = new Ap(this.components, this.world);
          n.onPointAdded.add(() => {
            this._clickCount === 3 && !n.workingPlane && (n.computeWorkingPlane(), this._vertexPicker.workingPlane = n.workingPlane);
          }), n.onPointRemoved.add(() => this._clickCount--), this._currentAreaElement = n;
        }
        this._currentAreaElement.setPoint(e2, this._clickCount), this._currentAreaElement.computeArea(), this._clickCount++;
      }
    });
    b(this, "onMouseMove", () => {
      if (!this.world) {
        console.log("No world given for the area measurement!");
        return;
      }
      const e2 = this._vertexPicker.get(this.world);
      e2 && this._currentAreaElement && (this._currentAreaElement.setPoint(e2, this._clickCount), this._currentAreaElement.computeArea());
    });
    b(this, "onKeydown", (e2) => {
      this.enabled && (e2.key === "z" && e2.ctrlKey && this._currentAreaElement && this._currentAreaElement.removePoint(this._clickCount - 1), e2.key === "Enter" && this._currentAreaElement && this.endCreation(), e2.key === "Escape" && (this._clickCount === 0 && !this._currentAreaElement ? this.enabled = false : this.cancelCreation()));
    });
    this.components.add(ti2.uuid, this), this._vertexPicker = new Ua(e);
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    this._enabled = e, this._vertexPicker.enabled = e, this.setupEvents(e), e || this.cancelCreation();
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the working plane for the area measurement.
   * Sets the working plane for the vertex picker.
   * @param plane - The new working plane or null if no plane is to be used.
   */
  set workingPlane(e) {
    this._vertexPicker.workingPlane = e;
  }
  /**
   * Getter for the working plane for the area measurement.
   * @returns The current working plane or null if no plane is being used.
   */
  get workingPlane() {
    return this._vertexPicker.workingPlane;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this._vertexPicker.dispose(), this._currentAreaElement && this._currentAreaElement.dispose();
    for (const e of this.list)
      e.dispose();
    this.components = null, this.onDisposed.trigger(ti2.uuid), this.onDisposed.reset();
  }
  // TODO: Implement this
  /** {@link OBC.Createable.delete} */
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [];
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
    this._currentAreaElement && (this.list.push(this._currentAreaElement), this._currentAreaElement.removePoint(this._clickCount), this._currentAreaElement.computeWorkingPlane(), this._currentAreaElement.computeArea(), this._currentAreaElement = null), this._vertexPicker.workingPlane = null, this._clickCount = 0;
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
    this._currentAreaElement && (this._currentAreaElement.dispose(), this._currentAreaElement = null), this._vertexPicker.workingPlane = null, this._clickCount = 0;
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The area measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the area measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    e ? (s.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (s.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
};
b(ti, "uuid", "c453a99e-f054-4781-9060-33df617db4a5");
var vc = ti;
var Fp = class {
  constructor(t, e) {
    b(this, "enabled", true);
    b(this, "visible", true);
    b(this, "points", []);
    b(this, "world");
    b(this, "onDisposed", new $());
    b(this, "_lineMaterial", new fi({
      color: 6629591,
      linewidth: 2
    }));
    b(this, "_lineGeometry", new Fr());
    b(this, "_line", new vh(this._lineGeometry, this._lineMaterial));
    b(this, "_labelMarker");
    b(this, "onAngleComputed", new $());
    b(this, "onPointAdded", new $());
    this.world = t;
    const n = zn();
    this._labelMarker = new ft(t, n), this.labelMarker.visible = true, this.onPointAdded.add(() => {
      this.points.length === 1 && t.scene.three.add(this._line), this.points.length === 3 && (this.labelMarker.visible = true);
    }), this.onAngleComputed.add((s) => {
      this.labelMarker.three.element.textContent = `${s.toFixed(2)}`, this.labelMarker.three.position.copy(
        this.points[1] ?? new Vector3()
      );
    }), e == null || e.forEach((s) => this.setPoint(s));
  }
  set lineMaterial(t) {
    this._lineMaterial.dispose(), this._lineMaterial = t, this._line.material = t, this._lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
  }
  get lineMaterial() {
    return this._lineMaterial;
  }
  set labelMarker(t) {
    this._labelMarker.dispose(), this._labelMarker = t;
  }
  get labelMarker() {
    return this._labelMarker;
  }
  get angle() {
    return {
      points: this.points,
      angle: this.computeAngle()
    };
  }
  setPoint(t, e) {
    let n;
    if (e ? n = e : n = this.points.length === 0 ? 0 : this.points.length, ![0, 1, 2].includes(n))
      return;
    this.points[n] = t, this.onPointAdded.trigger(t);
    const s = this.points.map((i) => [i.x, i.y, i.z]);
    this._lineGeometry.setPositions(s.flat());
  }
  toggleLabel() {
    this.labelMarker.toggleVisibility();
  }
  computeAngle() {
    const t = this.points[0], e = this.points[1], n = this.points[2];
    if (!(t && e && n))
      return 0;
    const s = new Vector3().subVectors(e, t), i = new Vector3().subVectors(e, n), r = MathUtils.radToDeg(s.angleTo(i));
    return this.onAngleComputed.trigger(r), r;
  }
  dispose() {
    this.points = [], this.labelMarker.dispose(), this.onAngleComputed.reset(), this.onPointAdded.reset(), this.labelMarker.dispose(), this._line.removeFromParent(), this._lineMaterial.dispose(), this._lineGeometry.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var ni = class ni2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "world");
    b(this, "list", []);
    b(this, "_lineMaterial");
    b(this, "_enabled", false);
    b(this, "_vertexPicker");
    b(this, "_currentAngleElement", null);
    b(this, "_clickCount", 0);
    b(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world) {
        console.log("No world selected for angle measurement!");
        return;
      }
      const e2 = this._vertexPicker.get(this.world);
      if (e2) {
        if (!this._currentAngleElement) {
          const n = new Fp(this.world);
          n.lineMaterial = this.lineMaterial, this._currentAngleElement = n;
        }
        this._currentAngleElement.setPoint(e2, this._clickCount), this._currentAngleElement.setPoint(
          e2,
          this._clickCount + 1
        ), this._currentAngleElement.setPoint(
          e2,
          this._clickCount + 2
        ), this._currentAngleElement.computeAngle(), this._clickCount++, this._clickCount === 3 && this.endCreation();
      }
    });
    b(this, "onMouseMove", () => {
      if (!this.world) {
        console.log("No world selected for angle measurement!");
        return;
      }
      const e2 = this._vertexPicker.get(this.world);
      e2 && this._currentAngleElement && (this._currentAngleElement.setPoint(e2, this._clickCount), this._currentAngleElement.computeAngle());
    });
    b(this, "onKeyDown", (e2) => {
      this.enabled && e2.key === "Escape" && this.cancelCreation();
    });
    this.components.add(ni2.uuid, this), this._vertexPicker = new Ua(e), this._lineMaterial = new fi({
      color: 6629591,
      linewidth: 2
    });
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    this._enabled = e, this.setupEvents(e), this._vertexPicker.enabled = e, e || this.cancelCreation();
  }
  /**
   * Getter for the line material used for the angle measurement lines.
   */
  get lineMaterial() {
    return this._lineMaterial;
  }
  /**
   * Setter for the line material used for the angle measurement lines.
   * Disposes the old material and sets the new one.
   * Also updates the resolution of the material to match the window size.
   * @param material - The new line material to use.
   */
  set lineMaterial(e) {
    this._lineMaterial.dispose(), this._lineMaterial = e, this._lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
  }
  /**
   * Getter for the working plane for the angle measurement.
   * @returns The current working plane or null if no plane is being used.
   */
  get workingPlane() {
    return this._vertexPicker.workingPlane;
  }
  /**
   * Setter for the working plane for the angle measurement.
   * Sets the working plane for the vertex picker.
   * @param plane - The new working plane or null if no plane is to be used.
   */
  set workingPlane(e) {
    this._vertexPicker.workingPlane = e;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this._lineMaterial.dispose(), this._vertexPicker.dispose();
    for (const e of this.list)
      e.dispose();
    this._currentAngleElement && this._currentAngleElement.dispose(), this.components = null, this.onDisposed.trigger(ni2.uuid), this.onDisposed.reset();
  }
  // TODO: Implement this
  /** {@link OBC.Createable.delete} */
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [];
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
    this._currentAngleElement && (this.list.push(this._currentAngleElement), this._currentAngleElement.computeAngle(), this._currentAngleElement = null), this._clickCount = 0;
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
    this._currentAngleElement && (this._currentAngleElement.dispose(), this._currentAngleElement = null), this._clickCount = 0;
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("No world selected for angle measurement!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    e ? (s.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeyDown)) : (s.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeyDown));
  }
};
b(ni, "uuid", "622fb2c9-528c-4b0a-8a0e-6a1375f0a3aa");
var Ic = ni;
var si = class si2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "onBeforeUpdate", new $());
    b(this, "onAfterUpdate", new $());
    b(this, "snapDistance", 0.25);
    b(this, "list", []);
    b(this, "world");
    b(this, "_vertexPicker");
    b(this, "_lineMaterial", new LineBasicMaterial({
      color: "#DC2626",
      linewidth: 2,
      depthTest: false
    }));
    b(this, "_visible", true);
    b(this, "_enabled", false);
    b(this, "_temp", {
      isDragging: false,
      start: new Vector3(),
      end: new Vector3(),
      dimension: void 0
    });
    b(this, "create", (e2) => {
      const n = e2 instanceof Object3D ? e2 : void 0;
      if (this._enabled) {
        if (!this._temp.isDragging) {
          this.drawStart(n);
          return;
        }
        this.endCreation();
      }
    });
    b(this, "onMouseMove", () => {
      this.world && this._vertexPicker.get(this.world);
    });
    this.components.add(si2.uuid, this), this._vertexPicker = new Ua(e, {
      previewElement: zn(),
      snapDistance: this.snapDistance
    });
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    e || this.cancelCreation(), this._enabled = e, this._vertexPicker.enabled = e, this.setupEvents(e);
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this._visible;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(e) {
    this._visible = e;
    for (const n of this.list)
      n.visible = e;
  }
  /**
   * Getter for the color of the dimension lines.
   * Returns the color of the line material used for the dimension lines.
   *
   */
  get color() {
    return this._lineMaterial.color;
  }
  /**
   * Setter for the color of the dimension lines.
   * Sets the color of the line material used for the dimension lines.
   *
   */
  set color(e) {
    this._lineMaterial.color = e;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.enabled = false;
    for (const e of this.list)
      e.dispose();
    this._lineMaterial.dispose(), this.list = [], this._vertexPicker.dispose(), this.onDisposed.trigger(si2.uuid), this.onDisposed.reset();
  }
  /** {@link OBC.Updateable.update} */
  async update(e) {
    this._enabled && this._temp.isDragging && this.drawInProcess();
  }
  /**
   * Creates a new dimension line between two given points.
   *
   * @param p1 - The start point of the dimension line.
   * @param p2 - The end point of the dimension line.
   *
   */
  createOnPoints(e, n) {
    const s = this.drawDimension();
    s.startPoint = e, s.endPoint = n, s.createBoundingBox(), this.list.push(s);
  }
  /** {@link OBC.Createable.delete} */
  delete() {
    if (!this.world)
      throw new Error("World is needed for Length Measurement!");
    if (!this._enabled || this.list.length === 0)
      return;
    const e = this.getBoundingBoxes(), i = this.components.get(Dt).get(this.world).castRay(e);
    if (!i)
      return;
    const r = this.list.find(
      (o) => o.boundingBox === i.object
    );
    if (r) {
      const o = this.list.indexOf(r);
      this.list.splice(o, 1), r.dispose();
    }
  }
  /**
   * Deletes a specific measurement from the list.
   *
   * @param measurement - The measurement to be deleted.
   *
   * @remarks
   * If the measurement does not exist in the list, no action is taken.
   *
   */
  async deleteMeasurement(e) {
    if (e) {
      const n = this.list.indexOf(e);
      this.list.splice(n, 1), e.dispose();
    }
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [];
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
    var e;
    this._temp.dimension && (this._temp.isDragging = false, (e = this._temp.dimension) == null || e.dispose(), this._temp.dimension = void 0);
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
    this._temp.dimension && (this._temp.dimension.createBoundingBox(), this.list.push(this._temp.dimension), this._temp.dimension = void 0, this._temp.isDragging = false);
  }
  drawStart(e) {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    const n = e ? [e] : void 0, r = this.components.get(Dt).get(this.world).castRay(n), o = this._vertexPicker.get(this.world);
    r && o && (this._temp.isDragging = true, this._temp.start = e ? r.point : o);
  }
  drawInProcess() {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    if (!this.components.get(Dt).get(this.world).castRay())
      return;
    const i = this._vertexPicker.get(this.world);
    i && (this._temp.end = i, this._temp.dimension || (this._temp.dimension = this.drawDimension()), this._temp.dimension.endPoint = this._temp.end);
  }
  drawDimension() {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    return new di(this.components, this.world, {
      start: this._temp.start,
      end: this._temp.end,
      lineMaterial: this._lineMaterial,
      endpointElement: zn()
    });
  }
  getBoundingBoxes() {
    return this.list.map((e) => e.boundingBox).filter((e) => e !== void 0);
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the length measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    s && (s.removeEventListener("pointermove", this.onMouseMove), e && s.addEventListener("pointermove", this.onMouseMove));
  }
};
b(si, "uuid", "2f9bcacf-18a9-4be6-a293-e898eae64ea1");
var _n = si;
var Br = class Br2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "onVolumeFound", new $());
    b(this, "label", null);
    b(this, "world");
    b(this, "_enabled", false);
    b(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world)
        throw new Error("World is needed for Volume Measurement!");
      const s = this.components.get(Dt).get(this.world).castRay();
      if (!s || !s.object)
        return;
      const { object: i } = s;
      if (i instanceof Mesh) {
        const r = this.getVolumeOfMesh(i);
        this.onVolumeFound.trigger(r);
      }
    });
    b(this, "onMouseMove", () => {
    });
    b(this, "onKeydown", (e2) => {
    });
    this.components.add(Br2.uuid, this);
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    this._enabled = e, this.setupEvents(e), e || this.cancelCreation();
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Disposable.dispose} */
  async dispose() {
    var e;
    this.setupEvents(false), (e = this.label) == null || e.dispose(), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  /** {@link OBC.Createable.delete} */
  delete() {
  }
  /**
   * Deletes all the measurements created by this component.
   */
  async deleteAll() {
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
  }
  /**
   * Calculates the volume of a set of fragments.
   *
   * @param frags - A map of fragment IDs to their corresponding item IDs.
   * @returns The total volume of the fragments.
   *
   * @remarks
   * This method creates a set of instanced meshes from the given fragments and item IDs.
   * It then calculates the volume of each mesh and returns the total volume.
   *
   * @throws Will throw an error if the world is not set.
   * @throws Will throw an error if the label is not created.
   * @throws Will throw an error if the world's renderer is not set.
   * @throws Will throw an error if the geometry of the meshes is not indexed.
   * @throws Will throw an error if the fragment manager is not available.
   */
  getVolumeFromFragments(e) {
    const n = this.components.get(He), s = new Matrix4(), i = [];
    for (const r in e) {
      const o = n.list.get(r);
      if (!o)
        continue;
      const l = e[r];
      let u = 0;
      for (const f of l) {
        const g = o.getInstancesIDs(f);
        g && (u += g.size);
      }
      const d = new InstancedMesh(
        o.mesh.geometry,
        void 0,
        u
      );
      let m = 0;
      for (const f of l) {
        const g = o.getInstancesIDs(f);
        if (g)
          for (const v of g)
            o.mesh.getMatrixAt(v, s), d.setMatrixAt(m++, s);
      }
      i.push(d);
    }
    return this.getVolumeFromMeshes(i);
  }
  /**
   * Calculates the total volume of a set of meshes.
   *
   * @param meshes - An array of meshes or instanced meshes to calculate the volume from.
   * @returns The total volume of the meshes.
   *
   * @throws Will throw an error if the world is not set.
   * @throws Will throw an error if the label is not created.
   *
   * @remarks
   * This method calculates the volume of each mesh in the provided array and returns the total volume.
   * It also handles the creation of a label if it doesn't exist, adds the label to the world's scene,
   * and positions the label at the center of the bounding sphere of the meshes.
   *
   */
  getVolumeFromMeshes(e) {
    if (!this.world)
      throw new Error("World is needed for Volume Measurement!");
    this.label || (this.label = this.newLabel(), this.label.three.removeFromParent());
    let n = 0;
    for (const o of e)
      n += this.getVolumeOfMesh(o);
    this.label.visible = true, this.world.scene.three.add(this.label.three);
    const s = this.components.get(Jc);
    for (const o of e)
      o.geometry.computeBoundingSphere(), s.addMesh(o);
    const i = s.getSphere();
    s.reset(), this.label.three.position.copy(i.center);
    const r = Math.trunc(n * 100) / 100;
    return this.label.three.element.textContent = r.toString(), n;
  }
  /**
   * Clears the label associated with the volume measurement.
   *
   * @remarks
   * This method is used to hide the label when the volume measurement is no longer needed.
   * If the label exists, it sets its visibility to false.
   *
   */
  clear() {
    this.label && (this.label.visible = false);
  }
  newLabel() {
    if (!this.world)
      throw new Error("World is needed for Volume Measurement!");
    const e = zn();
    return new ft(this.world, e);
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The volume measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the volume measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    e ? (s.addEventListener("click", this.create), s.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (s.removeEventListener("click", this.create), s.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
  // https://stackoverflow.com/a/1568551
  getVolumeOfMesh(e) {
    let n = 0;
    const s = new Vector3(), i = new Vector3(), r = new Vector3(), { index: o } = e.geometry, l = e.geometry.attributes.position.array;
    if (!o)
      return console.warn("Geometry must be indexed to compute its volume!"), 0;
    const u = [];
    if (e instanceof InstancedMesh)
      for (let m = 0; m < e.count; m++) {
        const f = new Matrix4();
        e.getMatrixAt(m, f), u.push(f);
      }
    else
      u.push(new Matrix4().identity());
    const { matrixWorld: d } = e;
    for (let m = 0; m < o.array.length - 2; m += 3)
      for (const f of u) {
        const g = f.multiply(d), v = o.array[m] * 3, y = o.array[m + 1] * 3, x = o.array[m + 2] * 3;
        s.set(l[v], l[v + 1], l[v + 2]).applyMatrix4(g), i.set(l[y], l[y + 1], l[y + 2]).applyMatrix4(g), r.set(l[x], l[x + 1], l[x + 2]).applyMatrix4(g), n += this.getSignedVolumeOfTriangle(s, i, r);
      }
    return Math.abs(n);
  }
  getSignedVolumeOfTriangle(e, n, s) {
    const i = s.x * n.y * e.z, r = n.x * s.y * e.z, o = s.x * e.y * n.z, l = e.x * s.y * n.z, u = n.x * e.y * s.z, d = e.x * n.y * s.z;
    return 1 / 6 * (-i + r + o - l - u + d);
  }
};
b(Br, "uuid", "811da532-7af3-4635-b592-1c06ae494af5");
var yc = Br;
var kr = class kr2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "selection", []);
    b(this, "preview", new Mesh(
      new BufferGeometry(),
      new MeshBasicMaterial({
        side: 2,
        depthTest: false,
        transparent: true,
        opacity: 0.25,
        color: "#BCF124"
      })
    ));
    b(this, "selectionMaterial", new MeshBasicMaterial({
      side: 2,
      depthTest: false,
      transparent: true,
      color: "#BCF124",
      opacity: 0.75
    }));
    b(this, "world");
    b(this, "_enabled", false);
    b(this, "_currentSelelection", null);
    b(this, "create", () => {
      if (!this.world)
        throw new Error("No world given to the face measurement!");
      if (!this.enabled || !this._currentSelelection)
        return;
      const e2 = this.world.scene.three, n = new BufferGeometry(), s = new Mesh(n, this.selectionMaterial);
      n.setAttribute(
        "position",
        this.preview.geometry.attributes.position
      ), e2.add(s), n.computeBoundingSphere();
      const { area: i, perimeter: r } = this._currentSelelection, o = this.newLabel(n, i);
      s.add(o.three), this.selection.push({ area: i, perimeter: r, mesh: s, label: o });
    });
    b(this, "onMouseMove", () => {
      if (!this.world)
        throw new Error("The face measurement needs a world to work!");
      if (!this.enabled) {
        this.unselect();
        return;
      }
      const s = this.components.get(Dt).get(this.world).castRay();
      if (!s || !s.object || s.faceIndex === void 0) {
        this.unselect();
        return;
      }
      const { object: i, faceIndex: r } = s;
      i instanceof Mesh || i instanceof InstancedMesh ? this.updateSelection(i, r, s.instanceId) : this.unselect();
    });
    b(this, "onKeydown", (e2) => {
    });
    this.components.add(kr2.uuid, this), this.preview.frustumCulled = false;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    if (!this.world)
      throw new Error("No world given for the Face measurement!");
    this._enabled = e, this.setupEvents(e), e ? this.world.scene.three.add(this.preview) : (this.preview.removeFromParent(), this.cancelCreation()), this.setVisibility(e);
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.deleteAll(), this.preview.removeFromParent(), this.preview.material.dispose(), this.preview.geometry.dispose(), this.selectionMaterial.dispose(), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  /** {@link OBC.Createable.delete} */
  delete() {
    if (!this.world)
      throw new Error("No world given to the face measurement!");
    const e = this.selection.map((l) => l.mesh), i = this.components.get(Dt).get(this.world).castRay(e);
    if (!i || !i.object)
      return;
    const r = this.selection.find((l) => l.mesh === i.object);
    if (!r)
      return;
    r.mesh.removeFromParent(), r.mesh.geometry.dispose(), r.label.dispose();
    const o = this.selection.indexOf(r);
    this.selection.splice(o, 1);
  }
  /**
   * Deletes all the selections made by the user.
   * It iterates over the `selection` array, removes each mesh and label from the scene,
   * disposes the geometry and material of the mesh, and finally clears the `selection` array.
   */
  deleteAll() {
    for (const e of this.selection)
      e.mesh.removeFromParent(), e.mesh.geometry.dispose(), e.label.dispose();
    this.selection = [];
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
  }
  /**
   * Retrieves the current state of the AreaMeasurement component in a serialized format.
   * This method is used for saving measurements.
   *
   * @returns {SerializedAreaMeasure[]} An array of SerializedAreaMeasure objects,
   * each representing a single selection made by the user.
   */
  get() {
    const e = [];
    for (const n of this.selection) {
      const s = n.mesh.geometry, { area: i, perimeter: r } = n, o = s.attributes.position.array;
      e.push({ position: o, area: i, perimeter: r });
    }
    return e;
  }
  /**
   * Sets the state of the AreaMeasurement component from a serialized format.
   * This method is used for loading measurements.
   *
   * @param serialized - An array of SerializedAreaMeasure objects,
   * each representing a single selection made by the user.
   *
   * @throws Will throw an error if no world is given to the face measurement.
   */
  set(e) {
    if (!this.world)
      throw new Error("No world given to the face measurement!");
    const n = this.world.scene.three;
    for (const s of e) {
      const i = new BufferGeometry(), r = new Mesh(i, this.selectionMaterial);
      n.add(r);
      const o = new BufferAttribute(s.position, 3);
      i.setAttribute("position", o), i.computeBoundingSphere();
      const { area: l, perimeter: u } = s, d = this.newLabel(i, l);
      r.add(d.three), this.selection.push({ area: l, perimeter: u, mesh: r, label: d });
    }
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the face measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    s.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown), e && (s.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown));
  }
  setVisibility(e) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    const n = this.world.scene.three;
    for (const s of this.selection) {
      const i = s.label.three;
      e ? (n.add(s.mesh), s.mesh.add(i)) : (s.mesh.removeFromParent(), i.removeFromParent());
    }
  }
  unselect() {
    this.preview.removeFromParent(), this._currentSelelection = null;
  }
  updateSelection(e, n, s) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    this.world.scene.three.add(this.preview);
    const o = this.components.get(Ar).getFace(e, n, s);
    if (o === null)
      return;
    const l = this.regenerateHighlight(e, o.indices, s);
    let u = 0;
    for (const { distance: d } of o.edges)
      u += d;
    this._currentSelelection = { perimeter: u, area: l };
  }
  newLabel(e, n) {
    if (!e.boundingSphere)
      throw new Error("Error computing area geometry");
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    const { center: s } = e.boundingSphere, i = zn(), r = Math.trunc(n * 100) / 100;
    i.textContent = r.toString();
    const o = new ft(this.world, i);
    return o.three.position.copy(s), o;
  }
  regenerateHighlight(e, n, s) {
    const i = [], r = [];
    let o = 0, l = 0;
    const u = new Triangle(), d = this.components.get(Ar);
    for (const g of n) {
      const { p1: v, p2: y, p3: x } = d.getVerticesAndNormal(
        e,
        g,
        s
      );
      i.push(v.x, v.y, v.z), i.push(y.x, y.y, y.z), i.push(x.x, x.y, x.z), u.set(v, y, x), l += u.getArea(), r.push(o, o + 1, o + 2), o += 3;
    }
    const m = new Float32Array(i), f = new BufferAttribute(m, 3);
    return this.preview.geometry.setAttribute("position", f), this.preview.geometry.setIndex(r), l;
  }
};
b(kr, "uuid", "30279548-1309-44f6-aa97-ce26eed73522");
var wc = kr;
var zr = class zr2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "preview");
    b(this, "tolerance", 0.3);
    b(this, "world");
    b(this, "_enabled", false);
    b(this, "_lineMaterial", new LineBasicMaterial({
      color: "#DC2626",
      linewidth: 2,
      depthTest: false,
      transparent: true
    }));
    b(this, "create", async () => {
      if (!this.preview || !this.enabled || !this.preview.visible)
        return;
      const e2 = this.components.get(_n);
      e2.world = this.world;
      const n = this.preview.startPoint.clone(), s = this.preview.endPoint.clone();
      e2.createOnPoints(n, s);
    });
    b(this, "onMouseMove", () => {
      if (!this.preview)
        return;
      if (!this.world)
        throw new Error("The edge measurement needs a world to work!");
      if (!this.enabled) {
        this.preview.visible = false;
        return;
      }
      const s = this.components.get(Dt).get(this.world).castRay();
      if (!s || !s.object) {
        this.preview.visible = false;
        return;
      }
      const { object: i, faceIndex: r, point: o } = s;
      if (r === void 0) {
        this.preview.visible = false;
        return;
      }
      i instanceof Mesh || i instanceof InstancedMesh ? this.updateSelection(i, o, r, s.instanceId) : this.preview.visible = false;
    });
    b(this, "onKeydown", (e2) => {
    });
    this.components.add(zr2.uuid, this);
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    if (this._enabled = e, this.setupEvents(e), e) {
      if (!this.world)
        throw new Error("The edge measurement needs a world to work!");
      if (!this.preview) {
        const n = document.createElement("div");
        n.className = "w-2 h-2 bg-red-600 rounded-full", this.preview = new di(this.components, this.world, {
          start: new Vector3(),
          end: new Vector3(),
          lineMaterial: this._lineMaterial,
          endpointElement: n
        }), this.preview.visible = false;
      }
    } else
      this.cancelCreation();
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.preview && this.preview.dispose(), this._lineMaterial.dispose(), this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  // TODO: this could be better. Fusion this class with lengthmeasurement?
  /** {@link OBC.Createable.delete} */
  delete() {
    if (!this.enabled)
      return;
    const e = this.components.get(_n), n = e.enabled;
    e.enabled = true, e.delete(), e.enabled = n;
  }
  /**
   * Deletes all the measurements created by the EdgeMeasurement component.
   */
  deleteAll() {
    this.components.get(_n).deleteAll();
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
  }
  /**
   * Retrieves the current state of the measurements created by the EdgeMeasurement component.
   * The state is serialized as an array of arrays, where each inner array represents a line measurement.
   * Each line measurement is represented by six numbers: the x, y, and z coordinates of the start and end points.
   */
  get() {
    const n = this.components.get(_n).list, s = [];
    for (const i of n) {
      const r = i.startPoint, o = i.endPoint, l = [r.x, r.y, r.z, o.x, o.y, o.z];
      s.push(l);
    }
    return s;
  }
  /**
   * Sets the state of the measurements created by the EdgeMeasurement component.
   * The state is serialized as an array of arrays, where each inner array represents a line measurement.
   * Each line measurement is represented by six numbers: the x, y, and z coordinates of the start and end points.
   *
   * @param dimensions - The serialized state of the measurements.
   * Each inner array should contain six numbers representing the x, y, and z coordinates of the start and end points of a line measurement.
   *
   */
  set(e) {
    const n = this.components.get(_n);
    n.world = this.world;
    for (const s of e) {
      const [i, r, o, l, u, d] = s, m = new Vector3(i, r, o), f = new Vector3(l, u, d);
      n.createOnPoints(m, f);
    }
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The edge measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the edge measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    e ? (s.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (s.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
  updateSelection(e, n, s, i) {
    if (!this.preview || !e.geometry.index)
      return;
    const o = this.components.get(Ar).getFace(e, s, i);
    if (!o)
      return;
    const { edges: l } = o;
    let u = Number.MAX_VALUE, d = [];
    for (const g of l) {
      const [v, y] = g.points, x = Ar.distanceFromPointToLine(
        n,
        v,
        y,
        true
      );
      x < this.tolerance && x < u && (u = x, d = g.points);
    }
    if (!d.length) {
      this.preview.visible = false;
      return;
    }
    const [m, f] = d;
    this.preview.startPoint = m, this.preview.endPoint = f, this.preview.visible = true;
  }
};
b(zr, "uuid", "e7be5749-89df-4514-8d25-83aa38ce12d8");
var Cc = zr;
var Rp = class extends Xc {
  constructor(e, n, s) {
    super(e, n, s);
    b(this, "threshold", 50);
    b(this, "bboxThreshold", 200);
    b(this, "maxLostTime", 3e4);
    b(this, "maxHiddenTime", 5e3);
    b(this, "boxes", /* @__PURE__ */ new Map());
    b(this, "_geometry");
    b(this, "_material", new MeshBasicMaterial({
      transparent: true,
      side: 2,
      opacity: 1
    }));
    b(this, "onViewUpdated", new ei());
    b(this, "_modelIDIndex", /* @__PURE__ */ new Map());
    b(this, "_indexModelID", /* @__PURE__ */ new Map());
    b(this, "_nextModelID", 0);
    b(this, "_geometries", /* @__PURE__ */ new Map());
    b(this, "_geometriesGroups", /* @__PURE__ */ new Map());
    b(this, "_foundGeometries", /* @__PURE__ */ new Set());
    b(this, "_intervalID", null);
    b(this, "codes", /* @__PURE__ */ new Map());
    b(this, "handleWorkerMessage", async (e2) => {
      const n2 = e2.data.colors, s2 = {}, i2 = {}, r = {}, o = {}, l = performance.now();
      let u = false;
      const d = new Set(this._foundGeometries);
      for (const [m, f] of n2) {
        const g = this._geometries.get(m);
        if (!g)
          continue;
        const v = f > this.threshold, { exists: y } = g;
        if (!v && !y)
          continue;
        const x = this._indexModelID.get(g.modelIndex);
        d.delete(m), v && y ? (g.time = l, o[x] || (o[x] = /* @__PURE__ */ new Set()), o[x].add(g.geometryID), this._foundGeometries.add(m), u = true) : v && !y ? (s2[x] || (s2[x] = /* @__PURE__ */ new Map()), g.time = l, g.exists = true, s2[x].has(f) || s2[x].set(f, /* @__PURE__ */ new Set()), s2[x].get(f).add(g.geometryID), this._foundGeometries.add(m), u = true) : !v && y && (this.handleLostGeometries(l, m, g, i2, r), u = true);
      }
      u && await this.onViewUpdated.trigger({ toLoad: s2, toRemove: i2, toHide: r, toShow: o }), this._isWorkerBusy = false;
    });
    this.updateInterval = 500, this._geometry = new BoxGeometry(1, 1, 1), this._geometry.groups = [], this._geometry.deleteAttribute("uv");
    const i = this._geometry.attributes.position.array;
    for (let r = 0; r < i.length; r++)
      i[r] += 0.5;
    this._geometry.attributes.position.needsUpdate = true, this.worker.addEventListener("message", this.handleWorkerMessage), this.autoUpdate && (this._intervalID = window.setInterval(
      this.updateVisibility,
      this.updateInterval
    ));
  }
  dispose() {
    super.dispose(), this.onViewUpdated.reset(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null);
    for (const [e, n] of this._geometriesGroups) {
      n.removeFromParent();
      const s = [...n.children];
      for (const i of s)
        i.removeFromParent();
    }
    this._geometriesGroups.clear();
    for (const [e, n] of this.boxes)
      n.dispose(true);
    this.boxes.clear();
    for (const [e, n] of this._geometries)
      n.fragment && (n.fragment.dispose(true), n.fragment = void 0);
    this._geometries.clear(), this._geometry.dispose(), this._material.dispose(), this._modelIDIndex.clear(), this._indexModelID.clear(), this.codes.clear();
  }
  add(e, n, s) {
    const i = this.createModelIndex(e), r = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const o = /* @__PURE__ */ new Map(), l = new Matrix4(), u = new Ue(this._geometry, this._material, 10);
    this.boxes.set(i, u), this.scene.add(u.mesh);
    const d = new Group();
    this.scene.add(d), this._geometriesGroups.set(i, d);
    const m = /* @__PURE__ */ new Map();
    for (const g of n)
      for (const v of g.geometries) {
        const { geometryID: y, transformation: x, color: A } = v, R = new Color();
        R.setRGB(A[0], A[1], A[2], "srgb");
        const P = this.getInstanceID(g.id, y), C = s[y];
        if (!C) {
          console.log(`Geometry not found: ${y}`);
          continue;
        }
        const { boundingBox: O } = C;
        let B;
        o.has(y) ? B = o.get(y) : (B = this.getAvailableColor(), this.increaseColor(), o.set(y, B));
        const { r: Y, g: H, b: K, code: Z } = B, q = new Color();
        q.setRGB(Y / 255, H / 255, K / 255, "srgb"), this.codes.has(i) || this.codes.set(i, /* @__PURE__ */ new Map()), this.codes.get(i).set(y, Z);
        const se = new Matrix4(), he = Object.values(O);
        if (se.fromArray(x), l.fromArray(he), se.multiply(l), m.has(P)) {
          const me = m.get(P);
          if (me === void 0 || !me.colors)
            throw new Error("Malformed item!");
          me.colors.push(q), me.geometryColors.push(R), me.transforms.push(se);
        } else
          m.set(P, {
            id: P,
            colors: [q],
            geometryColors: [R],
            transforms: [se]
          });
        if (this._geometries.has(Z))
          this._geometries.get(Z).assetIDs.add(g.id);
        else {
          const me = /* @__PURE__ */ new Set([g.id]);
          this._geometries.set(Z, {
            modelIndex: i,
            geometryID: y,
            assetIDs: me,
            exists: false,
            hidden: false,
            time: 0
          });
        }
      }
    const f = Array.from(m.values());
    u.add(f), ColorManagement.enabled = r;
  }
  remove(e) {
    const n = this._modelIDIndex.get(e);
    if (n === void 0)
      throw new Error("Model doesn't exist!");
    const s = this._geometriesGroups.get(n);
    s.removeFromParent();
    const i = [...s.children];
    for (const l of i)
      l.removeFromParent();
    this._geometriesGroups.delete(n), this.boxes.get(n).dispose(false), this.boxes.delete(n);
    const o = this.codes.get(n);
    this.codes.delete(n);
    for (const [l, u] of o) {
      const d = this._geometries.get(u);
      d && d.fragment && (d.fragment.dispose(false), d.fragment = void 0), this._geometries.delete(u);
    }
    this._modelIDIndex.delete(e), this._indexModelID.delete(n), this._foundGeometries.clear();
  }
  addFragment(e, n, s) {
    const i = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const r = this._modelIDIndex.get(e), l = this.codes.get(r).get(n), u = this._geometries.get(l);
    if (this.setGeometryVisibility(u, false, false), !u.fragment) {
      u.fragment = new Ue(
        s.mesh.geometry,
        this._material,
        s.capacity
      );
      const v = this._geometriesGroups.get(r);
      if (!v)
        throw new Error("Group not found!");
      v.add(u.fragment.mesh);
    }
    const [d, m, f] = l.split("-").map((v) => parseInt(v, 10)), g = [];
    for (const v of s.ids) {
      const y = s.get(v);
      if (!y.colors)
        throw new Error("Malformed fragments!");
      for (const x of y.colors)
        x.setRGB(d / 255, m / 255, f / 255, "srgb");
      g.push(y);
    }
    u.fragment.add(g), ColorManagement.enabled = i, this.needsUpdate = true;
  }
  removeFragment(e, n) {
    const s = this._modelIDIndex.get(e), r = this.codes.get(s).get(n), o = this._geometries.get(r);
    if (o.hidden || this.setGeometryVisibility(o, true, false), o.fragment) {
      const { fragment: l } = o;
      l.dispose(false), o.fragment = void 0;
    }
  }
  setModelTransformation(e, n) {
    const s = this._modelIDIndex.get(e);
    if (s === void 0)
      throw new Error("Model not found!");
    const i = this.boxes.get(s);
    i && (i.mesh.position.set(0, 0, 0), i.mesh.rotation.set(0, 0, 0), i.mesh.scale.set(1, 1, 1), i.mesh.applyMatrix4(n));
    const r = this._geometriesGroups.get(s);
    r && (r.position.set(0, 0, 0), r.rotation.set(0, 0, 0), r.scale.set(1, 1, 1), r.applyMatrix4(n));
  }
  setVisibility(e, n, s) {
    const i = this._modelIDIndex.get(n);
    if (i !== void 0)
      for (const [r, o] of s) {
        const l = this.codes.get(i);
        if (l === void 0)
          throw new Error("Map not found!");
        const u = l.get(r), d = this._geometries.get(u);
        if (d === void 0)
          throw new Error("Geometry not found!");
        d.hidden = !e, this.setGeometryVisibility(d, e, true, o);
      }
  }
  setGeometryVisibility(e, n, s, i) {
    const { modelIndex: r, geometryID: o, assetIDs: l } = e, u = this.boxes.get(r);
    if (u === void 0)
      throw new Error("Model not found!");
    const d = i || l;
    if (s && e.fragment)
      e.fragment.setVisibility(n, d);
    else {
      const m = /* @__PURE__ */ new Set();
      for (const f of d) {
        const g = this.getInstanceID(f, o);
        m.add(g);
      }
      u.setVisibility(n, m);
    }
  }
  handleLostGeometries(e, n, s, i, r) {
    const o = this._indexModelID.get(s.modelIndex), l = e - s.time;
    l > this.maxLostTime ? (i[o] || (i[o] = /* @__PURE__ */ new Set()), s.exists = false, i[o].add(s.geometryID), this._foundGeometries.delete(n)) : l > this.maxHiddenTime && (r[o] || (r[o] = /* @__PURE__ */ new Set()), r[o].add(s.geometryID));
  }
  createModelIndex(e) {
    if (this._modelIDIndex.has(e))
      throw new Error("Can't load the same model twice!");
    const n = this._nextModelID;
    return this._nextModelID++, this._modelIDIndex.set(e, n), this._indexModelID.set(n, e), n;
  }
  getInstanceID(e, n) {
    const i = 10 ** (Math.log(n) * Math.LOG10E + 1 | 0);
    return e + n / i;
  }
};
var Fh = { exports: {} };
(function(h, t) {
  (function(e, n) {
    h.exports = n();
  })(hc, function() {
    var e = function(a, c) {
      return (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, E) {
        p.__proto__ = E;
      } || function(p, E) {
        for (var I in E)
          Object.prototype.hasOwnProperty.call(E, I) && (p[I] = E[I]);
      })(a, c);
    }, n = function() {
      return (n = Object.assign || function(a) {
        for (var c, p = 1, E = arguments.length; p < E; p++)
          for (var I in c = arguments[p])
            Object.prototype.hasOwnProperty.call(c, I) && (a[I] = c[I]);
        return a;
      }).apply(this, arguments);
    };
    function s(a, c, p) {
      for (var E, I = 0, T = c.length; I < T; I++)
        !E && I in c || ((E = E || Array.prototype.slice.call(c, 0, I))[I] = c[I]);
      return a.concat(E || Array.prototype.slice.call(c));
    }
    var i = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : hc, r = Object.keys, o = Array.isArray;
    function l(a, c) {
      return typeof c != "object" || r(c).forEach(function(p) {
        a[p] = c[p];
      }), a;
    }
    typeof Promise > "u" || i.Promise || (i.Promise = Promise);
    var u = Object.getPrototypeOf, d = {}.hasOwnProperty;
    function m(a, c) {
      return d.call(a, c);
    }
    function f(a, c) {
      typeof c == "function" && (c = c(u(a))), (typeof Reflect > "u" ? r : Reflect.ownKeys)(c).forEach(function(p) {
        v(a, p, c[p]);
      });
    }
    var g = Object.defineProperty;
    function v(a, c, p, E) {
      g(a, c, l(p && m(p, "get") && typeof p.get == "function" ? { get: p.get, set: p.set, configurable: true } : { value: p, configurable: true, writable: true }, E));
    }
    function y(a) {
      return { from: function(c) {
        return a.prototype = Object.create(c.prototype), v(a.prototype, "constructor", a), { extend: f.bind(null, a.prototype) };
      } };
    }
    var x = Object.getOwnPropertyDescriptor, A = [].slice;
    function R(a, c, p) {
      return A.call(a, c, p);
    }
    function P(a, c) {
      return c(a);
    }
    function C(a) {
      if (!a)
        throw new Error("Assertion Failed");
    }
    function O(a) {
      i.setImmediate ? setImmediate(a) : setTimeout(a, 0);
    }
    function B(a, c) {
      if (typeof c == "string" && m(a, c))
        return a[c];
      if (!c)
        return a;
      if (typeof c != "string") {
        for (var p = [], E = 0, I = c.length; E < I; ++E) {
          var T = B(a, c[E]);
          p.push(T);
        }
        return p;
      }
      var F = c.indexOf(".");
      if (F !== -1) {
        var M = a[c.substr(0, F)];
        return M == null ? void 0 : B(M, c.substr(F + 1));
      }
    }
    function Y(a, c, p) {
      if (a && c !== void 0 && !("isFrozen" in Object && Object.isFrozen(a)))
        if (typeof c != "string" && "length" in c) {
          C(typeof p != "string" && "length" in p);
          for (var E = 0, I = c.length; E < I; ++E)
            Y(a, c[E], p[E]);
        } else {
          var T, F, M = c.indexOf(".");
          M !== -1 ? (T = c.substr(0, M), (F = c.substr(M + 1)) === "" ? p === void 0 ? o(a) && !isNaN(parseInt(T)) ? a.splice(T, 1) : delete a[T] : a[T] = p : Y(M = !(M = a[T]) || !m(a, T) ? a[T] = {} : M, F, p)) : p === void 0 ? o(a) && !isNaN(parseInt(c)) ? a.splice(c, 1) : delete a[c] : a[c] = p;
        }
    }
    function H(a) {
      var c, p = {};
      for (c in a)
        m(a, c) && (p[c] = a[c]);
      return p;
    }
    var K = [].concat;
    function Z(a) {
      return K.apply([], a);
    }
    var Jt = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Z([8, 16, 32, 64].map(function(a) {
      return ["Int", "Uint", "Float"].map(function(c) {
        return c + a + "Array";
      });
    }))).filter(function(a) {
      return i[a];
    }), q = new Set(Jt.map(function(a) {
      return i[a];
    })), ne = null;
    function se(a) {
      return ne = /* @__PURE__ */ new WeakMap(), a = function c(p) {
        if (!p || typeof p != "object")
          return p;
        var E = ne.get(p);
        if (E)
          return E;
        if (o(p)) {
          E = [], ne.set(p, E);
          for (var I = 0, T = p.length; I < T; ++I)
            E.push(c(p[I]));
        } else if (q.has(p.constructor))
          E = p;
        else {
          var F, M = u(p);
          for (F in E = M === Object.prototype ? {} : Object.create(M), ne.set(p, E), p)
            m(p, F) && (E[F] = c(p[F]));
        }
        return E;
      }(a), ne = null, a;
    }
    var he = {}.toString;
    function me(a) {
      return he.call(a).slice(8, -1);
    }
    var Ie = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ee = typeof Ie == "symbol" ? function(a) {
      var c;
      return a != null && (c = a[Ie]) && c.apply(a);
    } : function() {
      return null;
    };
    function ue(a, c) {
      return c = a.indexOf(c), 0 <= c && a.splice(c, 1), 0 <= c;
    }
    var Le = {};
    function we(a) {
      var c, p, E, I;
      if (arguments.length === 1) {
        if (o(a))
          return a.slice();
        if (this === Le && typeof a == "string")
          return [a];
        if (I = Ee(a)) {
          for (p = []; !(E = I.next()).done; )
            p.push(E.value);
          return p;
        }
        if (a == null)
          return [a];
        if (typeof (c = a.length) != "number")
          return [a];
        for (p = new Array(c); c--; )
          p[c] = a[c];
        return p;
      }
      for (c = arguments.length, p = new Array(c); c--; )
        p[c] = arguments[c];
      return p;
    }
    var Ke = typeof Symbol < "u" ? function(a) {
      return a[Symbol.toStringTag] === "AsyncFunction";
    } : function() {
      return false;
    }, Ts = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], It = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ts), Nt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
    function vt(a, c) {
      this.name = a, this.message = c;
    }
    function Is(a, c) {
      return a + ". Errors: " + Object.keys(c).map(function(p) {
        return c[p].toString();
      }).filter(function(p, E, I) {
        return I.indexOf(p) === E;
      }).join(`
`);
    }
    function Cn(a, c, p, E) {
      this.failures = c, this.failedKeys = E, this.successCount = p, this.message = Is(a, c);
    }
    function Zt(a, c) {
      this.name = "BulkError", this.failures = Object.keys(c).map(function(p) {
        return c[p];
      }), this.failuresByPos = c, this.message = Is(a, this.failures);
    }
    y(vt).from(Error).extend({ toString: function() {
      return this.name + ": " + this.message;
    } }), y(Cn).from(vt), y(Zt).from(vt);
    var Qt = It.reduce(function(a, c) {
      return a[c] = c + "Error", a;
    }, {}), je = vt, pe = It.reduce(function(a, c) {
      var p = c + "Error";
      function E(I, T) {
        this.name = p, I ? typeof I == "string" ? (this.message = "".concat(I).concat(T ? `
 ` + T : ""), this.inner = T || null) : typeof I == "object" && (this.message = "".concat(I.name, " ").concat(I.message), this.inner = I) : (this.message = Nt[c] || p, this.inner = null);
      }
      return y(E).from(je), a[c] = E, a;
    }, {});
    pe.Syntax = SyntaxError, pe.Type = TypeError, pe.Range = RangeError;
    var Ge = Ts.reduce(function(a, c) {
      return a[c + "Error"] = pe[c], a;
    }, {}), St = It.reduce(function(a, c) {
      return ["Syntax", "Type", "Range"].indexOf(c) === -1 && (a[c + "Error"] = pe[c]), a;
    }, {});
    function Oe() {
    }
    function _t(a) {
      return a;
    }
    function qr(a, c) {
      return a == null || a === _t ? c : function(p) {
        return c(a(p));
      };
    }
    function At(a, c) {
      return function() {
        a.apply(this, arguments), c.apply(this, arguments);
      };
    }
    function ys(a, c) {
      return a === Oe ? c : function() {
        var p = a.apply(this, arguments);
        p !== void 0 && (arguments[0] = p);
        var E = this.onsuccess, I = this.onerror;
        this.onsuccess = null, this.onerror = null;
        var T = c.apply(this, arguments);
        return E && (this.onsuccess = this.onsuccess ? At(E, this.onsuccess) : E), I && (this.onerror = this.onerror ? At(I, this.onerror) : I), T !== void 0 ? T : p;
      };
    }
    function ws(a, c) {
      return a === Oe ? c : function() {
        a.apply(this, arguments);
        var p = this.onsuccess, E = this.onerror;
        this.onsuccess = this.onerror = null, c.apply(this, arguments), p && (this.onsuccess = this.onsuccess ? At(p, this.onsuccess) : p), E && (this.onerror = this.onerror ? At(E, this.onerror) : E);
      };
    }
    function Rh(a, c) {
      return a === Oe ? c : function(p) {
        var E = a.apply(this, arguments);
        l(p, E);
        var I = this.onsuccess, T = this.onerror;
        return this.onsuccess = null, this.onerror = null, p = c.apply(this, arguments), I && (this.onsuccess = this.onsuccess ? At(I, this.onsuccess) : I), T && (this.onerror = this.onerror ? At(T, this.onerror) : T), E === void 0 ? p === void 0 ? void 0 : p : l(E, p);
      };
    }
    function Ph(a, c) {
      return a === Oe ? c : function() {
        return c.apply(this, arguments) !== false && a.apply(this, arguments);
      };
    }
    function Jr(a, c) {
      return a === Oe ? c : function() {
        var p = a.apply(this, arguments);
        if (p && typeof p.then == "function") {
          for (var E = this, I = arguments.length, T = new Array(I); I--; )
            T[I] = arguments[I];
          return p.then(function() {
            return c.apply(E, T);
          });
        }
        return c.apply(this, arguments);
      };
    }
    St.ModifyError = Cn, St.DexieError = vt, St.BulkError = Zt;
    var Ut = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function Ba(a) {
      Ut = a;
    }
    var Cs = {}, ka = 100, Jt = typeof Promise > "u" ? [] : function() {
      var a = Promise.resolve();
      if (typeof crypto > "u" || !crypto.subtle)
        return [a, u(a), a];
      var c = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
      return [c, u(c), a];
    }(), Ts = Jt[0], It = Jt[1], Jt = Jt[2], It = It && It.then, bs = Ts && Ts.constructor, $r = !!Jt, xs = function(a, c) {
      Ss.push([a, c]), mi && (queueMicrotask(Oh), mi = false);
    }, eo = true, mi = true, Tn = [], gi = [], to = _t, on = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: Oe, pgp: false, env: {}, finalize: Oe }, ge = on, Ss = [], bn = 0, Ei = [];
    function ce(a) {
      if (typeof this != "object")
        throw new TypeError("Promises must be constructed via new");
      this._listeners = [], this._lib = false;
      var c = this._PSD = ge;
      if (typeof a != "function") {
        if (a !== Cs)
          throw new TypeError("Not a function");
        return this._state = arguments[1], this._value = arguments[2], void (this._state === false && so(this, this._value));
      }
      this._state = null, this._value = null, ++c.ref, function p(E, I) {
        try {
          I(function(T) {
            if (E._state === null) {
              if (T === E)
                throw new TypeError("A promise cannot be resolved with itself.");
              var F = E._lib && Vn();
              T && typeof T.then == "function" ? p(E, function(M, _) {
                T instanceof ce ? T._then(M, _) : T.then(M, _);
              }) : (E._state = true, E._value = T, Va(E)), F && Gn();
            }
          }, so.bind(null, E));
        } catch (T) {
          so(E, T);
        }
      }(this, a);
    }
    var no = { get: function() {
      var a = ge, c = wi;
      function p(E, I) {
        var T = this, F = !a.global && (a !== ge || c !== wi), M = F && !ln(), _ = new ce(function(L, z) {
          io(T, new za(Ya(E, a, F, M), Ya(I, a, F, M), L, z, a));
        });
        return this._consoleTask && (_._consoleTask = this._consoleTask), _;
      }
      return p.prototype = Cs, p;
    }, set: function(a) {
      v(this, "then", a && a.prototype === Cs ? no : { get: function() {
        return a;
      }, set: no.set });
    } };
    function za(a, c, p, E, I) {
      this.onFulfilled = typeof a == "function" ? a : null, this.onRejected = typeof c == "function" ? c : null, this.resolve = p, this.reject = E, this.psd = I;
    }
    function so(a, c) {
      var p, E;
      gi.push(c), a._state === null && (p = a._lib && Vn(), c = to(c), a._state = false, a._value = c, E = a, Tn.some(function(I) {
        return I._value === E._value;
      }) || Tn.push(E), Va(a), p && Gn());
    }
    function Va(a) {
      var c = a._listeners;
      a._listeners = [];
      for (var p = 0, E = c.length; p < E; ++p)
        io(a, c[p]);
      var I = a._PSD;
      --I.ref || I.finalize(), bn === 0 && (++bn, xs(function() {
        --bn == 0 && ro();
      }, []));
    }
    function io(a, c) {
      if (a._state !== null) {
        var p = a._state ? c.onFulfilled : c.onRejected;
        if (p === null)
          return (a._state ? c.resolve : c.reject)(a._value);
        ++c.psd.ref, ++bn, xs(Mh, [p, a, c]);
      } else
        a._listeners.push(c);
    }
    function Mh(a, c, p) {
      try {
        var E, I = c._value;
        !c._state && gi.length && (gi = []), E = Ut && c._consoleTask ? c._consoleTask.run(function() {
          return a(I);
        }) : a(I), c._state || gi.indexOf(I) !== -1 || function(T) {
          for (var F = Tn.length; F; )
            if (Tn[--F]._value === T._value)
              return Tn.splice(F, 1);
        }(c), p.resolve(E);
      } catch (T) {
        p.reject(T);
      } finally {
        --bn == 0 && ro(), --p.psd.ref || p.psd.finalize();
      }
    }
    function Oh() {
      xn(on, function() {
        Vn() && Gn();
      });
    }
    function Vn() {
      var a = eo;
      return mi = eo = false, a;
    }
    function Gn() {
      var a, c, p;
      do
        for (; 0 < Ss.length; )
          for (a = Ss, Ss = [], p = a.length, c = 0; c < p; ++c) {
            var E = a[c];
            E[0].apply(null, E[1]);
          }
      while (0 < Ss.length);
      mi = eo = true;
    }
    function ro() {
      var a = Tn;
      Tn = [], a.forEach(function(E) {
        E._PSD.onunhandled.call(null, E._value, E);
      });
      for (var c = Ei.slice(0), p = c.length; p; )
        c[--p]();
    }
    function vi(a) {
      return new ce(Cs, false, a);
    }
    function ze(a, c) {
      var p = ge;
      return function() {
        var E = Vn(), I = ge;
        try {
          return cn(p, true), a.apply(this, arguments);
        } catch (T) {
          c && c(T);
        } finally {
          cn(I, false), E && Gn();
        }
      };
    }
    f(ce.prototype, { then: no, _then: function(a, c) {
      io(this, new za(null, null, a, c, ge));
    }, catch: function(a) {
      if (arguments.length === 1)
        return this.then(null, a);
      var c = a, p = arguments[1];
      return typeof c == "function" ? this.then(null, function(E) {
        return (E instanceof c ? p : vi)(E);
      }) : this.then(null, function(E) {
        return (E && E.name === c ? p : vi)(E);
      });
    }, finally: function(a) {
      return this.then(function(c) {
        return ce.resolve(a()).then(function() {
          return c;
        });
      }, function(c) {
        return ce.resolve(a()).then(function() {
          return vi(c);
        });
      });
    }, timeout: function(a, c) {
      var p = this;
      return a < 1 / 0 ? new ce(function(E, I) {
        var T = setTimeout(function() {
          return I(new pe.Timeout(c));
        }, a);
        p.then(E, I).finally(clearTimeout.bind(null, T));
      }) : this;
    } }), typeof Symbol < "u" && Symbol.toStringTag && v(ce.prototype, Symbol.toStringTag, "Dexie.Promise"), on.env = Ga(), f(ce, { all: function() {
      var a = we.apply(null, arguments).map(Ci);
      return new ce(function(c, p) {
        a.length === 0 && c([]);
        var E = a.length;
        a.forEach(function(I, T) {
          return ce.resolve(I).then(function(F) {
            a[T] = F, --E || c(a);
          }, p);
        });
      });
    }, resolve: function(a) {
      return a instanceof ce ? a : a && typeof a.then == "function" ? new ce(function(c, p) {
        a.then(c, p);
      }) : new ce(Cs, true, a);
    }, reject: vi, race: function() {
      var a = we.apply(null, arguments).map(Ci);
      return new ce(function(c, p) {
        a.map(function(E) {
          return ce.resolve(E).then(c, p);
        });
      });
    }, PSD: { get: function() {
      return ge;
    }, set: function(a) {
      return ge = a;
    } }, totalEchoes: { get: function() {
      return wi;
    } }, newPSD: an2, usePSD: xn, scheduler: { get: function() {
      return xs;
    }, set: function(a) {
      xs = a;
    } }, rejectionMapper: { get: function() {
      return to;
    }, set: function(a) {
      to = a;
    } }, follow: function(a, c) {
      return new ce(function(p, E) {
        return an2(function(I, T) {
          var F = ge;
          F.unhandleds = [], F.onunhandled = T, F.finalize = At(function() {
            var M, _ = this;
            M = function() {
              _.unhandleds.length === 0 ? I() : T(_.unhandleds[0]);
            }, Ei.push(function L() {
              M(), Ei.splice(Ei.indexOf(L), 1);
            }), ++bn, xs(function() {
              --bn == 0 && ro();
            }, []);
          }, F.finalize), a();
        }, c, p, E);
      });
    } }), bs && (bs.allSettled && v(ce, "allSettled", function() {
      var a = we.apply(null, arguments).map(Ci);
      return new ce(function(c) {
        a.length === 0 && c([]);
        var p = a.length, E = new Array(p);
        a.forEach(function(I, T) {
          return ce.resolve(I).then(function(F) {
            return E[T] = { status: "fulfilled", value: F };
          }, function(F) {
            return E[T] = { status: "rejected", reason: F };
          }).then(function() {
            return --p || c(E);
          });
        });
      });
    }), bs.any && typeof AggregateError < "u" && v(ce, "any", function() {
      var a = we.apply(null, arguments).map(Ci);
      return new ce(function(c, p) {
        a.length === 0 && p(new AggregateError([]));
        var E = a.length, I = new Array(E);
        a.forEach(function(T, F) {
          return ce.resolve(T).then(function(M) {
            return c(M);
          }, function(M) {
            I[F] = M, --E || p(new AggregateError(I));
          });
        });
      });
    }));
    var qe = { awaits: 0, echoes: 0, id: 0 }, Dh = 0, Ii = [], yi = 0, wi = 0, Lh = 0;
    function an2(a, c, p, E) {
      var I = ge, T = Object.create(I);
      return T.parent = I, T.ref = 0, T.global = false, T.id = ++Lh, on.env, T.env = $r ? { Promise: ce, PromiseProp: { value: ce, configurable: true, writable: true }, all: ce.all, race: ce.race, allSettled: ce.allSettled, any: ce.any, resolve: ce.resolve, reject: ce.reject } : {}, c && l(T, c), ++I.ref, T.finalize = function() {
        --this.parent.ref || this.parent.finalize();
      }, E = xn(T, a, p, E), T.ref === 0 && T.finalize(), E;
    }
    function Yn() {
      return qe.id || (qe.id = ++Dh), ++qe.awaits, qe.echoes += ka, qe.id;
    }
    function ln() {
      return !!qe.awaits && (--qe.awaits == 0 && (qe.id = 0), qe.echoes = qe.awaits * ka, true);
    }
    function Ci(a) {
      return qe.echoes && a && a.constructor === bs ? (Yn(), a.then(function(c) {
        return ln(), c;
      }, function(c) {
        return ln(), Xe(c);
      })) : a;
    }
    function Nh() {
      var a = Ii[Ii.length - 1];
      Ii.pop(), cn(a, false);
    }
    function cn(a, c) {
      var p, E = ge;
      (c ? !qe.echoes || yi++ && a === ge : !yi || --yi && a === ge) || queueMicrotask(c ? (function(I) {
        ++wi, qe.echoes && --qe.echoes != 0 || (qe.echoes = qe.awaits = qe.id = 0), Ii.push(ge), cn(I, true);
      }).bind(null, a) : Nh), a !== ge && (ge = a, E === on && (on.env = Ga()), $r && (p = on.env.Promise, c = a.env, (E.global || a.global) && (Object.defineProperty(i, "Promise", c.PromiseProp), p.all = c.all, p.race = c.race, p.resolve = c.resolve, p.reject = c.reject, c.allSettled && (p.allSettled = c.allSettled), c.any && (p.any = c.any))));
    }
    function Ga() {
      var a = i.Promise;
      return $r ? { Promise: a, PromiseProp: Object.getOwnPropertyDescriptor(i, "Promise"), all: a.all, race: a.race, allSettled: a.allSettled, any: a.any, resolve: a.resolve, reject: a.reject } : {};
    }
    function xn(a, c, p, E, I) {
      var T = ge;
      try {
        return cn(a, true), c(p, E, I);
      } finally {
        cn(T, false);
      }
    }
    function Ya(a, c, p, E) {
      return typeof a != "function" ? a : function() {
        var I = ge;
        p && Yn(), cn(c, true);
        try {
          return a.apply(this, arguments);
        } finally {
          cn(I, false), E && queueMicrotask(ln);
        }
      };
    }
    function oo(a) {
      Promise === bs && qe.echoes === 0 ? yi === 0 ? a() : enqueueNativeMicroTask(a) : setTimeout(a, 0);
    }
    ("" + It).indexOf("[native code]") === -1 && (Yn = ln = Oe);
    var Xe = ce.reject, Sn = "", qt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ha = "String expected.", Hn = [], Ti = "__dbnames", ao = "readonly", lo = "readwrite";
    function An(a, c) {
      return a ? c ? function() {
        return a.apply(this, arguments) && c.apply(this, arguments);
      } : a : c;
    }
    var Wa = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
    function bi(a) {
      return typeof a != "string" || /\./.test(a) ? function(c) {
        return c;
      } : function(c) {
        return c[a] === void 0 && a in c && delete (c = se(c))[a], c;
      };
    }
    function Ka() {
      throw pe.Type();
    }
    function Me(a, c) {
      try {
        var p = ja(a), E = ja(c);
        if (p !== E)
          return p === "Array" ? 1 : E === "Array" ? -1 : p === "binary" ? 1 : E === "binary" ? -1 : p === "string" ? 1 : E === "string" ? -1 : p === "Date" ? 1 : E !== "Date" ? NaN : -1;
        switch (p) {
          case "number":
          case "Date":
          case "string":
            return c < a ? 1 : a < c ? -1 : 0;
          case "binary":
            return function(I, T) {
              for (var F = I.length, M = T.length, _ = F < M ? F : M, L = 0; L < _; ++L)
                if (I[L] !== T[L])
                  return I[L] < T[L] ? -1 : 1;
              return F === M ? 0 : F < M ? -1 : 1;
            }(Xa(a), Xa(c));
          case "Array":
            return function(I, T) {
              for (var F = I.length, M = T.length, _ = F < M ? F : M, L = 0; L < _; ++L) {
                var z = Me(I[L], T[L]);
                if (z !== 0)
                  return z;
              }
              return F === M ? 0 : F < M ? -1 : 1;
            }(a, c);
        }
      } catch {
      }
      return NaN;
    }
    function ja(a) {
      var c = typeof a;
      return c != "object" ? c : ArrayBuffer.isView(a) ? "binary" : (a = me(a), a === "ArrayBuffer" ? "binary" : a);
    }
    function Xa(a) {
      return a instanceof Uint8Array ? a : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : new Uint8Array(a);
    }
    var Za = (Be.prototype._trans = function(a, c, p) {
      var E = this._tx || ge.trans, I = this.name, T = Ut && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(a === "readonly" ? "read" : "write", " ").concat(this.name));
      function F(L, z, D) {
        if (!D.schema[I])
          throw new pe.NotFound("Table " + I + " not part of transaction");
        return c(D.idbtrans, D);
      }
      var M = Vn();
      try {
        var _ = E && E.db._novip === this.db._novip ? E === ge.trans ? E._promise(a, F, p) : an2(function() {
          return E._promise(a, F, p);
        }, { trans: E, transless: ge.transless || ge }) : function L(z, D, V, N) {
          if (z.idbdb && (z._state.openComplete || ge.letThrough || z._vip)) {
            var k = z._createTransaction(D, V, z._dbSchema);
            try {
              k.create(), z._state.PR1398_maxLoop = 3;
            } catch (G) {
              return G.name === Qt.InvalidState && z.isOpen() && 0 < --z._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), z.close({ disableAutoOpen: false }), z.open().then(function() {
                return L(z, D, V, N);
              })) : Xe(G);
            }
            return k._promise(D, function(G, U) {
              return an2(function() {
                return ge.trans = k, N(G, U, k);
              });
            }).then(function(G) {
              if (D === "readwrite")
                try {
                  k.idbtrans.commit();
                } catch {
                }
              return D === "readonly" ? G : k._completion.then(function() {
                return G;
              });
            });
          }
          if (z._state.openComplete)
            return Xe(new pe.DatabaseClosed(z._state.dbOpenError));
          if (!z._state.isBeingOpened) {
            if (!z._state.autoOpen)
              return Xe(new pe.DatabaseClosed());
            z.open().catch(Oe);
          }
          return z._state.dbReadyPromise.then(function() {
            return L(z, D, V, N);
          });
        }(this.db, a, [this.name], F);
        return T && (_._consoleTask = T, _ = _.catch(function(L) {
          return console.trace(L), Xe(L);
        })), _;
      } finally {
        M && Gn();
      }
    }, Be.prototype.get = function(a, c) {
      var p = this;
      return a && a.constructor === Object ? this.where(a).first(c) : a == null ? Xe(new pe.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(E) {
        return p.core.get({ trans: E, key: a }).then(function(I) {
          return p.hook.reading.fire(I);
        });
      }).then(c);
    }, Be.prototype.where = function(a) {
      if (typeof a == "string")
        return new this.db.WhereClause(this, a);
      if (o(a))
        return new this.db.WhereClause(this, "[".concat(a.join("+"), "]"));
      var c = r(a);
      if (c.length === 1)
        return this.where(c[0]).equals(a[c[0]]);
      var p = this.schema.indexes.concat(this.schema.primKey).filter(function(_) {
        if (_.compound && c.every(function(z) {
          return 0 <= _.keyPath.indexOf(z);
        })) {
          for (var L = 0; L < c.length; ++L)
            if (c.indexOf(_.keyPath[L]) === -1)
              return false;
          return true;
        }
        return false;
      }).sort(function(_, L) {
        return _.keyPath.length - L.keyPath.length;
      })[0];
      if (p && this.db._maxKey !== Sn) {
        var F = p.keyPath.slice(0, c.length);
        return this.where(F).equals(F.map(function(L) {
          return a[L];
        }));
      }
      !p && Ut && console.warn("The query ".concat(JSON.stringify(a), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(c.join("+"), "]"));
      var E = this.schema.idxByName, I = this.db._deps.indexedDB;
      function T(_, L) {
        return I.cmp(_, L) === 0;
      }
      var M = c.reduce(function(V, L) {
        var z = V[0], D = V[1], V = E[L], N = a[L];
        return [z || V, z || !V ? An(D, V && V.multi ? function(k) {
          return k = B(k, L), o(k) && k.some(function(G) {
            return T(N, G);
          });
        } : function(k) {
          return T(N, B(k, L));
        }) : D];
      }, [null, null]), F = M[0], M = M[1];
      return F ? this.where(F.name).equals(a[F.keyPath]).filter(M) : p ? this.filter(M) : this.where(c).equals("");
    }, Be.prototype.filter = function(a) {
      return this.toCollection().and(a);
    }, Be.prototype.count = function(a) {
      return this.toCollection().count(a);
    }, Be.prototype.offset = function(a) {
      return this.toCollection().offset(a);
    }, Be.prototype.limit = function(a) {
      return this.toCollection().limit(a);
    }, Be.prototype.each = function(a) {
      return this.toCollection().each(a);
    }, Be.prototype.toArray = function(a) {
      return this.toCollection().toArray(a);
    }, Be.prototype.toCollection = function() {
      return new this.db.Collection(new this.db.WhereClause(this));
    }, Be.prototype.orderBy = function(a) {
      return new this.db.Collection(new this.db.WhereClause(this, o(a) ? "[".concat(a.join("+"), "]") : a));
    }, Be.prototype.reverse = function() {
      return this.toCollection().reverse();
    }, Be.prototype.mapToClass = function(a) {
      var c, p = this.db, E = this.name;
      function I() {
        return c !== null && c.apply(this, arguments) || this;
      }
      (this.schema.mappedClass = a).prototype instanceof Ka && (function(_, L) {
        if (typeof L != "function" && L !== null)
          throw new TypeError("Class extends value " + String(L) + " is not a constructor or null");
        function z() {
          this.constructor = _;
        }
        e(_, L), _.prototype = L === null ? Object.create(L) : (z.prototype = L.prototype, new z());
      }(I, c = a), Object.defineProperty(I.prototype, "db", { get: function() {
        return p;
      }, enumerable: false, configurable: true }), I.prototype.table = function() {
        return E;
      }, a = I);
      for (var T = /* @__PURE__ */ new Set(), F = a.prototype; F; F = u(F))
        Object.getOwnPropertyNames(F).forEach(function(_) {
          return T.add(_);
        });
      function M(_) {
        if (!_)
          return _;
        var L, z = Object.create(a.prototype);
        for (L in _)
          if (!T.has(L))
            try {
              z[L] = _[L];
            } catch {
            }
        return z;
      }
      return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = M, this.hook("reading", M), a;
    }, Be.prototype.defineClass = function() {
      return this.mapToClass(function(a) {
        l(this, a);
      });
    }, Be.prototype.add = function(a, c) {
      var p = this, E = this.schema.primKey, I = E.auto, T = E.keyPath, F = a;
      return T && I && (F = bi(T)(a)), this._trans("readwrite", function(M) {
        return p.core.mutate({ trans: M, type: "add", keys: c != null ? [c] : null, values: [F] });
      }).then(function(M) {
        return M.numFailures ? ce.reject(M.failures[0]) : M.lastResult;
      }).then(function(M) {
        if (T)
          try {
            Y(a, T, M);
          } catch {
          }
        return M;
      });
    }, Be.prototype.update = function(a, c) {
      return typeof a != "object" || o(a) ? this.where(":id").equals(a).modify(c) : (a = B(a, this.schema.primKey.keyPath), a === void 0 ? Xe(new pe.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(a).modify(c));
    }, Be.prototype.put = function(a, c) {
      var p = this, E = this.schema.primKey, I = E.auto, T = E.keyPath, F = a;
      return T && I && (F = bi(T)(a)), this._trans("readwrite", function(M) {
        return p.core.mutate({ trans: M, type: "put", values: [F], keys: c != null ? [c] : null });
      }).then(function(M) {
        return M.numFailures ? ce.reject(M.failures[0]) : M.lastResult;
      }).then(function(M) {
        if (T)
          try {
            Y(a, T, M);
          } catch {
          }
        return M;
      });
    }, Be.prototype.delete = function(a) {
      var c = this;
      return this._trans("readwrite", function(p) {
        return c.core.mutate({ trans: p, type: "delete", keys: [a] });
      }).then(function(p) {
        return p.numFailures ? ce.reject(p.failures[0]) : void 0;
      });
    }, Be.prototype.clear = function() {
      var a = this;
      return this._trans("readwrite", function(c) {
        return a.core.mutate({ trans: c, type: "deleteRange", range: Wa });
      }).then(function(c) {
        return c.numFailures ? ce.reject(c.failures[0]) : void 0;
      });
    }, Be.prototype.bulkGet = function(a) {
      var c = this;
      return this._trans("readonly", function(p) {
        return c.core.getMany({ keys: a, trans: p }).then(function(E) {
          return E.map(function(I) {
            return c.hook.reading.fire(I);
          });
        });
      });
    }, Be.prototype.bulkAdd = function(a, c, p) {
      var E = this, I = Array.isArray(c) ? c : void 0, T = (p = p || (I ? void 0 : c)) ? p.allKeys : void 0;
      return this._trans("readwrite", function(F) {
        var L = E.schema.primKey, M = L.auto, L = L.keyPath;
        if (L && I)
          throw new pe.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
        if (I && I.length !== a.length)
          throw new pe.InvalidArgument("Arguments objects and keys must have the same length");
        var _ = a.length, L = L && M ? a.map(bi(L)) : a;
        return E.core.mutate({ trans: F, type: "add", keys: I, values: L, wantResults: T }).then(function(k) {
          var D = k.numFailures, V = k.results, N = k.lastResult, k = k.failures;
          if (D === 0)
            return T ? V : N;
          throw new Zt("".concat(E.name, ".bulkAdd(): ").concat(D, " of ").concat(_, " operations failed"), k);
        });
      });
    }, Be.prototype.bulkPut = function(a, c, p) {
      var E = this, I = Array.isArray(c) ? c : void 0, T = (p = p || (I ? void 0 : c)) ? p.allKeys : void 0;
      return this._trans("readwrite", function(F) {
        var L = E.schema.primKey, M = L.auto, L = L.keyPath;
        if (L && I)
          throw new pe.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
        if (I && I.length !== a.length)
          throw new pe.InvalidArgument("Arguments objects and keys must have the same length");
        var _ = a.length, L = L && M ? a.map(bi(L)) : a;
        return E.core.mutate({ trans: F, type: "put", keys: I, values: L, wantResults: T }).then(function(k) {
          var D = k.numFailures, V = k.results, N = k.lastResult, k = k.failures;
          if (D === 0)
            return T ? V : N;
          throw new Zt("".concat(E.name, ".bulkPut(): ").concat(D, " of ").concat(_, " operations failed"), k);
        });
      });
    }, Be.prototype.bulkUpdate = function(a) {
      var c = this, p = this.core, E = a.map(function(F) {
        return F.key;
      }), I = a.map(function(F) {
        return F.changes;
      }), T = [];
      return this._trans("readwrite", function(F) {
        return p.getMany({ trans: F, keys: E, cache: "clone" }).then(function(M) {
          var _ = [], L = [];
          a.forEach(function(D, V) {
            var N = D.key, k = D.changes, G = M[V];
            if (G) {
              for (var U = 0, W = Object.keys(k); U < W.length; U++) {
                var j = W[U], X = k[j];
                if (j === c.schema.primKey.keyPath) {
                  if (Me(X, N) !== 0)
                    throw new pe.Constraint("Cannot update primary key in bulkUpdate()");
                } else
                  Y(G, j, X);
              }
              T.push(V), _.push(N), L.push(G);
            }
          });
          var z = _.length;
          return p.mutate({ trans: F, type: "put", keys: _, values: L, updates: { keys: E, changeSpecs: I } }).then(function(D) {
            var V = D.numFailures, N = D.failures;
            if (V === 0)
              return z;
            for (var k = 0, G = Object.keys(N); k < G.length; k++) {
              var U, W = G[k], j = T[Number(W)];
              j != null && (U = N[W], delete N[W], N[j] = U);
            }
            throw new Zt("".concat(c.name, ".bulkUpdate(): ").concat(V, " of ").concat(z, " operations failed"), N);
          });
        });
      });
    }, Be.prototype.bulkDelete = function(a) {
      var c = this, p = a.length;
      return this._trans("readwrite", function(E) {
        return c.core.mutate({ trans: E, type: "delete", keys: a });
      }).then(function(F) {
        var I = F.numFailures, T = F.lastResult, F = F.failures;
        if (I === 0)
          return T;
        throw new Zt("".concat(c.name, ".bulkDelete(): ").concat(I, " of ").concat(p, " operations failed"), F);
      });
    }, Be);
    function Be() {
    }
    function As(a) {
      function c(F, M) {
        if (M) {
          for (var _ = arguments.length, L = new Array(_ - 1); --_; )
            L[_ - 1] = arguments[_];
          return p[F].subscribe.apply(null, L), a;
        }
        if (typeof F == "string")
          return p[F];
      }
      var p = {};
      c.addEventType = T;
      for (var E = 1, I = arguments.length; E < I; ++E)
        T(arguments[E]);
      return c;
      function T(F, M, _) {
        if (typeof F != "object") {
          var L;
          M = M || Ph;
          var z = { subscribers: [], fire: _ = _ || Oe, subscribe: function(D) {
            z.subscribers.indexOf(D) === -1 && (z.subscribers.push(D), z.fire = M(z.fire, D));
          }, unsubscribe: function(D) {
            z.subscribers = z.subscribers.filter(function(V) {
              return V !== D;
            }), z.fire = z.subscribers.reduce(M, _);
          } };
          return p[F] = c[F] = z;
        }
        r(L = F).forEach(function(D) {
          var V = L[D];
          if (o(V))
            T(D, L[D][0], L[D][1]);
          else {
            if (V !== "asap")
              throw new pe.InvalidArgument("Invalid event config");
            var N = T(D, _t, function() {
              for (var k = arguments.length, G = new Array(k); k--; )
                G[k] = arguments[k];
              N.subscribers.forEach(function(U) {
                O(function() {
                  U.apply(null, G);
                });
              });
            });
          }
        });
      }
    }
    function Fs(a, c) {
      return y(c).from({ prototype: a }), c;
    }
    function Wn(a, c) {
      return !(a.filter || a.algorithm || a.or) && (c ? a.justLimit : !a.replayFilter);
    }
    function co(a, c) {
      a.filter = An(a.filter, c);
    }
    function ho(a, c, p) {
      var E = a.replayFilter;
      a.replayFilter = E ? function() {
        return An(E(), c());
      } : c, a.justLimit = p && !E;
    }
    function xi(a, c) {
      if (a.isPrimKey)
        return c.primaryKey;
      var p = c.getIndexByKeyPath(a.index);
      if (!p)
        throw new pe.Schema("KeyPath " + a.index + " on object store " + c.name + " is not indexed");
      return p;
    }
    function Qa(a, c, p) {
      var E = xi(a, c.schema);
      return c.openCursor({ trans: p, values: !a.keysOnly, reverse: a.dir === "prev", unique: !!a.unique, query: { index: E, range: a.range } });
    }
    function Si(a, c, p, E) {
      var I = a.replayFilter ? An(a.filter, a.replayFilter()) : a.filter;
      if (a.or) {
        var T = {}, F = function(M, _, L) {
          var z, D;
          I && !I(_, L, function(V) {
            return _.stop(V);
          }, function(V) {
            return _.fail(V);
          }) || ((D = "" + (z = _.primaryKey)) == "[object ArrayBuffer]" && (D = "" + new Uint8Array(z)), m(T, D) || (T[D] = true, c(M, _, L)));
        };
        return Promise.all([a.or._iterate(F, p), qa(Qa(a, E, p), a.algorithm, F, !a.keysOnly && a.valueMapper)]);
      }
      return qa(Qa(a, E, p), An(a.algorithm, I), c, !a.keysOnly && a.valueMapper);
    }
    function qa(a, c, p, E) {
      var I = ze(E ? function(T, F, M) {
        return p(E(T), F, M);
      } : p);
      return a.then(function(T) {
        if (T)
          return T.start(function() {
            var F = function() {
              return T.continue();
            };
            c && !c(T, function(M) {
              return F = M;
            }, function(M) {
              T.stop(M), F = Oe;
            }, function(M) {
              T.fail(M), F = Oe;
            }) || I(T.value, T, function(M) {
              return F = M;
            }), F();
          });
      });
    }
    var Jt = Symbol(), Rs = (Ja.prototype.execute = function(a) {
      if (this.add !== void 0) {
        var c = this.add;
        if (o(c))
          return s(s([], o(a) ? a : [], true), c).sort();
        if (typeof c == "number")
          return (Number(a) || 0) + c;
        if (typeof c == "bigint")
          try {
            return BigInt(a) + c;
          } catch {
            return BigInt(0) + c;
          }
        throw new TypeError("Invalid term ".concat(c));
      }
      if (this.remove !== void 0) {
        var p = this.remove;
        if (o(p))
          return o(a) ? a.filter(function(E) {
            return !p.includes(E);
          }).sort() : [];
        if (typeof p == "number")
          return Number(a) - p;
        if (typeof p == "bigint")
          try {
            return BigInt(a) - p;
          } catch {
            return BigInt(0) - p;
          }
        throw new TypeError("Invalid subtrahend ".concat(p));
      }
      return c = (c = this.replacePrefix) === null || c === void 0 ? void 0 : c[0], c && typeof a == "string" && a.startsWith(c) ? this.replacePrefix[1] + a.substring(c.length) : a;
    }, Ja);
    function Ja(a) {
      Object.assign(this, a);
    }
    var _h = (Re2.prototype._read = function(a, c) {
      var p = this._ctx;
      return p.error ? p.table._trans(null, Xe.bind(null, p.error)) : p.table._trans("readonly", a).then(c);
    }, Re2.prototype._write = function(a) {
      var c = this._ctx;
      return c.error ? c.table._trans(null, Xe.bind(null, c.error)) : c.table._trans("readwrite", a, "locked");
    }, Re2.prototype._addAlgorithm = function(a) {
      var c = this._ctx;
      c.algorithm = An(c.algorithm, a);
    }, Re2.prototype._iterate = function(a, c) {
      return Si(this._ctx, a, c, this._ctx.table.core);
    }, Re2.prototype.clone = function(a) {
      var c = Object.create(this.constructor.prototype), p = Object.create(this._ctx);
      return a && l(p, a), c._ctx = p, c;
    }, Re2.prototype.raw = function() {
      return this._ctx.valueMapper = null, this;
    }, Re2.prototype.each = function(a) {
      var c = this._ctx;
      return this._read(function(p) {
        return Si(c, a, p, c.table.core);
      });
    }, Re2.prototype.count = function(a) {
      var c = this;
      return this._read(function(p) {
        var E = c._ctx, I = E.table.core;
        if (Wn(E, true))
          return I.count({ trans: p, query: { index: xi(E, I.schema), range: E.range } }).then(function(F) {
            return Math.min(F, E.limit);
          });
        var T = 0;
        return Si(E, function() {
          return ++T, false;
        }, p, I).then(function() {
          return T;
        });
      }).then(a);
    }, Re2.prototype.sortBy = function(a, c) {
      var p = a.split(".").reverse(), E = p[0], I = p.length - 1;
      function T(_, L) {
        return L ? T(_[p[L]], L - 1) : _[E];
      }
      var F = this._ctx.dir === "next" ? 1 : -1;
      function M(_, L) {
        return _ = T(_, I), L = T(L, I), _ < L ? -F : L < _ ? F : 0;
      }
      return this.toArray(function(_) {
        return _.sort(M);
      }).then(c);
    }, Re2.prototype.toArray = function(a) {
      var c = this;
      return this._read(function(p) {
        var E = c._ctx;
        if (E.dir === "next" && Wn(E, true) && 0 < E.limit) {
          var I = E.valueMapper, T = xi(E, E.table.core.schema);
          return E.table.core.query({ trans: p, limit: E.limit, values: true, query: { index: T, range: E.range } }).then(function(M) {
            return M = M.result, I ? M.map(I) : M;
          });
        }
        var F = [];
        return Si(E, function(M) {
          return F.push(M);
        }, p, E.table.core).then(function() {
          return F;
        });
      }, a);
    }, Re2.prototype.offset = function(a) {
      var c = this._ctx;
      return a <= 0 || (c.offset += a, Wn(c) ? ho(c, function() {
        var p = a;
        return function(E, I) {
          return p === 0 || (p === 1 ? --p : I(function() {
            E.advance(p), p = 0;
          }), false);
        };
      }) : ho(c, function() {
        var p = a;
        return function() {
          return --p < 0;
        };
      })), this;
    }, Re2.prototype.limit = function(a) {
      return this._ctx.limit = Math.min(this._ctx.limit, a), ho(this._ctx, function() {
        var c = a;
        return function(p, E, I) {
          return --c <= 0 && E(I), 0 <= c;
        };
      }, true), this;
    }, Re2.prototype.until = function(a, c) {
      return co(this._ctx, function(p, E, I) {
        return !a(p.value) || (E(I), c);
      }), this;
    }, Re2.prototype.first = function(a) {
      return this.limit(1).toArray(function(c) {
        return c[0];
      }).then(a);
    }, Re2.prototype.last = function(a) {
      return this.reverse().first(a);
    }, Re2.prototype.filter = function(a) {
      var c;
      return co(this._ctx, function(p) {
        return a(p.value);
      }), (c = this._ctx).isMatch = An(c.isMatch, a), this;
    }, Re2.prototype.and = function(a) {
      return this.filter(a);
    }, Re2.prototype.or = function(a) {
      return new this.db.WhereClause(this._ctx.table, a, this);
    }, Re2.prototype.reverse = function() {
      return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
    }, Re2.prototype.desc = function() {
      return this.reverse();
    }, Re2.prototype.eachKey = function(a) {
      var c = this._ctx;
      return c.keysOnly = !c.isMatch, this.each(function(p, E) {
        a(E.key, E);
      });
    }, Re2.prototype.eachUniqueKey = function(a) {
      return this._ctx.unique = "unique", this.eachKey(a);
    }, Re2.prototype.eachPrimaryKey = function(a) {
      var c = this._ctx;
      return c.keysOnly = !c.isMatch, this.each(function(p, E) {
        a(E.primaryKey, E);
      });
    }, Re2.prototype.keys = function(a) {
      var c = this._ctx;
      c.keysOnly = !c.isMatch;
      var p = [];
      return this.each(function(E, I) {
        p.push(I.key);
      }).then(function() {
        return p;
      }).then(a);
    }, Re2.prototype.primaryKeys = function(a) {
      var c = this._ctx;
      if (c.dir === "next" && Wn(c, true) && 0 < c.limit)
        return this._read(function(E) {
          var I = xi(c, c.table.core.schema);
          return c.table.core.query({ trans: E, values: false, limit: c.limit, query: { index: I, range: c.range } });
        }).then(function(E) {
          return E.result;
        }).then(a);
      c.keysOnly = !c.isMatch;
      var p = [];
      return this.each(function(E, I) {
        p.push(I.primaryKey);
      }).then(function() {
        return p;
      }).then(a);
    }, Re2.prototype.uniqueKeys = function(a) {
      return this._ctx.unique = "unique", this.keys(a);
    }, Re2.prototype.firstKey = function(a) {
      return this.limit(1).keys(function(c) {
        return c[0];
      }).then(a);
    }, Re2.prototype.lastKey = function(a) {
      return this.reverse().firstKey(a);
    }, Re2.prototype.distinct = function() {
      var a = this._ctx, a = a.index && a.table.schema.idxByName[a.index];
      if (!a || !a.multi)
        return this;
      var c = {};
      return co(this._ctx, function(I) {
        var E = I.primaryKey.toString(), I = m(c, E);
        return c[E] = true, !I;
      }), this;
    }, Re2.prototype.modify = function(a) {
      var c = this, p = this._ctx;
      return this._write(function(E) {
        var I, T, F;
        F = typeof a == "function" ? a : (I = r(a), T = I.length, function(U) {
          for (var W = false, j = 0; j < T; ++j) {
            var X = I[j], Q = a[X], ee = B(U, X);
            Q instanceof Rs ? (Y(U, X, Q.execute(ee)), W = true) : ee !== Q && (Y(U, X, Q), W = true);
          }
          return W;
        });
        function M(U, X) {
          var j = X.failures, X = X.numFailures;
          k += U - X;
          for (var Q = 0, ee = r(j); Q < ee.length; Q++) {
            var ae2 = ee[Q];
            N.push(j[ae2]);
          }
        }
        var _ = p.table.core, L = _.schema.primaryKey, z = L.outbound, D = L.extractKey, V = c.db._options.modifyChunkSize || 200, N = [], k = 0, G = [];
        return c.clone().primaryKeys().then(function(U) {
          function W(X) {
            var Q = Math.min(V, U.length - X);
            return _.getMany({ trans: E, keys: U.slice(X, X + Q), cache: "immutable" }).then(function(ee) {
              for (var ae2 = [], ie = [], oe = z ? [] : null, le = [], re = 0; re < Q; ++re) {
                var Ce = ee[re], Te = { value: se(Ce), primKey: U[X + re] };
                F.call(Te, Te.value, Te) !== false && (Te.value == null ? le.push(U[X + re]) : z || Me(D(Ce), D(Te.value)) === 0 ? (ie.push(Te.value), z && oe.push(U[X + re])) : (le.push(U[X + re]), ae2.push(Te.value)));
              }
              return Promise.resolve(0 < ae2.length && _.mutate({ trans: E, type: "add", values: ae2 }).then(function(Ae) {
                for (var xe in Ae.failures)
                  le.splice(parseInt(xe), 1);
                M(ae2.length, Ae);
              })).then(function() {
                return (0 < ie.length || j && typeof a == "object") && _.mutate({ trans: E, type: "put", keys: oe, values: ie, criteria: j, changeSpec: typeof a != "function" && a, isAdditionalChunk: 0 < X }).then(function(Ae) {
                  return M(ie.length, Ae);
                });
              }).then(function() {
                return (0 < le.length || j && a === uo) && _.mutate({ trans: E, type: "delete", keys: le, criteria: j, isAdditionalChunk: 0 < X }).then(function(Ae) {
                  return M(le.length, Ae);
                });
              }).then(function() {
                return U.length > X + Q && W(X + V);
              });
            });
          }
          var j = Wn(p) && p.limit === 1 / 0 && (typeof a != "function" || a === uo) && { index: p.index, range: p.range };
          return W(0).then(function() {
            if (0 < N.length)
              throw new Cn("Error modifying one or more objects", N, k, G);
            return U.length;
          });
        });
      });
    }, Re2.prototype.delete = function() {
      var a = this._ctx, c = a.range;
      return Wn(a) && (a.isPrimKey || c.type === 3) ? this._write(function(p) {
        var E = a.table.core.schema.primaryKey, I = c;
        return a.table.core.count({ trans: p, query: { index: E, range: I } }).then(function(T) {
          return a.table.core.mutate({ trans: p, type: "deleteRange", range: I }).then(function(F) {
            var M = F.failures;
            if (F.lastResult, F.results, F = F.numFailures, F)
              throw new Cn("Could not delete some values", Object.keys(M).map(function(_) {
                return M[_];
              }), T - F);
            return T - F;
          });
        });
      }) : this.modify(uo);
    }, Re2);
    function Re2() {
    }
    var uo = function(a, c) {
      return c.value = null;
    };
    function Uh(a, c) {
      return a < c ? -1 : a === c ? 0 : 1;
    }
    function Bh(a, c) {
      return c < a ? -1 : a === c ? 0 : 1;
    }
    function mt(a, c, p) {
      return a = a instanceof el ? new a.Collection(a) : a, a._ctx.error = new (p || TypeError)(c), a;
    }
    function Kn(a) {
      return new a.Collection(a, function() {
        return $a("");
      }).limit(0);
    }
    function Ai(a, c, p, E) {
      var I, T, F, M, _, L, z, D = p.length;
      if (!p.every(function(k) {
        return typeof k == "string";
      }))
        return mt(a, Ha);
      function V(k) {
        I = k === "next" ? function(U) {
          return U.toUpperCase();
        } : function(U) {
          return U.toLowerCase();
        }, T = k === "next" ? function(U) {
          return U.toLowerCase();
        } : function(U) {
          return U.toUpperCase();
        }, F = k === "next" ? Uh : Bh;
        var G = p.map(function(U) {
          return { lower: T(U), upper: I(U) };
        }).sort(function(U, W) {
          return F(U.lower, W.lower);
        });
        M = G.map(function(U) {
          return U.upper;
        }), _ = G.map(function(U) {
          return U.lower;
        }), z = (L = k) === "next" ? "" : E;
      }
      V("next"), a = new a.Collection(a, function() {
        return hn(M[0], _[D - 1] + E);
      }), a._ondirectionchange = function(k) {
        V(k);
      };
      var N = 0;
      return a._addAlgorithm(function(k, G, U) {
        var W = k.key;
        if (typeof W != "string")
          return false;
        var j = T(W);
        if (c(j, _, N))
          return true;
        for (var X = null, Q = N; Q < D; ++Q) {
          var ee = function(ae2, ie, oe, le, re, Ce) {
            for (var Te = Math.min(ae2.length, le.length), Ae = -1, xe = 0; xe < Te; ++xe) {
              var Ft = ie[xe];
              if (Ft !== le[xe])
                return re(ae2[xe], oe[xe]) < 0 ? ae2.substr(0, xe) + oe[xe] + oe.substr(xe + 1) : re(ae2[xe], le[xe]) < 0 ? ae2.substr(0, xe) + le[xe] + oe.substr(xe + 1) : 0 <= Ae ? ae2.substr(0, Ae) + ie[Ae] + oe.substr(Ae + 1) : null;
              re(ae2[xe], Ft) < 0 && (Ae = xe);
            }
            return Te < le.length && Ce === "next" ? ae2 + oe.substr(ae2.length) : Te < ae2.length && Ce === "prev" ? ae2.substr(0, oe.length) : Ae < 0 ? null : ae2.substr(0, Ae) + le[Ae] + oe.substr(Ae + 1);
          }(W, j, M[Q], _[Q], F, L);
          ee === null && X === null ? N = Q + 1 : (X === null || 0 < F(X, ee)) && (X = ee);
        }
        return G(X !== null ? function() {
          k.continue(X + z);
        } : U), false;
      }), a;
    }
    function hn(a, c, p, E) {
      return { type: 2, lower: a, upper: c, lowerOpen: p, upperOpen: E };
    }
    function $a(a) {
      return { type: 1, lower: a, upper: a };
    }
    var el = (Object.defineProperty(Je.prototype, "Collection", { get: function() {
      return this._ctx.table.db.Collection;
    }, enumerable: false, configurable: true }), Je.prototype.between = function(a, c, p, E) {
      p = p !== false, E = E === true;
      try {
        return 0 < this._cmp(a, c) || this._cmp(a, c) === 0 && (p || E) && (!p || !E) ? Kn(this) : new this.Collection(this, function() {
          return hn(a, c, !p, !E);
        });
      } catch {
        return mt(this, qt);
      }
    }, Je.prototype.equals = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return $a(a);
      });
    }, Je.prototype.above = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return hn(a, void 0, true);
      });
    }, Je.prototype.aboveOrEqual = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return hn(a, void 0, false);
      });
    }, Je.prototype.below = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return hn(void 0, a, false, true);
      });
    }, Je.prototype.belowOrEqual = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return hn(void 0, a);
      });
    }, Je.prototype.startsWith = function(a) {
      return typeof a != "string" ? mt(this, Ha) : this.between(a, a + Sn, true, true);
    }, Je.prototype.startsWithIgnoreCase = function(a) {
      return a === "" ? this.startsWith(a) : Ai(this, function(c, p) {
        return c.indexOf(p[0]) === 0;
      }, [a], Sn);
    }, Je.prototype.equalsIgnoreCase = function(a) {
      return Ai(this, function(c, p) {
        return c === p[0];
      }, [a], "");
    }, Je.prototype.anyOfIgnoreCase = function() {
      var a = we.apply(Le, arguments);
      return a.length === 0 ? Kn(this) : Ai(this, function(c, p) {
        return p.indexOf(c) !== -1;
      }, a, "");
    }, Je.prototype.startsWithAnyOfIgnoreCase = function() {
      var a = we.apply(Le, arguments);
      return a.length === 0 ? Kn(this) : Ai(this, function(c, p) {
        return p.some(function(E) {
          return c.indexOf(E) === 0;
        });
      }, a, Sn);
    }, Je.prototype.anyOf = function() {
      var a = this, c = we.apply(Le, arguments), p = this._cmp;
      try {
        c.sort(p);
      } catch {
        return mt(this, qt);
      }
      if (c.length === 0)
        return Kn(this);
      var E = new this.Collection(this, function() {
        return hn(c[0], c[c.length - 1]);
      });
      E._ondirectionchange = function(T) {
        p = T === "next" ? a._ascending : a._descending, c.sort(p);
      };
      var I = 0;
      return E._addAlgorithm(function(T, F, M) {
        for (var _ = T.key; 0 < p(_, c[I]); )
          if (++I === c.length)
            return F(M), false;
        return p(_, c[I]) === 0 || (F(function() {
          T.continue(c[I]);
        }), false);
      }), E;
    }, Je.prototype.notEqual = function(a) {
      return this.inAnyRange([[-1 / 0, a], [a, this.db._maxKey]], { includeLowers: false, includeUppers: false });
    }, Je.prototype.noneOf = function() {
      var a = we.apply(Le, arguments);
      if (a.length === 0)
        return new this.Collection(this);
      try {
        a.sort(this._ascending);
      } catch {
        return mt(this, qt);
      }
      var c = a.reduce(function(p, E) {
        return p ? p.concat([[p[p.length - 1][1], E]]) : [[-1 / 0, E]];
      }, null);
      return c.push([a[a.length - 1], this.db._maxKey]), this.inAnyRange(c, { includeLowers: false, includeUppers: false });
    }, Je.prototype.inAnyRange = function(W, c) {
      var p = this, E = this._cmp, I = this._ascending, T = this._descending, F = this._min, M = this._max;
      if (W.length === 0)
        return Kn(this);
      if (!W.every(function(j) {
        return j[0] !== void 0 && j[1] !== void 0 && I(j[0], j[1]) <= 0;
      }))
        return mt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", pe.InvalidArgument);
      var _ = !c || c.includeLowers !== false, L = c && c.includeUppers === true, z, D = I;
      function V(j, X) {
        return D(j[0], X[0]);
      }
      try {
        (z = W.reduce(function(j, X) {
          for (var Q = 0, ee = j.length; Q < ee; ++Q) {
            var ae2 = j[Q];
            if (E(X[0], ae2[1]) < 0 && 0 < E(X[1], ae2[0])) {
              ae2[0] = F(ae2[0], X[0]), ae2[1] = M(ae2[1], X[1]);
              break;
            }
          }
          return Q === ee && j.push(X), j;
        }, [])).sort(V);
      } catch {
        return mt(this, qt);
      }
      var N = 0, k = L ? function(j) {
        return 0 < I(j, z[N][1]);
      } : function(j) {
        return 0 <= I(j, z[N][1]);
      }, G = _ ? function(j) {
        return 0 < T(j, z[N][0]);
      } : function(j) {
        return 0 <= T(j, z[N][0]);
      }, U = k, W = new this.Collection(this, function() {
        return hn(z[0][0], z[z.length - 1][1], !_, !L);
      });
      return W._ondirectionchange = function(j) {
        D = j === "next" ? (U = k, I) : (U = G, T), z.sort(V);
      }, W._addAlgorithm(function(j, X, Q) {
        for (var ee, ae2 = j.key; U(ae2); )
          if (++N === z.length)
            return X(Q), false;
        return !k(ee = ae2) && !G(ee) || (p._cmp(ae2, z[N][1]) === 0 || p._cmp(ae2, z[N][0]) === 0 || X(function() {
          D === I ? j.continue(z[N][0]) : j.continue(z[N][1]);
        }), false);
      }), W;
    }, Je.prototype.startsWithAnyOf = function() {
      var a = we.apply(Le, arguments);
      return a.every(function(c) {
        return typeof c == "string";
      }) ? a.length === 0 ? Kn(this) : this.inAnyRange(a.map(function(c) {
        return [c, c + Sn];
      })) : mt(this, "startsWithAnyOf() only works with strings");
    }, Je);
    function Je() {
    }
    function Bt(a) {
      return ze(function(c) {
        return Ps(c), a(c.target.error), false;
      });
    }
    function Ps(a) {
      a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault();
    }
    var Ms = "storagemutated", fo = "x-storagemutated-1", un = As(null, Ms), kh = (kt.prototype._lock = function() {
      return C(!ge.global), ++this._reculock, this._reculock !== 1 || ge.global || (ge.lockOwnerFor = this), this;
    }, kt.prototype._unlock = function() {
      if (C(!ge.global), --this._reculock == 0)
        for (ge.global || (ge.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var a = this._blockedFuncs.shift();
          try {
            xn(a[1], a[0]);
          } catch {
          }
        }
      return this;
    }, kt.prototype._locked = function() {
      return this._reculock && ge.lockOwnerFor !== this;
    }, kt.prototype.create = function(a) {
      var c = this;
      if (!this.mode)
        return this;
      var p = this.db.idbdb, E = this.db._state.dbOpenError;
      if (C(!this.idbtrans), !a && !p)
        switch (E && E.name) {
          case "DatabaseClosedError":
            throw new pe.DatabaseClosed(E);
          case "MissingAPIError":
            throw new pe.MissingAPI(E.message, E);
          default:
            throw new pe.OpenFailed(E);
        }
      if (!this.active)
        throw new pe.TransactionInactive();
      return C(this._completion._state === null), (a = this.idbtrans = a || (this.db.core || p).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = ze(function(I) {
        Ps(I), c._reject(a.error);
      }), a.onabort = ze(function(I) {
        Ps(I), c.active && c._reject(new pe.Abort(a.error)), c.active = false, c.on("abort").fire(I);
      }), a.oncomplete = ze(function() {
        c.active = false, c._resolve(), "mutatedParts" in a && un.storagemutated.fire(a.mutatedParts);
      }), this;
    }, kt.prototype._promise = function(a, c, p) {
      var E = this;
      if (a === "readwrite" && this.mode !== "readwrite")
        return Xe(new pe.ReadOnly("Transaction is readonly"));
      if (!this.active)
        return Xe(new pe.TransactionInactive());
      if (this._locked())
        return new ce(function(T, F) {
          E._blockedFuncs.push([function() {
            E._promise(a, c, p).then(T, F);
          }, ge]);
        });
      if (p)
        return an2(function() {
          var T = new ce(function(F, M) {
            E._lock();
            var _ = c(F, M, E);
            _ && _.then && _.then(F, M);
          });
          return T.finally(function() {
            return E._unlock();
          }), T._lib = true, T;
        });
      var I = new ce(function(T, F) {
        var M = c(T, F, E);
        M && M.then && M.then(T, F);
      });
      return I._lib = true, I;
    }, kt.prototype._root = function() {
      return this.parent ? this.parent._root() : this;
    }, kt.prototype.waitFor = function(a) {
      var c, p = this._root(), E = ce.resolve(a);
      p._waitingFor ? p._waitingFor = p._waitingFor.then(function() {
        return E;
      }) : (p._waitingFor = E, p._waitingQueue = [], c = p.idbtrans.objectStore(p.storeNames[0]), function T() {
        for (++p._spinCount; p._waitingQueue.length; )
          p._waitingQueue.shift()();
        p._waitingFor && (c.get(-1 / 0).onsuccess = T);
      }());
      var I = p._waitingFor;
      return new ce(function(T, F) {
        E.then(function(M) {
          return p._waitingQueue.push(ze(T.bind(null, M)));
        }, function(M) {
          return p._waitingQueue.push(ze(F.bind(null, M)));
        }).finally(function() {
          p._waitingFor === I && (p._waitingFor = null);
        });
      });
    }, kt.prototype.abort = function() {
      this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new pe.Abort()));
    }, kt.prototype.table = function(a) {
      var c = this._memoizedTables || (this._memoizedTables = {});
      if (m(c, a))
        return c[a];
      var p = this.schema[a];
      if (!p)
        throw new pe.NotFound("Table " + a + " not part of transaction");
      return p = new this.db.Table(a, p, this), p.core = this.db.core.table(a), c[a] = p;
    }, kt);
    function kt() {
    }
    function po(a, c, p, E, I, T, F) {
      return { name: a, keyPath: c, unique: p, multi: E, auto: I, compound: T, src: (p && !F ? "&" : "") + (E ? "*" : "") + (I ? "++" : "") + tl(c) };
    }
    function tl(a) {
      return typeof a == "string" ? a : a ? "[" + [].join.call(a, "+") + "]" : "";
    }
    function mo(a, c, p) {
      return { name: a, primKey: c, indexes: p, mappedClass: null, idxByName: (E = function(I) {
        return [I.name, I];
      }, p.reduce(function(I, T, F) {
        return F = E(T, F), F && (I[F[0]] = F[1]), I;
      }, {})) };
      var E;
    }
    var Os = function(a) {
      try {
        return a.only([[]]), Os = function() {
          return [[]];
        }, [[]];
      } catch {
        return Os = function() {
          return Sn;
        }, Sn;
      }
    };
    function go(a) {
      return a == null ? function() {
      } : typeof a == "string" ? (c = a).split(".").length === 1 ? function(p) {
        return p[c];
      } : function(p) {
        return B(p, c);
      } : function(p) {
        return B(p, a);
      };
      var c;
    }
    function nl(a) {
      return [].slice.call(a);
    }
    var zh = 0;
    function Ds(a) {
      return a == null ? ":id" : typeof a == "string" ? a : "[".concat(a.join("+"), "]");
    }
    function Vh(a, c, _) {
      function E(U) {
        if (U.type === 3)
          return null;
        if (U.type === 4)
          throw new Error("Cannot convert never type to IDBKeyRange");
        var N = U.lower, k = U.upper, G = U.lowerOpen, U = U.upperOpen;
        return N === void 0 ? k === void 0 ? null : c.upperBound(k, !!U) : k === void 0 ? c.lowerBound(N, !!G) : c.bound(N, k, !!G, !!U);
      }
      function I(V) {
        var N, k = V.name;
        return { name: k, schema: V, mutate: function(G) {
          var U = G.trans, W = G.type, j = G.keys, X = G.values, Q = G.range;
          return new Promise(function(ee, ae2) {
            ee = ze(ee);
            var ie = U.objectStore(k), oe = ie.keyPath == null, le = W === "put" || W === "add";
            if (!le && W !== "delete" && W !== "deleteRange")
              throw new Error("Invalid operation type: " + W);
            var re, Ce = (j || X || { length: 1 }).length;
            if (j && X && j.length !== X.length)
              throw new Error("Given keys array must have same length as given values array.");
            if (Ce === 0)
              return ee({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
            function Te(lt) {
              ++Ft, Ps(lt);
            }
            var Ae = [], xe = [], Ft = 0;
            if (W === "deleteRange") {
              if (Q.type === 4)
                return ee({ numFailures: Ft, failures: xe, results: [], lastResult: void 0 });
              Q.type === 3 ? Ae.push(re = ie.clear()) : Ae.push(re = ie.delete(E(Q)));
            } else {
              var oe = le ? oe ? [X, j] : [X, null] : [j, null], Se = oe[0], it = oe[1];
              if (le)
                for (var rt = 0; rt < Ce; ++rt)
                  Ae.push(re = it && it[rt] !== void 0 ? ie[W](Se[rt], it[rt]) : ie[W](Se[rt])), re.onerror = Te;
              else
                for (rt = 0; rt < Ce; ++rt)
                  Ae.push(re = ie[W](Se[rt])), re.onerror = Te;
            }
            function zi(lt) {
              lt = lt.target.result, Ae.forEach(function(Pn, No) {
                return Pn.error != null && (xe[No] = Pn.error);
              }), ee({ numFailures: Ft, failures: xe, results: W === "delete" ? j : Ae.map(function(Pn) {
                return Pn.result;
              }), lastResult: lt });
            }
            re.onerror = function(lt) {
              Te(lt), zi(lt);
            }, re.onsuccess = zi;
          });
        }, getMany: function(G) {
          var U = G.trans, W = G.keys;
          return new Promise(function(j, X) {
            j = ze(j);
            for (var Q, ee = U.objectStore(k), ae2 = W.length, ie = new Array(ae2), oe = 0, le = 0, re = function(Ae) {
              Ae = Ae.target, ie[Ae._pos] = Ae.result, ++le === oe && j(ie);
            }, Ce = Bt(X), Te = 0; Te < ae2; ++Te)
              W[Te] != null && ((Q = ee.get(W[Te]))._pos = Te, Q.onsuccess = re, Q.onerror = Ce, ++oe);
            oe === 0 && j(ie);
          });
        }, get: function(G) {
          var U = G.trans, W = G.key;
          return new Promise(function(j, X) {
            j = ze(j);
            var Q = U.objectStore(k).get(W);
            Q.onsuccess = function(ee) {
              return j(ee.target.result);
            }, Q.onerror = Bt(X);
          });
        }, query: (N = L, function(G) {
          return new Promise(function(U, W) {
            U = ze(U);
            var j, X, Q, oe = G.trans, ee = G.values, ae2 = G.limit, re = G.query, ie = ae2 === 1 / 0 ? void 0 : ae2, le = re.index, re = re.range, oe = oe.objectStore(k), le = le.isPrimaryKey ? oe : oe.index(le.name), re = E(re);
            if (ae2 === 0)
              return U({ result: [] });
            N ? ((ie = ee ? le.getAll(re, ie) : le.getAllKeys(re, ie)).onsuccess = function(Ce) {
              return U({ result: Ce.target.result });
            }, ie.onerror = Bt(W)) : (j = 0, X = !ee && "openKeyCursor" in le ? le.openKeyCursor(re) : le.openCursor(re), Q = [], X.onsuccess = function(Ce) {
              var Te = X.result;
              return Te ? (Q.push(ee ? Te.value : Te.primaryKey), ++j === ae2 ? U({ result: Q }) : void Te.continue()) : U({ result: Q });
            }, X.onerror = Bt(W));
          });
        }), openCursor: function(G) {
          var U = G.trans, W = G.values, j = G.query, X = G.reverse, Q = G.unique;
          return new Promise(function(ee, ae2) {
            ee = ze(ee);
            var le = j.index, ie = j.range, oe = U.objectStore(k), oe = le.isPrimaryKey ? oe : oe.index(le.name), le = X ? Q ? "prevunique" : "prev" : Q ? "nextunique" : "next", re = !W && "openKeyCursor" in oe ? oe.openKeyCursor(E(ie), le) : oe.openCursor(E(ie), le);
            re.onerror = Bt(ae2), re.onsuccess = ze(function(Ce) {
              var Te, Ae, xe, Ft, Se = re.result;
              Se ? (Se.___id = ++zh, Se.done = false, Te = Se.continue.bind(Se), Ae = (Ae = Se.continuePrimaryKey) && Ae.bind(Se), xe = Se.advance.bind(Se), Ft = function() {
                throw new Error("Cursor not stopped");
              }, Se.trans = U, Se.stop = Se.continue = Se.continuePrimaryKey = Se.advance = function() {
                throw new Error("Cursor not started");
              }, Se.fail = ze(ae2), Se.next = function() {
                var it = this, rt = 1;
                return this.start(function() {
                  return rt-- ? it.continue() : it.stop();
                }).then(function() {
                  return it;
                });
              }, Se.start = function(it) {
                function rt() {
                  if (re.result)
                    try {
                      it();
                    } catch (lt) {
                      Se.fail(lt);
                    }
                  else
                    Se.done = true, Se.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, Se.stop();
                }
                var zi = new Promise(function(lt, Pn) {
                  lt = ze(lt), re.onerror = Bt(Pn), Se.fail = Pn, Se.stop = function(No) {
                    Se.stop = Se.continue = Se.continuePrimaryKey = Se.advance = Ft, lt(No);
                  };
                });
                return re.onsuccess = ze(function(lt) {
                  re.onsuccess = rt, rt();
                }), Se.continue = Te, Se.continuePrimaryKey = Ae, Se.advance = xe, rt(), zi;
              }, ee(Se)) : ee(null);
            }, ae2);
          });
        }, count: function(G) {
          var U = G.query, W = G.trans, j = U.index, X = U.range;
          return new Promise(function(Q, ee) {
            var ae2 = W.objectStore(k), ie = j.isPrimaryKey ? ae2 : ae2.index(j.name), ae2 = E(X), ie = ae2 ? ie.count(ae2) : ie.count();
            ie.onsuccess = ze(function(oe) {
              return Q(oe.target.result);
            }), ie.onerror = Bt(ee);
          });
        } };
      }
      var T, F, M, z = (F = _, M = nl((T = a).objectStoreNames), { schema: { name: T.name, tables: M.map(function(V) {
        return F.objectStore(V);
      }).map(function(V) {
        var N = V.keyPath, U = V.autoIncrement, k = o(N), G = {}, U = { name: V.name, primaryKey: { name: null, isPrimaryKey: true, outbound: N == null, compound: k, keyPath: N, autoIncrement: U, unique: true, extractKey: go(N) }, indexes: nl(V.indexNames).map(function(W) {
          return V.index(W);
        }).map(function(Q) {
          var j = Q.name, X = Q.unique, ee = Q.multiEntry, Q = Q.keyPath, ee = { name: j, compound: o(Q), keyPath: Q, unique: X, multiEntry: ee, extractKey: go(Q) };
          return G[Ds(Q)] = ee;
        }), getIndexByKeyPath: function(W) {
          return G[Ds(W)];
        } };
        return G[":id"] = U.primaryKey, N != null && (G[Ds(N)] = U.primaryKey), U;
      }) }, hasGetAll: 0 < M.length && "getAll" in F.objectStore(M[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), _ = z.schema, L = z.hasGetAll, z = _.tables.map(I), D = {};
      return z.forEach(function(V) {
        return D[V.name] = V;
      }), { stack: "dbcore", transaction: a.transaction.bind(a), table: function(V) {
        if (!D[V])
          throw new Error("Table '".concat(V, "' not found"));
        return D[V];
      }, MIN_KEY: -1 / 0, MAX_KEY: Os(c), schema: _ };
    }
    function Gh(a, c, p, E) {
      var I = p.IDBKeyRange;
      return p.indexedDB, { dbcore: (E = Vh(c, I, E), a.dbcore.reduce(function(T, F) {
        return F = F.create, n(n({}, T), F(T));
      }, E)) };
    }
    function Fi(a, E) {
      var p = E.db, E = Gh(a._middlewares, p, a._deps, E);
      a.core = E.dbcore, a.tables.forEach(function(I) {
        var T = I.name;
        a.core.schema.tables.some(function(F) {
          return F.name === T;
        }) && (I.core = a.core.table(T), a[T] instanceof a.Table && (a[T].core = I.core));
      });
    }
    function Ri(a, c, p, E) {
      p.forEach(function(I) {
        var T = E[I];
        c.forEach(function(F) {
          var M = function _(L, z) {
            return x(L, z) || (L = u(L)) && _(L, z);
          }(F, I);
          (!M || "value" in M && M.value === void 0) && (F === a.Transaction.prototype || F instanceof a.Transaction ? v(F, I, { get: function() {
            return this.table(I);
          }, set: function(_) {
            g(this, I, { value: _, writable: true, configurable: true, enumerable: true });
          } }) : F[I] = new a.Table(I, T));
        });
      });
    }
    function Eo(a, c) {
      c.forEach(function(p) {
        for (var E in p)
          p[E] instanceof a.Table && delete p[E];
      });
    }
    function Yh(a, c) {
      return a._cfg.version - c._cfg.version;
    }
    function Hh(a, c, p, E) {
      var I = a._dbSchema;
      p.objectStoreNames.contains("$meta") && !I.$meta && (I.$meta = mo("$meta", il("")[0], []), a._storeNames.push("$meta"));
      var T = a._createTransaction("readwrite", a._storeNames, I);
      T.create(p), T._completion.catch(E);
      var F = T._reject.bind(T), M = ge.transless || ge;
      an2(function() {
        return ge.trans = T, ge.transless = M, c !== 0 ? (Fi(a, p), L = c, ((_ = T).storeNames.includes("$meta") ? _.table("$meta").get("version").then(function(z) {
          return z ?? L;
        }) : ce.resolve(L)).then(function(z) {
          return V = z, N = T, k = p, G = [], z = (D = a)._versions, U = D._dbSchema = Mi(0, D.idbdb, k), (z = z.filter(function(W) {
            return W._cfg.version >= V;
          })).length !== 0 ? (z.forEach(function(W) {
            G.push(function() {
              var j = U, X = W._cfg.dbschema;
              Oi(D, j, k), Oi(D, X, k), U = D._dbSchema = X;
              var Q = vo(j, X);
              Q.add.forEach(function(le) {
                Io(k, le[0], le[1].primKey, le[1].indexes);
              }), Q.change.forEach(function(le) {
                if (le.recreate)
                  throw new pe.Upgrade("Not yet support for changing primary key");
                var re = k.objectStore(le.name);
                le.add.forEach(function(Ce) {
                  return Pi(re, Ce);
                }), le.change.forEach(function(Ce) {
                  re.deleteIndex(Ce.name), Pi(re, Ce);
                }), le.del.forEach(function(Ce) {
                  return re.deleteIndex(Ce);
                });
              });
              var ee = W._cfg.contentUpgrade;
              if (ee && W._cfg.version > V) {
                Fi(D, k), N._memoizedTables = {};
                var ae2 = H(X);
                Q.del.forEach(function(le) {
                  ae2[le] = j[le];
                }), Eo(D, [D.Transaction.prototype]), Ri(D, [D.Transaction.prototype], r(ae2), ae2), N.schema = ae2;
                var ie, oe = Ke(ee);
                return oe && Yn(), Q = ce.follow(function() {
                  var le;
                  (ie = ee(N)) && oe && (le = ln.bind(null, null), ie.then(le, le));
                }), ie && typeof ie.then == "function" ? ce.resolve(ie) : Q.then(function() {
                  return ie;
                });
              }
            }), G.push(function(j) {
              var X, Q, ee = W._cfg.dbschema;
              X = ee, Q = j, [].slice.call(Q.db.objectStoreNames).forEach(function(ae2) {
                return X[ae2] == null && Q.db.deleteObjectStore(ae2);
              }), Eo(D, [D.Transaction.prototype]), Ri(D, [D.Transaction.prototype], D._storeNames, D._dbSchema), N.schema = D._dbSchema;
            }), G.push(function(j) {
              D.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(D.idbdb.version / 10) === W._cfg.version ? (D.idbdb.deleteObjectStore("$meta"), delete D._dbSchema.$meta, D._storeNames = D._storeNames.filter(function(X) {
                return X !== "$meta";
              })) : j.objectStore("$meta").put(W._cfg.version, "version"));
            });
          }), function W() {
            return G.length ? ce.resolve(G.shift()(N.idbtrans)).then(W) : ce.resolve();
          }().then(function() {
            sl(U, k);
          })) : ce.resolve();
          var D, V, N, k, G, U;
        }).catch(F)) : (r(I).forEach(function(z) {
          Io(p, z, I[z].primKey, I[z].indexes);
        }), Fi(a, p), void ce.follow(function() {
          return a.on.populate.fire(T);
        }).catch(F));
        var _, L;
      });
    }
    function Wh(a, c) {
      sl(a._dbSchema, c), c.db.version % 10 != 0 || c.objectStoreNames.contains("$meta") || c.db.createObjectStore("$meta").add(Math.ceil(c.db.version / 10 - 1), "version");
      var p = Mi(0, a.idbdb, c);
      Oi(a, a._dbSchema, c);
      for (var E = 0, I = vo(p, a._dbSchema).change; E < I.length; E++) {
        var T = function(F) {
          if (F.change.length || F.recreate)
            return console.warn("Unable to patch indexes of table ".concat(F.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
          var M = c.objectStore(F.name);
          F.add.forEach(function(_) {
            Ut && console.debug("Dexie upgrade patch: Creating missing index ".concat(F.name, ".").concat(_.src)), Pi(M, _);
          });
        }(I[E]);
        if (typeof T == "object")
          return T.value;
      }
    }
    function vo(a, c) {
      var p, E = { del: [], add: [], change: [] };
      for (p in a)
        c[p] || E.del.push(p);
      for (p in c) {
        var I = a[p], T = c[p];
        if (I) {
          var F = { name: p, def: T, recreate: false, del: [], add: [], change: [] };
          if ("" + (I.primKey.keyPath || "") != "" + (T.primKey.keyPath || "") || I.primKey.auto !== T.primKey.auto)
            F.recreate = true, E.change.push(F);
          else {
            var M = I.idxByName, _ = T.idxByName, L = void 0;
            for (L in M)
              _[L] || F.del.push(L);
            for (L in _) {
              var z = M[L], D = _[L];
              z ? z.src !== D.src && F.change.push(D) : F.add.push(D);
            }
            (0 < F.del.length || 0 < F.add.length || 0 < F.change.length) && E.change.push(F);
          }
        } else
          E.add.push([p, T]);
      }
      return E;
    }
    function Io(a, c, p, E) {
      var I = a.db.createObjectStore(c, p.keyPath ? { keyPath: p.keyPath, autoIncrement: p.auto } : { autoIncrement: p.auto });
      return E.forEach(function(T) {
        return Pi(I, T);
      }), I;
    }
    function sl(a, c) {
      r(a).forEach(function(p) {
        c.db.objectStoreNames.contains(p) || (Ut && console.debug("Dexie: Creating missing table", p), Io(c, p, a[p].primKey, a[p].indexes));
      });
    }
    function Pi(a, c) {
      a.createIndex(c.name, c.keyPath, { unique: c.unique, multiEntry: c.multi });
    }
    function Mi(a, c, p) {
      var E = {};
      return R(c.objectStoreNames, 0).forEach(function(I) {
        for (var T = p.objectStore(I), F = po(tl(L = T.keyPath), L || "", true, false, !!T.autoIncrement, L && typeof L != "string", true), M = [], _ = 0; _ < T.indexNames.length; ++_) {
          var z = T.index(T.indexNames[_]), L = z.keyPath, z = po(z.name, L, !!z.unique, !!z.multiEntry, false, L && typeof L != "string", false);
          M.push(z);
        }
        E[I] = mo(I, F, M);
      }), E;
    }
    function Oi(a, c, p) {
      for (var E = p.db.objectStoreNames, I = 0; I < E.length; ++I) {
        var T = E[I], F = p.objectStore(T);
        a._hasGetAll = "getAll" in F;
        for (var M = 0; M < F.indexNames.length; ++M) {
          var _ = F.indexNames[M], L = F.index(_).keyPath, z = typeof L == "string" ? L : "[" + R(L).join("+") + "]";
          !c[T] || (L = c[T].idxByName[z]) && (L.name = _, delete c[T].idxByName[z], c[T].idxByName[_] = L);
        }
      }
      typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && i.WorkerGlobalScope && i instanceof i.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (a._hasGetAll = false);
    }
    function il(a) {
      return a.split(",").map(function(c, p) {
        var E = (c = c.trim()).replace(/([&*]|\+\+)/g, ""), I = /^\[/.test(E) ? E.match(/^\[(.*)\]$/)[1].split("+") : E;
        return po(E, I || null, /\&/.test(c), /\*/.test(c), /\+\+/.test(c), o(I), p === 0);
      });
    }
    var Kh = (Di.prototype._parseStoresSpec = function(a, c) {
      r(a).forEach(function(p) {
        if (a[p] !== null) {
          var E = il(a[p]), I = E.shift();
          if (I.unique = true, I.multi)
            throw new pe.Schema("Primary key cannot be multi-valued");
          E.forEach(function(T) {
            if (T.auto)
              throw new pe.Schema("Only primary key can be marked as autoIncrement (++)");
            if (!T.keyPath)
              throw new pe.Schema("Index must have a name and cannot be an empty string");
          }), c[p] = mo(p, I, E);
        }
      });
    }, Di.prototype.stores = function(p) {
      var c = this.db;
      this._cfg.storesSource = this._cfg.storesSource ? l(this._cfg.storesSource, p) : p;
      var p = c._versions, E = {}, I = {};
      return p.forEach(function(T) {
        l(E, T._cfg.storesSource), I = T._cfg.dbschema = {}, T._parseStoresSpec(E, I);
      }), c._dbSchema = I, Eo(c, [c._allTables, c, c.Transaction.prototype]), Ri(c, [c._allTables, c, c.Transaction.prototype, this._cfg.tables], r(I), I), c._storeNames = r(I), this;
    }, Di.prototype.upgrade = function(a) {
      return this._cfg.contentUpgrade = Jr(this._cfg.contentUpgrade || Oe, a), this;
    }, Di);
    function Di() {
    }
    function yo(a, c) {
      var p = a._dbNamesDB;
      return p || (p = a._dbNamesDB = new $t(Ti, { addons: [], indexedDB: a, IDBKeyRange: c })).version(1).stores({ dbnames: "name" }), p.table("dbnames");
    }
    function wo(a) {
      return a && typeof a.databases == "function";
    }
    function Co(a) {
      return an2(function() {
        return ge.letThrough = true, a();
      });
    }
    function To(a) {
      return !("from" in a);
    }
    var st = function(a, c) {
      if (!this) {
        var p = new st();
        return a && "d" in a && l(p, a), p;
      }
      l(this, arguments.length ? { d: 1, from: a, to: 1 < arguments.length ? c : a } : { d: 0 });
    };
    function Ls(a, c, p) {
      var E = Me(c, p);
      if (!isNaN(E)) {
        if (0 < E)
          throw RangeError();
        if (To(a))
          return l(a, { from: c, to: p, d: 1 });
        var I = a.l, E = a.r;
        if (Me(p, a.from) < 0)
          return I ? Ls(I, c, p) : a.l = { from: c, to: p, d: 1, l: null, r: null }, rl(a);
        if (0 < Me(c, a.to))
          return E ? Ls(E, c, p) : a.r = { from: c, to: p, d: 1, l: null, r: null }, rl(a);
        Me(c, a.from) < 0 && (a.from = c, a.l = null, a.d = E ? E.d + 1 : 1), 0 < Me(p, a.to) && (a.to = p, a.r = null, a.d = a.l ? a.l.d + 1 : 1), p = !a.r, I && !a.l && Ns(a, I), E && p && Ns(a, E);
      }
    }
    function Ns(a, c) {
      To(c) || function p(E, _) {
        var T = _.from, F = _.to, M = _.l, _ = _.r;
        Ls(E, T, F), M && p(E, M), _ && p(E, _);
      }(a, c);
    }
    function Li(a, c) {
      var p = bo(c), E = p.next();
      if (E.done)
        return false;
      for (var I = E.value, T = bo(a), F = T.next(I.from), M = F.value; !E.done && !F.done; ) {
        if (Me(M.from, I.to) <= 0 && 0 <= Me(M.to, I.from))
          return true;
        Me(I.from, M.from) < 0 ? I = (E = p.next(M.from)).value : M = (F = T.next(I.from)).value;
      }
      return false;
    }
    function bo(a) {
      var c = To(a) ? null : { s: 0, n: a };
      return { next: function(p) {
        for (var E = 0 < arguments.length; c; )
          switch (c.s) {
            case 0:
              if (c.s = 1, E)
                for (; c.n.l && Me(p, c.n.from) < 0; )
                  c = { up: c, n: c.n.l, s: 1 };
              else
                for (; c.n.l; )
                  c = { up: c, n: c.n.l, s: 1 };
            case 1:
              if (c.s = 2, !E || Me(p, c.n.to) <= 0)
                return { value: c.n, done: false };
            case 2:
              if (c.n.r) {
                c.s = 3, c = { up: c, n: c.n.r, s: 0 };
                continue;
              }
            case 3:
              c = c.up;
          }
        return { done: true };
      } };
    }
    function rl(a) {
      var c, p, E = (((c = a.r) === null || c === void 0 ? void 0 : c.d) || 0) - (((p = a.l) === null || p === void 0 ? void 0 : p.d) || 0), I = 1 < E ? "r" : E < -1 ? "l" : "";
      I && (c = I == "r" ? "l" : "r", p = n({}, a), E = a[I], a.from = E.from, a.to = E.to, a[I] = E[I], p[I] = E[c], (a[c] = p).d = ol(p)), a.d = ol(a);
    }
    function ol(p) {
      var c = p.r, p = p.l;
      return (c ? p ? Math.max(c.d, p.d) : c.d : p ? p.d : 0) + 1;
    }
    function Ni(a, c) {
      return r(c).forEach(function(p) {
        a[p] ? Ns(a[p], c[p]) : a[p] = function E(I) {
          var T, F, M = {};
          for (T in I)
            m(I, T) && (F = I[T], M[T] = !F || typeof F != "object" || q.has(F.constructor) ? F : E(F));
          return M;
        }(c[p]);
      }), a;
    }
    function xo(a, c) {
      return a.all || c.all || Object.keys(a).some(function(p) {
        return c[p] && Li(c[p], a[p]);
      });
    }
    f(st.prototype, ((It = { add: function(a) {
      return Ns(this, a), this;
    }, addKey: function(a) {
      return Ls(this, a, a), this;
    }, addKeys: function(a) {
      var c = this;
      return a.forEach(function(p) {
        return Ls(c, p, p);
      }), this;
    } })[Ie] = function() {
      return bo(this);
    }, It));
    var Fn = {}, So = {}, Ao = false;
    function _i(a) {
      Ni(So, a), Ao || (Ao = true, setTimeout(function() {
        Ao = false, Fo(So, !(So = {}));
      }, 0));
    }
    function Fo(a, c) {
      c === void 0 && (c = false);
      var p = /* @__PURE__ */ new Set();
      if (a.all)
        for (var E = 0, I = Object.values(Fn); E < I.length; E++)
          al(F = I[E], a, p, c);
      else
        for (var T in a) {
          var F, M = /^idb\:\/\/(.*)\/(.*)\//.exec(T);
          M && (T = M[1], M = M[2], (F = Fn["idb://".concat(T, "/").concat(M)]) && al(F, a, p, c));
        }
      p.forEach(function(_) {
        return _();
      });
    }
    function al(a, c, p, E) {
      for (var I = [], T = 0, F = Object.entries(a.queries.query); T < F.length; T++) {
        for (var M = F[T], _ = M[0], L = [], z = 0, D = M[1]; z < D.length; z++) {
          var V = D[z];
          xo(c, V.obsSet) ? V.subscribers.forEach(function(U) {
            return p.add(U);
          }) : E && L.push(V);
        }
        E && I.push([_, L]);
      }
      if (E)
        for (var N = 0, k = I; N < k.length; N++) {
          var G = k[N], _ = G[0], L = G[1];
          a.queries.query[_] = L;
        }
    }
    function jh(a) {
      var c = a._state, p = a._deps.indexedDB;
      if (c.isBeingOpened || a.idbdb)
        return c.dbReadyPromise.then(function() {
          return c.dbOpenError ? Xe(c.dbOpenError) : a;
        });
      c.isBeingOpened = true, c.dbOpenError = null, c.openComplete = false;
      var E = c.openCanceller, I = Math.round(10 * a.verno), T = false;
      function F() {
        if (c.openCanceller !== E)
          throw new pe.DatabaseClosed("db.open() was cancelled");
      }
      function M() {
        return new ce(function(V, N) {
          if (F(), !p)
            throw new pe.MissingAPI();
          var k = a.name, G = c.autoSchema || !I ? p.open(k) : p.open(k, I);
          if (!G)
            throw new pe.MissingAPI();
          G.onerror = Bt(N), G.onblocked = ze(a._fireOnBlocked), G.onupgradeneeded = ze(function(U) {
            var W;
            z = G.transaction, c.autoSchema && !a._options.allowEmptyDB ? (G.onerror = Ps, z.abort(), G.result.close(), (W = p.deleteDatabase(k)).onsuccess = W.onerror = ze(function() {
              N(new pe.NoSuchDatabase("Database ".concat(k, " doesnt exist")));
            })) : (z.onerror = Bt(N), U = U.oldVersion > Math.pow(2, 62) ? 0 : U.oldVersion, D = U < 1, a.idbdb = G.result, T && Wh(a, z), Hh(a, U / 10, z, N));
          }, N), G.onsuccess = ze(function() {
            z = null;
            var U, W, j, X, Q, ee = a.idbdb = G.result, ae2 = R(ee.objectStoreNames);
            if (0 < ae2.length)
              try {
                var ie = ee.transaction((X = ae2).length === 1 ? X[0] : X, "readonly");
                if (c.autoSchema)
                  W = ee, j = ie, (U = a).verno = W.version / 10, j = U._dbSchema = Mi(0, W, j), U._storeNames = R(W.objectStoreNames, 0), Ri(U, [U._allTables], r(j), j);
                else if (Oi(a, a._dbSchema, ie), ((Q = vo(Mi(0, (Q = a).idbdb, ie), Q._dbSchema)).add.length || Q.change.some(function(oe) {
                  return oe.add.length || oe.change.length;
                })) && !T)
                  return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), ee.close(), I = ee.version + 1, T = true, V(M());
                Fi(a, ie);
              } catch {
              }
            Hn.push(a), ee.onversionchange = ze(function(oe) {
              c.vcFired = true, a.on("versionchange").fire(oe);
            }), ee.onclose = ze(function(oe) {
              a.on("close").fire(oe);
            }), D && (Q = a._deps, ie = k, ee = Q.indexedDB, Q = Q.IDBKeyRange, wo(ee) || ie === Ti || yo(ee, Q).put({ name: ie }).catch(Oe)), V();
          }, N);
        }).catch(function(V) {
          switch (V == null ? void 0 : V.name) {
            case "UnknownError":
              if (0 < c.PR1398_maxLoop)
                return c.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), M();
              break;
            case "VersionError":
              if (0 < I)
                return I = 0, M();
          }
          return ce.reject(V);
        });
      }
      var _, L = c.dbReadyResolve, z = null, D = false;
      return ce.race([E, (typeof navigator > "u" ? ce.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(V) {
        function N() {
          return indexedDB.databases().finally(V);
        }
        _ = setInterval(N, 100), N();
      }).finally(function() {
        return clearInterval(_);
      }) : Promise.resolve()).then(M)]).then(function() {
        return F(), c.onReadyBeingFired = [], ce.resolve(Co(function() {
          return a.on.ready.fire(a.vip);
        })).then(function V() {
          if (0 < c.onReadyBeingFired.length) {
            var N = c.onReadyBeingFired.reduce(Jr, Oe);
            return c.onReadyBeingFired = [], ce.resolve(Co(function() {
              return N(a.vip);
            })).then(V);
          }
        });
      }).finally(function() {
        c.openCanceller === E && (c.onReadyBeingFired = null, c.isBeingOpened = false);
      }).catch(function(V) {
        c.dbOpenError = V;
        try {
          z && z.abort();
        } catch {
        }
        return E === c.openCanceller && a._close(), Xe(V);
      }).finally(function() {
        c.openComplete = true, L();
      }).then(function() {
        var V;
        return D && (V = {}, a.tables.forEach(function(N) {
          N.schema.indexes.forEach(function(k) {
            k.name && (V["idb://".concat(a.name, "/").concat(N.name, "/").concat(k.name)] = new st(-1 / 0, [[[]]]));
          }), V["idb://".concat(a.name, "/").concat(N.name, "/")] = V["idb://".concat(a.name, "/").concat(N.name, "/:dels")] = new st(-1 / 0, [[[]]]);
        }), un(Ms).fire(V), Fo(V, true)), a;
      });
    }
    function Ro(a) {
      function c(T) {
        return a.next(T);
      }
      var p = I(c), E = I(function(T) {
        return a.throw(T);
      });
      function I(T) {
        return function(_) {
          var M = T(_), _ = M.value;
          return M.done ? _ : _ && typeof _.then == "function" ? _.then(p, E) : o(_) ? Promise.all(_).then(p, E) : p(_);
        };
      }
      return I(c)();
    }
    function Ui(a, c, p) {
      for (var E = o(a) ? a.slice() : [a], I = 0; I < p; ++I)
        E.push(c);
      return E;
    }
    var Xh = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(a) {
      return n(n({}, a), { table: function(c) {
        var p = a.table(c), E = p.schema, I = {}, T = [];
        function F(D, V, N) {
          var k = Ds(D), G = I[k] = I[k] || [], U = D == null ? 0 : typeof D == "string" ? 1 : D.length, W = 0 < V, W = n(n({}, N), { name: W ? "".concat(k, "(virtual-from:").concat(N.name, ")") : N.name, lowLevelIndex: N, isVirtual: W, keyTail: V, keyLength: U, extractKey: go(D), unique: !W && N.unique });
          return G.push(W), W.isPrimaryKey || T.push(W), 1 < U && F(U === 2 ? D[0] : D.slice(0, U - 1), V + 1, N), G.sort(function(j, X) {
            return j.keyTail - X.keyTail;
          }), W;
        }
        c = F(E.primaryKey.keyPath, 0, E.primaryKey), I[":id"] = [c];
        for (var M = 0, _ = E.indexes; M < _.length; M++) {
          var L = _[M];
          F(L.keyPath, 0, L);
        }
        function z(D) {
          var V, N = D.query.index;
          return N.isVirtual ? n(n({}, D), { query: { index: N.lowLevelIndex, range: (V = D.query.range, N = N.keyTail, { type: V.type === 1 ? 2 : V.type, lower: Ui(V.lower, V.lowerOpen ? a.MAX_KEY : a.MIN_KEY, N), lowerOpen: true, upper: Ui(V.upper, V.upperOpen ? a.MIN_KEY : a.MAX_KEY, N), upperOpen: true }) } }) : D;
        }
        return n(n({}, p), { schema: n(n({}, E), { primaryKey: c, indexes: T, getIndexByKeyPath: function(D) {
          return (D = I[Ds(D)]) && D[0];
        } }), count: function(D) {
          return p.count(z(D));
        }, query: function(D) {
          return p.query(z(D));
        }, openCursor: function(D) {
          var V = D.query.index, N = V.keyTail, k = V.isVirtual, G = V.keyLength;
          return k ? p.openCursor(z(D)).then(function(W) {
            return W && U(W);
          }) : p.openCursor(D);
          function U(W) {
            return Object.create(W, { continue: { value: function(j) {
              j != null ? W.continue(Ui(j, D.reverse ? a.MAX_KEY : a.MIN_KEY, N)) : D.unique ? W.continue(W.key.slice(0, G).concat(D.reverse ? a.MIN_KEY : a.MAX_KEY, N)) : W.continue();
            } }, continuePrimaryKey: { value: function(j, X) {
              W.continuePrimaryKey(Ui(j, a.MAX_KEY, N), X);
            } }, primaryKey: { get: function() {
              return W.primaryKey;
            } }, key: { get: function() {
              var j = W.key;
              return G === 1 ? j[0] : j.slice(0, G);
            } }, value: { get: function() {
              return W.value;
            } } });
          }
        } });
      } });
    } };
    function Po(a, c, p, E) {
      return p = p || {}, E = E || "", r(a).forEach(function(I) {
        var T, F, M;
        m(c, I) ? (T = a[I], F = c[I], typeof T == "object" && typeof F == "object" && T && F ? (M = me(T)) !== me(F) ? p[E + I] = c[I] : M === "Object" ? Po(T, F, p, E + I + ".") : T !== F && (p[E + I] = c[I]) : T !== F && (p[E + I] = c[I])) : p[E + I] = void 0;
      }), r(c).forEach(function(I) {
        m(a, I) || (p[E + I] = c[I]);
      }), p;
    }
    function Mo(a, c) {
      return c.type === "delete" ? c.keys : c.keys || c.values.map(a.extractKey);
    }
    var Zh = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(a) {
      return n(n({}, a), { table: function(c) {
        var p = a.table(c), E = p.schema.primaryKey;
        return n(n({}, p), { mutate: function(I) {
          var T = ge.trans, F = T.table(c).hook, M = F.deleting, _ = F.creating, L = F.updating;
          switch (I.type) {
            case "add":
              if (_.fire === Oe)
                break;
              return T._promise("readwrite", function() {
                return z(I);
              }, true);
            case "put":
              if (_.fire === Oe && L.fire === Oe)
                break;
              return T._promise("readwrite", function() {
                return z(I);
              }, true);
            case "delete":
              if (M.fire === Oe)
                break;
              return T._promise("readwrite", function() {
                return z(I);
              }, true);
            case "deleteRange":
              if (M.fire === Oe)
                break;
              return T._promise("readwrite", function() {
                return function D(V, N, k) {
                  return p.query({ trans: V, values: false, query: { index: E, range: N }, limit: k }).then(function(G) {
                    var U = G.result;
                    return z({ type: "delete", keys: U, trans: V }).then(function(W) {
                      return 0 < W.numFailures ? Promise.reject(W.failures[0]) : U.length < k ? { failures: [], numFailures: 0, lastResult: void 0 } : D(V, n(n({}, N), { lower: U[U.length - 1], lowerOpen: true }), k);
                    });
                  });
                }(I.trans, I.range, 1e4);
              }, true);
          }
          return p.mutate(I);
          function z(D) {
            var V, N, k, G = ge.trans, U = D.keys || Mo(E, D);
            if (!U)
              throw new Error("Keys missing");
            return (D = D.type === "add" || D.type === "put" ? n(n({}, D), { keys: U }) : n({}, D)).type !== "delete" && (D.values = s([], D.values)), D.keys && (D.keys = s([], D.keys)), V = p, k = U, ((N = D).type === "add" ? Promise.resolve([]) : V.getMany({ trans: N.trans, keys: k, cache: "immutable" })).then(function(W) {
              var j = U.map(function(X, Q) {
                var ee, ae2, ie, oe = W[Q], le = { onerror: null, onsuccess: null };
                return D.type === "delete" ? M.fire.call(le, X, oe, G) : D.type === "add" || oe === void 0 ? (ee = _.fire.call(le, X, D.values[Q], G), X == null && ee != null && (D.keys[Q] = X = ee, E.outbound || Y(D.values[Q], E.keyPath, X))) : (ee = Po(oe, D.values[Q]), (ae2 = L.fire.call(le, ee, X, oe, G)) && (ie = D.values[Q], Object.keys(ae2).forEach(function(re) {
                  m(ie, re) ? ie[re] = ae2[re] : Y(ie, re, ae2[re]);
                }))), le;
              });
              return p.mutate(D).then(function(X) {
                for (var Q = X.failures, ee = X.results, ae2 = X.numFailures, X = X.lastResult, ie = 0; ie < U.length; ++ie) {
                  var oe = (ee || U)[ie], le = j[ie];
                  oe == null ? le.onerror && le.onerror(Q[ie]) : le.onsuccess && le.onsuccess(D.type === "put" && W[ie] ? D.values[ie] : oe);
                }
                return { failures: Q, results: ee, numFailures: ae2, lastResult: X };
              }).catch(function(X) {
                return j.forEach(function(Q) {
                  return Q.onerror && Q.onerror(X);
                }), Promise.reject(X);
              });
            });
          }
        } });
      } });
    } };
    function ll(a, c, p) {
      try {
        if (!c || c.keys.length < a.length)
          return null;
        for (var E = [], I = 0, T = 0; I < c.keys.length && T < a.length; ++I)
          Me(c.keys[I], a[T]) === 0 && (E.push(p ? se(c.values[I]) : c.values[I]), ++T);
        return E.length === a.length ? E : null;
      } catch {
        return null;
      }
    }
    var Qh = { stack: "dbcore", level: -1, create: function(a) {
      return { table: function(c) {
        var p = a.table(c);
        return n(n({}, p), { getMany: function(E) {
          if (!E.cache)
            return p.getMany(E);
          var I = ll(E.keys, E.trans._cache, E.cache === "clone");
          return I ? ce.resolve(I) : p.getMany(E).then(function(T) {
            return E.trans._cache = { keys: E.keys, values: E.cache === "clone" ? se(T) : T }, T;
          });
        }, mutate: function(E) {
          return E.type !== "add" && (E.trans._cache = null), p.mutate(E);
        } });
      } };
    } };
    function cl(a, c) {
      return a.trans.mode === "readonly" && !!a.subscr && !a.trans.explicit && a.trans.db._options.cache !== "disabled" && !c.schema.primaryKey.outbound;
    }
    function hl(a, c) {
      switch (a) {
        case "query":
          return c.values && !c.unique;
        case "get":
        case "getMany":
        case "count":
        case "openCursor":
          return false;
      }
    }
    var qh = { stack: "dbcore", level: 0, name: "Observability", create: function(a) {
      var c = a.schema.name, p = new st(a.MIN_KEY, a.MAX_KEY);
      return n(n({}, a), { transaction: function(E, I, T) {
        if (ge.subscr && I !== "readonly")
          throw new pe.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ge.querier));
        return a.transaction(E, I, T);
      }, table: function(E) {
        var I = a.table(E), T = I.schema, F = T.primaryKey, D = T.indexes, M = F.extractKey, _ = F.outbound, L = F.autoIncrement && D.filter(function(N) {
          return N.compound && N.keyPath.includes(F.keyPath);
        }), z = n(n({}, I), { mutate: function(N) {
          function k(re) {
            return re = "idb://".concat(c, "/").concat(E, "/").concat(re), X[re] || (X[re] = new st());
          }
          var G, U, W, j = N.trans, X = N.mutatedParts || (N.mutatedParts = {}), Q = k(""), ee = k(":dels"), ae2 = N.type, le = N.type === "deleteRange" ? [N.range] : N.type === "delete" ? [N.keys] : N.values.length < 50 ? [Mo(F, N).filter(function(re) {
            return re;
          }), N.values] : [], ie = le[0], oe = le[1], le = N.trans._cache;
          return o(ie) ? (Q.addKeys(ie), (le = ae2 === "delete" || ie.length === oe.length ? ll(ie, le) : null) || ee.addKeys(ie), (le || oe) && (G = k, U = le, W = oe, T.indexes.forEach(function(re) {
            var Ce = G(re.name || "");
            function Te(xe) {
              return xe != null ? re.extractKey(xe) : null;
            }
            function Ae(xe) {
              return re.multiEntry && o(xe) ? xe.forEach(function(Ft) {
                return Ce.addKey(Ft);
              }) : Ce.addKey(xe);
            }
            (U || W).forEach(function(xe, it) {
              var Se = U && Te(U[it]), it = W && Te(W[it]);
              Me(Se, it) !== 0 && (Se != null && Ae(Se), it != null && Ae(it));
            });
          }))) : ie ? (oe = { from: ie.lower, to: ie.upper }, ee.add(oe), Q.add(oe)) : (Q.add(p), ee.add(p), T.indexes.forEach(function(re) {
            return k(re.name).add(p);
          })), I.mutate(N).then(function(re) {
            return !ie || N.type !== "add" && N.type !== "put" || (Q.addKeys(re.results), L && L.forEach(function(Ce) {
              var Te = N.values.map(function(xe) {
                return Ce.extractKey(xe);
              }), Ae = Ce.keyPath.findIndex(function(xe) {
                return xe === F.keyPath;
              });
              re.results.forEach(function(xe) {
                return Te[Ae] = xe;
              }), k(Ce.name).addKeys(Te);
            })), j.mutatedParts = Ni(j.mutatedParts || {}, X), re;
          });
        } }), D = function(k) {
          var G = k.query, k = G.index, G = G.range;
          return [k, new st((k = G.lower) !== null && k !== void 0 ? k : a.MIN_KEY, (G = G.upper) !== null && G !== void 0 ? G : a.MAX_KEY)];
        }, V = { get: function(N) {
          return [F, new st(N.key)];
        }, getMany: function(N) {
          return [F, new st().addKeys(N.keys)];
        }, count: D, query: D, openCursor: D };
        return r(V).forEach(function(N) {
          z[N] = function(k) {
            var G = ge.subscr, U = !!G, W = cl(ge, I) && hl(N, k) ? k.obsSet = {} : G;
            if (U) {
              var j = function(oe) {
                return oe = "idb://".concat(c, "/").concat(E, "/").concat(oe), W[oe] || (W[oe] = new st());
              }, X = j(""), Q = j(":dels"), G = V[N](k), U = G[0], G = G[1];
              if ((N === "query" && U.isPrimaryKey && !k.values ? Q : j(U.name || "")).add(G), !U.isPrimaryKey) {
                if (N !== "count") {
                  var ee = N === "query" && _ && k.values && I.query(n(n({}, k), { values: false }));
                  return I[N].apply(this, arguments).then(function(oe) {
                    if (N === "query") {
                      if (_ && k.values)
                        return ee.then(function(Te) {
                          return Te = Te.result, X.addKeys(Te), oe;
                        });
                      var le = k.values ? oe.result.map(M) : oe.result;
                      (k.values ? X : Q).addKeys(le);
                    } else if (N === "openCursor") {
                      var re = oe, Ce = k.values;
                      return re && Object.create(re, { key: { get: function() {
                        return Q.addKey(re.primaryKey), re.key;
                      } }, primaryKey: { get: function() {
                        var Te = re.primaryKey;
                        return Q.addKey(Te), Te;
                      } }, value: { get: function() {
                        return Ce && X.addKey(re.primaryKey), re.value;
                      } } });
                    }
                    return oe;
                  });
                }
                Q.add(p);
              }
            }
            return I[N].apply(this, arguments);
          };
        }), z;
      } });
    } };
    function ul(a, c, p) {
      if (p.numFailures === 0)
        return c;
      if (c.type === "deleteRange")
        return null;
      var E = c.keys ? c.keys.length : "values" in c && c.values ? c.values.length : 1;
      return p.numFailures === E ? null : (c = n({}, c), o(c.keys) && (c.keys = c.keys.filter(function(I, T) {
        return !(T in p.failures);
      })), "values" in c && o(c.values) && (c.values = c.values.filter(function(I, T) {
        return !(T in p.failures);
      })), c);
    }
    function Oo(a, c) {
      return p = a, ((E = c).lower === void 0 || (E.lowerOpen ? 0 < Me(p, E.lower) : 0 <= Me(p, E.lower))) && (a = a, (c = c).upper === void 0 || (c.upperOpen ? Me(a, c.upper) < 0 : Me(a, c.upper) <= 0));
      var p, E;
    }
    function dl(a, c, V, E, I, T) {
      if (!V || V.length === 0)
        return a;
      var F = c.query.index, M = F.multiEntry, _ = c.query.range, L = E.schema.primaryKey.extractKey, z = F.extractKey, D = (F.lowLevelIndex || F).extractKey, V = V.reduce(function(N, k) {
        var G = N, U = k.type === "add" || k.type === "put" ? k.values.filter(function(Q) {
          return Q = z(Q), M && o(Q) ? Q.some(function(ee) {
            return Oo(ee, _);
          }) : Oo(Q, _);
        }).map(function(Q) {
          return Q = se(Q), T && Object.freeze(Q), Q;
        }) : [];
        switch (k.type) {
          case "add":
            G = N.concat(c.values ? U : U.map(function(ee) {
              return L(ee);
            }));
            break;
          case "put":
            var W = new st().addKeys(k.values.map(function(ee) {
              return L(ee);
            })), G = N.filter(function(ee) {
              return ee = c.values ? L(ee) : ee, !Li(new st(ee), W);
            }).concat(c.values ? U : U.map(function(ee) {
              return L(ee);
            }));
            break;
          case "delete":
            var j = new st().addKeys(k.keys);
            G = N.filter(function(ee) {
              return ee = c.values ? L(ee) : ee, !Li(new st(ee), j);
            });
            break;
          case "deleteRange":
            var X = k.range;
            G = N.filter(function(ee) {
              return !Oo(L(ee), X);
            });
        }
        return G;
      }, a);
      return V === a ? a : (V.sort(function(N, k) {
        return Me(D(N), D(k)) || Me(L(N), L(k));
      }), c.limit && c.limit < 1 / 0 && (V.length > c.limit ? V.length = c.limit : a.length === c.limit && V.length < c.limit && (I.dirty = true)), T ? Object.freeze(V) : V);
    }
    function fl(a, c) {
      return Me(a.lower, c.lower) === 0 && Me(a.upper, c.upper) === 0 && !!a.lowerOpen == !!c.lowerOpen && !!a.upperOpen == !!c.upperOpen;
    }
    function Jh(a, c) {
      return function(p, E, I, T) {
        if (p === void 0)
          return E !== void 0 ? -1 : 0;
        if (E === void 0)
          return 1;
        if ((E = Me(p, E)) === 0) {
          if (I && T)
            return 0;
          if (I)
            return 1;
          if (T)
            return -1;
        }
        return E;
      }(a.lower, c.lower, a.lowerOpen, c.lowerOpen) <= 0 && 0 <= function(p, E, I, T) {
        if (p === void 0)
          return E !== void 0 ? 1 : 0;
        if (E === void 0)
          return -1;
        if ((E = Me(p, E)) === 0) {
          if (I && T)
            return 0;
          if (I)
            return -1;
          if (T)
            return 1;
        }
        return E;
      }(a.upper, c.upper, a.upperOpen, c.upperOpen);
    }
    function $h(a, c, p, E) {
      a.subscribers.add(p), E.addEventListener("abort", function() {
        var I, T;
        a.subscribers.delete(p), a.subscribers.size === 0 && (I = a, T = c, setTimeout(function() {
          I.subscribers.size === 0 && ue(T, I);
        }, 3e3));
      });
    }
    var eu = { stack: "dbcore", level: 0, name: "Cache", create: function(a) {
      var c = a.schema.name;
      return n(n({}, a), { transaction: function(p, E, I) {
        var T, F, M = a.transaction(p, E, I);
        return E === "readwrite" && (F = (T = new AbortController()).signal, I = function(_) {
          return function() {
            if (T.abort(), E === "readwrite") {
              for (var L = /* @__PURE__ */ new Set(), z = 0, D = p; z < D.length; z++) {
                var V = D[z], N = Fn["idb://".concat(c, "/").concat(V)];
                if (N) {
                  var k = a.table(V), G = N.optimisticOps.filter(function(Ce) {
                    return Ce.trans === M;
                  });
                  if (M._explicit && _ && M.mutatedParts)
                    for (var U = 0, W = Object.values(N.queries.query); U < W.length; U++)
                      for (var j = 0, X = (ae2 = W[U]).slice(); j < X.length; j++)
                        xo((ie = X[j]).obsSet, M.mutatedParts) && (ue(ae2, ie), ie.subscribers.forEach(function(Ce) {
                          return L.add(Ce);
                        }));
                  else if (0 < G.length) {
                    N.optimisticOps = N.optimisticOps.filter(function(Ce) {
                      return Ce.trans !== M;
                    });
                    for (var Q = 0, ee = Object.values(N.queries.query); Q < ee.length; Q++)
                      for (var ae2, ie, oe, le = 0, re = (ae2 = ee[Q]).slice(); le < re.length; le++)
                        (ie = re[le]).res != null && M.mutatedParts && (_ && !ie.dirty ? (oe = Object.isFrozen(ie.res), oe = dl(ie.res, ie.req, G, k, ie, oe), ie.dirty ? (ue(ae2, ie), ie.subscribers.forEach(function(Ce) {
                          return L.add(Ce);
                        })) : oe !== ie.res && (ie.res = oe, ie.promise = ce.resolve({ result: oe }))) : (ie.dirty && ue(ae2, ie), ie.subscribers.forEach(function(Ce) {
                          return L.add(Ce);
                        })));
                  }
                }
              }
              L.forEach(function(Ce) {
                return Ce();
              });
            }
          };
        }, M.addEventListener("abort", I(false), { signal: F }), M.addEventListener("error", I(false), { signal: F }), M.addEventListener("complete", I(true), { signal: F })), M;
      }, table: function(p) {
        var E = a.table(p), I = E.schema.primaryKey;
        return n(n({}, E), { mutate: function(T) {
          var F = ge.trans;
          if (I.outbound || F.db._options.cache === "disabled" || F.explicit)
            return E.mutate(T);
          var M = Fn["idb://".concat(c, "/").concat(p)];
          return M ? (F = E.mutate(T), T.type !== "add" && T.type !== "put" || !(50 <= T.values.length || Mo(I, T).some(function(_) {
            return _ == null;
          })) ? (M.optimisticOps.push(T), T.mutatedParts && _i(T.mutatedParts), F.then(function(_) {
            0 < _.numFailures && (ue(M.optimisticOps, T), (_ = ul(0, T, _)) && M.optimisticOps.push(_), T.mutatedParts && _i(T.mutatedParts));
          }), F.catch(function() {
            ue(M.optimisticOps, T), T.mutatedParts && _i(T.mutatedParts);
          })) : F.then(function(_) {
            var L = ul(0, n(n({}, T), { values: T.values.map(function(N, D) {
              var V, N = (V = I.keyPath) !== null && V !== void 0 && V.includes(".") ? se(N) : n({}, N);
              return Y(N, I.keyPath, _.results[D]), N;
            }) }), _);
            M.optimisticOps.push(L), queueMicrotask(function() {
              return T.mutatedParts && _i(T.mutatedParts);
            });
          }), F) : E.mutate(T);
        }, query: function(T) {
          if (!cl(ge, E) || !hl("query", T))
            return E.query(T);
          var F = ((L = ge.trans) === null || L === void 0 ? void 0 : L.db._options.cache) === "immutable", D = ge, M = D.requery, _ = D.signal, L = function(k, G, U, W) {
            var j = Fn["idb://".concat(k, "/").concat(G)];
            if (!j)
              return [];
            if (!(G = j.queries[U]))
              return [null, false, j, null];
            var X = G[(W.query ? W.query.index.name : null) || ""];
            if (!X)
              return [null, false, j, null];
            switch (U) {
              case "query":
                var Q = X.find(function(ee) {
                  return ee.req.limit === W.limit && ee.req.values === W.values && fl(ee.req.query.range, W.query.range);
                });
                return Q ? [Q, true, j, X] : [X.find(function(ee) {
                  return ("limit" in ee.req ? ee.req.limit : 1 / 0) >= W.limit && (!W.values || ee.req.values) && Jh(ee.req.query.range, W.query.range);
                }), false, j, X];
              case "count":
                return Q = X.find(function(ee) {
                  return fl(ee.req.query.range, W.query.range);
                }), [Q, !!Q, j, X];
            }
          }(c, p, "query", T), z = L[0], D = L[1], V = L[2], N = L[3];
          return z && D ? z.obsSet = T.obsSet : (D = E.query(T).then(function(k) {
            var G = k.result;
            if (z && (z.res = G), F) {
              for (var U = 0, W = G.length; U < W; ++U)
                Object.freeze(G[U]);
              Object.freeze(G);
            } else
              k.result = se(G);
            return k;
          }).catch(function(k) {
            return N && z && ue(N, z), Promise.reject(k);
          }), z = { obsSet: T.obsSet, promise: D, subscribers: /* @__PURE__ */ new Set(), type: "query", req: T, dirty: false }, N ? N.push(z) : (N = [z], (V = V || (Fn["idb://".concat(c, "/").concat(p)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[T.query.index.name || ""] = N)), $h(z, N, M, _), z.promise.then(function(k) {
            return { result: dl(k.result, T, V == null ? void 0 : V.optimisticOps, E, z, F) };
          });
        } });
      } });
    } };
    function Bi(a, c) {
      return new Proxy(a, { get: function(p, E, I) {
        return E === "db" ? c : Reflect.get(p, E, I);
      } });
    }
    var $t = (Ze.prototype.version = function(a) {
      if (isNaN(a) || a < 0.1)
        throw new pe.Type("Given version is not a positive number");
      if (a = Math.round(10 * a) / 10, this.idbdb || this._state.isBeingOpened)
        throw new pe.Schema("Cannot add version when database is open");
      this.verno = Math.max(this.verno, a);
      var c = this._versions, p = c.filter(function(E) {
        return E._cfg.version === a;
      })[0];
      return p || (p = new this.Version(a), c.push(p), c.sort(Yh), p.stores({}), this._state.autoSchema = false, p);
    }, Ze.prototype._whenReady = function(a) {
      var c = this;
      return this.idbdb && (this._state.openComplete || ge.letThrough || this._vip) ? a() : new ce(function(p, E) {
        if (c._state.openComplete)
          return E(new pe.DatabaseClosed(c._state.dbOpenError));
        if (!c._state.isBeingOpened) {
          if (!c._state.autoOpen)
            return void E(new pe.DatabaseClosed());
          c.open().catch(Oe);
        }
        c._state.dbReadyPromise.then(p, E);
      }).then(a);
    }, Ze.prototype.use = function(a) {
      var c = a.stack, p = a.create, E = a.level, I = a.name;
      return I && this.unuse({ stack: c, name: I }), a = this._middlewares[c] || (this._middlewares[c] = []), a.push({ stack: c, create: p, level: E ?? 10, name: I }), a.sort(function(T, F) {
        return T.level - F.level;
      }), this;
    }, Ze.prototype.unuse = function(a) {
      var c = a.stack, p = a.name, E = a.create;
      return c && this._middlewares[c] && (this._middlewares[c] = this._middlewares[c].filter(function(I) {
        return E ? I.create !== E : !!p && I.name !== p;
      })), this;
    }, Ze.prototype.open = function() {
      var a = this;
      return xn(on, function() {
        return jh(a);
      });
    }, Ze.prototype._close = function() {
      var a = this._state, c = Hn.indexOf(this);
      if (0 <= c && Hn.splice(c, 1), this.idbdb) {
        try {
          this.idbdb.close();
        } catch {
        }
        this.idbdb = null;
      }
      a.isBeingOpened || (a.dbReadyPromise = new ce(function(p) {
        a.dbReadyResolve = p;
      }), a.openCanceller = new ce(function(p, E) {
        a.cancelOpen = E;
      }));
    }, Ze.prototype.close = function(p) {
      var c = (p === void 0 ? { disableAutoOpen: true } : p).disableAutoOpen, p = this._state;
      c ? (p.isBeingOpened && p.cancelOpen(new pe.DatabaseClosed()), this._close(), p.autoOpen = false, p.dbOpenError = new pe.DatabaseClosed()) : (this._close(), p.autoOpen = this._options.autoOpen || p.isBeingOpened, p.openComplete = false, p.dbOpenError = null);
    }, Ze.prototype.delete = function(a) {
      var c = this;
      a === void 0 && (a = { disableAutoOpen: true });
      var p = 0 < arguments.length && typeof arguments[0] != "object", E = this._state;
      return new ce(function(I, T) {
        function F() {
          c.close(a);
          var M = c._deps.indexedDB.deleteDatabase(c.name);
          M.onsuccess = ze(function() {
            var _, L, z;
            _ = c._deps, L = c.name, z = _.indexedDB, _ = _.IDBKeyRange, wo(z) || L === Ti || yo(z, _).delete(L).catch(Oe), I();
          }), M.onerror = Bt(T), M.onblocked = c._fireOnBlocked;
        }
        if (p)
          throw new pe.InvalidArgument("Invalid closeOptions argument to db.delete()");
        E.isBeingOpened ? E.dbReadyPromise.then(F) : F();
      });
    }, Ze.prototype.backendDB = function() {
      return this.idbdb;
    }, Ze.prototype.isOpen = function() {
      return this.idbdb !== null;
    }, Ze.prototype.hasBeenClosed = function() {
      var a = this._state.dbOpenError;
      return a && a.name === "DatabaseClosed";
    }, Ze.prototype.hasFailed = function() {
      return this._state.dbOpenError !== null;
    }, Ze.prototype.dynamicallyOpened = function() {
      return this._state.autoSchema;
    }, Object.defineProperty(Ze.prototype, "tables", { get: function() {
      var a = this;
      return r(this._allTables).map(function(c) {
        return a._allTables[c];
      });
    }, enumerable: false, configurable: true }), Ze.prototype.transaction = function() {
      var a = (function(c, p, E) {
        var I = arguments.length;
        if (I < 2)
          throw new pe.InvalidArgument("Too few arguments");
        for (var T = new Array(I - 1); --I; )
          T[I - 1] = arguments[I];
        return E = T.pop(), [c, Z(T), E];
      }).apply(this, arguments);
      return this._transaction.apply(this, a);
    }, Ze.prototype._transaction = function(a, c, p) {
      var E = this, I = ge.trans;
      I && I.db === this && a.indexOf("!") === -1 || (I = null);
      var T, F, M = a.indexOf("?") !== -1;
      a = a.replace("!", "").replace("?", "");
      try {
        if (F = c.map(function(L) {
          if (L = L instanceof E.Table ? L.name : L, typeof L != "string")
            throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
          return L;
        }), a == "r" || a === ao)
          T = ao;
        else {
          if (a != "rw" && a != lo)
            throw new pe.InvalidArgument("Invalid transaction mode: " + a);
          T = lo;
        }
        if (I) {
          if (I.mode === ao && T === lo) {
            if (!M)
              throw new pe.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
            I = null;
          }
          I && F.forEach(function(L) {
            if (I && I.storeNames.indexOf(L) === -1) {
              if (!M)
                throw new pe.SubTransaction("Table " + L + " not included in parent transaction.");
              I = null;
            }
          }), M && I && !I.active && (I = null);
        }
      } catch (L) {
        return I ? I._promise(null, function(z, D) {
          D(L);
        }) : Xe(L);
      }
      var _ = (function L(z, D, V, N, k) {
        return ce.resolve().then(function() {
          var G = ge.transless || ge, U = z._createTransaction(D, V, z._dbSchema, N);
          if (U.explicit = true, G = { trans: U, transless: G }, N)
            U.idbtrans = N.idbtrans;
          else
            try {
              U.create(), U.idbtrans._explicit = true, z._state.PR1398_maxLoop = 3;
            } catch (X) {
              return X.name === Qt.InvalidState && z.isOpen() && 0 < --z._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), z.close({ disableAutoOpen: false }), z.open().then(function() {
                return L(z, D, V, null, k);
              })) : Xe(X);
            }
          var W, j = Ke(k);
          return j && Yn(), G = ce.follow(function() {
            var X;
            (W = k.call(U, U)) && (j ? (X = ln.bind(null, null), W.then(X, X)) : typeof W.next == "function" && typeof W.throw == "function" && (W = Ro(W)));
          }, G), (W && typeof W.then == "function" ? ce.resolve(W).then(function(X) {
            return U.active ? X : Xe(new pe.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : G.then(function() {
            return W;
          })).then(function(X) {
            return N && U._resolve(), U._completion.then(function() {
              return X;
            });
          }).catch(function(X) {
            return U._reject(X), Xe(X);
          });
        });
      }).bind(null, this, T, F, I, p);
      return I ? I._promise(T, _, "lock") : ge.trans ? xn(ge.transless, function() {
        return E._whenReady(_);
      }) : this._whenReady(_);
    }, Ze.prototype.table = function(a) {
      if (!m(this._allTables, a))
        throw new pe.InvalidTable("Table ".concat(a, " does not exist"));
      return this._allTables[a];
    }, Ze);
    function Ze(a, c) {
      var p = this;
      this._middlewares = {}, this.verno = 0;
      var E = Ze.dependencies;
      this._options = c = n({ addons: Ze.addons, autoOpen: true, indexedDB: E.indexedDB, IDBKeyRange: E.IDBKeyRange, cache: "cloned" }, c), this._deps = { indexedDB: c.indexedDB, IDBKeyRange: c.IDBKeyRange }, E = c.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
      var I, T, F, M, _, L = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: Oe, dbReadyPromise: null, cancelOpen: Oe, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3, autoOpen: c.autoOpen };
      L.dbReadyPromise = new ce(function(D) {
        L.dbReadyResolve = D;
      }), L.openCanceller = new ce(function(D, V) {
        L.cancelOpen = V;
      }), this._state = L, this.name = a, this.on = As(this, "populate", "blocked", "versionchange", "close", { ready: [Jr, Oe] }), this.on.ready.subscribe = P(this.on.ready.subscribe, function(D) {
        return function(V, N) {
          Ze.vip(function() {
            var k, G = p._state;
            G.openComplete ? (G.dbOpenError || ce.resolve().then(V), N && D(V)) : G.onReadyBeingFired ? (G.onReadyBeingFired.push(V), N && D(V)) : (D(V), k = p, N || D(function U() {
              k.on.ready.unsubscribe(V), k.on.ready.unsubscribe(U);
            }));
          });
        };
      }), this.Collection = (I = this, Fs(_h.prototype, function(W, U) {
        this.db = I;
        var N = Wa, k = null;
        if (U)
          try {
            N = U();
          } catch (j) {
            k = j;
          }
        var G = W._ctx, U = G.table, W = U.hook.reading.fire;
        this._ctx = { table: U, index: G.index, isPrimKey: !G.index || U.schema.primKey.keyPath && G.index === U.schema.primKey.name, range: N, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: k, or: G.or, valueMapper: W !== _t ? W : null };
      })), this.Table = (T = this, Fs(Za.prototype, function(D, V, N) {
        this.db = T, this._tx = N, this.name = D, this.schema = V, this.hook = T._allTables[D] ? T._allTables[D].hook : As(null, { creating: [ys, Oe], reading: [qr, _t], updating: [Rh, Oe], deleting: [ws, Oe] });
      })), this.Transaction = (F = this, Fs(kh.prototype, function(D, V, N, k, G) {
        var U = this;
        this.db = F, this.mode = D, this.storeNames = V, this.schema = N, this.chromeTransactionDurability = k, this.idbtrans = null, this.on = As(this, "complete", "error", "abort"), this.parent = G || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ce(function(W, j) {
          U._resolve = W, U._reject = j;
        }), this._completion.then(function() {
          U.active = false, U.on.complete.fire();
        }, function(W) {
          var j = U.active;
          return U.active = false, U.on.error.fire(W), U.parent ? U.parent._reject(W) : j && U.idbtrans && U.idbtrans.abort(), Xe(W);
        });
      })), this.Version = (M = this, Fs(Kh.prototype, function(D) {
        this.db = M, this._cfg = { version: D, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      })), this.WhereClause = (_ = this, Fs(el.prototype, function(D, V, N) {
        if (this.db = _, this._ctx = { table: D, index: V === ":id" ? null : V, or: N }, this._cmp = this._ascending = Me, this._descending = function(k, G) {
          return Me(G, k);
        }, this._max = function(k, G) {
          return 0 < Me(k, G) ? k : G;
        }, this._min = function(k, G) {
          return Me(k, G) < 0 ? k : G;
        }, this._IDBKeyRange = _._deps.IDBKeyRange, !this._IDBKeyRange)
          throw new pe.MissingAPI();
      })), this.on("versionchange", function(D) {
        0 < D.newVersion ? console.warn("Another connection wants to upgrade database '".concat(p.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(p.name, "'. Closing db now to resume the delete request.")), p.close({ disableAutoOpen: false });
      }), this.on("blocked", function(D) {
        !D.newVersion || D.newVersion < D.oldVersion ? console.warn("Dexie.delete('".concat(p.name, "') was blocked")) : console.warn("Upgrade '".concat(p.name, "' blocked by other connection holding version ").concat(D.oldVersion / 10));
      }), this._maxKey = Os(c.IDBKeyRange), this._createTransaction = function(D, V, N, k) {
        return new p.Transaction(D, V, N, p._options.chromeTransactionDurability, k);
      }, this._fireOnBlocked = function(D) {
        p.on("blocked").fire(D), Hn.filter(function(V) {
          return V.name === p.name && V !== p && !V._state.vcFired;
        }).map(function(V) {
          return V.on("versionchange").fire(D);
        });
      }, this.use(Qh), this.use(eu), this.use(qh), this.use(Xh), this.use(Zh);
      var z = new Proxy(this, { get: function(D, V, N) {
        if (V === "_vip")
          return true;
        if (V === "table")
          return function(G) {
            return Bi(p.table(G), z);
          };
        var k = Reflect.get(D, V, N);
        return k instanceof Za ? Bi(k, z) : V === "tables" ? k.map(function(G) {
          return Bi(G, z);
        }) : V === "_createTransaction" ? function() {
          return Bi(k.apply(this, arguments), z);
        } : k;
      } });
      this.vip = z, E.forEach(function(D) {
        return D(p);
      });
    }
    var ki, It = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", tu = (Do.prototype.subscribe = function(a, c, p) {
      return this._subscribe(a && typeof a != "function" ? a : { next: a, error: c, complete: p });
    }, Do.prototype[It] = function() {
      return this;
    }, Do);
    function Do(a) {
      this._subscribe = a;
    }
    try {
      ki = { indexedDB: i.indexedDB || i.mozIndexedDB || i.webkitIndexedDB || i.msIndexedDB, IDBKeyRange: i.IDBKeyRange || i.webkitIDBKeyRange };
    } catch {
      ki = { indexedDB: null, IDBKeyRange: null };
    }
    function pl(a) {
      var c, p = false, E = new tu(function(I) {
        var T = Ke(a), F, M = false, _ = {}, L = {}, z = { get closed() {
          return M;
        }, unsubscribe: function() {
          M || (M = true, F && F.abort(), D && un.storagemutated.unsubscribe(N));
        } };
        I.start && I.start(z);
        var D = false, V = function() {
          return oo(k);
        }, N = function(G) {
          Ni(_, G), xo(L, _) && V();
        }, k = function() {
          var G, U, W;
          !M && ki.indexedDB && (_ = {}, G = {}, F && F.abort(), F = new AbortController(), W = function(j) {
            var X = Vn();
            try {
              T && Yn();
              var Q = an2(a, j);
              return Q = T ? Q.finally(ln) : Q;
            } finally {
              X && Gn();
            }
          }(U = { subscr: G, signal: F.signal, requery: V, querier: a, trans: null }), Promise.resolve(W).then(function(j) {
            p = true, c = j, M || U.signal.aborted || (_ = {}, function(X) {
              for (var Q in X)
                if (m(X, Q))
                  return;
              return 1;
            }(L = G) || D || (un(Ms, N), D = true), oo(function() {
              return !M && I.next && I.next(j);
            }));
          }, function(j) {
            p = false, ["DatabaseClosedError", "AbortError"].includes(j == null ? void 0 : j.name) || M || oo(function() {
              M || I.error && I.error(j);
            });
          }));
        };
        return setTimeout(V, 0), z;
      });
      return E.hasValue = function() {
        return p;
      }, E.getValue = function() {
        return c;
      }, E;
    }
    var Rn = $t;
    function Lo(a) {
      var c = dn;
      try {
        dn = true, un.storagemutated.fire(a), Fo(a, true);
      } finally {
        dn = c;
      }
    }
    f(Rn, n(n({}, St), { delete: function(a) {
      return new Rn(a, { addons: [] }).delete();
    }, exists: function(a) {
      return new Rn(a, { addons: [] }).open().then(function(c) {
        return c.close(), true;
      }).catch("NoSuchDatabaseError", function() {
        return false;
      });
    }, getDatabaseNames: function(a) {
      try {
        return c = Rn.dependencies, p = c.indexedDB, c = c.IDBKeyRange, (wo(p) ? Promise.resolve(p.databases()).then(function(E) {
          return E.map(function(I) {
            return I.name;
          }).filter(function(I) {
            return I !== Ti;
          });
        }) : yo(p, c).toCollection().primaryKeys()).then(a);
      } catch {
        return Xe(new pe.MissingAPI());
      }
      var c, p;
    }, defineClass: function() {
      return function(a) {
        l(this, a);
      };
    }, ignoreTransaction: function(a) {
      return ge.trans ? xn(ge.transless, a) : a();
    }, vip: Co, async: function(a) {
      return function() {
        try {
          var c = Ro(a.apply(this, arguments));
          return c && typeof c.then == "function" ? c : ce.resolve(c);
        } catch (p) {
          return Xe(p);
        }
      };
    }, spawn: function(a, c, p) {
      try {
        var E = Ro(a.apply(p, c || []));
        return E && typeof E.then == "function" ? E : ce.resolve(E);
      } catch (I) {
        return Xe(I);
      }
    }, currentTransaction: { get: function() {
      return ge.trans || null;
    } }, waitFor: function(a, c) {
      return c = ce.resolve(typeof a == "function" ? Rn.ignoreTransaction(a) : a).timeout(c || 6e4), ge.trans ? ge.trans.waitFor(c) : c;
    }, Promise: ce, debug: { get: function() {
      return Ut;
    }, set: function(a) {
      Ba(a);
    } }, derive: y, extend: l, props: f, override: P, Events: As, on: un, liveQuery: pl, extendObservabilitySet: Ni, getByKeyPath: B, setByKeyPath: Y, delByKeyPath: function(a, c) {
      typeof c == "string" ? Y(a, c, void 0) : "length" in c && [].map.call(c, function(p) {
        Y(a, p, void 0);
      });
    }, shallowClone: H, deepClone: se, getObjectDiff: Po, cmp: Me, asap: O, minKey: -1 / 0, addons: [], connections: Hn, errnames: Qt, dependencies: ki, cache: Fn, semVer: "4.0.7", version: "4.0.7".split(".").map(function(a) {
      return parseInt(a);
    }).reduce(function(a, c, p) {
      return a + c / Math.pow(10, 2 * p);
    }) })), Rn.maxKey = Os(Rn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (un(Ms, function(a) {
      dn || (a = new CustomEvent(fo, { detail: a }), dn = true, dispatchEvent(a), dn = false);
    }), addEventListener(fo, function(a) {
      a = a.detail, dn || Lo(a);
    }));
    var jn, dn = false, ml = function() {
    };
    return typeof BroadcastChannel < "u" && ((ml = function() {
      (jn = new BroadcastChannel(fo)).onmessage = function(a) {
        return a.data && Lo(a.data);
      };
    })(), typeof jn.unref == "function" && jn.unref(), un(Ms, function(a) {
      dn || jn.postMessage(a);
    })), typeof addEventListener < "u" && (addEventListener("pagehide", function(a) {
      if (!$t.disableBfCache && a.persisted) {
        Ut && console.debug("Dexie: handling persisted pagehide"), jn != null && jn.close();
        for (var c = 0, p = Hn; c < p.length; c++)
          p[c].close({ disableAutoOpen: false });
      }
    }), addEventListener("pageshow", function(a) {
      !$t.disableBfCache && a.persisted && (Ut && console.debug("Dexie: handling persisted pageshow"), ml(), Lo({ all: new st(-1 / 0, [[]]) }));
    })), ce.rejectionMapper = function(a, c) {
      return !a || a instanceof vt || a instanceof TypeError || a instanceof SyntaxError || !a.name || !Ge[a.name] ? a : (c = new Ge[a.name](c || a.message, a), "stack" in a && v(c, "stack", { get: function() {
        return this.inner.stack;
      } }), c);
    }, Ba(Ut), n($t, Object.freeze({ __proto__: null, Dexie: $t, liveQuery: pl, Entity: Ka, cmp: Me, PropModSymbol: Jt, PropModification: Rs, replacePrefix: function(a, c) {
      return new Rs({ replacePrefix: [a, c] });
    }, add: function(a) {
      return new Rs({ add: a });
    }, remove: function(a) {
      return new Rs({ remove: a });
    }, default: $t, RangeSet: st, mergeRanges: Ns, rangesOverlap: Li }), { default: $t }), $t;
  });
})(Fh);
var Pp = Fh.exports;
var Sa = Ih(Pp);
var Tc = Symbol.for("Dexie");
var Aa = globalThis[Tc] || (globalThis[Tc] = Sa);
if (Sa.semVer !== Aa.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Sa.semVer} and ${Aa.semVer}`);
var Mp = class extends Aa {
  // number = type of the primkey
  constructor() {
    super("MyAppDatabase");
    b(this, "files");
    this.version(1).stores({
      files: "id, file"
    });
  }
};
var ii = class ii2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "enabled", true);
    b(this, "onFragmentsDeleted", new $());
    b(this, "onFragmentsLoaded", new $());
    b(this, "onDisposed", new $());
    b(this, "models", {});
    b(this, "serializer", new fn());
    b(this, "maxRamTime", 5e3);
    b(this, "useCache", true);
    b(this, "_culler", null);
    b(this, "_world", null);
    b(this, "_ramCache", /* @__PURE__ */ new Map());
    b(this, "_fileCache", new Mp());
    b(this, "_url", null);
    b(this, "_isDisposing", false);
    b(this, "_geometryInstances", {});
    b(this, "_loadedFragments", {});
    b(this, "fragIDData", /* @__PURE__ */ new Map());
    b(this, "_baseMaterial", new MeshLambertMaterial());
    b(this, "_baseMaterialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    }));
    this.components.add(ii2.uuid, this);
  }
  /**
   * The URL of the data source for the streaming service.
   * It must be set before using the streaming service.
   * If not set, an error will be thrown when trying to access the URL.
   */
  get url() {
    if (!this._url)
      throw new Error("url must be set before using the streaming service!");
    return this._url;
  }
  /**
   * Sets the URL of the data source for the streaming service.
   * @param value - The new URL to be set.
   */
  set url(e) {
    this._url = e;
  }
  /**
   * The world in which the fragments will be displayed.
   * It must be set before using the streaming service.
   * If not set, an error will be thrown when trying to access the world.
   */
  get world() {
    if (!this._world)
      throw new Error("You must set a world before using the streamer!");
    return this._world;
  }
  /**
   * Sets the world in which the fragments will be displayed.
   * @param world - The new world to be set.
   */
  set world(e) {
    var n;
    this._world = e, (n = this._culler) == null || n.dispose(), this._culler = new Rp(this.components, e), this._culler.onViewUpdated.add(
      async ({ toLoad: s, toRemove: i, toShow: r, toHide: o }) => {
        await this.loadFoundGeometries(s), await this.unloadLostGeometries(i), this.setMeshVisibility(r, true), this.setMeshVisibility(o, false);
      }
    );
  }
  /**
   * The culler used for managing and rendering the fragments.
   * It is automatically created when the world is set.
   */
  get culler() {
    if (!this._culler)
      throw new Error("You must set a world before using the streamer!");
    return this._culler;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    var e;
    this._isDisposing = true, this.onFragmentsLoaded.reset(), this.onFragmentsDeleted.reset(), this._ramCache.clear(), this.models = {}, this._geometryInstances = {}, this._loadedFragments = {}, this.fragIDData.clear(), this._baseMaterial.dispose(), this._baseMaterialT.dispose(), (e = this._culler) == null || e.dispose(), this.onDisposed.trigger(ii2.uuid), this.onDisposed.reset(), this._isDisposing = false;
  }
  /**
   * Loads a new fragment group into the scene using streaming.
   *
   * @param settings - The settings for the new fragment group.
   * @param coordinate - Whether to federate this model with the rest.
   * @param properties - Optional properties for the new fragment group.
   * @returns The newly loaded fragment group.
   */
  async load(e, n, s) {
    const { assets: i, geometries: r, globalDataFileId: o } = e, l = this.url + o, d = await (await fetch(l)).arrayBuffer(), m = new Uint8Array(d), g = this.components.get(He).load(m, { coordinate: n });
    this.world.scene.three.add(g);
    const { opaque: v, transparent: y } = g.geometryIDs;
    for (const [A, R] of v) {
      const P = g.keyFragments.get(R);
      if (P === void 0)
        throw new Error("Malformed fragments group!");
      this.fragIDData.set(P, [g, A, /* @__PURE__ */ new Set()]);
    }
    for (const [A, R] of y) {
      const P = g.keyFragments.get(R);
      if (P === void 0)
        throw new Error("Malformed fragments group!");
      this.fragIDData.set(P, [g, Math.abs(A), /* @__PURE__ */ new Set()]);
    }
    this.culler.add(g.uuid, i, r), this.models[g.uuid] = { assets: i, geometries: r };
    const x = /* @__PURE__ */ new Map();
    for (const A of i) {
      const R = A.id;
      for (const { transformation: P, geometryID: C, color: O } of A.geometries) {
        x.has(C) || x.set(C, []);
        const B = x.get(C);
        if (!B)
          throw new Error("Malformed instances");
        B.push({ id: R, transformation: P, color: O });
      }
    }
    if (this._geometryInstances[g.uuid] = x, s) {
      const A = /* @__PURE__ */ new Map(), R = /* @__PURE__ */ new Map();
      for (const H in s.ids) {
        const K = s.ids[H], Z = parseInt(H, 10);
        A.set(Z, K);
      }
      for (const H in s.types) {
        const K = s.types[H], Z = parseInt(H, 10);
        R.set(Z, K);
      }
      const P = o.replace(
        "-global",
        "-properties"
      );
      g.streamSettings = {
        baseUrl: this.url,
        baseFileName: P,
        ids: A,
        types: R
      };
      const { indexesFile: C } = s, B = await (await fetch(this.url + C)).text(), Y = this.components.get(Xr);
      Y.setRelationMap(g, Y.getRelationsMapFromJSON(B));
    }
    return this.culler.needsUpdate = true, g;
  }
  /**
   * Removes a fragment group from the scene.
   *
   * @param modelID - The unique identifier of the fragment group to remove.
   */
  remove(e) {
    this._isDisposing = true;
    const s = this.components.get(He).groups.get(e);
    if (s === void 0) {
      console.log("Group to delete not found.");
      return;
    }
    delete this.models[e], delete this._geometryInstances[e], delete this._loadedFragments[e];
    const i = s.keyFragments.values();
    for (const r of i)
      this.fragIDData.delete(r);
    this.culler.remove(e), this._isDisposing = false;
  }
  /**
   * Sets the visibility of items in fragments based on the provided filter.
   *
   * @param visible - The visibility state to set.
   * @param filter - A map of fragment IDs to arrays of item IDs.
   *                  Only items with IDs present in the arrays will be visible.
   */
  setVisibility(e, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i in n) {
      const r = this.fragIDData.get(i);
      if (r === void 0)
        throw new Error("Geometry not found!");
      const [o, l, u] = r, d = o.uuid;
      s.has(d) || s.set(d, /* @__PURE__ */ new Map());
      const m = s.get(d), f = n[i];
      for (const v of f)
        e ? u.delete(v) : u.add(v);
      m.get(l) || m.set(l, /* @__PURE__ */ new Set());
      const g = m.get(l);
      for (const v of f)
        g.add(v);
    }
    for (const [i, r] of s) {
      this.culler.setVisibility(e, i, r);
      for (const [o] of r) {
        const l = this._loadedFragments[i];
        if (!l)
          continue;
        const u = l[o];
        if (u)
          for (const d of u) {
            const m = n[d.id];
            m && d.setVisibility(e, m);
          }
      }
    }
    this.culler.needsUpdate = true;
  }
  /**
   * Clears the local cache used for storing downloaded fragment files.
   *
   * @returns A Promise that resolves when the cache is cleared.
   */
  async clearCache() {
    await this._fileCache.delete();
  }
  async loadFoundGeometries(e) {
    for (const n in e) {
      if (this._isDisposing)
        return;
      const i = this.components.get(He).groups.get(n);
      if (!i)
        return;
      const { geometries: r } = this.models[n], o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Set();
      for (const [f, g] of e[n])
        for (const v of g) {
          l.add(v);
          const y = r[v];
          if (!y)
            throw new Error("Geometry not found");
          if (y.geometryFile) {
            const x = y.geometryFile, A = o.get(x) || 0;
            o.set(x, A + f);
          }
        }
      const u = Array.from(o).sort((f, g) => g[1] - f[1]);
      for (const [f] of u) {
        const g = this.url + f;
        if (!this._ramCache.has(g)) {
          let x = new Uint8Array();
          if (this.useCache) {
            const R = await this._fileCache.files.get(g);
            if (R)
              x = R.file;
            else {
              const C = await (await fetch(g)).arrayBuffer();
              x = new Uint8Array(C), this._fileCache.files.add({ file: x, id: g });
            }
          } else {
            const P = await (await fetch(g)).arrayBuffer();
            x = new Uint8Array(P);
          }
          const A = this.serializer.import(x);
          this._ramCache.set(g, { data: A, time: performance.now() });
        }
        const v = this._ramCache.get(g);
        if (!v)
          continue;
        v.time = performance.now();
        const y = [];
        if (v)
          for (const [x, { position: A, index: R, normal: P }] of v.data) {
            if (this._isDisposing)
              return;
            if (!l.has(x) || !this._geometryInstances[n] || !this._geometryInstances[n].has(x))
              continue;
            const O = this._geometryInstances[n].get(x);
            if (!O)
              throw new Error("Instances not found!");
            const B = new BufferGeometry(), Y = new BufferAttribute(A, 3), H = new BufferAttribute(P, 3);
            B.setAttribute("position", Y), B.setAttribute("normal", H), B.setIndex(Array.from(R));
            const K = [], Z = [];
            for (const q of O)
              q.color[3] === 1 ? Z.push(q) : K.push(q);
            this.newFragment(i, x, B, K, true, y), this.newFragment(i, x, B, Z, false, y);
          }
        y.length && !this._isDisposing && this.onFragmentsLoaded.trigger(y);
      }
      const d = /* @__PURE__ */ new Set(), m = performance.now();
      for (const [f, { time: g }] of this._ramCache)
        m - g > this.maxRamTime && d.add(f);
      for (const f of d)
        this._ramCache.delete(f);
    }
  }
  async unloadLostGeometries(e) {
    if (this._isDisposing)
      return;
    const n = [], s = this.components.get(He);
    for (const i in e) {
      const r = s.groups.get(i);
      if (!r)
        throw new Error("Fragment group not found!");
      if (!this._loadedFragments[i])
        continue;
      const o = this._loadedFragments[i], l = e[i];
      for (const u of l) {
        if (this.culler.removeFragment(r.uuid, u), !o[u])
          continue;
        const d = o[u];
        for (const m of d)
          r.items.splice(r.items.indexOf(m), 1), n.push(m);
        delete o[u];
      }
    }
    n.length && this.onFragmentsDeleted.trigger(n);
    for (const i of n)
      s.list.delete(i.id), this.world.meshes.delete(i.mesh), i.mesh.material = [], i.dispose(true);
  }
  setMeshVisibility(e, n) {
    for (const s in e)
      for (const i of e[s]) {
        const r = this._loadedFragments[s];
        if (!r)
          continue;
        const o = r[i];
        if (o)
          for (const l of o)
            l.mesh.visible = n;
      }
  }
  newFragment(e, n, s, i, r, o) {
    if (i.length === 0 || this._isDisposing)
      return;
    const l = e.geometryIDs, u = r ? l.transparent : l.opaque, m = n * (r ? -1 : 1), f = u.get(m);
    if (f === void 0)
      return;
    const g = e.keyFragments.get(f);
    if (g === void 0)
      return;
    const v = this.components.get(He);
    if (v.list.has(g))
      return;
    const x = r ? this._baseMaterialT : this._baseMaterial, A = new Ue(s, x, i.length);
    A.id = g, A.mesh.uuid = g, A.group = e, e.add(A.mesh), e.items.push(A), v.list.set(A.id, A), this.world.meshes.add(A.mesh), this._loadedFragments[e.uuid] || (this._loadedFragments[e.uuid] = {});
    const R = this._loadedFragments[e.uuid];
    R[n] || (R[n] = []), R[n].push(A);
    const P = /* @__PURE__ */ new Map();
    for (let Y = 0; Y < i.length; Y++) {
      const H = new Matrix4(), K = new Color(), { id: Z, transformation: q, color: ne } = i[Y];
      H.fromArray(q);
      const [se, he, me] = ne;
      if (K.setRGB(se, he, me, "srgb"), P.has(Z)) {
        const Ie = P.get(Z);
        if (!Ie)
          continue;
        Ie.transforms.push(H), Ie.colors && Ie.colors.push(K);
      } else
        P.set(Z, { id: Z, colors: [K], transforms: [H] });
    }
    const C = Array.from(P.values());
    A.add(C);
    const O = this.fragIDData.get(A.id);
    if (!O)
      throw new Error("Fragment data not found!");
    const B = O[2];
    B.size && A.setVisibility(false, B), this.culler.addFragment(e.uuid, n, A), o.push(A);
  }
};
b(ii, "uuid", "22437e8d-9dbc-4b99-a04f-d2da280d50c8");
var bc = ii;
var Op = class {
  constructor() {
    b(this, "_meshes", /* @__PURE__ */ new Map());
  }
  /**
   * Highlights edges fill meshes based on selected fragments.
   */
  highlight(t, e, n, s) {
    if (!e.userData.indexFragmentMap || !e.geometry.index)
      return;
    const { userData: i } = e, r = i.indexFragmentMap, o = [], l = e.geometry.index.array;
    for (const [m, f] of r)
      for (const g in f)
        if (s[g]) {
          for (const v of f[g])
            if (s[g].has(v)) {
              const y = l[m * 3], x = l[m * 3 + 1], A = l[m * 3 + 2];
              o.push(y, x, A);
            }
        }
    this._meshes.has(t) || this._meshes.set(t, /* @__PURE__ */ new Map());
    const u = this._meshes.get(t);
    if (!u.has(e.uuid)) {
      const m = new MeshBasicMaterial({
        depthTest: false,
        side: 2,
        color: n
      }), f = new BufferGeometry();
      f.attributes = e.geometry.attributes;
      const g = new Mesh(f, m);
      g.frustumCulled = false, u.set(e.uuid, g);
    }
    const d = u.get(e.uuid);
    d.position.copy(e.position), e.parent && e.parent !== d.parent && e.parent.add(d), d.geometry.setIndex(o), d.material.color.copy(n);
  }
  /**
   * Clears the highlighted meshes for a specific style or all styles.
   *
   * @param name - The name of the style to clear. If not provided, clears all styles.
   *
   */
  clear(t) {
    for (const [e, n] of this._meshes)
      if (!(t && t !== e))
        for (const [s, i] of n)
          i.removeFromParent();
  }
  dispose() {
    for (const [t, e] of this._meshes)
      for (const [n, s] of e)
        s.removeFromParent(), s.geometry.attributes = {}, s.geometry.dispose(), s.material.dispose();
    this._meshes.clear();
  }
};
var ri = class ri2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "onBeforeUpdate", new $());
    b(this, "onAfterUpdate", new $());
    b(this, "onSetup", new $());
    b(this, "isSetup", false);
    b(this, "enabled", true);
    b(this, "events", {});
    b(this, "multiple", "ctrlKey");
    b(this, "zoomFactor", 1.5);
    b(this, "zoomToSelection", false);
    b(this, "backupColor", null);
    b(this, "selection", {});
    b(this, "config", {
      selectName: "select",
      hoverName: "hover",
      selectionColor: new Color("#BCF124"),
      hoverColor: new Color("#6528D7"),
      autoHighlightOnClick: true,
      world: null
    });
    b(this, "colors", /* @__PURE__ */ new Map());
    b(this, "_fills", new Op());
    b(this, "_mouseState", {
      down: false,
      moved: false
    });
    b(this, "_colorsBeforeSelect", {});
    b(this, "saveHighlightersBeforeSelect", (e2) => {
      var s;
      const n = this.components.get(He);
      for (const i in e2) {
        const r = n.list.get(i);
        if (!r)
          continue;
        const o = (s = r.group) == null ? void 0 : s.uuid;
        if (o)
          for (const l in this.selection) {
            if (l === this.config.selectName || l === this.config.hoverName)
              continue;
            const u = this.selection[l][i];
            if (u) {
              l in this._colorsBeforeSelect || (this._colorsBeforeSelect[l] = {}), o in this._colorsBeforeSelect[l] || (this._colorsBeforeSelect[l] = { [o]: /* @__PURE__ */ new Set() });
              for (const d of u)
                this._colorsBeforeSelect[l][o].add(d);
            }
          }
      }
    });
    b(this, "restoreHighlightersAfterDeselect", () => {
      const e2 = this.components.get(He);
      for (const n in this._colorsBeforeSelect) {
        let s = {};
        const i = this._colorsBeforeSelect[n];
        for (const r in i) {
          const o = e2.groups.get(r);
          if (!o)
            continue;
          const l = o.getFragmentMap(i[r]);
          s = { ...s, ...l };
        }
        this.highlightByID(n, s, false, false);
      }
      this._colorsBeforeSelect = {};
    });
    b(this, "clearHover", () => {
      this.selection[this.config.hoverName] = {};
    });
    b(this, "onMouseDown", () => {
      this.enabled && (this._mouseState.down = true);
    });
    b(this, "onMouseUp", async (e2) => {
      const n = this.config.world;
      if (!n)
        throw new Error("No world found!");
      if (!n.renderer)
        throw new Error("This world doesn't have a renderer!");
      if (this.enabled && e2.target === n.renderer.three.domElement) {
        if (this._mouseState.down = false, this._mouseState.moved || e2.button !== 0) {
          this._mouseState.moved = false;
          return;
        }
        if (this._mouseState.moved = false, this.config.autoHighlightOnClick) {
          const s = this.multiple === "none" ? true : !e2[this.multiple];
          await this.highlight(this.config.selectName, s, this.zoomToSelection);
        }
      }
    });
    b(this, "onMouseMove", async () => {
      if (!this.enabled)
        return;
      if (this._mouseState.moved) {
        this.clear(this.config.hoverName);
        return;
      }
      this._mouseState.moved = this._mouseState.down;
      const e2 = {};
      for (const n in this.selection) {
        if (n === this.config.hoverName)
          continue;
        const s = this.selection[n];
        for (const i in s) {
          i in e2 || (e2[i] = /* @__PURE__ */ new Set());
          const r = s[i];
          for (const o of r)
            e2[i].add(o);
        }
      }
      await this.highlight(this.config.hoverName, true, false, e2);
    });
    this.components.add(ri2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.setupEvents(false), this._fills.dispose(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.selection = {};
    for (const e in this.events)
      this.events[e].onClear.reset(), this.events[e].onHighlight.reset();
    this.onSetup.reset(), this.events = {}, this.onDisposed.trigger(ri2.uuid), this.onDisposed.reset();
  }
  /**
   * Adds a new selection with the given name and color.
   * Throws an error if a selection with the same name already exists.
   *
   * @param name - The name of the new selection.
   * @param color - The color to be used for highlighting the selection.
   *
   * @throws Will throw an error if a selection with the same name already exists.
   */
  add(e, n) {
    if (this.selection[e] || this.colors.has(e))
      throw new Error("A selection with that name already exists!");
    this.colors.set(e, n), this.selection[e] = {}, this.events[e] = {
      onHighlight: new $(),
      onClear: new $()
    };
  }
  /**
   * Highlights a fragment based on a raycast from the mouse position.
   *
   * @param name - The name of the selection.
   * @param removePrevious - Whether to remove previous highlights.
   * @param zoomToSelection - Whether to zoom to the highlighted selection.
   * @param exclude - Fragments to exclude from the highlight.
   *
   * @returns The highlighted fragment and its ID, or null if no fragment was highlighted.
   *
   * @throws Will throw an error if the world or a required component is not found.
   * @throws Will throw an error if the selection does not exist.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  async highlight(e, n = true, s = this.zoomToSelection, i = {}) {
    if (!this.enabled)
      return null;
    if (!this.config.world)
      throw new Error("No world found in config!");
    const r = this.config.world;
    if (!this.selection[e])
      throw new Error(`Selection ${e} does not exist.`);
    const o = [], u = this.components.get(He).meshes;
    for (const C of u)
      o.push(C);
    const d = this.components.get(ai);
    for (const C of d.list) {
      const O = C;
      if (O.edges) {
        const B = O.edges.fillMeshes;
        for (const Y of B)
          o.push(Y);
      }
    }
    const g = this.components.get(Dt).get(r).castRay(o);
    if (!g || !g.face)
      return this.clear(e), null;
    const v = g.object;
    if (!v.fragment && v.userData.indexFragmentMap) {
      if (g.faceIndex === void 0 || !v.geometry.index)
        return null;
      const { userData: C } = v, B = C.indexFragmentMap.get(g.faceIndex);
      if (B) {
        await this.highlightByID(
          e,
          B,
          n,
          s,
          i,
          v
        );
        const Y = Object.keys(B)[0];
        return { id: Array.from(B[Y])[0], fragments: B };
      }
      return null;
    }
    const y = v.geometry, x = g.instanceId;
    if (!y || x === void 0)
      return null;
    const A = v.fragment.getItemID(x);
    if (A === null)
      throw new Error("Item ID not found!");
    const R = v.fragment.group;
    if (!R)
      throw new Error("Fragment must belong to a FragmentsGroup!");
    const P = R.getFragmentMap([A]);
    return await this.highlightByID(
      e,
      P,
      n,
      s,
      i
    ), { id: A, fragments: P };
  }
  /**
   * Highlights a fragment based on a given fragment ID map.
   *
   * @param name - The name of the selection.
   * @param fragmentIdMap - The fragment ID map to highlight.
   * @param removePrevious - Whether to remove previous highlights.
   * @param zoomToSelection - Whether to zoom to the highlighted selection.
   * @param exclude - Fragments to exclude from the highlight.
   * @param fillMesh - The fill mesh to also highlight, if any.
   *
   * @returns Promise that resolves when the highlighting is complete.
   *
   * @throws Will throw an error if the selection does not exist.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  async highlightByID(e, n, s = true, i = this.zoomToSelection, r = {}, o = void 0) {
    if (!this.enabled)
      return;
    s && this.clear(e);
    const l = this.components.get(He), u = this.colors.get(e);
    if (!u)
      throw new Error("Color for selection not found!");
    const d = {};
    for (const m in n) {
      const f = n[m], g = r[m];
      for (const v of f)
        (!g || !g.has(v)) && (d[m] || (d[m] = /* @__PURE__ */ new Set()), d[m].add(v));
    }
    for (const m in d) {
      const f = l.list.get(m);
      if (!f)
        continue;
      this.selection[e][m] || (this.selection[e][m] = /* @__PURE__ */ new Set());
      const g = n[m];
      for (const v of g)
        this.selection[e][m].add(v), f.setColor(u, [v]);
      if (f.mesh.userData.fills)
        for (const v of f.mesh.userData.fills)
          this._fills.highlight(e, v, u, n);
    }
    this.events[e].onHighlight.trigger(this.selection[e]), o && this._fills.highlight(e, o, u, n), i && await this.zoomSelection(e);
  }
  /**
   * Clears the selection for the given name or all selections if no name is provided.
   *
   * @param name - The name of the selection to clear. If not provided, clears all selections.
   *
   * @throws Will throw an error if the FragmentsManager is not found.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  clear(e) {
    const n = e ? [e] : Object.keys(this.selection);
    for (const s of n) {
      this._fills.clear(s);
      const i = this.components.get(He), r = this.selection[s];
      for (const o in this.selection[s]) {
        const l = i.list.get(o);
        if (!l)
          continue;
        const u = r[o];
        u && (this.backupColor ? l.setColor(this.backupColor) : l.resetColor(u));
      }
      this.events[s].onClear.trigger(null), this.selection[s] = {};
    }
  }
  /**
   * Sets up the Highlighter with the provided configuration.
   *
   * @param config - Optional configuration for the Highlighter.
   * If not provided, the Highlighter will use the default configuration.
   *
   * @throws Will throw an error if the world or a required component is not found.
   * @throws Will throw an error if the selection already exists.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  setup(e) {
    this.config = { ...this.config, ...e }, this.add(this.config.selectName, this.config.selectionColor), this.add(this.config.hoverName, this.config.hoverColor), this.setupEvents(true), this.enabled = true, this.isSetup = true, this.onSetup.trigger(this);
  }
  async zoomSelection(e) {
    if (!this.config.world)
      throw new Error("No world found in config!");
    const n = this.config.world;
    if (!n.camera.hasCameraControls())
      return;
    const s = this.components.get(Jc), i = this.components.get(He);
    s.reset();
    const r = this.selection[e];
    if (!Object.keys(r).length)
      return;
    for (const A in r) {
      const R = i.list.get(A);
      if (!R)
        continue;
      const P = r[A];
      s.addMesh(R.mesh, P);
    }
    const o = s.getSphere(), l = 1 / 0, u = -1 / 0, { x: d, y: m, z: f } = o.center, g = o.radius === l || d === l || m === l || f === l, v = o.radius === u || d === u || m === u || f === u, y = o.radius === 0;
    if (g || v || y)
      return;
    o.radius *= this.zoomFactor, await n.camera.controls.fitToSphere(o, true);
  }
  setupEvents(e) {
    if (!this.config.world)
      throw new Error("No world found while setting up events!");
    if (this.config.world.isDisposing)
      return;
    if (!this.config.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const n = this.config.world.renderer.three.domElement, s = this.events[this.config.selectName].onHighlight;
    s.remove(this.clearHover), s.remove(this.saveHighlightersBeforeSelect);
    const i = this.events[this.config.selectName].onClear;
    i.remove(this.restoreHighlightersAfterDeselect), n.removeEventListener("mousedown", this.onMouseDown), n.removeEventListener("mouseup", this.onMouseUp), n.removeEventListener("pointermove", this.onMouseMove), e && (s.add(this.clearHover), s.add(this.saveHighlightersBeforeSelect), i.add(this.restoreHighlightersAfterDeselect), n.addEventListener("mousedown", this.onMouseDown), n.addEventListener("mouseup", this.onMouseUp), n.addEventListener("pointermove", this.onMouseMove));
  }
};
b(ri, "uuid", "cb8a76f2-654a-4b50-80c6-66fd83cafd77");
var xc = ri;
var Vr = class Vr2 extends Fe {
  constructor(e) {
    super(e);
    b(this, "onDisposed", new $());
    b(this, "onNavigated", new $());
    b(this, "onExited", new $());
    b(this, "enabled", false);
    b(this, "currentPlan", null);
    b(this, "defaultSectionOffset", 1.5);
    b(this, "defaultCameraOffset", 30);
    b(this, "list", []);
    b(this, "world");
    b(this, "_floorPlanViewCached", false);
    b(this, "_previousCamera", new Vector3());
    b(this, "_previousTarget", new Vector3());
    b(this, "_previousProjection", "Perspective");
    this.components.add(Vr2.uuid, this);
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.onExited.reset(), this.onNavigated.reset(), this.list = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Generates floor plans from the provided IFC model.
   * @param model - The IFC model from which to generate floor plans.
   * @throws Will throw an error if the model does not have properties or if floor plans are not found.
   */
  async generate(e) {
    if (!e.hasProperties)
      throw new Error("Properties are needed to compute plan views!");
    const n = await e.getAllPropertiesOfType(
      IFCBUILDINGSTOREY
    );
    if (!n)
      throw new Error("Floorplans not found!");
    const s = e.coordinationMatrix.elements[13], i = await yn.getUnits(e);
    for (const r of Object.values(n)) {
      const o = { value: 0 };
      this.getAbsoluteFloorHeight(r.ObjectPlacement, o);
      const l = o.value * i + s;
      this.create({
        name: r.Name.value,
        id: r.GlobalId.value,
        normal: new Vector3(0, -1, 0),
        point: new Vector3(0, l, 0),
        ortho: true,
        offset: this.defaultSectionOffset
      });
    }
  }
  /**
   * Creates a new floor plan based on the provided configuration.
   *
   * @param config - The configuration object for the new floor plan.
   * @throws Will throw an error if the world is not set before creating the clipping planes.
   * @throws Will throw a warning if a floor plan with the same id already exists.
   */
  create(e) {
    if (!this.world)
      throw new Error(
        "You must set a world before creating the clipping planes!"
      );
    if (this.list.find((r) => r.id === e.id)) {
      console.warn(`There's already a plan with the id: ${e.id}`);
      return;
    }
    const s = this.createClippingPlane(e), i = { ...e, plane: s };
    this.list.push(i);
  }
  /**
   * Navigates to the floor plan with the specified id.
   *
   * @param id - The id of the floor plan to navigate to.
   * @param animate - Whether to animate the camera movement. Default is false.
   */
  async goTo(e, n = false) {
    var s;
    ((s = this.currentPlan) == null ? void 0 : s.id) !== e && (this.onNavigated.trigger({ id: e }), this.storeCameraPosition(), await this.hidePreviousClippingPlane(), this.updateCurrentPlan(e), await this.activateCurrentPlan(), this.enabled || (await this.moveCameraTo2DPlanPosition(n), this.enabled = true));
  }
  /**
   * Exits the floor plan view and returns to the 3D view.
   *
   * @param animate - Whether to animate the camera movement. Default is false.
   * @returns {Promise<void>}
   */
  async exitPlanView(e = false) {
    if (!this.enabled || !this.world)
      return;
    this.enabled = false, this.onExited.trigger(), this.cacheFloorplanView();
    const n = this.world.camera;
    n.set("Orbit"), await n.projection.set(this._previousProjection), this.currentPlan && this.currentPlan.plane && (this.currentPlan.plane.enabled = false, this.currentPlan.plane.edges.enabled = false, this.currentPlan.plane.edges.visible = false), this.currentPlan = null, await n.controls.setLookAt(
      this._previousCamera.x,
      this._previousCamera.y,
      this._previousCamera.z,
      this._previousTarget.x,
      this._previousTarget.y,
      this._previousTarget.z,
      e
    );
  }
  storeCameraPosition() {
    this.enabled ? this.cacheFloorplanView() : this.store3dCameraPosition();
  }
  createClippingPlane(e) {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    const { normal: n, point: s } = e, i = s.clone();
    e.offset && (i.y += e.offset);
    const r = this.components.get(ai), o = r.Type;
    r.Type = ui;
    const l = r.createFromNormalAndCoplanarPoint(
      this.world,
      n,
      i
    );
    return l.edges.update(), l.visible = false, l.enabled = false, l.edges.enabled = false, l.edges.visible = false, r.Type = o, l;
  }
  cacheFloorplanView() {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    this._floorPlanViewCached = true, this.world.camera.controls.saveState();
  }
  async moveCameraTo2DPlanPosition(e) {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    const n = this.world.camera;
    this._floorPlanViewCached ? await n.controls.reset(e) : await n.controls.setLookAt(0, 100, 0, 0, 0, 0, e);
  }
  async activateCurrentPlan() {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    if (!this.currentPlan)
      throw new Error("Current plan is not defined.");
    const e = this.world.camera;
    this.currentPlan.plane && (this.currentPlan.plane.enabled = true, this.currentPlan.plane.edges.fillNeedsUpdate = true, this.currentPlan.plane.edges.visible = true), e.set("Plan");
    const n = this.currentPlan.ortho ? "Orthographic" : "Perspective";
    await e.projection.set(n);
  }
  store3dCameraPosition() {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    const e = this.world.camera;
    e.three.getWorldPosition(this._previousCamera), e.controls.getTarget(this._previousTarget), this._previousProjection = e.projection.current;
  }
  updateCurrentPlan(e) {
    const n = this.list.find((s) => s.id === e);
    if (!n)
      throw new Error("The specified plan is undefined!");
    this.currentPlan = n;
  }
  async hidePreviousClippingPlane() {
    if (this.currentPlan) {
      const e = this.currentPlan.plane;
      e && (e.enabled = false), this.currentPlan.plane instanceof ui && (this.currentPlan.plane.edges.visible = false);
    }
  }
  getAbsoluteFloorHeight(e, n) {
    const s = e.RelativePlacement.Location.Coordinates;
    n.value += s[2].value, e.PlacementRelTo && this.getAbsoluteFloorHeight(e.PlacementRelTo, n);
  }
};
b(Vr, "uuid", "a80874aa-1c93-43a4-80f2-df346da086b1");
var Sc = Vr;

export {
  ft,
  Uf,
  nn,
  Ip,
  xa,
  yp,
  wp,
  ui,
  Cp,
  ps,
  fc,
  Ah,
  pc,
  mc,
  gc,
  Ec,
  di,
  Ua,
  vc,
  Ic,
  _n,
  yc,
  wc,
  Cc,
  Rp,
  Mp,
  bc,
  xc,
  Sc
};
/*! Bundled license information:

@thatopen/components-front/dist/index.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=chunk-ODJKMZZX.js.map
