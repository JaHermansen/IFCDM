import {
  FILE_DESCRIPTION,
  FILE_NAME,
  Handle,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCELEMENTQUANTITY,
  IFCOPENINGELEMENT,
  IFCOWNERHISTORY,
  IFCPROJECT,
  IFCPROPERTYSET,
  IFCRELAGGREGATES,
  IFCRELASSIGNSTOGROUP,
  IFCRELASSOCIATESCLASSIFICATION,
  IFCRELASSOCIATESMATERIAL,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCRELDEFINESBYPROPERTIES,
  IFCRELDEFINESBYTEMPLATE,
  IFCRELDEFINESBYTYPE,
  IFCSITE,
  IFCSPACE,
  IFCUNITASSIGNMENT,
  IfcAPI2,
  LogLevel,
  Ne,
  Re,
  Ue,
  ae,
  an,
  fn,
  ke,
  web_ifc_api_exports
} from "./chunk-7F5QJTWE.js";
import {
  AmbientLight,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  ColorManagement,
  CylinderGeometry,
  DirectionalLight,
  DoubleSide,
  EdgesGeometry,
  Euler,
  Float32BufferAttribute,
  FrontSide,
  InstancedMesh,
  Line,
  Line3,
  LineBasicMaterial,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  Triangle,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer
} from "./chunk-UZOV2HZI.js";

// node_modules/@thatopen/components/dist/index.mjs
var kn = Object.defineProperty;
var Wn = (l, e, t) => e in l ? kn(l, e, { enumerable: true, configurable: true, writable: true, value: t }) : l[e] = t;
var I = (l, e, t) => (Wn(l, typeof e != "symbol" ? e + "" : e, t), t);
var Mn = 0;
var eo = 1;
var so = 2;
var xi = 2;
var Ys = 1.25;
var bi = 1;
var Cs = 6 * 4 + 4 + 4;
var Us = 65535;
var io = Math.pow(2, -24);
var Vs = Symbol("SKIP_GENERATION");
function no(l) {
  return l.index ? l.index.count : l.attributes.position.count;
}
function pe(l) {
  return no(l) / 3;
}
function oo(l, e = ArrayBuffer) {
  return l > 65535 ? new Uint32Array(new e(4 * l)) : new Uint16Array(new e(2 * l));
}
function ro(l, e) {
  if (!l.index) {
    const t = l.attributes.position.count, s = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = oo(t, s);
    l.setIndex(new BufferAttribute(i, 1));
    for (let o = 0; o < t; o++)
      i[o] = o;
  }
}
function wn(l) {
  const e = pe(l), t = l.drawRange, s = t.start / 3, i = (t.start + t.count) / 3, o = Math.max(0, s), n = Math.min(e, i) - o;
  return [{
    offset: Math.floor(o),
    count: Math.floor(n)
  }];
}
function Dn(l) {
  if (!l.groups || !l.groups.length)
    return wn(l);
  const e = [], t = /* @__PURE__ */ new Set(), s = l.drawRange, i = s.start / 3, o = (s.start + s.count) / 3;
  for (const r of l.groups) {
    const a = r.start / 3, c = (r.start + r.count) / 3;
    t.add(Math.max(i, a)), t.add(Math.min(o, c));
  }
  const n = Array.from(t.values()).sort((r, a) => r - a);
  for (let r = 0; r < n.length - 1; r++) {
    const a = n[r], c = n[r + 1];
    e.push({
      offset: Math.floor(a),
      count: Math.floor(c - a)
    });
  }
  return e;
}
function ao(l) {
  if (l.groups.length === 0)
    return false;
  const e = pe(l), t = Dn(l).sort((o, n) => o.offset - n.offset), s = t[t.length - 1];
  s.count = Math.min(e - s.offset, s.count);
  let i = 0;
  return t.forEach(({ count: o }) => i += o), e !== i;
}
function K(l, e, t) {
  return t.min.x = e[l], t.min.y = e[l + 1], t.min.z = e[l + 2], t.max.x = e[l + 3], t.max.y = e[l + 4], t.max.z = e[l + 5], t;
}
function co(l) {
  l[0] = l[1] = l[2] = 1 / 0, l[3] = l[4] = l[5] = -1 / 0;
}
function vi(l) {
  let e = -1, t = -1 / 0;
  for (let s = 0; s < 3; s++) {
    const i = l[s + 3] - l[s];
    i > t && (t = i, e = s);
  }
  return e;
}
function Bi(l, e) {
  e.set(l);
}
function Yi(l, e, t) {
  let s, i;
  for (let o = 0; o < 3; o++) {
    const n = o + 3;
    s = l[o], i = e[o], t[o] = s < i ? s : i, s = l[n], i = e[n], t[n] = s > i ? s : i;
  }
}
function Qe(l, e, t) {
  for (let s = 0; s < 3; s++) {
    const i = e[l + 2 * s], o = e[l + 2 * s + 1], n = i - o, r = i + o;
    n < t[s] && (t[s] = n), r > t[s + 3] && (t[s + 3] = r);
  }
}
function Re2(l) {
  const e = l[3] - l[0], t = l[4] - l[1], s = l[5] - l[2];
  return 2 * (e * t + t * s + s * e);
}
function Gs(l, e, t, s, i = null) {
  let o = 1 / 0, n = 1 / 0, r = 1 / 0, a = -1 / 0, c = -1 / 0, E = -1 / 0, d = 1 / 0, h = 1 / 0, u = 1 / 0, p = -1 / 0, A = -1 / 0, m = -1 / 0;
  const C = i !== null;
  for (let R = e * 6, F = (e + t) * 6; R < F; R += 6) {
    const f = l[R + 0], T = l[R + 1], O = f - T, _ = f + T;
    O < o && (o = O), _ > a && (a = _), C && f < d && (d = f), C && f > p && (p = f);
    const S = l[R + 2], N = l[R + 3], P = S - N, w = S + N;
    P < n && (n = P), w > c && (c = w), C && S < h && (h = S), C && S > A && (A = S);
    const y = l[R + 4], U = l[R + 5], x = y - U, B = y + U;
    x < r && (r = x), B > E && (E = B), C && y < u && (u = y), C && y > m && (m = y);
  }
  s[0] = o, s[1] = n, s[2] = r, s[3] = a, s[4] = c, s[5] = E, C && (i[0] = d, i[1] = h, i[2] = u, i[3] = p, i[4] = A, i[5] = m);
}
function lo(l, e, t, s) {
  let i = 1 / 0, o = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, c = -1 / 0;
  for (let E = e * 6, d = (e + t) * 6; E < d; E += 6) {
    const h = l[E + 0];
    h < i && (i = h), h > r && (r = h);
    const u = l[E + 2];
    u < o && (o = u), u > a && (a = u);
    const p = l[E + 4];
    p < n && (n = p), p > c && (c = p);
  }
  s[0] = i, s[1] = o, s[2] = n, s[3] = r, s[4] = a, s[5] = c;
}
function ho(l, e) {
  co(e);
  const t = l.attributes.position, s = l.index ? l.index.array : null, i = pe(l), o = new Float32Array(i * 6), n = t.normalized, r = t.array, a = t.offset || 0;
  let c = 3;
  t.isInterleavedBufferAttribute && (c = t.data.stride);
  const E = ["getX", "getY", "getZ"];
  for (let d = 0; d < i; d++) {
    const h = d * 3, u = d * 6;
    let p = h + 0, A = h + 1, m = h + 2;
    s && (p = s[p], A = s[A], m = s[m]), n || (p = p * c + a, A = A * c + a, m = m * c + a);
    for (let C = 0; C < 3; C++) {
      let R, F, f;
      n ? (R = t[E[C]](p), F = t[E[C]](A), f = t[E[C]](m)) : (R = r[p + C], F = r[A + C], f = r[m + C]);
      let T = R;
      F < T && (T = F), f < T && (T = f);
      let O = R;
      F > O && (O = F), f > O && (O = f);
      const _ = (O - T) / 2, S = C * 2;
      o[u + S + 0] = T + _, o[u + S + 1] = _ + (Math.abs(T) + _) * io, T < e[C] && (e[C] = T), O > e[C + 3] && (e[C + 3] = O);
    }
  }
  return o;
}
var Mt = 32;
var Eo = (l, e) => l.candidate - e.candidate;
var Ut = new Array(Mt).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
}));
var je = new Float32Array(6);
function uo(l, e, t, s, i, o) {
  let n = -1, r = 0;
  if (o === Mn)
    n = vi(e), n !== -1 && (r = (e[n] + e[n + 3]) / 2);
  else if (o === eo)
    n = vi(l), n !== -1 && (r = Io(t, s, i, n));
  else if (o === so) {
    const a = Re2(l);
    let c = Ys * i;
    const E = s * 6, d = (s + i) * 6;
    for (let h = 0; h < 3; h++) {
      const u = e[h], m = (e[h + 3] - u) / Mt;
      if (i < Mt / 4) {
        const C = [...Ut];
        C.length = i;
        let R = 0;
        for (let f = E; f < d; f += 6, R++) {
          const T = C[R];
          T.candidate = t[f + 2 * h], T.count = 0;
          const {
            bounds: O,
            leftCacheBounds: _,
            rightCacheBounds: S
          } = T;
          for (let N = 0; N < 3; N++)
            S[N] = 1 / 0, S[N + 3] = -1 / 0, _[N] = 1 / 0, _[N + 3] = -1 / 0, O[N] = 1 / 0, O[N + 3] = -1 / 0;
          Qe(f, t, O);
        }
        C.sort(Eo);
        let F = i;
        for (let f = 0; f < F; f++) {
          const T = C[f];
          for (; f + 1 < F && C[f + 1].candidate === T.candidate; )
            C.splice(f + 1, 1), F--;
        }
        for (let f = E; f < d; f += 6) {
          const T = t[f + 2 * h];
          for (let O = 0; O < F; O++) {
            const _ = C[O];
            T >= _.candidate ? Qe(f, t, _.rightCacheBounds) : (Qe(f, t, _.leftCacheBounds), _.count++);
          }
        }
        for (let f = 0; f < F; f++) {
          const T = C[f], O = T.count, _ = i - T.count, S = T.leftCacheBounds, N = T.rightCacheBounds;
          let P = 0;
          O !== 0 && (P = Re2(S) / a);
          let w = 0;
          _ !== 0 && (w = Re2(N) / a);
          const y = bi + Ys * (P * O + w * _);
          y < c && (n = h, c = y, r = T.candidate);
        }
      } else {
        for (let F = 0; F < Mt; F++) {
          const f = Ut[F];
          f.count = 0, f.candidate = u + m + F * m;
          const T = f.bounds;
          for (let O = 0; O < 3; O++)
            T[O] = 1 / 0, T[O + 3] = -1 / 0;
        }
        for (let F = E; F < d; F += 6) {
          let O = ~~((t[F + 2 * h] - u) / m);
          O >= Mt && (O = Mt - 1);
          const _ = Ut[O];
          _.count++, Qe(F, t, _.bounds);
        }
        const C = Ut[Mt - 1];
        Bi(C.bounds, C.rightCacheBounds);
        for (let F = Mt - 2; F >= 0; F--) {
          const f = Ut[F], T = Ut[F + 1];
          Yi(f.bounds, T.rightCacheBounds, f.rightCacheBounds);
        }
        let R = 0;
        for (let F = 0; F < Mt - 1; F++) {
          const f = Ut[F], T = f.count, O = f.bounds, S = Ut[F + 1].rightCacheBounds;
          T !== 0 && (R === 0 ? Bi(O, je) : Yi(O, je, je)), R += T;
          let N = 0, P = 0;
          R !== 0 && (N = Re2(je) / a);
          const w = i - R;
          w !== 0 && (P = Re2(S) / a);
          const y = bi + Ys * (N * R + P * w);
          y < c && (n = h, c = y, r = f.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);
  return { axis: n, pos: r };
}
function Io(l, e, t, s) {
  let i = 0;
  for (let o = e, n = e + t; o < n; o++)
    i += l[o * 6 + s * 2];
  return i / t;
}
var qe = class {
  constructor() {
  }
};
function fo(l, e, t, s, i, o) {
  let n = s, r = s + i - 1;
  const a = o.pos, c = o.axis * 2;
  for (; ; ) {
    for (; n <= r && t[n * 6 + c] < a; )
      n++;
    for (; n <= r && t[r * 6 + c] >= a; )
      r--;
    if (n < r) {
      for (let E = 0; E < 3; E++) {
        let d = e[n * 3 + E];
        e[n * 3 + E] = e[r * 3 + E], e[r * 3 + E] = d;
      }
      for (let E = 0; E < 6; E++) {
        let d = t[n * 6 + E];
        t[n * 6 + E] = t[r * 6 + E], t[r * 6 + E] = d;
      }
      n++, r--;
    } else
      return n;
  }
}
function po(l, e, t, s, i, o) {
  let n = s, r = s + i - 1;
  const a = o.pos, c = o.axis * 2;
  for (; ; ) {
    for (; n <= r && t[n * 6 + c] < a; )
      n++;
    for (; n <= r && t[r * 6 + c] >= a; )
      r--;
    if (n < r) {
      let E = l[n];
      l[n] = l[r], l[r] = E;
      for (let d = 0; d < 6; d++) {
        let h = t[n * 6 + d];
        t[n * 6 + d] = t[r * 6 + d], t[r * 6 + d] = h;
      }
      n++, r--;
    } else
      return n;
  }
}
function Co(l, e) {
  const t = (l.index ? l.index.count : l.attributes.position.count) / 3, s = t > 2 ** 16, i = s ? 4 : 2, o = e ? new SharedArrayBuffer(t * i) : new ArrayBuffer(t * i), n = s ? new Uint32Array(o) : new Uint16Array(o);
  for (let r = 0, a = n.length; r < a; r++)
    n[r] = r;
  return n;
}
function To(l, e) {
  const t = l.geometry, s = t.index ? t.index.array : null, i = e.maxDepth, o = e.verbose, n = e.maxLeafTris, r = e.strategy, a = e.onProgress, c = pe(t), E = l._indirectBuffer;
  let d = false;
  const h = new Float32Array(6), u = new Float32Array(6), p = ho(t, h), A = e.indirect ? po : fo, m = [], C = e.indirect ? wn(t) : Dn(t);
  if (C.length === 1) {
    const f = C[0], T = new qe();
    T.boundingData = h, lo(p, f.offset, f.count, u), F(T, f.offset, f.count, u), m.push(T);
  } else
    for (let f of C) {
      const T = new qe();
      T.boundingData = new Float32Array(6), Gs(p, f.offset, f.count, T.boundingData, u), F(T, f.offset, f.count, u), m.push(T);
    }
  return m;
  function R(f) {
    a && a(f / c);
  }
  function F(f, T, O, _ = null, S = 0) {
    if (!d && S >= i && (d = true, o && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`), console.warn(t))), O <= n || S >= i)
      return R(T + O), f.offset = T, f.count = O, f;
    const N = uo(f.boundingData, _, p, T, O, r);
    if (N.axis === -1)
      return R(T + O), f.offset = T, f.count = O, f;
    const P = A(E, s, p, T, O, N);
    if (P === T || P === T + O)
      R(T + O), f.offset = T, f.count = O;
    else {
      f.splitAxis = N.axis;
      const w = new qe(), y = T, U = P - T;
      f.left = w, w.boundingData = new Float32Array(6), Gs(p, y, U, w.boundingData, u), F(w, y, U, u, S + 1);
      const x = new qe(), B = P, H = O - U;
      f.right = x, x.boundingData = new Float32Array(6), Gs(p, B, H, x.boundingData, u), F(x, B, H, u, S + 1);
    }
    return f;
  }
}
function mo(l, e) {
  const t = l.geometry;
  e.indirect && (l._indirectBuffer = Co(t, e.useSharedArrayBuffer), ao(t) && !e.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), l._indirectBuffer || ro(t, e);
  const s = To(l, e);
  let i, o, n;
  const r = [], a = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let d = 0; d < s.length; d++) {
    const h = s[d];
    let u = c(h);
    const p = new a(Cs * u);
    i = new Float32Array(p), o = new Uint32Array(p), n = new Uint16Array(p), E(0, h), r.push(p);
  }
  l._roots = r;
  return;
  function c(d) {
    return d.count ? 1 : 1 + c(d.left) + c(d.right);
  }
  function E(d, h) {
    const u = d / 4, p = d / 2, A = !!h.count, m = h.boundingData;
    for (let C = 0; C < 6; C++)
      i[u + C] = m[C];
    if (A) {
      const C = h.offset, R = h.count;
      return o[u + 6] = C, n[p + 14] = R, n[p + 15] = Us, d + Cs;
    } else {
      const C = h.left, R = h.right, F = h.splitAxis;
      let f;
      if (f = E(d + Cs, C), f / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return o[u + 6] = f / 4, f = E(f, R), o[u + 7] = F, f;
    }
  }
}
var wt = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(e, t) {
    let s = 1 / 0, i = -1 / 0;
    for (let o = 0, n = e.length; o < n; o++) {
      const a = e[o][t];
      s = a < s ? a : s, i = a > i ? a : i;
    }
    this.min = s, this.max = i;
  }
  setFromPoints(e, t) {
    let s = 1 / 0, i = -1 / 0;
    for (let o = 0, n = t.length; o < n; o++) {
      const r = t[o], a = e.dot(r);
      s = a < s ? a : s, i = a > i ? a : i;
    }
    this.min = s, this.max = i;
  }
  isSeparated(e) {
    return this.min > e.max || e.min > this.max;
  }
};
wt.prototype.setFromBox = function() {
  const l = new Vector3();
  return function(t, s) {
    const i = s.min, o = s.max;
    let n = 1 / 0, r = -1 / 0;
    for (let a = 0; a <= 1; a++)
      for (let c = 0; c <= 1; c++)
        for (let E = 0; E <= 1; E++) {
          l.x = i.x * a + o.x * (1 - a), l.y = i.y * c + o.y * (1 - c), l.z = i.z * E + o.z * (1 - E);
          const d = t.dot(l);
          n = Math.min(d, n), r = Math.max(d, r);
        }
    this.min = n, this.max = r;
  };
}();
var Ro = function() {
  const l = new Vector3(), e = new Vector3(), t = new Vector3();
  return function(i, o, n) {
    const r = i.start, a = l, c = o.start, E = e;
    t.subVectors(r, c), l.subVectors(i.end, i.start), e.subVectors(o.end, o.start);
    const d = t.dot(E), h = E.dot(a), u = E.dot(E), p = t.dot(a), m = a.dot(a) * u - h * h;
    let C, R;
    m !== 0 ? C = (d * h - p * u) / m : C = 0, R = (d + C * h) / u, n.x = C, n.y = R;
  };
}();
var Oi = function() {
  const l = new Vector2(), e = new Vector3(), t = new Vector3();
  return function(i, o, n, r) {
    Ro(i, o, l);
    let a = l.x, c = l.y;
    if (a >= 0 && a <= 1 && c >= 0 && c <= 1) {
      i.at(a, n), o.at(c, r);
      return;
    } else if (a >= 0 && a <= 1) {
      c < 0 ? o.at(0, r) : o.at(1, r), i.closestPointToPoint(r, true, n);
      return;
    } else if (c >= 0 && c <= 1) {
      a < 0 ? i.at(0, n) : i.at(1, n), o.closestPointToPoint(n, true, r);
      return;
    } else {
      let E;
      a < 0 ? E = i.start : E = i.end;
      let d;
      c < 0 ? d = o.start : d = o.end;
      const h = e, u = t;
      if (i.closestPointToPoint(d, true, e), o.closestPointToPoint(E, true, t), h.distanceToSquared(d) <= u.distanceToSquared(E)) {
        n.copy(h), r.copy(d);
        return;
      } else {
        n.copy(E), r.copy(u);
        return;
      }
    }
  };
}();
var Ao = function() {
  const l = new Vector3(), e = new Vector3(), t = new Plane(), s = new Line3();
  return function(o, n) {
    const { radius: r, center: a } = o, { a: c, b: E, c: d } = n;
    if (s.start = c, s.end = E, s.closestPointToPoint(a, true, l).distanceTo(a) <= r || (s.start = c, s.end = d, s.closestPointToPoint(a, true, l).distanceTo(a) <= r) || (s.start = E, s.end = d, s.closestPointToPoint(a, true, l).distanceTo(a) <= r))
      return true;
    const A = n.getPlane(t);
    if (Math.abs(A.distanceToPoint(a)) <= r) {
      const C = A.projectPoint(a, e);
      if (n.containsPoint(C))
        return true;
    }
    return false;
  };
}();
var Fo = 1e-15;
function zs(l) {
  return Math.abs(l) < Fo;
}
var Ft = class extends Triangle {
  constructor(...e) {
    super(...e), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new wt()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(e) {
    return Ao(e, this);
  }
  update() {
    const e = this.a, t = this.b, s = this.c, i = this.points, o = this.satAxes, n = this.satBounds, r = o[0], a = n[0];
    this.getNormal(r), a.setFromPoints(r, i);
    const c = o[1], E = n[1];
    c.subVectors(e, t), E.setFromPoints(c, i);
    const d = o[2], h = n[2];
    d.subVectors(t, s), h.setFromPoints(d, i);
    const u = o[3], p = n[3];
    u.subVectors(s, e), p.setFromPoints(u, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(r, e), this.needsUpdate = false;
  }
};
Ft.prototype.closestPointToSegment = function() {
  const l = new Vector3(), e = new Vector3(), t = new Line3();
  return function(i, o = null, n = null) {
    const { start: r, end: a } = i, c = this.points;
    let E, d = 1 / 0;
    for (let h = 0; h < 3; h++) {
      const u = (h + 1) % 3;
      t.start.copy(c[h]), t.end.copy(c[u]), Oi(t, i, l, e), E = l.distanceToSquared(e), E < d && (d = E, o && o.copy(l), n && n.copy(e));
    }
    return this.closestPointToPoint(r, l), E = r.distanceToSquared(l), E < d && (d = E, o && o.copy(l), n && n.copy(r)), this.closestPointToPoint(a, l), E = a.distanceToSquared(l), E < d && (d = E, o && o.copy(l), n && n.copy(a)), Math.sqrt(d);
  };
}();
Ft.prototype.intersectsTriangle = function() {
  const l = new Ft(), e = new Array(3), t = new Array(3), s = new wt(), i = new wt(), o = new Vector3(), n = new Vector3(), r = new Vector3(), a = new Vector3(), c = new Vector3(), E = new Line3(), d = new Line3(), h = new Line3(), u = new Vector3();
  function p(A, m, C) {
    const R = A.points;
    let F = 0, f = -1;
    for (let T = 0; T < 3; T++) {
      const { start: O, end: _ } = E;
      O.copy(R[T]), _.copy(R[(T + 1) % 3]), E.delta(n);
      const S = zs(m.distanceToPoint(O));
      if (zs(m.normal.dot(n)) && S) {
        C.copy(E), F = 2;
        break;
      }
      const N = m.intersectLine(E, u);
      if (!N && S && u.copy(O), (N || S) && !zs(u.distanceTo(_))) {
        if (F <= 1)
          (F === 1 ? C.start : C.end).copy(u), S && (f = F);
        else if (F >= 2) {
          (f === 1 ? C.start : C.end).copy(u), F = 2;
          break;
        }
        if (F++, F === 2 && f === -1)
          break;
      }
    }
    return F;
  }
  return function(m, C = null, R = false) {
    this.needsUpdate && this.update(), m.isExtendedTriangle ? m.needsUpdate && m.update() : (l.copy(m), l.update(), m = l);
    const F = this.plane, f = m.plane;
    if (Math.abs(F.normal.dot(f.normal)) > 1 - 1e-10) {
      const T = this.satBounds, O = this.satAxes;
      t[0] = m.a, t[1] = m.b, t[2] = m.c;
      for (let N = 0; N < 4; N++) {
        const P = T[N], w = O[N];
        if (s.setFromPoints(w, t), P.isSeparated(s))
          return false;
      }
      const _ = m.satBounds, S = m.satAxes;
      e[0] = this.a, e[1] = this.b, e[2] = this.c;
      for (let N = 0; N < 4; N++) {
        const P = _[N], w = S[N];
        if (s.setFromPoints(w, e), P.isSeparated(s))
          return false;
      }
      for (let N = 0; N < 4; N++) {
        const P = O[N];
        for (let w = 0; w < 4; w++) {
          const y = S[w];
          if (o.crossVectors(P, y), s.setFromPoints(o, e), i.setFromPoints(o, t), s.isSeparated(i))
            return false;
        }
      }
      return C && (R || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), C.start.set(0, 0, 0), C.end.set(0, 0, 0)), true;
    } else {
      const T = p(this, f, d);
      if (T === 1 && m.containsPoint(d.end))
        return C && (C.start.copy(d.end), C.end.copy(d.end)), true;
      if (T !== 2)
        return false;
      const O = p(m, F, h);
      if (O === 1 && this.containsPoint(h.end))
        return C && (C.start.copy(h.end), C.end.copy(h.end)), true;
      if (O !== 2)
        return false;
      if (d.delta(r), h.delta(a), r.dot(a) < 0) {
        let U = h.start;
        h.start = h.end, h.end = U;
      }
      const _ = d.start.dot(r), S = d.end.dot(r), N = h.start.dot(r), P = h.end.dot(r), w = S < N, y = _ < P;
      return _ !== P && N !== S && w === y ? false : (C && (c.subVectors(d.start, h.start), c.dot(r) > 0 ? C.start.copy(d.start) : C.start.copy(h.start), c.subVectors(d.end, h.end), c.dot(r) < 0 ? C.end.copy(d.end) : C.end.copy(h.end)), true);
    }
  };
}();
Ft.prototype.distanceToPoint = function() {
  const l = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, l), t.distanceTo(l);
  };
}();
Ft.prototype.distanceToTriangle = function() {
  const l = new Vector3(), e = new Vector3(), t = ["a", "b", "c"], s = new Line3(), i = new Line3();
  return function(n, r = null, a = null) {
    const c = r || a ? s : null;
    if (this.intersectsTriangle(n, c))
      return (r || a) && (r && c.getCenter(r), a && c.getCenter(a)), 0;
    let E = 1 / 0;
    for (let d = 0; d < 3; d++) {
      let h;
      const u = t[d], p = n[u];
      this.closestPointToPoint(p, l), h = p.distanceToSquared(l), h < E && (E = h, r && r.copy(l), a && a.copy(p));
      const A = this[u];
      n.closestPointToPoint(A, l), h = A.distanceToSquared(l), h < E && (E = h, r && r.copy(A), a && a.copy(l));
    }
    for (let d = 0; d < 3; d++) {
      const h = t[d], u = t[(d + 1) % 3];
      s.set(this[h], this[u]);
      for (let p = 0; p < 3; p++) {
        const A = t[p], m = t[(p + 1) % 3];
        i.set(n[A], n[m]), Oi(s, i, l, e);
        const C = l.distanceToSquared(e);
        C < E && (E = C, r && r.copy(l), a && a.copy(e));
      }
    }
    return Math.sqrt(E);
  };
}();
var at = class {
  constructor(e, t, s) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new wt()), this.alignedSatBounds = new Array(3).fill().map(() => new wt()), this.needsUpdate = false, e && this.min.copy(e), t && this.max.copy(t), s && this.matrix.copy(s);
  }
  set(e, t, s) {
    this.min.copy(e), this.max.copy(t), this.matrix.copy(s), this.needsUpdate = true;
  }
  copy(e) {
    this.min.copy(e.min), this.max.copy(e.max), this.matrix.copy(e.matrix), this.needsUpdate = true;
  }
};
at.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const e = this.matrix, t = this.min, s = this.max, i = this.points;
    for (let c = 0; c <= 1; c++)
      for (let E = 0; E <= 1; E++)
        for (let d = 0; d <= 1; d++) {
          const h = 1 * c | 2 * E | 4 * d, u = i[h];
          u.x = c ? s.x : t.x, u.y = E ? s.y : t.y, u.z = d ? s.z : t.z, u.applyMatrix4(e);
        }
    const o = this.satBounds, n = this.satAxes, r = i[0];
    for (let c = 0; c < 3; c++) {
      const E = n[c], d = o[c], h = 1 << c, u = i[h];
      E.subVectors(r, u), d.setFromPoints(E, i);
    }
    const a = this.alignedSatBounds;
    a[0].setFromPointsField(i, "x"), a[1].setFromPointsField(i, "y"), a[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  };
}();
at.prototype.intersectsBox = function() {
  const l = new wt();
  return function(t) {
    this.needsUpdate && this.update();
    const s = t.min, i = t.max, o = this.satBounds, n = this.satAxes, r = this.alignedSatBounds;
    if (l.min = s.x, l.max = i.x, r[0].isSeparated(l) || (l.min = s.y, l.max = i.y, r[1].isSeparated(l)) || (l.min = s.z, l.max = i.z, r[2].isSeparated(l)))
      return false;
    for (let a = 0; a < 3; a++) {
      const c = n[a], E = o[a];
      if (l.setFromBox(c, t), E.isSeparated(l))
        return false;
    }
    return true;
  };
}();
at.prototype.intersectsTriangle = function() {
  const l = new Ft(), e = new Array(3), t = new wt(), s = new wt(), i = new Vector3();
  return function(n) {
    this.needsUpdate && this.update(), n.isExtendedTriangle ? n.needsUpdate && n.update() : (l.copy(n), l.update(), n = l);
    const r = this.satBounds, a = this.satAxes;
    e[0] = n.a, e[1] = n.b, e[2] = n.c;
    for (let h = 0; h < 3; h++) {
      const u = r[h], p = a[h];
      if (t.setFromPoints(p, e), u.isSeparated(t))
        return false;
    }
    const c = n.satBounds, E = n.satAxes, d = this.points;
    for (let h = 0; h < 3; h++) {
      const u = c[h], p = E[h];
      if (t.setFromPoints(p, d), u.isSeparated(t))
        return false;
    }
    for (let h = 0; h < 3; h++) {
      const u = a[h];
      for (let p = 0; p < 4; p++) {
        const A = E[p];
        if (i.crossVectors(u, A), t.setFromPoints(i, e), s.setFromPoints(i, d), t.isSeparated(s))
          return false;
      }
    }
    return true;
  };
}();
at.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(e, t) {
    return this.needsUpdate && this.update(), t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  };
}();
at.prototype.distanceToPoint = function() {
  const l = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, l), t.distanceTo(l);
  };
}();
at.prototype.distanceToBox = function() {
  const l = ["x", "y", "z"], e = new Array(12).fill().map(() => new Line3()), t = new Array(12).fill().map(() => new Line3()), s = new Vector3(), i = new Vector3();
  return function(n, r = 0, a = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(n))
      return (a || c) && (n.getCenter(i), this.closestPointToPoint(i, s), n.closestPointToPoint(s, i), a && a.copy(s), c && c.copy(i)), 0;
    const E = r * r, d = n.min, h = n.max, u = this.points;
    let p = 1 / 0;
    for (let m = 0; m < 8; m++) {
      const C = u[m];
      i.copy(C).clamp(d, h);
      const R = C.distanceToSquared(i);
      if (R < p && (p = R, a && a.copy(C), c && c.copy(i), R < E))
        return Math.sqrt(R);
    }
    let A = 0;
    for (let m = 0; m < 3; m++)
      for (let C = 0; C <= 1; C++)
        for (let R = 0; R <= 1; R++) {
          const F = (m + 1) % 3, f = (m + 2) % 3, T = C << F | R << f, O = 1 << m | C << F | R << f, _ = u[T], S = u[O];
          e[A].set(_, S);
          const P = l[m], w = l[F], y = l[f], U = t[A], x = U.start, B = U.end;
          x[P] = d[P], x[w] = C ? d[w] : h[w], x[y] = R ? d[y] : h[w], B[P] = h[P], B[w] = C ? d[w] : h[w], B[y] = R ? d[y] : h[w], A++;
        }
    for (let m = 0; m <= 1; m++)
      for (let C = 0; C <= 1; C++)
        for (let R = 0; R <= 1; R++) {
          i.x = m ? h.x : d.x, i.y = C ? h.y : d.y, i.z = R ? h.z : d.z, this.closestPointToPoint(i, s);
          const F = i.distanceToSquared(s);
          if (F < p && (p = F, a && a.copy(s), c && c.copy(i), F < E))
            return Math.sqrt(F);
        }
    for (let m = 0; m < 12; m++) {
      const C = e[m];
      for (let R = 0; R < 12; R++) {
        const F = t[R];
        Oi(C, F, s, i);
        const f = s.distanceToSquared(i);
        if (f < p && (p = f, a && a.copy(s), c && c.copy(i), f < E))
          return Math.sqrt(f);
      }
    }
    return Math.sqrt(p);
  };
}();
var gi = class {
  constructor(e) {
    this._getNewPrimitive = e, this._primitives = [];
  }
  getPrimitive() {
    const e = this._primitives;
    return e.length === 0 ? this._getNewPrimitive() : e.pop();
  }
  releasePrimitive(e) {
    this._primitives.push(e);
  }
};
var Oo = class extends gi {
  constructor() {
    super(() => new Ft());
  }
};
var It = new Oo();
function ht(l, e) {
  return e[l + 15] === 65535;
}
function Et(l, e) {
  return e[l + 6];
}
function ft(l, e) {
  return e[l + 14];
}
function pt(l) {
  return l + 8;
}
function Ct(l, e) {
  return e[l + 6];
}
function Un(l, e) {
  return e[l + 7];
}
var go = class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const e = [];
    let t = null;
    this.setBuffer = (s) => {
      t && e.push(t), t = s, this.float32Array = new Float32Array(s), this.uint16Array = new Uint16Array(s), this.uint32Array = new Uint32Array(s);
    }, this.clearBuffer = () => {
      t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, e.length !== 0 && this.setBuffer(e.pop());
    };
  }
};
var Z = new go();
var Yt;
var Ie;
var Jt = [];
var Ke = new gi(() => new Box3());
function _o(l, e, t, s, i, o) {
  Yt = Ke.getPrimitive(), Ie = Ke.getPrimitive(), Jt.push(Yt, Ie), Z.setBuffer(l._roots[e]);
  const n = ai(0, l.geometry, t, s, i, o);
  Z.clearBuffer(), Ke.releasePrimitive(Yt), Ke.releasePrimitive(Ie), Jt.pop(), Jt.pop();
  const r = Jt.length;
  return r > 0 && (Ie = Jt[r - 1], Yt = Jt[r - 2]), n;
}
function ai(l, e, t, s, i = null, o = 0, n = 0) {
  const { float32Array: r, uint16Array: a, uint32Array: c } = Z;
  let E = l * 2;
  if (ht(E, a)) {
    const h = Et(l, c), u = ft(E, a);
    return K(l, r, Yt), s(h, u, false, n, o + l, Yt);
  } else {
    let P = function(y) {
      const { uint16Array: U, uint32Array: x } = Z;
      let B = y * 2;
      for (; !ht(B, U); )
        y = pt(y), B = y * 2;
      return Et(y, x);
    }, w = function(y) {
      const { uint16Array: U, uint32Array: x } = Z;
      let B = y * 2;
      for (; !ht(B, U); )
        y = Ct(y, x), B = y * 2;
      return Et(y, x) + ft(B, U);
    };
    const h = pt(l), u = Ct(l, c);
    let p = h, A = u, m, C, R, F;
    if (i && (R = Yt, F = Ie, K(p, r, R), K(A, r, F), m = i(R), C = i(F), C < m)) {
      p = u, A = h;
      const y = m;
      m = C, C = y, R = F;
    }
    R || (R = Yt, K(p, r, R));
    const f = ht(p * 2, a), T = t(R, f, m, n + 1, o + p);
    let O;
    if (T === xi) {
      const y = P(p), x = w(p) - y;
      O = s(y, x, true, n + 1, o + p, R);
    } else
      O = T && ai(
        p,
        e,
        t,
        s,
        i,
        o,
        n + 1
      );
    if (O)
      return true;
    F = Ie, K(A, r, F);
    const _ = ht(A * 2, a), S = t(F, _, C, n + 1, o + A);
    let N;
    if (S === xi) {
      const y = P(A), x = w(A) - y;
      N = s(y, x, true, n + 1, o + A, F);
    } else
      N = S && ai(
        A,
        e,
        t,
        s,
        i,
        o,
        n + 1
      );
    return !!N;
  }
}
var Ae = new Vector3();
var Hs = new Vector3();
function So(l, e, t = {}, s = 0, i = 1 / 0) {
  const o = s * s, n = i * i;
  let r = 1 / 0, a = null;
  if (l.shapecast(
    {
      boundsTraverseOrder: (E) => (Ae.copy(e).clamp(E.min, E.max), Ae.distanceToSquared(e)),
      intersectsBounds: (E, d, h) => h < r && h < n,
      intersectsTriangle: (E, d) => {
        E.closestPointToPoint(e, Ae);
        const h = e.distanceToSquared(Ae);
        return h < r && (Hs.copy(Ae), r = h, a = d), h < o;
      }
    }
  ), r === 1 / 0)
    return null;
  const c = Math.sqrt(r);
  return t.point ? t.point.copy(Hs) : t.point = Hs.clone(), t.distance = c, t.faceIndex = a, t;
}
var te = new Vector3();
var ee = new Vector3();
var se = new Vector3();
var $e = new Vector2();
var Je = new Vector2();
var ts = new Vector2();
var Vi = new Vector3();
var Gi = new Vector3();
var zi = new Vector3();
var es = new Vector3();
function No(l, e, t, s, i, o) {
  let n;
  return o === BackSide ? n = l.intersectTriangle(s, t, e, true, i) : n = l.intersectTriangle(e, t, s, o !== DoubleSide, i), n === null ? null : {
    distance: l.origin.distanceTo(i),
    point: i.clone()
  };
}
function Lo(l, e, t, s, i, o, n, r, a) {
  te.fromBufferAttribute(e, o), ee.fromBufferAttribute(e, n), se.fromBufferAttribute(e, r);
  const c = No(l, te, ee, se, es, a);
  if (c) {
    s && ($e.fromBufferAttribute(s, o), Je.fromBufferAttribute(s, n), ts.fromBufferAttribute(s, r), c.uv = Triangle.getInterpolation(es, te, ee, se, $e, Je, ts, new Vector2())), i && ($e.fromBufferAttribute(i, o), Je.fromBufferAttribute(i, n), ts.fromBufferAttribute(i, r), c.uv1 = Triangle.getInterpolation(es, te, ee, se, $e, Je, ts, new Vector2())), t && (Vi.fromBufferAttribute(t, o), Gi.fromBufferAttribute(t, n), zi.fromBufferAttribute(t, r), c.normal = Triangle.getInterpolation(es, te, ee, se, Vi, Gi, zi, new Vector3()), c.normal.dot(l.direction) > 0 && c.normal.multiplyScalar(-1));
    const E = {
      a: o,
      b: n,
      c: r,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(te, ee, se, E.normal), c.face = E, c.faceIndex = o;
  }
  return c;
}
function xs(l, e, t, s, i) {
  const o = s * 3;
  let n = o + 0, r = o + 1, a = o + 2;
  const c = l.index;
  l.index && (n = c.getX(n), r = c.getX(r), a = c.getX(a));
  const { position: E, normal: d, uv: h, uv1: u } = l.attributes, p = Lo(t, E, d, h, u, n, r, a, e);
  return p ? (p.faceIndex = s, i && i.push(p), p) : null;
}
function tt(l, e, t, s) {
  const i = l.a, o = l.b, n = l.c;
  let r = e, a = e + 1, c = e + 2;
  t && (r = t.getX(r), a = t.getX(a), c = t.getX(c)), i.x = s.getX(r), i.y = s.getY(r), i.z = s.getZ(r), o.x = s.getX(a), o.y = s.getY(a), o.z = s.getZ(a), n.x = s.getX(c), n.y = s.getY(c), n.z = s.getZ(c);
}
function Po(l, e, t, s, i, o) {
  const { geometry: n, _indirectBuffer: r } = l;
  for (let a = s, c = s + i; a < c; a++)
    xs(n, e, t, a, o);
}
function yo(l, e, t, s, i) {
  const { geometry: o, _indirectBuffer: n } = l;
  let r = 1 / 0, a = null;
  for (let c = s, E = s + i; c < E; c++) {
    let d;
    d = xs(o, e, t, c), d && d.distance < r && (a = d, r = d.distance);
  }
  return a;
}
function Mo(l, e, t, s, i, o, n) {
  const { geometry: r } = t, { index: a } = r, c = r.attributes.position;
  for (let E = l, d = e + l; E < d; E++) {
    let h;
    if (h = E, tt(n, h * 3, a, c), n.needsUpdate = true, s(n, h, i, o))
      return true;
  }
  return false;
}
function wo(l, e = null) {
  e && Array.isArray(e) && (e = new Set(e));
  const t = l.geometry, s = t.index ? t.index.array : null, i = t.attributes.position;
  let o, n, r, a, c = 0;
  const E = l._roots;
  for (let h = 0, u = E.length; h < u; h++)
    o = E[h], n = new Uint32Array(o), r = new Uint16Array(o), a = new Float32Array(o), d(0, c), c += o.byteLength;
  function d(h, u, p = false) {
    const A = h * 2;
    if (r[A + 15] === Us) {
      const C = n[h + 6], R = r[A + 14];
      let F = 1 / 0, f = 1 / 0, T = 1 / 0, O = -1 / 0, _ = -1 / 0, S = -1 / 0;
      for (let N = 3 * C, P = 3 * (C + R); N < P; N++) {
        let w = s[N];
        const y = i.getX(w), U = i.getY(w), x = i.getZ(w);
        y < F && (F = y), y > O && (O = y), U < f && (f = U), U > _ && (_ = U), x < T && (T = x), x > S && (S = x);
      }
      return a[h + 0] !== F || a[h + 1] !== f || a[h + 2] !== T || a[h + 3] !== O || a[h + 4] !== _ || a[h + 5] !== S ? (a[h + 0] = F, a[h + 1] = f, a[h + 2] = T, a[h + 3] = O, a[h + 4] = _, a[h + 5] = S, true) : false;
    } else {
      const C = h + 8, R = n[h + 6], F = C + u, f = R + u;
      let T = p, O = false, _ = false;
      e ? T || (O = e.has(F), _ = e.has(f), T = !O && !_) : (O = true, _ = true);
      const S = T || O, N = T || _;
      let P = false;
      S && (P = d(C, u, T));
      let w = false;
      N && (w = d(R, u, T));
      const y = P || w;
      if (y)
        for (let U = 0; U < 3; U++) {
          const x = C + U, B = R + U, H = a[x], q = a[x + 3], st = a[B], Q = a[B + 3];
          a[h + U] = H < st ? H : st, a[h + U + 3] = q > Q ? q : Q;
        }
      return y;
    }
  }
}
var Hi = new Box3();
function Gt(l, e, t, s) {
  return K(l, e, Hi), t.intersectBox(Hi, s);
}
function Do(l, e, t, s, i, o) {
  const { geometry: n, _indirectBuffer: r } = l;
  for (let a = s, c = s + i; a < c; a++) {
    let E = r ? r[a] : a;
    xs(n, e, t, E, o);
  }
}
function Uo(l, e, t, s, i) {
  const { geometry: o, _indirectBuffer: n } = l;
  let r = 1 / 0, a = null;
  for (let c = s, E = s + i; c < E; c++) {
    let d;
    d = xs(o, e, t, n ? n[c] : c), d && d.distance < r && (a = d, r = d.distance);
  }
  return a;
}
function xo(l, e, t, s, i, o, n) {
  const { geometry: r } = t, { index: a } = r, c = r.attributes.position;
  for (let E = l, d = e + l; E < d; E++) {
    let h;
    if (h = t.resolveTriangleIndex(E), tt(n, h * 3, a, c), n.needsUpdate = true, s(n, h, i, o))
      return true;
  }
  return false;
}
var ki = new Vector3();
function bo(l, e, t, s, i) {
  Z.setBuffer(l._roots[e]), ci(0, l, t, s, i), Z.clearBuffer();
}
function ci(l, e, t, s, i) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z, a = l * 2;
  if (ht(a, n)) {
    const E = Et(l, r), d = ft(a, n);
    Po(e, t, s, E, d, i);
  } else {
    const E = pt(l);
    Gt(E, o, s, ki) && ci(E, e, t, s, i);
    const d = Ct(l, r);
    Gt(d, o, s, ki) && ci(d, e, t, s, i);
  }
}
var Wi = new Vector3();
var vo = ["x", "y", "z"];
function Bo(l, e, t, s) {
  Z.setBuffer(l._roots[e]);
  const i = li(0, l, t, s);
  return Z.clearBuffer(), i;
}
function li(l, e, t, s) {
  const { float32Array: i, uint16Array: o, uint32Array: n } = Z;
  let r = l * 2;
  if (ht(r, o)) {
    const c = Et(l, n), E = ft(r, o);
    return yo(e, t, s, c, E);
  } else {
    const c = Un(l, n), E = vo[c], h = s.direction[E] >= 0;
    let u, p;
    h ? (u = pt(l), p = Ct(l, n)) : (u = Ct(l, n), p = pt(l));
    const m = Gt(u, i, s, Wi) ? li(u, e, t, s) : null;
    if (m) {
      const F = m.point[E];
      if (h ? F <= i[p + c] : (
        // min bounding data
        F >= i[p + c + 3]
      ))
        return m;
    }
    const R = Gt(p, i, s, Wi) ? li(p, e, t, s) : null;
    return m && R ? m.distance <= R.distance ? m : R : m || R || null;
  }
}
var ss = new Box3();
var ie = new Ft();
var ne = new Ft();
var Fe = new Matrix4();
var Xi = new at();
var is = new at();
function Yo(l, e, t, s) {
  Z.setBuffer(l._roots[e]);
  const i = hi(0, l, t, s);
  return Z.clearBuffer(), i;
}
function hi(l, e, t, s, i = null) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z;
  let a = l * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), Xi.set(t.boundingBox.min, t.boundingBox.max, s), i = Xi), ht(a, n)) {
    const E = e.geometry, d = E.index, h = E.attributes.position, u = t.index, p = t.attributes.position, A = Et(l, r), m = ft(a, n);
    if (Fe.copy(s).invert(), t.boundsTree)
      return K(l, o, is), is.matrix.copy(Fe), is.needsUpdate = true, t.boundsTree.shapecast({
        intersectsBounds: (R) => is.intersectsBox(R),
        intersectsTriangle: (R) => {
          R.a.applyMatrix4(s), R.b.applyMatrix4(s), R.c.applyMatrix4(s), R.needsUpdate = true;
          for (let F = A * 3, f = (m + A) * 3; F < f; F += 3)
            if (tt(ne, F, d, h), ne.needsUpdate = true, R.intersectsTriangle(ne))
              return true;
          return false;
        }
      });
    for (let C = A * 3, R = (m + A) * 3; C < R; C += 3) {
      tt(ie, C, d, h), ie.a.applyMatrix4(Fe), ie.b.applyMatrix4(Fe), ie.c.applyMatrix4(Fe), ie.needsUpdate = true;
      for (let F = 0, f = u.count; F < f; F += 3)
        if (tt(ne, F, u, p), ne.needsUpdate = true, ie.intersectsTriangle(ne))
          return true;
    }
  } else {
    const E = l + 8, d = r[l + 6];
    return K(E, o, ss), !!(i.intersectsBox(ss) && hi(E, e, t, s, i) || (K(d, o, ss), i.intersectsBox(ss) && hi(d, e, t, s, i)));
  }
}
var ns = new Matrix4();
var ks = new at();
var Oe = new at();
var Vo = new Vector3();
var Go = new Vector3();
var zo = new Vector3();
var Ho = new Vector3();
function ko(l, e, t, s = {}, i = {}, o = 0, n = 1 / 0) {
  e.boundingBox || e.computeBoundingBox(), ks.set(e.boundingBox.min, e.boundingBox.max, t), ks.needsUpdate = true;
  const r = l.geometry, a = r.attributes.position, c = r.index, E = e.attributes.position, d = e.index, h = It.getPrimitive(), u = It.getPrimitive();
  let p = Vo, A = Go, m = null, C = null;
  i && (m = zo, C = Ho);
  let R = 1 / 0, F = null, f = null;
  return ns.copy(t).invert(), Oe.matrix.copy(ns), l.shapecast(
    {
      boundsTraverseOrder: (T) => ks.distanceToBox(T),
      intersectsBounds: (T, O, _) => _ < R && _ < n ? (O && (Oe.min.copy(T.min), Oe.max.copy(T.max), Oe.needsUpdate = true), true) : false,
      intersectsRange: (T, O) => {
        if (e.boundsTree)
          return e.boundsTree.shapecast({
            boundsTraverseOrder: (S) => Oe.distanceToBox(S),
            intersectsBounds: (S, N, P) => P < R && P < n,
            intersectsRange: (S, N) => {
              for (let P = S, w = S + N; P < w; P++) {
                tt(u, 3 * P, d, E), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
                for (let y = T, U = T + O; y < U; y++) {
                  tt(h, 3 * y, c, a), h.needsUpdate = true;
                  const x = h.distanceToTriangle(u, p, m);
                  if (x < R && (A.copy(p), C && C.copy(m), R = x, F = y, f = P), x < o)
                    return true;
                }
              }
            }
          });
        {
          const _ = pe(e);
          for (let S = 0, N = _; S < N; S++) {
            tt(u, 3 * S, d, E), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
            for (let P = T, w = T + O; P < w; P++) {
              tt(h, 3 * P, c, a), h.needsUpdate = true;
              const y = h.distanceToTriangle(u, p, m);
              if (y < R && (A.copy(p), C && C.copy(m), R = y, F = P, f = S), y < o)
                return true;
            }
          }
        }
      }
    }
  ), It.releasePrimitive(h), It.releasePrimitive(u), R === 1 / 0 ? null : (s.point ? s.point.copy(A) : s.point = A.clone(), s.distance = R, s.faceIndex = F, i && (i.point ? i.point.copy(C) : i.point = C.clone(), i.point.applyMatrix4(ns), A.applyMatrix4(ns), i.distance = A.sub(i.point).length(), i.faceIndex = f), s);
}
function Wo(l, e = null) {
  e && Array.isArray(e) && (e = new Set(e));
  const t = l.geometry, s = t.index ? t.index.array : null, i = t.attributes.position;
  let o, n, r, a, c = 0;
  const E = l._roots;
  for (let h = 0, u = E.length; h < u; h++)
    o = E[h], n = new Uint32Array(o), r = new Uint16Array(o), a = new Float32Array(o), d(0, c), c += o.byteLength;
  function d(h, u, p = false) {
    const A = h * 2;
    if (r[A + 15] === Us) {
      const C = n[h + 6], R = r[A + 14];
      let F = 1 / 0, f = 1 / 0, T = 1 / 0, O = -1 / 0, _ = -1 / 0, S = -1 / 0;
      for (let N = C, P = C + R; N < P; N++) {
        const w = 3 * l.resolveTriangleIndex(N);
        for (let y = 0; y < 3; y++) {
          let U = w + y;
          U = s ? s[U] : U;
          const x = i.getX(U), B = i.getY(U), H = i.getZ(U);
          x < F && (F = x), x > O && (O = x), B < f && (f = B), B > _ && (_ = B), H < T && (T = H), H > S && (S = H);
        }
      }
      return a[h + 0] !== F || a[h + 1] !== f || a[h + 2] !== T || a[h + 3] !== O || a[h + 4] !== _ || a[h + 5] !== S ? (a[h + 0] = F, a[h + 1] = f, a[h + 2] = T, a[h + 3] = O, a[h + 4] = _, a[h + 5] = S, true) : false;
    } else {
      const C = h + 8, R = n[h + 6], F = C + u, f = R + u;
      let T = p, O = false, _ = false;
      e ? T || (O = e.has(F), _ = e.has(f), T = !O && !_) : (O = true, _ = true);
      const S = T || O, N = T || _;
      let P = false;
      S && (P = d(C, u, T));
      let w = false;
      N && (w = d(R, u, T));
      const y = P || w;
      if (y)
        for (let U = 0; U < 3; U++) {
          const x = C + U, B = R + U, H = a[x], q = a[x + 3], st = a[B], Q = a[B + 3];
          a[h + U] = H < st ? H : st, a[h + U + 3] = q > Q ? q : Q;
        }
      return y;
    }
  }
}
var Zi = new Vector3();
function Xo(l, e, t, s, i) {
  Z.setBuffer(l._roots[e]), Ei(0, l, t, s, i), Z.clearBuffer();
}
function Ei(l, e, t, s, i) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z, a = l * 2;
  if (ht(a, n)) {
    const E = Et(l, r), d = ft(a, n);
    Do(e, t, s, E, d, i);
  } else {
    const E = pt(l);
    Gt(E, o, s, Zi) && Ei(E, e, t, s, i);
    const d = Ct(l, r);
    Gt(d, o, s, Zi) && Ei(d, e, t, s, i);
  }
}
var Qi = new Vector3();
var Zo = ["x", "y", "z"];
function Qo(l, e, t, s) {
  Z.setBuffer(l._roots[e]);
  const i = di(0, l, t, s);
  return Z.clearBuffer(), i;
}
function di(l, e, t, s) {
  const { float32Array: i, uint16Array: o, uint32Array: n } = Z;
  let r = l * 2;
  if (ht(r, o)) {
    const c = Et(l, n), E = ft(r, o);
    return Uo(e, t, s, c, E);
  } else {
    const c = Un(l, n), E = Zo[c], h = s.direction[E] >= 0;
    let u, p;
    h ? (u = pt(l), p = Ct(l, n)) : (u = Ct(l, n), p = pt(l));
    const m = Gt(u, i, s, Qi) ? di(u, e, t, s) : null;
    if (m) {
      const F = m.point[E];
      if (h ? F <= i[p + c] : (
        // min bounding data
        F >= i[p + c + 3]
      ))
        return m;
    }
    const R = Gt(p, i, s, Qi) ? di(p, e, t, s) : null;
    return m && R ? m.distance <= R.distance ? m : R : m || R || null;
  }
}
var os = new Box3();
var oe = new Ft();
var re = new Ft();
var ge = new Matrix4();
var ji = new at();
var rs = new at();
function jo(l, e, t, s) {
  Z.setBuffer(l._roots[e]);
  const i = ui(0, l, t, s);
  return Z.clearBuffer(), i;
}
function ui(l, e, t, s, i = null) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z;
  let a = l * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), ji.set(t.boundingBox.min, t.boundingBox.max, s), i = ji), ht(a, n)) {
    const E = e.geometry, d = E.index, h = E.attributes.position, u = t.index, p = t.attributes.position, A = Et(l, r), m = ft(a, n);
    if (ge.copy(s).invert(), t.boundsTree)
      return K(l, o, rs), rs.matrix.copy(ge), rs.needsUpdate = true, t.boundsTree.shapecast({
        intersectsBounds: (R) => rs.intersectsBox(R),
        intersectsTriangle: (R) => {
          R.a.applyMatrix4(s), R.b.applyMatrix4(s), R.c.applyMatrix4(s), R.needsUpdate = true;
          for (let F = A, f = m + A; F < f; F++)
            if (tt(re, 3 * e.resolveTriangleIndex(F), d, h), re.needsUpdate = true, R.intersectsTriangle(re))
              return true;
          return false;
        }
      });
    for (let C = A, R = m + A; C < R; C++) {
      const F = e.resolveTriangleIndex(C);
      tt(oe, 3 * F, d, h), oe.a.applyMatrix4(ge), oe.b.applyMatrix4(ge), oe.c.applyMatrix4(ge), oe.needsUpdate = true;
      for (let f = 0, T = u.count; f < T; f += 3)
        if (tt(re, f, u, p), re.needsUpdate = true, oe.intersectsTriangle(re))
          return true;
    }
  } else {
    const E = l + 8, d = r[l + 6];
    return K(E, o, os), !!(i.intersectsBox(os) && ui(E, e, t, s, i) || (K(d, o, os), i.intersectsBox(os) && ui(d, e, t, s, i)));
  }
}
var as = new Matrix4();
var Ws = new at();
var _e = new at();
var qo = new Vector3();
var Ko = new Vector3();
var $o = new Vector3();
var Jo = new Vector3();
function tr(l, e, t, s = {}, i = {}, o = 0, n = 1 / 0) {
  e.boundingBox || e.computeBoundingBox(), Ws.set(e.boundingBox.min, e.boundingBox.max, t), Ws.needsUpdate = true;
  const r = l.geometry, a = r.attributes.position, c = r.index, E = e.attributes.position, d = e.index, h = It.getPrimitive(), u = It.getPrimitive();
  let p = qo, A = Ko, m = null, C = null;
  i && (m = $o, C = Jo);
  let R = 1 / 0, F = null, f = null;
  return as.copy(t).invert(), _e.matrix.copy(as), l.shapecast(
    {
      boundsTraverseOrder: (T) => Ws.distanceToBox(T),
      intersectsBounds: (T, O, _) => _ < R && _ < n ? (O && (_e.min.copy(T.min), _e.max.copy(T.max), _e.needsUpdate = true), true) : false,
      intersectsRange: (T, O) => {
        if (e.boundsTree) {
          const _ = e.boundsTree;
          return _.shapecast({
            boundsTraverseOrder: (S) => _e.distanceToBox(S),
            intersectsBounds: (S, N, P) => P < R && P < n,
            intersectsRange: (S, N) => {
              for (let P = S, w = S + N; P < w; P++) {
                const y = _.resolveTriangleIndex(P);
                tt(u, 3 * y, d, E), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
                for (let U = T, x = T + O; U < x; U++) {
                  const B = l.resolveTriangleIndex(U);
                  tt(h, 3 * B, c, a), h.needsUpdate = true;
                  const H = h.distanceToTriangle(u, p, m);
                  if (H < R && (A.copy(p), C && C.copy(m), R = H, F = U, f = P), H < o)
                    return true;
                }
              }
            }
          });
        } else {
          const _ = pe(e);
          for (let S = 0, N = _; S < N; S++) {
            tt(u, 3 * S, d, E), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
            for (let P = T, w = T + O; P < w; P++) {
              const y = l.resolveTriangleIndex(P);
              tt(h, 3 * y, c, a), h.needsUpdate = true;
              const U = h.distanceToTriangle(u, p, m);
              if (U < R && (A.copy(p), C && C.copy(m), R = U, F = P, f = S), U < o)
                return true;
            }
          }
        }
      }
    }
  ), It.releasePrimitive(h), It.releasePrimitive(u), R === 1 / 0 ? null : (s.point ? s.point.copy(A) : s.point = A.clone(), s.distance = R, s.faceIndex = F, i && (i.point ? i.point.copy(C) : i.point = C.clone(), i.point.applyMatrix4(as), A.applyMatrix4(as), i.distance = A.sub(i.point).length(), i.faceIndex = f), s);
}
function er() {
  return typeof SharedArrayBuffer < "u";
}
var xe = new Z.constructor();
var As = new Z.constructor();
var vt = new gi(() => new Box3());
var ae2 = new Box3();
var ce = new Box3();
var Xs = new Box3();
var Zs = new Box3();
var Qs = false;
function sr(l, e, t, s) {
  if (Qs)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Qs = true;
  const i = l._roots, o = e._roots;
  let n, r = 0, a = 0;
  const c = new Matrix4().copy(t).invert();
  for (let E = 0, d = i.length; E < d; E++) {
    xe.setBuffer(i[E]), a = 0;
    const h = vt.getPrimitive();
    K(0, xe.float32Array, h), h.applyMatrix4(c);
    for (let u = 0, p = o.length; u < p && (As.setBuffer(o[E]), n = Tt(
      0,
      0,
      t,
      c,
      s,
      r,
      a,
      0,
      0,
      h
    ), As.clearBuffer(), a += o[u].length, !n); u++)
      ;
    if (vt.releasePrimitive(h), xe.clearBuffer(), r += i[E].length, n)
      break;
  }
  return Qs = false, n;
}
function Tt(l, e, t, s, i, o = 0, n = 0, r = 0, a = 0, c = null, E = false) {
  let d, h;
  E ? (d = As, h = xe) : (d = xe, h = As);
  const u = d.float32Array, p = d.uint32Array, A = d.uint16Array, m = h.float32Array, C = h.uint32Array, R = h.uint16Array, F = l * 2, f = e * 2, T = ht(F, A), O = ht(f, R);
  let _ = false;
  if (O && T)
    E ? _ = i(
      Et(e, C),
      ft(e * 2, R),
      Et(l, p),
      ft(l * 2, A),
      a,
      n + e,
      r,
      o + l
    ) : _ = i(
      Et(l, p),
      ft(l * 2, A),
      Et(e, C),
      ft(e * 2, R),
      r,
      o + l,
      a,
      n + e
    );
  else if (O) {
    const S = vt.getPrimitive();
    K(e, m, S), S.applyMatrix4(t);
    const N = pt(l), P = Ct(l, p);
    K(N, u, ae2), K(P, u, ce);
    const w = S.intersectsBox(ae2), y = S.intersectsBox(ce);
    _ = w && Tt(
      e,
      N,
      s,
      t,
      i,
      n,
      o,
      a,
      r + 1,
      S,
      !E
    ) || y && Tt(
      e,
      P,
      s,
      t,
      i,
      n,
      o,
      a,
      r + 1,
      S,
      !E
    ), vt.releasePrimitive(S);
  } else {
    const S = pt(e), N = Ct(e, C);
    K(S, m, Xs), K(N, m, Zs);
    const P = c.intersectsBox(Xs), w = c.intersectsBox(Zs);
    if (P && w)
      _ = Tt(
        l,
        S,
        t,
        s,
        i,
        o,
        n,
        r,
        a + 1,
        c,
        E
      ) || Tt(
        l,
        N,
        t,
        s,
        i,
        o,
        n,
        r,
        a + 1,
        c,
        E
      );
    else if (P)
      if (T)
        _ = Tt(
          l,
          S,
          t,
          s,
          i,
          o,
          n,
          r,
          a + 1,
          c,
          E
        );
      else {
        const y = vt.getPrimitive();
        y.copy(Xs).applyMatrix4(t);
        const U = pt(l), x = Ct(l, p);
        K(U, u, ae2), K(x, u, ce);
        const B = y.intersectsBox(ae2), H = y.intersectsBox(ce);
        _ = B && Tt(
          S,
          U,
          s,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          y,
          !E
        ) || H && Tt(
          S,
          x,
          s,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          y,
          !E
        ), vt.releasePrimitive(y);
      }
    else if (w)
      if (T)
        _ = Tt(
          l,
          N,
          t,
          s,
          i,
          o,
          n,
          r,
          a + 1,
          c,
          E
        );
      else {
        const y = vt.getPrimitive();
        y.copy(Zs).applyMatrix4(t);
        const U = pt(l), x = Ct(l, p);
        K(U, u, ae2), K(x, u, ce);
        const B = y.intersectsBox(ae2), H = y.intersectsBox(ce);
        _ = B && Tt(
          N,
          U,
          s,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          y,
          !E
        ) || H && Tt(
          N,
          x,
          s,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          y,
          !E
        ), vt.releasePrimitive(y);
      }
  }
  return _;
}
var cs = new at();
var qi = new Box3();
var _i = class __i {
  static serialize(e, t = {}) {
    t = {
      cloneBuffers: true,
      ...t
    };
    const s = e.geometry, i = e._roots, o = e._indirectBuffer, n = s.getIndex();
    let r;
    return t.cloneBuffers ? r = {
      roots: i.map((a) => a.slice()),
      index: n.array.slice(),
      indirectBuffer: o ? o.slice() : null
    } : r = {
      roots: i,
      index: n.array,
      indirectBuffer: o
    }, r;
  }
  static deserialize(e, t, s = {}) {
    s = {
      setIndex: true,
      indirect: !!e.indirectBuffer,
      ...s
    };
    const { index: i, roots: o, indirectBuffer: n } = e, r = new __i(t, { ...s, [Vs]: true });
    if (r._roots = o, r._indirectBuffer = n || null, s.setIndex) {
      const a = t.getIndex();
      if (a === null) {
        const c = new BufferAttribute(e.index, 1, false);
        t.setIndex(c);
      } else
        a.array !== i && (a.array.set(i), a.needsUpdate = true);
    }
    return r;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(e, t = {}) {
    if (e.isBufferGeometry) {
      if (e.index && e.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (t = Object.assign({
      strategy: Mn,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Vs]: false
    }, t), t.useSharedArrayBuffer && !er())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = e, this._roots = null, this._indirectBuffer = null, t[Vs] || (mo(this, t), !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new Box3())));
    const { _indirectBuffer: s } = this;
    this.resolveTriangleIndex = t.indirect ? (i) => s[i] : (i) => i;
  }
  refit(e = null) {
    return (this.indirect ? Wo : wo)(this, e);
  }
  traverse(e, t = 0) {
    const s = this._roots[t], i = new Uint32Array(s), o = new Uint16Array(s);
    n(0);
    function n(r, a = 0) {
      const c = r * 2, E = o[c + 15] === Us;
      if (E) {
        const d = i[r + 6], h = o[c + 14];
        e(a, E, new Float32Array(s, r * 4, 6), d, h);
      } else {
        const d = r + Cs / 4, h = i[r + 6], u = i[r + 7];
        e(a, E, new Float32Array(s, r * 4, 6), u) || (n(d, a + 1), n(h, a + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(e, t = FrontSide) {
    const s = this._roots, i = this.geometry, o = [], n = t.isMaterial, r = Array.isArray(t), a = i.groups, c = n ? t.side : t, E = this.indirect ? Xo : bo;
    for (let d = 0, h = s.length; d < h; d++) {
      const u = r ? t[a[d].materialIndex].side : c, p = o.length;
      if (E(this, d, u, e, o), r) {
        const A = a[d].materialIndex;
        for (let m = p, C = o.length; m < C; m++)
          o[m].face.materialIndex = A;
      }
    }
    return o;
  }
  raycastFirst(e, t = FrontSide) {
    const s = this._roots, i = this.geometry, o = t.isMaterial, n = Array.isArray(t);
    let r = null;
    const a = i.groups, c = o ? t.side : t, E = this.indirect ? Qo : Bo;
    for (let d = 0, h = s.length; d < h; d++) {
      const u = n ? t[a[d].materialIndex].side : c, p = E(this, d, u, e);
      p != null && (r == null || p.distance < r.distance) && (r = p, n && (p.face.materialIndex = a[d].materialIndex));
    }
    return r;
  }
  intersectsGeometry(e, t) {
    let s = false;
    const i = this._roots, o = this.indirect ? jo : Yo;
    for (let n = 0, r = i.length; n < r && (s = o(this, n, e, t), !s); n++)
      ;
    return s;
  }
  shapecast(e) {
    const t = It.getPrimitive(), s = this.indirect ? xo : Mo;
    let {
      boundsTraverseOrder: i,
      intersectsBounds: o,
      intersectsRange: n,
      intersectsTriangle: r
    } = e;
    if (n && r) {
      const d = n;
      n = (h, u, p, A, m) => d(h, u, p, A, m) ? true : s(h, u, this, r, p, A, t);
    } else
      n || (r ? n = (d, h, u, p) => s(d, h, this, r, u, p, t) : n = (d, h, u) => u);
    let a = false, c = 0;
    const E = this._roots;
    for (let d = 0, h = E.length; d < h; d++) {
      const u = E[d];
      if (a = _o(this, d, o, n, i, c), a)
        break;
      c += u.byteLength;
    }
    return It.releasePrimitive(t), a;
  }
  bvhcast(e, t, s) {
    let {
      intersectsRanges: i,
      intersectsTriangles: o
    } = s;
    const n = It.getPrimitive(), r = this.geometry.index, a = this.geometry.attributes.position, c = this.indirect ? (p) => {
      const A = this.resolveTriangleIndex(p);
      tt(n, A * 3, r, a);
    } : (p) => {
      tt(n, p * 3, r, a);
    }, E = It.getPrimitive(), d = e.geometry.index, h = e.geometry.attributes.position, u = e.indirect ? (p) => {
      const A = e.resolveTriangleIndex(p);
      tt(E, A * 3, d, h);
    } : (p) => {
      tt(E, p * 3, d, h);
    };
    if (o) {
      const p = (A, m, C, R, F, f, T, O) => {
        for (let _ = C, S = C + R; _ < S; _++) {
          u(_), E.a.applyMatrix4(t), E.b.applyMatrix4(t), E.c.applyMatrix4(t), E.needsUpdate = true;
          for (let N = A, P = A + m; N < P; N++)
            if (c(N), n.needsUpdate = true, o(n, E, N, _, F, f, T, O))
              return true;
        }
        return false;
      };
      if (i) {
        const A = i;
        i = function(m, C, R, F, f, T, O, _) {
          return A(m, C, R, F, f, T, O, _) ? true : p(m, C, R, F, f, T, O, _);
        };
      } else
        i = p;
    }
    return sr(this, e, t, i);
  }
  /* Derived Cast Functions */
  intersectsBox(e, t) {
    return cs.set(e.min, e.max, t), cs.needsUpdate = true, this.shapecast(
      {
        intersectsBounds: (s) => cs.intersectsBox(s),
        intersectsTriangle: (s) => cs.intersectsTriangle(s)
      }
    );
  }
  intersectsSphere(e) {
    return this.shapecast(
      {
        intersectsBounds: (t) => e.intersectsBox(t),
        intersectsTriangle: (t) => t.intersectsSphere(e)
      }
    );
  }
  closestPointToGeometry(e, t, s = {}, i = {}, o = 0, n = 1 / 0) {
    return (this.indirect ? tr : ko)(
      this,
      e,
      t,
      s,
      i,
      o,
      n
    );
  }
  closestPointToPoint(e, t = {}, s = 0, i = 1 / 0) {
    return So(
      this,
      e,
      t,
      s,
      i
    );
  }
  getBoundingBox(e) {
    return e.makeEmpty(), this._roots.forEach((s) => {
      K(0, new Float32Array(s), qi), e.union(qi);
    }), e;
  }
};
function Ki(l, e, t) {
  return l === null || (l.point.applyMatrix4(e.matrixWorld), l.distance = l.point.distanceTo(t.ray.origin), l.object = e, l.distance < t.near || l.distance > t.far) ? null : l;
}
var js = new Ray();
var $i = new Matrix4();
var ir = Mesh.prototype.raycast;
function nr(l, e) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    $i.copy(this.matrixWorld).invert(), js.copy(l.ray).applyMatrix4($i);
    const t = this.geometry.boundsTree;
    if (l.firstHitOnly === true) {
      const s = Ki(t.raycastFirst(js, this.material), this, l);
      s && e.push(s);
    } else {
      const s = t.raycast(js, this.material);
      for (let i = 0, o = s.length; i < o; i++) {
        const n = Ki(s[i], this, l);
        n && e.push(n);
      }
    }
  } else
    ir.call(this, l, e);
}
function or(l) {
  return this.boundsTree = new _i(this, l), this.boundsTree;
}
function rr() {
  this.boundsTree = null;
}
var D = class {
  constructor() {
    I(this, "trigger", (e) => {
      const t = this.handlers.slice(0);
      for (const s of t)
        s(e);
    });
    I(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(e) {
    this.handlers.push(e);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(e) {
    this.handlers = this.handlers.filter((t) => t !== e);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var Ts = class {
  constructor() {
    I(this, "trigger", async (e) => {
      const t = this.handlers.slice(0);
      for (const s of t)
        await s(e);
    });
    I(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(e) {
    this.handlers.push(e);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(e) {
    this.handlers = this.handlers.filter((t) => t !== e);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var Si = class {
  constructor(e) {
    I(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this);
    I(this, "isResizeable", () => "resize" in this && "getSize" in this);
    I(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this);
    I(this, "isHideable", () => "visible" in this);
    I(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this);
    this.components = e;
  }
};
var et = class extends Si {
};
var Ni = class extends Si {
  constructor(t) {
    super(t);
    I(this, "worlds", /* @__PURE__ */ new Map());
    I(this, "onWorldChanged", new D());
    I(this, "currentWorld", null);
    this.onWorldChanged.add(({ world: s, action: i }) => {
      i === "removed" && this.worlds.delete(s.uuid);
    });
  }
};
var ar = class extends Ni {
  constructor() {
    super(...arguments);
    I(this, "hasCameraControls", () => "controls" in this);
  }
};
var cr = class extends Ni {
  constructor() {
    super(...arguments);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "onResize", new D());
    I(this, "onClippingPlanesUpdated", new D());
    I(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(t, s, i) {
    s.isLocal = i;
    const o = this.clippingPlanes.indexOf(s);
    t && o === -1 ? this.clippingPlanes.push(s) : !t && o > -1 && this.clippingPlanes.splice(o, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (n) => !n.isLocal
    );
  }
};
var be = class be2 extends et {
  constructor(t) {
    super(t);
    I(this, "_disposedComponents", /* @__PURE__ */ new Set());
    I(this, "enabled", true);
    t.add(be2.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, s = true, i = true) {
    t.removeFromParent();
    const o = t;
    o.dispose && o.dispose(), this.disposeGeometryAndMaterials(t, s), i && o.children && o.children.length && this.disposeChildren(o), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    t.boundsTree && t.disposeBoundsTree && t.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, s) {
    const i = t;
    i.geometry && this.disposeGeometry(i.geometry), s && i.material && be2.disposeMaterial(i), i.material = [], i.geometry = null;
  }
  disposeChildren(t) {
    for (const s of t.children)
      this.destroy(s);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const s of t.material)
          s.dispose();
      else
        t.material.dispose();
  }
};
I(be, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var zt = be;
var lr = class extends Ni {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(zt);
    for (const s of this.three.children) {
      const i = s;
      i.geometry && t.destroy(i);
    }
    this.three.children = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var ms = 0;
var hr = 1;
var Er = new Vector3();
var Ji = new Line3();
var qs = new Plane();
var tn = new Vector3();
var ls = new Triangle();
var dr = class {
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new en(), this.unassigned = new en(), this.vertices = [];
  }
  setFromPoints(e) {
    if (e.length >= 4) {
      this.makeEmpty();
      for (let t = 0, s = e.length; t < s; t++)
        this.vertices.push(new ur(e[t]));
      this.compute();
    }
    return this;
  }
  setFromObject(e) {
    const t = [];
    return e.updateMatrixWorld(true), e.traverse(function(s) {
      const i = s.geometry;
      if (i !== void 0) {
        const o = i.attributes.position;
        if (o !== void 0)
          for (let n = 0, r = o.count; n < r; n++) {
            const a = new Vector3();
            a.fromBufferAttribute(o, n).applyMatrix4(s.matrixWorld), t.push(a);
          }
      }
    }), this.setFromPoints(t);
  }
  containsPoint(e) {
    const t = this.faces;
    for (let s = 0, i = t.length; s < i; s++)
      if (t[s].distanceToPoint(e) > this.tolerance)
        return false;
    return true;
  }
  intersectRay(e, t) {
    const s = this.faces;
    let i = -1 / 0, o = 1 / 0;
    for (let n = 0, r = s.length; n < r; n++) {
      const a = s[n], c = a.distanceToPoint(e.origin), E = a.normal.dot(e.direction);
      if (c > 0 && E >= 0)
        return null;
      const d = E !== 0 ? -c / E : 0;
      if (!(d <= 0) && (E > 0 ? o = Math.min(d, o) : i = Math.max(d, i), i > o))
        return null;
    }
    return i !== -1 / 0 ? e.at(i, t) : e.at(o, t), t;
  }
  intersectsRay(e) {
    return this.intersectRay(e, Er) !== null;
  }
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(e, t) {
    return e.face = t, t.outside === null ? this.assigned.append(e) : this.assigned.insertBefore(t.outside, e), t.outside = e, this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(e, t) {
    return e === t.outside && (e.next !== null && e.next.face === t ? t.outside = e.next : t.outside = null), this.assigned.remove(e), this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(e) {
    if (e.outside !== null) {
      const t = e.outside;
      let s = e.outside;
      for (; s.next !== null && s.next.face === e; )
        s = s.next;
      return this.assigned.removeSubList(t, s), t.prev = s.next = null, e.outside = null, t;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(e, t) {
    const s = this.removeAllVerticesFromFace(e);
    if (s !== void 0)
      if (t === void 0)
        this.unassigned.appendChain(s);
      else {
        let i = s;
        do {
          const o = i.next;
          t.distanceToPoint(i.point) > this.tolerance ? this.addVertexToFace(i, t) : this.unassigned.append(i), i = o;
        } while (i !== null);
      }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(e) {
    if (this.unassigned.isEmpty() === false) {
      let t = this.unassigned.first();
      do {
        const s = t.next;
        let i = this.tolerance, o = null;
        for (let n = 0; n < e.length; n++) {
          const r = e[n];
          if (r.mark === ms) {
            const a = r.distanceToPoint(t.point);
            if (a > i && (i = a, o = r), i > 1e3 * this.tolerance)
              break;
          }
        }
        o !== null && this.addVertexToFace(t, o), t = s;
      } while (t !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const e = new Vector3(), t = new Vector3(), s = [], i = [];
    for (let o = 0; o < 3; o++)
      s[o] = i[o] = this.vertices[0];
    e.copy(this.vertices[0].point), t.copy(this.vertices[0].point);
    for (let o = 0, n = this.vertices.length; o < n; o++) {
      const r = this.vertices[o], a = r.point;
      for (let c = 0; c < 3; c++)
        a.getComponent(c) < e.getComponent(c) && (e.setComponent(c, a.getComponent(c)), s[c] = r);
      for (let c = 0; c < 3; c++)
        a.getComponent(c) > t.getComponent(c) && (t.setComponent(c, a.getComponent(c)), i[c] = r);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(e.x), Math.abs(t.x)) + Math.max(Math.abs(e.y), Math.abs(t.y)) + Math.max(Math.abs(e.z), Math.abs(t.z))), { min: s, max: i };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const e = this.vertices, t = this.computeExtremes(), s = t.min, i = t.max;
    let o = 0, n = 0;
    for (let h = 0; h < 3; h++) {
      const u = i[h].point.getComponent(h) - s[h].point.getComponent(h);
      u > o && (o = u, n = h);
    }
    const r = s[n], a = i[n];
    let c, E;
    o = 0, Ji.set(r.point, a.point);
    for (let h = 0, u = this.vertices.length; h < u; h++) {
      const p = e[h];
      if (p !== r && p !== a) {
        Ji.closestPointToPoint(p.point, true, tn);
        const A = tn.distanceToSquared(p.point);
        A > o && (o = A, c = p);
      }
    }
    o = -1, qs.setFromCoplanarPoints(r.point, a.point, c.point);
    for (let h = 0, u = this.vertices.length; h < u; h++) {
      const p = e[h];
      if (p !== r && p !== a && p !== c) {
        const A = Math.abs(qs.distanceToPoint(p.point));
        A > o && (o = A, E = p);
      }
    }
    const d = [];
    if (qs.distanceToPoint(E.point) < 0) {
      d.push(
        Rt.create(r, a, c),
        Rt.create(E, a, r),
        Rt.create(E, c, a),
        Rt.create(E, r, c)
      );
      for (let h = 0; h < 3; h++) {
        const u = (h + 1) % 3;
        d[h + 1].getEdge(2).setTwin(d[0].getEdge(u)), d[h + 1].getEdge(1).setTwin(d[u + 1].getEdge(0));
      }
    } else {
      d.push(
        Rt.create(r, c, a),
        Rt.create(E, r, a),
        Rt.create(E, a, c),
        Rt.create(E, c, r)
      );
      for (let h = 0; h < 3; h++) {
        const u = (h + 1) % 3;
        d[h + 1].getEdge(2).setTwin(d[0].getEdge((3 - h) % 3)), d[h + 1].getEdge(0).setTwin(d[u + 1].getEdge(1));
      }
    }
    for (let h = 0; h < 4; h++)
      this.faces.push(d[h]);
    for (let h = 0, u = e.length; h < u; h++) {
      const p = e[h];
      if (p !== r && p !== a && p !== c && p !== E) {
        o = this.tolerance;
        let A = null;
        for (let m = 0; m < 4; m++) {
          const C = this.faces[m].distanceToPoint(p.point);
          C > o && (o = C, A = this.faces[m]);
        }
        A !== null && this.addVertexToFace(p, A);
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const e = [];
    for (let t = 0; t < this.faces.length; t++) {
      const s = this.faces[t];
      s.mark === ms && e.push(s);
    }
    return this.faces = e, this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let e, t = 0;
      const s = this.assigned.first().face;
      let i = s.outside;
      do {
        const o = s.distanceToPoint(i.point);
        o > t && (t = o, e = i), i = i.next;
      } while (i !== null && i.face === s);
      return e;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(e, t, s, i) {
    this.deleteFaceVertices(s), s.mark = hr;
    let o;
    t === null ? o = t = s.getEdge(0) : o = t.next;
    do {
      const n = o.twin, r = n.face;
      r.mark === ms && (r.distanceToPoint(e) > this.tolerance ? this.computeHorizon(e, n, r, i) : i.push(o)), o = o.next;
    } while (o !== t);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(e, t) {
    const s = Rt.create(e, t.tail(), t.head());
    return this.faces.push(s), s.getEdge(-1).setTwin(t.twin), s.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(e, t) {
    this.newFaces = [];
    let s = null, i = null;
    for (let o = 0; o < t.length; o++) {
      const n = t[o], r = this.addAdjoiningFace(e, n);
      s === null ? s = r : r.next.setTwin(i), this.newFaces.push(r.face), i = r;
    }
    return s.next.setTwin(i), this;
  }
  // Adds a vertex to the hull
  addVertexToHull(e) {
    const t = [];
    return this.unassigned.clear(), this.removeVertexFromFace(e, e.face), this.computeHorizon(e.point, null, e.face, t), this.addNewFaces(e, t), this.resolveUnassignedPoints(this.newFaces), this;
  }
  cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  compute() {
    let e;
    for (this.computeInitialHull(); (e = this.nextVertexToAdd()) !== void 0; )
      this.addVertexToHull(e);
    return this.reindexFaces(), this.cleanup(), this;
  }
};
var Rt = class _Rt {
  constructor() {
    this.normal = new Vector3(), this.midpoint = new Vector3(), this.area = 0, this.constant = 0, this.outside = null, this.mark = ms, this.edge = null;
  }
  static create(e, t, s) {
    const i = new _Rt(), o = new Ks(e, i), n = new Ks(t, i), r = new Ks(s, i);
    return o.next = r.prev = n, n.next = o.prev = r, r.next = n.prev = o, i.edge = o, i.compute();
  }
  getEdge(e) {
    let t = this.edge;
    for (; e > 0; )
      t = t.next, e--;
    for (; e < 0; )
      t = t.prev, e++;
    return t;
  }
  compute() {
    const e = this.edge.tail(), t = this.edge.head(), s = this.edge.next.head();
    return ls.set(e.point, t.point, s.point), ls.getNormal(this.normal), ls.getMidpoint(this.midpoint), this.area = ls.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) - this.constant;
  }
};
var Ks = class {
  constructor(e, t) {
    this.vertex = e, this.prev = null, this.next = null, this.twin = null, this.face = t;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const e = this.head(), t = this.tail();
    return t !== null ? t.point.distanceTo(e.point) : -1;
  }
  lengthSquared() {
    const e = this.head(), t = this.tail();
    return t !== null ? t.point.distanceToSquared(e.point) : -1;
  }
  setTwin(e) {
    return this.twin = e, e.twin = this, this;
  }
};
var ur = class {
  constructor(e) {
    this.point = e, this.prev = null, this.next = null, this.face = null;
  }
};
var en = class {
  constructor() {
    this.head = null, this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return this.head = this.tail = null, this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(e, t) {
    return t.prev = e.prev, t.next = e, t.prev === null ? this.head = t : t.prev.next = t, e.prev = t, this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(e, t) {
    return t.prev = e, t.next = e.next, t.next === null ? this.tail = t : t.next.prev = t, e.next = t, this;
  }
  // Appends a vertex to the end of the linked list
  append(e) {
    return this.head === null ? this.head = e : this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e, this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(e) {
    for (this.head === null ? this.head = e : this.tail.next = e, e.prev = this.tail; e.next !== null; )
      e = e.next;
    return this.tail = e, this;
  }
  // Removes a vertex from the linked list
  remove(e) {
    return e.prev === null ? this.head = e.next : e.prev.next = e.next, e.next === null ? this.tail = e.prev : e.next.prev = e.prev, this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(e, t) {
    return e.prev === null ? this.head = t.next : e.prev.next = t.next, t.next === null ? this.tail = e.prev : t.next.prev = e.prev, this;
  }
  isEmpty() {
    return this.head === null;
  }
};
var Ii = [2, 2, 1];
var fi = [1, 0, 0];
function Nt(l, e) {
  return l * 3 + e;
}
function Ir(l) {
  const e = l.elements;
  let t = 0;
  for (let s = 0; s < 9; s++)
    t += e[s] * e[s];
  return Math.sqrt(t);
}
function fr(l) {
  const e = l.elements;
  let t = 0;
  for (let s = 0; s < 3; s++) {
    const i = e[Nt(Ii[s], fi[s])];
    t += 2 * i * i;
  }
  return Math.sqrt(t);
}
function pr(l, e) {
  let t = 0, s = 1;
  const i = l.elements;
  for (let c = 0; c < 3; c++) {
    const E = Math.abs(i[Nt(Ii[c], fi[c])]);
    E > t && (t = E, s = c);
  }
  let o = 1, n = 0;
  const r = fi[s], a = Ii[s];
  if (Math.abs(i[Nt(a, r)]) > Number.EPSILON) {
    const c = i[Nt(a, a)], E = i[Nt(r, r)], d = i[Nt(a, r)], h = (c - E) / 2 / d;
    let u;
    h < 0 ? u = -1 / (-h + Math.sqrt(1 + h * h)) : u = 1 / (h + Math.sqrt(1 + h * h)), o = 1 / Math.sqrt(1 + u * u), n = u * o;
  }
  return e.identity(), e.elements[Nt(r, r)] = o, e.elements[Nt(a, a)] = o, e.elements[Nt(a, r)] = n, e.elements[Nt(r, a)] = -n, e;
}
function Cr(l, e) {
  let t = 0, s = 0;
  const i = 10;
  e.unitary.identity(), e.diagonal.copy(l);
  const o = e.unitary, n = e.diagonal, r = new Matrix3(), a = new Matrix3(), c = Number.EPSILON * Ir(n);
  for (; s < i && fr(n) > c; )
    pr(n, r), a.copy(r).transpose(), n.multiply(r), n.premultiply(a), o.multiply(r), ++t > 2 && (s++, t = 0);
  return e;
}
function Tr(l) {
  const e = [];
  for (let it = 0; it < l.length - 2; it += 3) {
    const Xt = l[it], J = l[it + 1], $t = l[it + 2];
    e.push(new Vector3(Xt, J, $t));
  }
  const t = new dr();
  t.setFromPoints(e);
  const s = {
    unitary: new Matrix3(),
    diagonal: new Matrix3()
  }, i = t.faces, o = [], n = [];
  for (let it = 0, Xt = i.length; it < Xt; it++) {
    const J = i[it];
    let $t = J.edge;
    o.length = 0;
    do
      o.push($t), $t = $t.next;
    while ($t !== J.edge);
    const zn = o.length - 2;
    for (let Xe = 1, Hn = zn; Xe <= Hn; Xe++) {
      const bs = o[0].vertex, vs = o[Xe + 0].vertex, Bs = o[Xe + 1].vertex;
      n.push(bs.point.x, bs.point.y, bs.point.z), n.push(vs.point.x, vs.point.y, vs.point.z), n.push(Bs.point.x, Bs.point.y, Bs.point.z);
    }
  }
  const r = new Vector3(), a = new Vector3(), c = new Vector3(), E = new Vector3(), d = new Vector3(), h = new Vector3(), u = new Vector3(), p = new Vector3();
  let A = 0, m = 0, C = 0, R = 0, F = 0, f = 0, T = 0;
  for (let it = 0, Xt = n.length; it < Xt; it += 9) {
    r.fromArray(n, it), a.fromArray(n, it + 3), c.fromArray(n, it + 6), u.set(0, 0, 0), u.add(r).add(a).add(c).divideScalar(3), E.subVectors(a, r), d.subVectors(c, r);
    const J = h.crossVectors(E, d).length() / 2;
    p.add(h.copy(u).multiplyScalar(J)), A += J, m += (9 * u.x * u.x + r.x * r.x + a.x * a.x + c.x * c.x) * (J / 12), C += (9 * u.x * u.y + r.x * r.y + a.x * a.y + c.x * c.y) * (J / 12), R += (9 * u.x * u.z + r.x * r.z + a.x * a.z + c.x * c.z) * (J / 12), F += (9 * u.y * u.y + r.y * r.y + a.y * a.y + c.y * c.y) * (J / 12), f += (9 * u.y * u.z + r.y * r.z + a.y * a.z + c.y * c.z) * (J / 12), T += (9 * u.z * u.z + r.z * r.z + a.z * a.z + c.z * c.z) * (J / 12);
  }
  p.divideScalar(A), m /= A, C /= A, R /= A, F /= A, f /= A, T /= A, m -= p.x * p.x, C -= p.x * p.y, R -= p.x * p.z, F -= p.y * p.y, f -= p.y * p.z, T -= p.z * p.z;
  const O = new Matrix3();
  O.elements[0] = m, O.elements[1] = C, O.elements[2] = R, O.elements[3] = C, O.elements[4] = F, O.elements[5] = f, O.elements[6] = R, O.elements[7] = f, O.elements[8] = T, Cr(O, s);
  const _ = s.unitary, S = new Vector3(), N = new Vector3(), P = new Vector3();
  _.extractBasis(S, N, P);
  let w = -1 / 0, y = -1 / 0, U = -1 / 0, x = 1 / 0, B = 1 / 0, H = 1 / 0;
  for (let it = 0, Xt = e.length; it < Xt; it++) {
    const J = e[it];
    w = Math.max(S.dot(J), w), y = Math.max(N.dot(J), y), U = Math.max(P.dot(J), U), x = Math.min(S.dot(J), x), B = Math.min(N.dot(J), B), H = Math.min(P.dot(J), H);
  }
  S.multiplyScalar(0.5 * (x + w)), N.multiplyScalar(0.5 * (B + y)), P.multiplyScalar(0.5 * (H + U));
  const q = new Vector3(), st = new Vector3(), Q = new Matrix3();
  q.add(S).add(N).add(P), st.x = w - x, st.y = y - B, st.z = U - H, st.multiplyScalar(0.5), Q.copy(_);
  const { x: Ht, y: kt, z: Wt } = st, We = new Matrix4();
  We.makeScale(Ht * 2, kt * 2, Wt * 2);
  const Ce = new Matrix4();
  Ce.makeTranslation(-Ht, -kt, -Wt);
  const yi = new Matrix4();
  yi.makeTranslation(q.x, q.y, q.z);
  const Mi = new Matrix4();
  Mi.setFromMatrix3(Q);
  const Te = new Matrix4();
  return Te.multiply(yi), Te.multiply(Mi), Te.multiply(Ce), Te.multiply(We), { center: q, halfSizes: st, rotation: Q, transformation: Te };
}
function mr(l, e, t) {
  const s = [
    l[0] - e[0],
    l[1] - e[1],
    l[2] - e[2]
  ];
  return t[0] * s[0] + t[1] * s[1] + t[2] * s[2] > 0;
}
var sn = class {
  static isTransparent(e) {
    return e.transparent && e.opacity < 1;
  }
};
var $ = class $2 {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
    return `${$2._lut[e & 255] + $2._lut[e >> 8 & 255] + $2._lut[e >> 16 & 255] + $2._lut[e >> 24 & 255]}-${$2._lut[t & 255]}${$2._lut[t >> 8 & 255]}-${$2._lut[t >> 16 & 15 | 64]}${$2._lut[t >> 24 & 255]}-${$2._lut[s & 63 | 128]}${$2._lut[s >> 8 & 255]}-${$2._lut[s >> 16 & 255]}${$2._lut[s >> 24 & 255]}${$2._lut[i & 255]}${$2._lut[i >> 8 & 255]}${$2._lut[i >> 16 & 255]}${$2._lut[i >> 24 & 255]}`.toLowerCase();
  }
  static validate(e) {
    if (!$2._pattern.test(e))
      throw new Error(
        `${e} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
I($, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/), // prettier-ignore
I($, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var Ge = $;
var ea = class extends et {
  constructor(t, s) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onVertexFound", new D());
    I(this, "onVertexLost", new D());
    I(this, "components");
    I(this, "workingPlane", null);
    I(this, "_pickedPoint", null);
    I(this, "_config");
    I(this, "_enabled", false);
    this.components = t, this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...s
    }, this.enabled = false;
  }
  /**
   * Sets the enabled state of the VertexPicker.
   * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
   * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
   *
   * @param value - The new enabled state.
   */
  set enabled(t) {
    this._enabled = t, t || (this._pickedPoint = null);
  }
  /**
   * Gets the current enabled state of the VertexPicker.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the configuration for the VertexPicker component.
   *
   * @param value - A Partial object containing the configuration properties to update.
   * The properties not provided in the value object will retain their current values.
   *
   * @example
   * ```typescript
   * vertexPicker.config = {
   *   snapDistance: 0.5,
   *   showOnlyVertex: true,
   * };
   * ```
   */
  set config(t) {
    this._config = { ...this._config, ...t };
  }
  /**
   * Gets the current configuration for the VertexPicker component.
   *
   * @returns A copy of the current VertexPickerConfig object.
   *
   * @example
   * ```typescript
   * const currentConfig = vertexPicker.config;
   * console.log(currentConfig.snapDistance); // Output: 0.25
   * ```
   */
  get config() {
    return this._config;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onVertexFound.reset(), this.onVertexLost.reset(), this.components = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Performs the vertex picking operation based on the current state of the VertexPicker.
   *
   * @param world - The World instance to use for raycasting.
   *
   * @returns The current picked point, or null if no point is picked.
   *
   * @remarks
   * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
   * If enabled, it performs raycasting to find the closest intersecting object.
   * It then determines the closest vertex or point on the face, based on the configuration settings.
   * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
   * If the picked point is not on the working plane, it resets the `pickedPoint`.
   * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
   */
  get(t) {
    if (!this.enabled)
      return this._pickedPoint;
    const o = this.components.get(ze).get(t).castRay();
    if (!o)
      return this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint;
    const n = this.getClosestVertex(o);
    return n ? (this.workingPlane ? Math.abs(this.workingPlane.distanceToPoint(n)) < 1e-3 : true) ? ((this._pickedPoint === null || !this._pickedPoint.equals(n)) && (this._pickedPoint = n.clone(), this.onVertexFound.trigger(this._pickedPoint)), this._pickedPoint) : (this._pickedPoint = null, this._pickedPoint) : (this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint);
  }
  getClosestVertex(t) {
    let s = new Vector3(), i = false, o = Number.MAX_SAFE_INTEGER;
    const n = this.getVertices(t);
    if (n === null)
      return null;
    for (const r of n) {
      if (!r)
        continue;
      const a = t.point.distanceTo(r);
      a > o || a > this._config.snapDistance || (i = true, s = r, o = t.point.distanceTo(r));
    }
    return i ? s : this.config.showOnlyVertex ? null : t.point;
  }
  getVertices(t) {
    const s = t.object;
    if (!t.face || !s)
      return null;
    const i = s.geometry, o = new Matrix4(), { instanceId: n } = t, r = n !== void 0, a = s instanceof InstancedMesh;
    return a && r && s.getMatrixAt(n, o), [
      this.getVertex(t.face.a, i),
      this.getVertex(t.face.b, i),
      this.getVertex(t.face.c, i)
    ].map((c) => (c && (a && r && c.applyMatrix4(o), c.applyMatrix4(s.matrixWorld)), c));
  }
  getVertex(t, s) {
    if (t === void 0)
      return null;
    const i = s.attributes.position;
    return new Vector3(
      i.getX(t),
      i.getY(t),
      i.getZ(t)
    );
  }
};
var Fs = class Fs2 {
  constructor() {
    I(this, "onDisposed", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "enabled", false);
    I(this, "_clock");
    I(this, "update", () => {
      if (!this.enabled)
        return;
      const e = this._clock.getDelta();
      for (const [t, s] of this.list)
        s.enabled && s.isUpdateable() && s.update(e);
      requestAnimationFrame(this.update);
    });
    this._clock = new Clock(), Fs2.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  add(e, t) {
    if (this.list.has(e))
      throw new Error(
        "You're trying to add a component that already exists in the components instance. Use Components.get() instead."
      );
    Ge.validate(e), this.list.set(e, t);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  get(e) {
    const t = e.uuid;
    if (!this.list.has(t)) {
      const s = new e(this);
      return this.list.has(t) || this.add(t, s), s;
    }
    return this.list.get(t);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   *
   * @returns {void}
   */
  init() {
    this.enabled = true, this._clock.start(), this.update();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    for (const [e, t] of this.list)
      t.enabled = false, t.isDisposeable() && t.dispose();
    this._clock.stop(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = or, BufferGeometry.prototype.disposeBoundsTree = rr, Mesh.prototype.raycast = nr;
  }
};
I(Fs, "release", "2.0.20");
var pi = Fs;
var Rr = class {
  constructor(e) {
    I(this, "_event");
    I(this, "_position", new Vector2());
    I(this, "onDisposed", new D());
    I(this, "updateMouseInfo", (e2) => {
      this._event = e2;
    });
    this.dom = e, this.setupEvents(true);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const e = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(e, this._event), this._position.y = this.getPositionY(e, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  getPositionY(e, t) {
    return -((t.clientY - e.top) / (e.bottom - e.top)) * 2 + 1;
  }
  getPositionX(e, t) {
    return (t.clientX - e.left) / (e.right - e.left) * 2 - 1;
  }
  setupEvents(e) {
    e ? this.dom.addEventListener("pointermove", this.updateMouseInfo) : this.dom.removeEventListener("pointermove", this.updateMouseInfo);
  }
};
var Ar = class {
  constructor(e, t) {
    I(this, "enabled", true);
    I(this, "components");
    I(this, "onDisposed", new D());
    I(this, "mouse");
    I(this, "three", new Raycaster());
    I(this, "world");
    const s = t.renderer;
    if (!s)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = t, this.mouse = new Rr(s.three.domElement), this.components = e;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   */
  castRay(e = Array.from(this.world.meshes)) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const t = this.world.camera.three;
    return this.three.setFromCamera(this.mouse.position, t), this.intersect(e);
  }
  /**
   * Casts a ray from a given origin in a given direction and returns the first item found.
   * This method also takes into account the clipping planes used by the renderer.
   *
   * @param origin - The origin of the ray.
   * @param direction - The direction of the ray.
   * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
   * @returns The first intersection found or `null` if no intersection was found.
   */
  castRayFromVector(e, t, s = Array.from(this.world.meshes)) {
    return this.three.set(e, t), this.intersect(s);
  }
  intersect(e = Array.from(this.world.meshes)) {
    const t = this.three.intersectObjects(e), s = this.filterClippingPlanes(t);
    return s.length > 0 ? s[0] : null;
  }
  filterClippingPlanes(e) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const t = this.world.renderer.three;
    if (!t.clippingPlanes)
      return e;
    const s = t.clippingPlanes;
    return e.length <= 0 || !s || (s == null ? void 0 : s.length) <= 0 ? e : e.filter(
      (i) => s.every((o) => o.distanceToPoint(i.point) > 0)
    );
  }
};
var Os = class Os2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "onDisposed", new D());
    t.add(Os2.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const s = new Ar(this.components, t);
    return this.list.set(t.uuid, s), t.onDisposed.add(() => {
      this.delete(t);
    }), s;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(t) {
    const s = this.list.get(t.uuid);
    s && s.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, s] of this.list)
      s.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
I(Os, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var ze = Os;
var Fr = class extends Si {
  constructor() {
    super(...arguments);
    I(this, "meshes", /* @__PURE__ */ new Set());
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "isDisposing", false);
    I(this, "enabled", true);
    I(this, "uuid", Ge.create());
    I(this, "name");
    I(this, "_scene");
    I(this, "_camera");
    I(this, "_renderer", null);
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(t) {
    this._camera = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  /** {@link Disposable.dispose} */
  dispose(t = true) {
    if (this.enabled = false, this.isDisposing = true, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const s = this.components.get(zt);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const i of this.meshes)
        s.destroy(i);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.onDisposed.trigger();
  }
};
var sa = class extends lr {
  constructor(t) {
    super(t);
    I(this, "isSetup", false);
    I(this, "three");
    I(this, "onSetup", new D());
    I(this, "config", {
      directionalLight: {
        color: new Color("white"),
        intensity: 1.5,
        position: new Vector3(5, 10, 3)
      },
      ambientLight: {
        color: new Color("white"),
        intensity: 1
      }
    });
    this.three = new Scene(), this.three.background = new Color(2107698);
  }
  /** {@link Configurable.setup} */
  setup(t) {
    this.config = { ...this.config, ...t };
    const s = new DirectionalLight(
      this.config.directionalLight.color,
      this.config.directionalLight.intensity
    );
    s.position.copy(this.config.directionalLight.position);
    const i = new AmbientLight(
      this.config.ambientLight.color,
      this.config.ambientLight.intensity
    );
    this.three.add(s, i), this.isSetup = true, this.onSetup.trigger(this);
  }
};
var ia = class extends cr {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(t, s, i) {
    super(t);
    I(this, "enabled", true);
    I(this, "container");
    I(this, "three");
    I(this, "_canvas");
    I(this, "_parameters");
    I(this, "_resizeObserver", null);
    I(this, "onContainerUpdated", new D());
    I(this, "_resizing", false);
    I(this, "resize", (t2) => {
      if (this._resizing)
        return;
      this._resizing = true, this.onContainerUpdated.trigger();
      const s2 = t2 ? t2.x : this.container.clientWidth, i2 = t2 ? t2.y : this.container.clientHeight;
      this.three.setSize(s2, i2), this.onResize.trigger(new Vector2(s2, i2)), this._resizing = false;
    });
    I(this, "resizeEvent", () => {
      this.resize();
    });
    I(this, "onContextLost", (t2) => {
      t2.preventDefault(), this.enabled = false;
    });
    I(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      }), this.enabled = true;
    });
    this.container = s, this._parameters = i, this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...i
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(true), this.resize(), this._canvas = this.three.domElement;
    const o = this.three.getContext(), { canvas: n } = o;
    n.addEventListener("webglcontextlost", this.onContextLost, false), n.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, s = this.currentWorld.camera.three;
    this.three.render(t, s), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.setupEvents(false), this.three.domElement.remove(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(t) {
    const s = this.three.domElement.parentElement;
    if (!s)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(s), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = true, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
};
var V = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var L = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var le = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Zt(l) {
  return l.isPerspectiveCamera;
}
function bt(l) {
  return l.isOrthographicCamera;
}
var he = Math.PI * 2;
var nn = Math.PI / 2;
var xn = 1e-5;
var Se = Math.PI / 180;
function mt(l, e, t) {
  return Math.max(e, Math.min(t, l));
}
function X(l, e = xn) {
  return Math.abs(l) < e;
}
function k(l, e, t = xn) {
  return X(l - e, t);
}
function on(l, e) {
  return Math.round(l / e) * e;
}
function Ne2(l) {
  return isFinite(l) ? l : l < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Le(l) {
  return Math.abs(l) < Number.MAX_VALUE ? l : l * (1 / 0);
}
function hs(l, e, t, s, i = 1 / 0, o) {
  s = Math.max(1e-4, s);
  const n = 2 / s, r = n * o, a = 1 / (1 + r + 0.48 * r * r + 0.235 * r * r * r);
  let c = l - e;
  const E = e, d = i * s;
  c = mt(c, -d, d), e = l - c;
  const h = (t.value + n * c) * o;
  t.value = (t.value - n * h) * a;
  let u = e + (c + h) * a;
  return E - l > 0 == u > E && (u = E, t.value = (u - E) / o), u;
}
function rn(l, e, t, s, i = 1 / 0, o, n) {
  s = Math.max(1e-4, s);
  const r = 2 / s, a = r * o, c = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let E = e.x, d = e.y, h = e.z, u = l.x - E, p = l.y - d, A = l.z - h;
  const m = E, C = d, R = h, F = i * s, f = F * F, T = u * u + p * p + A * A;
  if (T > f) {
    const B = Math.sqrt(T);
    u = u / B * F, p = p / B * F, A = A / B * F;
  }
  E = l.x - u, d = l.y - p, h = l.z - A;
  const O = (t.x + r * u) * o, _ = (t.y + r * p) * o, S = (t.z + r * A) * o;
  t.x = (t.x - r * O) * c, t.y = (t.y - r * _) * c, t.z = (t.z - r * S) * c, n.x = E + (u + O) * c, n.y = d + (p + _) * c, n.z = h + (A + S) * c;
  const N = m - l.x, P = C - l.y, w = R - l.z, y = n.x - m, U = n.y - C, x = n.z - R;
  return N * y + P * U + w * x > 0 && (n.x = m, n.y = C, n.z = R, t.x = (n.x - m) / o, t.y = (n.y - C) / o, t.z = (n.z - R) / o), n;
}
function $s(l, e) {
  e.set(0, 0), l.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= l.length, e.y /= l.length;
}
function Js(l, e) {
  return bt(l) ? (console.warn(`${e} is not supported in OrthographicCamera`), true) : false;
}
var Or = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const s = this._listeners;
    s[e] === void 0 && (s[e] = []), s[e].indexOf(t) === -1 && s[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const s = this._listeners;
    return s[e] !== void 0 && s[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const s = this._listeners[e.type];
    if (s !== void 0) {
      e.target = this;
      const i = s.slice(0);
      for (let o = 0, n = i.length; o < n; o++)
        i[o].call(this, e);
    }
  }
};
var gr = "2.7.3";
var Es = 1 / 8;
var bn = typeof window < "u";
var _r = bn && /Mac/.test(navigator.platform);
var Sr = !(bn && "PointerEvent" in window);
var Y;
var an2;
var ds;
var ti;
var lt;
var G;
var z;
var Ee;
var Pe;
var gt;
var _t;
var Qt;
var cn;
var ln;
var dt;
var ye;
var de;
var hn;
var ei;
var En;
var si;
var ii;
var us;
var ot = class _ot extends Or {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    Y = e.THREE, an2 = Object.freeze(new Y.Vector3(0, 0, 0)), ds = Object.freeze(new Y.Vector3(0, 1, 0)), ti = Object.freeze(new Y.Vector3(0, 0, 1)), lt = new Y.Vector2(), G = new Y.Vector3(), z = new Y.Vector3(), Ee = new Y.Vector3(), Pe = new Y.Vector3(), gt = new Y.Vector3(), _t = new Y.Vector3(), Qt = new Y.Vector3(), cn = new Y.Vector3(), ln = new Y.Vector3(), dt = new Y.Spherical(), ye = new Y.Spherical(), de = new Y.Box3(), hn = new Y.Box3(), ei = new Y.Sphere(), En = new Y.Quaternion(), si = new Y.Quaternion(), ii = new Y.Matrix4(), us = new Y.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return L;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.verticalDragToForward = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = L.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = le.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new Y.Vector3(), this._focalOffsetVelocity = new Y.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (f, T, O) => {
      let _, S;
      if (Zt(this._camera)) {
        const N = G.copy(this._camera.position).sub(this._target), P = this._camera.getEffectiveFOV() * Se, w = N.length() * Math.tan(P * 0.5);
        _ = this.truckSpeed * f * w / this._elementRect.height, S = this.truckSpeed * T * w / this._elementRect.height;
      } else if (bt(this._camera)) {
        const N = this._camera;
        _ = f * (N.right - N.left) / N.zoom / this._elementRect.width, S = T * (N.top - N.bottom) / N.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (O ? this.setFocalOffset(this._focalOffsetEnd.x + _, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(_, 0, true), this.forward(-S, true)) : O ? this.setFocalOffset(this._focalOffsetEnd.x + _, this._focalOffsetEnd.y + S, this._focalOffsetEnd.z, true) : this.truck(_, S, true);
    }, this._rotateInternal = (f, T) => {
      const O = he * this.azimuthRotateSpeed * f / this._elementRect.height, _ = he * this.polarRotateSpeed * T / this._elementRect.height;
      this.rotate(O, _, true);
    }, this._dollyInternal = (f, T, O) => {
      const _ = Math.pow(0.95, -f * this.dollySpeed), S = this._sphericalEnd.radius, N = this._sphericalEnd.radius * _, P = mt(N, this.minDistance, this.maxDistance), w = P - N;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(N, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(w, true), this._dollyToNoClamp(P, true)) : this._dollyToNoClamp(P, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? N : P) - S, this._dollyControlCoord.set(T, O)), this._lastDollyDirection = Math.sign(-f);
    }, this._zoomInternal = (f, T, O) => {
      const _ = Math.pow(0.95, f * this.dollySpeed), S = this._zoom, N = this._zoom * _;
      this.zoomTo(N, true), this.dollyToCursor && (this._changedZoom += N - S, this._dollyControlCoord.set(T, O));
    }, typeof Y > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new Y.Quaternion().setFromUnitVectors(this._camera.up, ds), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = L.NONE, this._target = new Y.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new Y.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new Y.Spherical().setFromVector3(G.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new Y.Vector3(),
      new Y.Vector3(),
      new Y.Vector3(),
      new Y.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new Y.Box3(new Y.Vector3(-1 / 0, -1 / 0, -1 / 0), new Y.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new Y.Vector2(), this.mouseButtons = {
      left: L.ROTATE,
      middle: L.DOLLY,
      right: L.TRUCK,
      wheel: Zt(this._camera) ? L.DOLLY : bt(this._camera) ? L.ZOOM : L.NONE
    }, this.touches = {
      one: L.TOUCH_ROTATE,
      two: Zt(this._camera) ? L.TOUCH_DOLLY_TRUCK : bt(this._camera) ? L.TOUCH_ZOOM_TRUCK : L.NONE,
      three: L.TOUCH_TRUCK
    };
    const s = new Y.Vector2(), i = new Y.Vector2(), o = new Y.Vector2(), n = (f) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const _ = this._domElement.getBoundingClientRect(), S = f.clientX / _.width, N = f.clientY / _.height;
        if (S < this._interactiveArea.left || S > this._interactiveArea.right || N < this._interactiveArea.top || N > this._interactiveArea.bottom)
          return;
      }
      const T = f.pointerType !== "mouse" ? null : (f.buttons & V.LEFT) === V.LEFT ? V.LEFT : (f.buttons & V.MIDDLE) === V.MIDDLE ? V.MIDDLE : (f.buttons & V.RIGHT) === V.RIGHT ? V.RIGHT : null;
      if (T !== null) {
        const _ = this._findPointerByMouseButton(T);
        _ && this._disposePointer(_);
      }
      if ((f.buttons & V.LEFT) === V.LEFT && this._lockedPointer)
        return;
      const O = {
        pointerId: f.pointerId,
        clientX: f.clientX,
        clientY: f.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: T
      };
      this._activePointers.push(O), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", E), this._isDragging = true, A(f);
    }, r = (f) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const _ = this._domElement.getBoundingClientRect(), S = f.clientX / _.width, N = f.clientY / _.height;
        if (S < this._interactiveArea.left || S > this._interactiveArea.right || N < this._interactiveArea.top || N > this._interactiveArea.bottom)
          return;
      }
      const T = (f.buttons & V.LEFT) === V.LEFT ? V.LEFT : (f.buttons & V.MIDDLE) === V.MIDDLE ? V.MIDDLE : (f.buttons & V.RIGHT) === V.RIGHT ? V.RIGHT : null;
      if (T !== null) {
        const _ = this._findPointerByMouseButton(T);
        _ && this._disposePointer(_);
      }
      const O = {
        pointerId: 1,
        clientX: f.clientX,
        clientY: f.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (f.buttons & V.LEFT) === V.LEFT ? V.LEFT : (f.buttons & V.MIDDLE) === V.LEFT ? V.MIDDLE : (f.buttons & V.RIGHT) === V.LEFT ? V.RIGHT : null
      };
      this._activePointers.push(O), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", d), this._domElement.ownerDocument.addEventListener("mousemove", c), this._domElement.ownerDocument.addEventListener("mouseup", d), this._isDragging = true, A(f);
    }, a = (f) => {
      f.cancelable && f.preventDefault();
      const T = f.pointerId, O = this._lockedPointer || this._findPointerById(T);
      if (O) {
        if (O.clientX = f.clientX, O.clientY = f.clientY, O.deltaX = f.movementX, O.deltaY = f.movementY, this._state = 0, f.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (f.buttons & V.LEFT) === V.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (f.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (f.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right);
        m();
      }
    }, c = (f) => {
      const T = this._lockedPointer || this._findPointerById(1);
      T && (T.clientX = f.clientX, T.clientY = f.clientY, T.deltaX = f.movementX, T.deltaY = f.movementY, this._state = 0, (this._lockedPointer || (f.buttons & V.LEFT) === V.LEFT) && (this._state = this._state | this.mouseButtons.left), (f.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right), m());
    }, E = (f) => {
      const T = this._findPointerById(f.pointerId);
      if (!(T && T === this._lockedPointer)) {
        if (T && this._disposePointer(T), f.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = L.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = L.NONE;
        C();
      }
    }, d = () => {
      const f = this._findPointerById(1);
      f && f === this._lockedPointer || (f && this._disposePointer(f), this._state = L.NONE, C());
    };
    let h = -1;
    const u = (f) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === L.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const N = this._domElement.getBoundingClientRect(), P = f.clientX / N.width, w = f.clientY / N.height;
        if (P < this._interactiveArea.left || P > this._interactiveArea.right || w < this._interactiveArea.top || w > this._interactiveArea.bottom)
          return;
      }
      if (f.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === L.ROTATE || this.mouseButtons.wheel === L.TRUCK) {
        const N = performance.now();
        h - N < 1e3 && this._getClientRect(this._elementRect), h = N;
      }
      const T = _r ? -1 : -3, O = f.deltaMode === 1 ? f.deltaY / T : f.deltaY / (T * 10), _ = this.dollyToCursor ? (f.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, S = this.dollyToCursor ? (f.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case L.ROTATE: {
          this._rotateInternal(f.deltaX, f.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case L.TRUCK: {
          this._truckInternal(f.deltaX, f.deltaY, false), this._isUserControllingTruck = true;
          break;
        }
        case L.OFFSET: {
          this._truckInternal(f.deltaX, f.deltaY, true), this._isUserControllingOffset = true;
          break;
        }
        case L.DOLLY: {
          this._dollyInternal(-O, _, S), this._isUserControllingDolly = true;
          break;
        }
        case L.ZOOM: {
          this._zoomInternal(-O, _, S), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, p = (f) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _ot.ACTION.NONE) {
          const T = f instanceof PointerEvent ? f.pointerId : (f instanceof MouseEvent, 0), O = this._findPointerById(T);
          O && this._disposePointer(O), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", d);
          return;
        }
        f.preventDefault();
      }
    }, A = (f) => {
      if (!this._enabled)
        return;
      if ($s(this._activePointers, lt), this._getClientRect(this._elementRect), s.copy(lt), i.copy(lt), this._activePointers.length >= 2) {
        const O = lt.x - this._activePointers[1].clientX, _ = lt.y - this._activePointers[1].clientY, S = Math.sqrt(O * O + _ * _);
        o.set(0, S);
        const N = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, P = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(N, P);
      }
      if (this._state = 0, !f)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in f && f.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (f.buttons & V.LEFT) === V.LEFT && (this._state = this._state | this.mouseButtons.left), (f.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & L.ROTATE) === L.ROTATE || (this._state & L.TOUCH_ROTATE) === L.TOUCH_ROTATE || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE || (this._state & L.TOUCH_ZOOM_ROTATE) === L.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & L.TRUCK) === L.TRUCK || (this._state & L.TOUCH_TRUCK) === L.TOUCH_TRUCK || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_ZOOM_TRUCK) === L.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & L.DOLLY) === L.DOLLY || (this._state & L.TOUCH_DOLLY) === L.TOUCH_DOLLY || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & L.ZOOM) === L.ZOOM || (this._state & L.TOUCH_ZOOM) === L.TOUCH_ZOOM || (this._state & L.TOUCH_ZOOM_TRUCK) === L.TOUCH_ZOOM_TRUCK || (this._state & L.TOUCH_ZOOM_OFFSET) === L.TOUCH_ZOOM_OFFSET || (this._state & L.TOUCH_ZOOM_ROTATE) === L.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & L.OFFSET) === L.OFFSET || (this._state & L.TOUCH_OFFSET) === L.TOUCH_OFFSET || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET || (this._state & L.TOUCH_ZOOM_OFFSET) === L.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, m = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, $s(this._activePointers, lt);
      const T = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, O = T ? -T.deltaX : i.x - lt.x, _ = T ? -T.deltaY : i.y - lt.y;
      if (i.copy(lt), ((this._state & L.ROTATE) === L.ROTATE || (this._state & L.TOUCH_ROTATE) === L.TOUCH_ROTATE || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE || (this._state & L.TOUCH_ZOOM_ROTATE) === L.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(O, _), this._isUserControllingRotate = true), (this._state & L.DOLLY) === L.DOLLY || (this._state & L.ZOOM) === L.ZOOM) {
        const S = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, N = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, P = this.dollyDragInverted ? -1 : 1;
        (this._state & L.DOLLY) === L.DOLLY ? (this._dollyInternal(P * _ * Es, S, N), this._isUserControllingDolly = true) : (this._zoomInternal(P * _ * Es, S, N), this._isUserControllingZoom = true);
      }
      if ((this._state & L.TOUCH_DOLLY) === L.TOUCH_DOLLY || (this._state & L.TOUCH_ZOOM) === L.TOUCH_ZOOM || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_ZOOM_TRUCK) === L.TOUCH_ZOOM_TRUCK || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET || (this._state & L.TOUCH_ZOOM_OFFSET) === L.TOUCH_ZOOM_OFFSET || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE || (this._state & L.TOUCH_ZOOM_ROTATE) === L.TOUCH_ZOOM_ROTATE) {
        const S = lt.x - this._activePointers[1].clientX, N = lt.y - this._activePointers[1].clientY, P = Math.sqrt(S * S + N * N), w = o.y - P;
        o.set(0, P);
        const y = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, U = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & L.TOUCH_DOLLY) === L.TOUCH_DOLLY || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(w * Es, y, U), this._isUserControllingDolly = true) : (this._zoomInternal(w * Es, y, U), this._isUserControllingZoom = true);
      }
      ((this._state & L.TRUCK) === L.TRUCK || (this._state & L.TOUCH_TRUCK) === L.TOUCH_TRUCK || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_ZOOM_TRUCK) === L.TOUCH_ZOOM_TRUCK) && (this._truckInternal(O, _, false), this._isUserControllingTruck = true), ((this._state & L.OFFSET) === L.OFFSET || (this._state & L.TOUCH_OFFSET) === L.TOUCH_OFFSET || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET || (this._state & L.TOUCH_ZOOM_OFFSET) === L.TOUCH_ZOOM_OFFSET) && (this._truckInternal(O, _, true), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, C = () => {
      $s(this._activePointers, lt), i.copy(lt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.ownerDocument.removeEventListener("mouseup", d), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", R), this._domElement.ownerDocument.addEventListener("pointerlockerror", F), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", E), A());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", F));
    };
    const R = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, F = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (f) => {
      this._domElement = f, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", n), Sr && this._domElement.addEventListener("mousedown", r), this._domElement.addEventListener("pointercancel", E), this._domElement.addEventListener("wheel", u, { passive: false }), this._domElement.addEventListener("contextmenu", p);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", n), this._domElement.removeEventListener("mousedown", r), this._domElement.removeEventListener("pointercancel", E), this._domElement.removeEventListener("wheel", u, { passive: false }), this._domElement.removeEventListener("contextmenu", p), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.ownerDocument.removeEventListener("mouseup", d), this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", F));
    }, this.cancel = () => {
      this._state !== L.NONE && (this._state = L.NONE, this._activePointers.length = 0, C());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = mt(e.width, 0, 1), this._interactiveArea.height = mt(e.height, 0, 1), this._interactiveArea.x = mt(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = mt(e.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, s = false) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, s);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = false) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = false) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, s = false) {
    this._isUserControllingRotate = false;
    const i = mt(e, this.minAzimuthAngle, this.maxAzimuthAngle), o = mt(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = o, this._sphericalEnd.makeSafe(), this._needsUpdate = true, s || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const n = !s || k(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && k(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = false) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = le.NONE, this._changedDolly = 0, this._dollyToNoClamp(mt(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = false) {
    const s = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const n = this._collisionTest(), r = k(n, this._spherical.radius);
      if (!(s > e) && r)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, n);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = true, t || (this._spherical.radius = this._sphericalEnd.radius);
    const o = !t || k(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = false) {
    this._targetEnd.add(this._getCameraDirection(Pe).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const s = !t || k(this._target.x, this._targetEnd.x, this.restThreshold) && k(this._target.y, this._targetEnd.y, this.restThreshold) && k(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = false) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = false) {
    this._isUserControllingZoom = false, this._zoomEnd = mt(e, this.minZoom, this.maxZoom), this._needsUpdate = true, t || (this._zoom = this._zoomEnd);
    const s = !t || k(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(s);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, s = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, s);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, s = false) {
    this._camera.updateMatrix(), gt.setFromMatrixColumn(this._camera.matrix, 0), _t.setFromMatrixColumn(this._camera.matrix, 1), gt.multiplyScalar(e), _t.multiplyScalar(-t);
    const i = G.copy(gt).add(_t), o = z.copy(this._targetEnd).add(i);
    return this.moveTo(o.x, o.y, o.z, s);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = false) {
    G.setFromMatrixColumn(this._camera.matrix, 0), G.crossVectors(this._camera.up, G), G.multiplyScalar(e);
    const s = z.copy(this._targetEnd).add(G);
    return this.moveTo(s.x, s.y, s.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = false) {
    return G.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + G.x, this._targetEnd.y + G.y, this._targetEnd.z + G.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, s, i = false) {
    this._isUserControllingTruck = false;
    const o = G.set(e, t, s).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, o, this.boundaryFriction), this._needsUpdate = true, i || this._target.copy(this._targetEnd);
    const n = !i || k(this._target.x, this._targetEnd.x, this.restThreshold) && k(this._target.y, this._targetEnd.y, this.restThreshold) && k(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, s, i = false) {
    const r = G.set(e, t, s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(r.x, r.y, r.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: s = false, paddingLeft: i = 0, paddingRight: o = 0, paddingBottom: n = 0, paddingTop: r = 0 } = {}) {
    const a = [], c = e.isBox3 ? de.copy(e) : de.setFromObject(e);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const E = on(this._sphericalEnd.theta, nn), d = on(this._sphericalEnd.phi, nn);
    a.push(this.rotateTo(E, d, t));
    const h = G.setFromSpherical(this._sphericalEnd).normalize(), u = En.setFromUnitVectors(h, ti), p = k(Math.abs(h.y), 1);
    p && u.multiply(si.setFromAxisAngle(ds, E)), u.multiply(this._yAxisUpSpaceInverse);
    const A = hn.makeEmpty();
    z.copy(c.min).applyQuaternion(u), A.expandByPoint(z), z.copy(c.min).setX(c.max.x).applyQuaternion(u), A.expandByPoint(z), z.copy(c.min).setY(c.max.y).applyQuaternion(u), A.expandByPoint(z), z.copy(c.max).setZ(c.min.z).applyQuaternion(u), A.expandByPoint(z), z.copy(c.min).setZ(c.max.z).applyQuaternion(u), A.expandByPoint(z), z.copy(c.max).setY(c.min.y).applyQuaternion(u), A.expandByPoint(z), z.copy(c.max).setX(c.min.x).applyQuaternion(u), A.expandByPoint(z), z.copy(c.max).applyQuaternion(u), A.expandByPoint(z), A.min.x -= i, A.min.y -= n, A.max.x += o, A.max.y += r, u.setFromUnitVectors(ti, h), p && u.premultiply(si.invert()), u.premultiply(this._yAxisUpSpace);
    const m = A.getSize(G), C = A.getCenter(z).applyQuaternion(u);
    if (Zt(this._camera)) {
      const R = this.getDistanceToFitBox(m.x, m.y, m.z, s);
      a.push(this.moveTo(C.x, C.y, C.z, t)), a.push(this.dollyTo(R, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    } else if (bt(this._camera)) {
      const R = this._camera, F = R.right - R.left, f = R.top - R.bottom, T = s ? Math.max(F / m.x, f / m.y) : Math.min(F / m.x, f / m.y);
      a.push(this.moveTo(C.x, C.y, C.z, t)), a.push(this.zoomTo(T, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(a);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const s = [], o = e instanceof Y.Sphere ? ei.copy(e) : _ot.createBoundingSphere(e, ei);
    if (s.push(this.moveTo(o.center.x, o.center.y, o.center.z, t)), Zt(this._camera)) {
      const n = this.getDistanceToFitSphere(o.radius);
      s.push(this.dollyTo(n, t));
    } else if (bt(this._camera)) {
      const n = this._camera.right - this._camera.left, r = this._camera.top - this._camera.bottom, a = 2 * o.radius, c = Math.min(n / a, r / a);
      s.push(this.zoomTo(c, t));
    }
    return s.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(s);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, s, i, o, n, r = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = le.NONE, this._changedDolly = 0;
    const a = z.set(i, o, n), c = G.set(e, t, s);
    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(c.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, r || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const E = !r || k(this._target.x, this._targetEnd.x, this.restThreshold) && k(this._target.y, this._targetEnd.y, this.restThreshold) && k(this._target.z, this._targetEnd.z, this.restThreshold) && k(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && k(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && k(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(E);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, s, i, o, n, r, a, c, E, d, h, u, p = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = le.NONE, this._changedDolly = 0;
    const A = G.set(i, o, n), m = z.set(e, t, s);
    dt.setFromVector3(m.sub(A).applyQuaternion(this._yAxisUpSpace));
    const C = Ee.set(E, d, h), R = z.set(r, a, c);
    ye.setFromVector3(R.sub(C).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(A.lerp(C, u));
    const F = ye.theta - dt.theta, f = ye.phi - dt.phi, T = ye.radius - dt.radius;
    this._sphericalEnd.set(dt.radius + T * u, dt.phi + f * u, dt.theta + F * u), this.normalizeRotations(), this._needsUpdate = true, p || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const O = !p || k(this._target.x, this._targetEnd.x, this.restThreshold) && k(this._target.y, this._targetEnd.y, this.restThreshold) && k(this._target.z, this._targetEnd.z, this.restThreshold) && k(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && k(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && k(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(O);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, s, i = false) {
    return this.setLookAt(e, t, s, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, s, i = false) {
    const o = this.getPosition(G), n = this.setLookAt(o.x, o.y, o.z, e, t, s, i);
    return this._sphericalEnd.phi = mt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), n;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, s, i = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(e, t, s), this._needsUpdate = true, i || this._focalOffset.copy(this._focalOffsetEnd);
    const o = !i || k(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && k(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && k(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, s) {
    this._camera.updateMatrixWorld(), gt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), _t.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Qt.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = G.set(e, t, s), o = i.distanceTo(this._camera.position), n = i.sub(this._camera.position);
    gt.multiplyScalar(n.x), _t.multiplyScalar(n.y), Qt.multiplyScalar(n.z), G.copy(gt).add(_t).add(Qt), G.z = G.z + o, this.dollyTo(o, false), this.setFocalOffset(-G.x, G.y, -G.z, false), this.moveTo(e, t, s, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, s, i) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new Y.Vector4(), typeof e == "number" ? this._viewport.set(e, t, s, i) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, s, i = false) {
    if (Js(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const o = e / t, n = this._camera.getEffectiveFOV() * Se, r = this._camera.aspect;
    return ((i ? o > r : o < r) ? t : e / r) * 0.5 / Math.tan(n * 0.5) + s * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (Js(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * Se, s = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? t : s;
    return e / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = true) {
    return (e && e.isVector3 ? e : new Y.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = true) {
    return (e && e.isVector3 ? e : new Y.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = true) {
    return (e && e instanceof Y.Spherical ? e : new Y.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = true) {
    return (e && e.isVector3 ? e : new Y.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % he, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += he), this._spherical.theta += he * Math.round((this._sphericalEnd.theta - this._spherical.theta) / he);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = false) {
    if (!k(this._camera.up.x, this._cameraUp0.x) || !k(this._camera.up.y, this._cameraUp0.y) || !k(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const s = this.getPosition(G);
      this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, ds), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = G.subVectors(this._target, this._camera.position).normalize(), t = z.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
    const s = this.getPosition(G);
    this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, s = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, o = cn.subVectors(this._targetEnd, this._target), n = ln.subVectors(this._focalOffsetEnd, this._focalOffset), r = this._zoomEnd - this._zoom;
    if (X(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = hs(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, d, 1 / 0, e), this._needsUpdate = true;
    }
    if (X(s))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = hs(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, d, 1 / 0, e), this._needsUpdate = true;
    }
    if (X(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const d = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = hs(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, d, this.maxSpeed, e), this._needsUpdate = true;
    }
    if (X(o.x) && X(o.y) && X(o.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const d = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      rn(this._target, this._targetEnd, this._targetVelocity, d, this.maxSpeed, e, this._target), this._needsUpdate = true;
    }
    if (X(n.x) && X(n.y) && X(n.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const d = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      rn(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, d, this.maxSpeed, e, this._focalOffset), this._needsUpdate = true;
    }
    if (X(r))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const d = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = hs(this._zoom, this._zoomEnd, this._zoomVelocity, d, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (Zt(this._camera) && this._changedDolly !== 0) {
        const d = this._spherical.radius - this._lastDistance, h = this._camera, u = this._getCameraDirection(Pe), p = G.copy(u).cross(h.up).normalize();
        p.lengthSq() === 0 && (p.x = 1);
        const A = z.crossVectors(p, u), m = this._sphericalEnd.radius * Math.tan(h.getEffectiveFOV() * Se * 0.5), R = (this._sphericalEnd.radius - d - this._sphericalEnd.radius) / this._sphericalEnd.radius, F = Ee.copy(this._targetEnd).add(p.multiplyScalar(this._dollyControlCoord.x * m * h.aspect)).add(A.multiplyScalar(this._dollyControlCoord.y * m)), f = G.copy(this._targetEnd).lerp(F, R), T = this._lastDollyDirection === le.IN && this._spherical.radius <= this.minDistance, O = this._lastDollyDirection === le.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (T || O)) {
          this._sphericalEnd.radius -= d, this._spherical.radius -= d;
          const S = z.copy(u).multiplyScalar(-d);
          f.add(S);
        }
        this._boundary.clampPoint(f, f);
        const _ = z.subVectors(f, this._targetEnd);
        this._targetEnd.copy(f), this._target.add(_), this._changedDolly -= d, X(this._changedDolly) && (this._changedDolly = 0);
      } else if (bt(this._camera) && this._changedZoom !== 0) {
        const d = this._zoom - this._lastZoom, h = this._camera, u = G.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (h.near + h.far) / (h.near - h.far)).unproject(h), p = z.set(0, 0, -1).applyQuaternion(h.quaternion), A = Ee.copy(u).add(p.multiplyScalar(-u.dot(h.up))), C = -(this._zoom - d - this._zoom) / this._zoom, R = this._getCameraDirection(Pe), F = this._targetEnd.dot(R), f = G.copy(this._targetEnd).lerp(A, C), T = f.dot(R), O = R.multiplyScalar(T - F);
        f.sub(O), this._boundary.clampPoint(f, f);
        const _ = z.subVectors(f, this._targetEnd);
        this._targetEnd.copy(f), this._target.add(_), this._changedZoom -= d, X(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const a = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!X(this._focalOffset.x) || !X(this._focalOffset.y) || !X(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), gt.setFromMatrixColumn(this._camera.matrix, 0), _t.setFromMatrixColumn(this._camera.matrix, 1), Qt.setFromMatrixColumn(this._camera.matrix, 2), gt.multiplyScalar(this._focalOffset.x), _t.multiplyScalar(-this._focalOffset.y), Qt.multiplyScalar(this._focalOffset.z), G.copy(gt).add(_t).add(Qt), this._camera.position.add(G)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), G.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const E = this._needsUpdate;
    return E && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : E ? (this.dispatchEvent({ type: "update" }), X(t, this.restThreshold) && X(s, this.restThreshold) && X(i, this.restThreshold) && X(o.x, this.restThreshold) && X(o.y, this.restThreshold) && X(o.z, this.restThreshold) && X(n.x, this.restThreshold) && X(n.y, this.restThreshold) && X(n.z, this.restThreshold) && X(r, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !E && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = E, this._needsUpdate = false, E;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Ne2(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Ne2(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Ne2(this.maxPolarAngle),
      minAzimuthAngle: Ne2(this.minAzimuthAngle),
      maxAzimuthAngle: Ne2(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: G.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = false) {
    const s = JSON.parse(e);
    this.enabled = s.enabled, this.minDistance = s.minDistance, this.maxDistance = Le(s.maxDistance), this.minZoom = s.minZoom, this.maxZoom = Le(s.maxZoom), this.minPolarAngle = s.minPolarAngle, this.maxPolarAngle = Le(s.maxPolarAngle), this.minAzimuthAngle = Le(s.minAzimuthAngle), this.maxAzimuthAngle = Le(s.maxAzimuthAngle), this.smoothTime = s.smoothTime, this.draggingSmoothTime = s.draggingSmoothTime, this.dollySpeed = s.dollySpeed, this.truckSpeed = s.truckSpeed, this.dollyToCursor = s.dollyToCursor, this.verticalDragToForward = s.verticalDragToForward, this._target0.fromArray(s.target0), this._position0.fromArray(s.position0), this._zoom0 = s.zoom0, this._focalOffset0.fromArray(s.focalOffset0), this.moveTo(s.target[0], s.target[1], s.target[2], t), dt.setFromVector3(G.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(dt.theta, dt.phi, t), this.dollyTo(dt.radius, t), this.zoomTo(s.zoom, t), this.setFocalOffset(s.focalOffset[0], s.focalOffset[1], s.focalOffset[2], t), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", gr), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, s) {
    const i = t.lengthSq();
    if (i === 0)
      return e;
    const o = z.copy(t).add(e), r = this._boundary.clampPoint(o, Ee).sub(o), a = r.lengthSq();
    if (a === 0)
      return e.add(t);
    if (a === i)
      return e;
    if (s === 0)
      return e.add(t).add(r);
    {
      const c = 1 + s * a / t.dot(r);
      return e.add(z.copy(t).multiplyScalar(c)).add(r.multiplyScalar(1 - s));
    }
  }
  _updateNearPlaneCorners() {
    if (Zt(this._camera)) {
      const e = this._camera, t = e.near, s = e.getEffectiveFOV() * Se, i = Math.tan(s * 0.5) * t, o = i * e.aspect;
      this._nearPlaneCorners[0].set(-o, -i, 0), this._nearPlaneCorners[1].set(o, -i, 0), this._nearPlaneCorners[2].set(o, i, 0), this._nearPlaneCorners[3].set(-o, i, 0);
    } else if (bt(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, s = e.left * t, i = e.right * t, o = e.top * t, n = e.bottom * t;
      this._nearPlaneCorners[0].set(s, o, 0), this._nearPlaneCorners[1].set(i, o, 0), this._nearPlaneCorners[2].set(i, n, 0), this._nearPlaneCorners[3].set(s, n, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Js(this._camera, "_collisionTest"))
      return e;
    const s = this._getTargetDirection(Pe);
    ii.lookAt(an2, s, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const o = z.copy(this._nearPlaneCorners[i]);
      o.applyMatrix4(ii);
      const n = Ee.addVectors(this._target, o);
      us.set(n, s), us.far = this._spherical.radius + 1;
      const r = us.intersectObjects(this.colliderMeshes);
      r.length !== 0 && r[0].distance < e && (e = r[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const s = () => {
        this.removeEventListener("rest", s), t();
      };
      this.addEventListener("rest", s);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new Y.Sphere()) {
    const s = t, i = s.center;
    de.makeEmpty(), e.traverseVisible((n) => {
      n.isMesh && de.expandByObject(n);
    }), de.getCenter(i);
    let o = 0;
    return e.traverseVisible((n) => {
      if (!n.isMesh)
        return;
      const r = n, a = r.geometry.clone();
      a.applyMatrix4(r.matrixWorld);
      const E = a.attributes.position;
      for (let d = 0, h = E.count; d < h; d++)
        G.fromBufferAttribute(E, d), o = Math.max(o, i.distanceToSquared(G));
    }), s.radius = Math.sqrt(o), s;
  }
};
var He = class _He extends ar {
  constructor(t) {
    super(t);
    I(this, "onBeforeUpdate", new D());
    I(this, "onAfterUpdate", new D());
    I(this, "onAspectUpdated", new D());
    I(this, "onDisposed", new D());
    I(this, "three");
    I(this, "_allControls", /* @__PURE__ */ new Map());
    I(this, "updateAspect", () => {
      var t2;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((t2 = this.currentWorld.renderer) != null && t2.isResizeable()) {
          const s = this.currentWorld.renderer.getSize();
          this.three.aspect = s.width / s.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    });
    this.three = this.setupCamera(), this.setupEvents(true), this.onWorldChanged.add(({ action: s, world: i }) => {
      if (s === "added") {
        const o = this.newCameraControls();
        this._allControls.set(i.uuid, o);
      }
      if (s === "removed") {
        const o = this._allControls.get(i.uuid);
        o && (o.dispose(), this._allControls.delete(i.uuid));
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    return this.currentWorld === null ? false : this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(t) {
    this.currentWorld !== null && (this.controls.enabled = t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, s] of this._allControls)
      s.dispose();
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, s = new PerspectiveCamera(60, t, 1, 1e3);
    return s.position.set(50, 50, 50), s.lookAt(new Vector3(0, 0, 0)), s;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    ot.install({ THREE: _He.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, s = new ot(this.three, t);
    return s.smoothTime = 0.2, s.dollyToCursor = true, s.infinityDolly = true, s;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var gs = class gs2 extends et {
  constructor(t) {
    super(t);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "onWorldCreated", new D());
    I(this, "onWorldDeleted", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "enabled", true);
    t.add(gs2.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new Fr(this.components), s = t.uuid;
    if (this.list.has(s))
      throw new Error("There is already a world with this name!");
    return this.list.set(s, t), this.onWorldCreated.trigger(t), t;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   *
   * @returns {void}
   */
  delete(t) {
    if (!this.list.has(t.uuid))
      throw new Error("The provided world is not found in the list!");
    const s = t.uuid;
    this.list.delete(t.uuid), t.dispose(), this.onWorldDeleted.trigger(s);
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   *
   * @returns {void}
   */
  dispose() {
    this.enabled = false;
    for (const [t, s] of this.list)
      s.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(t) {
    if (this.enabled)
      for (const [s, i] of this.list)
        i.update(t);
  }
};
I(gs, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var Ci = gs;
var Nr = class {
  constructor(e, t, s) {
    I(this, "onDisposed", new D());
    I(this, "world");
    I(this, "components");
    I(this, "three");
    I(this, "_fade", 3);
    I(this, "updateZoom", () => {
      this.world.camera instanceof He && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    });
    this.world = t;
    const { color: i, size1: o, size2: n, distance: r } = s;
    this.components = e;
    const a = new PlaneGeometry(2, 2, 1, 1), c = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: o
        },
        uSize2: {
          value: n
        },
        uColor: {
          value: i
        },
        uDistance: {
          value: r
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new Mesh(a, c), this.three.frustumCulled = false, t.scene.three.add(this.three), this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(e) {
    e ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(e) {
    this._fade = e ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.components.get(zt).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(e) {
    if (this.world.isDisposing || !(this.world.camera instanceof He))
      return;
    const t = this.world.camera.controls;
    e ? t.addEventListener("update", this.updateZoom) : t.removeEventListener("update", this.updateZoom);
  }
};
var _s = class _s2 extends et {
  constructor(t) {
    super(t);
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "config", {
      color: new Color(12303291),
      size1: 1,
      size2: 10,
      distance: 500
    });
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    t.add(_s2.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const s = new Nr(this.components, t, this.config);
    return this.list.set(t.uuid, s), t.onDisposed.add(() => {
      this.delete(t);
    }), s;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(t) {
    const s = this.list.get(t.uuid);
    s && s.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, s] of this.list)
      s.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
I(_s, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var dn = _s;
var jt = new Raycaster();
var nt = new Vector3();
var xt = new Vector3();
var j = new Quaternion();
var un = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var ni = { type: "change" };
var In = { type: "mouseDown" };
var fn2 = { type: "mouseUp", mode: null };
var pn = { type: "objectChange" };
var Lr = class extends Object3D {
  constructor(e, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = true, this.visible = false, this.domElement = t, this.domElement.style.touchAction = "none";
    const s = new Ur();
    this._gizmo = s, this.add(s);
    const i = new xr();
    this._plane = i, this.add(i);
    const o = this;
    function n(R, F) {
      let f = F;
      Object.defineProperty(o, R, {
        get: function() {
          return f !== void 0 ? f : F;
        },
        set: function(T) {
          f !== T && (f = T, i[R] = T, s[R] = T, o.dispatchEvent({ type: R + "-changed", value: T }), o.dispatchEvent(ni));
        }
      }), o[R] = F, i[R] = F, s[R] = F;
    }
    n("camera", e), n("object", void 0), n("enabled", true), n("axis", null), n("mode", "translate"), n("translationSnap", null), n("rotationSnap", null), n("scaleSnap", null), n("space", "world"), n("size", 1), n("dragging", false), n("showX", true), n("showY", true), n("showZ", true);
    const r = new Vector3(), a = new Vector3(), c = new Quaternion(), E = new Quaternion(), d = new Vector3(), h = new Quaternion(), u = new Vector3(), p = new Vector3(), A = new Vector3(), m = 0, C = new Vector3();
    n("worldPosition", r), n("worldPositionStart", a), n("worldQuaternion", c), n("worldQuaternionStart", E), n("cameraPosition", d), n("cameraQuaternion", h), n("pointStart", u), n("pointEnd", p), n("rotationAxis", A), n("rotationAngle", m), n("eye", C), this._offset = new Vector3(), this._startNorm = new Vector3(), this._endNorm = new Vector3(), this._cameraScale = new Vector3(), this._parentPosition = new Vector3(), this._parentQuaternion = new Quaternion(), this._parentQuaternionInv = new Quaternion(), this._parentScale = new Vector3(), this._worldScaleStart = new Vector3(), this._worldQuaternionInv = new Quaternion(), this._worldScale = new Vector3(), this._positionStart = new Vector3(), this._quaternionStart = new Quaternion(), this._scaleStart = new Vector3(), this._getPointer = Pr.bind(this), this._onPointerDown = Mr.bind(this), this._onPointerHover = yr.bind(this), this._onPointerMove = wr.bind(this), this._onPointerUp = Dr.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === true)
      return;
    jt.setFromCamera(e, this.camera);
    const t = oi(this._gizmo.picker[this.mode], jt);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === true || e.button !== 0) && this.axis !== null) {
      jt.setFromCamera(e, this.camera);
      const t = oi(this._plane, jt, true);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = true, In.mode = this.mode, this.dispatchEvent(In);
    }
  }
  pointerMove(e) {
    const t = this.axis, s = this.mode, i = this.object;
    let o = this.space;
    if (s === "scale" ? o = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (o = "world"), i === void 0 || t === null || this.dragging === false || e.button !== -1)
      return;
    jt.setFromCamera(e, this.camera);
    const n = oi(this._plane, jt, true);
    if (n) {
      if (this.pointEnd.copy(n.point).sub(this.worldPositionStart), s === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (i.position.applyQuaternion(j.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), o === "world" && (i.parent && i.position.add(nt.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(nt.setFromMatrixPosition(i.parent.matrixWorld))));
      else if (s === "scale") {
        if (t.search("XYZ") !== -1) {
          let r = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (r *= -1), xt.set(r, r, r);
        } else
          nt.copy(this.pointStart), xt.copy(this.pointEnd), nt.applyQuaternion(this._worldQuaternionInv), xt.applyQuaternion(this._worldQuaternionInv), xt.divide(nt), t.search("X") === -1 && (xt.x = 1), t.search("Y") === -1 && (xt.y = 1), t.search("Z") === -1 && (xt.z = 1);
        i.scale.copy(this._scaleStart).multiply(xt), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (s === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const r = 20 / this.worldPosition.distanceTo(nt.setFromMatrixPosition(this.camera.matrixWorld));
        let a = false;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(nt.copy(this.rotationAxis).cross(this.eye)) * r) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(un[t]), nt.copy(un[t]), o === "local" && nt.applyQuaternion(this.worldQuaternion), nt.cross(this.eye), nt.length() === 0 ? a = true : this.rotationAngle = this._offset.dot(nt.normalize()) * r), (t === "E" || a) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(j.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(j.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(ni), this.dispatchEvent(pn);
    }
  }
  pointerUp(e) {
    e.button === 0 && (this.dragging && this.axis !== null && (fn2.mode = this.mode, this.dispatchEvent(fn2)), this.dragging = false, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  // Set current object
  attach(e) {
    return this.object = e, this.visible = true, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = false, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(ni), this.dispatchEvent(pn), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return jt;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
};
function Pr(l) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: l.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (l.clientX - e.left) / e.width * 2 - 1,
      y: -(l.clientY - e.top) / e.height * 2 + 1,
      button: l.button
    };
  }
}
function yr(l) {
  if (this.enabled)
    switch (l.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(l));
        break;
    }
}
function Mr(l) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(l.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(l)), this.pointerDown(this._getPointer(l)));
}
function wr(l) {
  this.enabled && this.pointerMove(this._getPointer(l));
}
function Dr(l) {
  this.enabled && (this.domElement.releasePointerCapture(l.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(l)));
}
function oi(l, e, t) {
  const s = e.intersectObject(l, true);
  for (let i = 0; i < s.length; i++)
    if (s[i].object.visible || t)
      return s[i];
  return false;
}
var Is = new Euler();
var W = new Vector3(0, 1, 0);
var Cn = new Vector3(0, 0, 0);
var Tn = new Matrix4();
var fs = new Quaternion();
var Rs = new Quaternion();
var St = new Vector3();
var mn = new Matrix4();
var De = new Vector3(1, 0, 0);
var qt = new Vector3(0, 1, 0);
var Ue2 = new Vector3(0, 0, 1);
var ps = new Vector3();
var Me = new Vector3();
var we = new Vector3();
var Ur = class extends Object3D {
  constructor() {
    super(), this.isTransformControlsGizmo = true, this.type = "TransformControlsGizmo";
    const e = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), t = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), s = e.clone();
    s.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const o = e.clone();
    o.color.setHex(16711680);
    const n = e.clone();
    n.color.setHex(65280);
    const r = e.clone();
    r.color.setHex(255);
    const a = e.clone();
    a.color.setHex(16711680), a.opacity = 0.5;
    const c = e.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const E = e.clone();
    E.color.setHex(255), E.opacity = 0.5;
    const d = e.clone();
    d.opacity = 0.25;
    const h = e.clone();
    h.color.setHex(16776960), h.opacity = 0.25, e.clone().color.setHex(16776960);
    const p = e.clone();
    p.color.setHex(7895160);
    const A = new CylinderGeometry(0, 0.04, 0.1, 12);
    A.translate(0, 0.05, 0);
    const m = new BoxGeometry(0.08, 0.08, 0.08);
    m.translate(0, 0.04, 0);
    const C = new BufferGeometry();
    C.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const R = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    R.translate(0, 0.25, 0);
    function F(B, H) {
      const q = new TorusGeometry(B, 75e-4, 3, 64, H * Math.PI * 2);
      return q.rotateY(Math.PI / 2), q.rotateX(Math.PI / 2), q;
    }
    function f() {
      const B = new BufferGeometry();
      return B.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), B;
    }
    const T = {
      X: [
        [new Mesh(A, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(A, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(R, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(A, n), [0, 0.5, 0]],
        [new Mesh(A, n), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(R, n)]
      ],
      Z: [
        [new Mesh(A, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(A, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(R, r), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), d.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), E.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), a.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, O = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), s)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, _ = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(f(), i), null, null, null, "helper"]
      ],
      X: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(C, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(C, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, S = {
      XYZE: [
        [new Mesh(F(0.5, 1), p), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(F(0.5, 0.5), o)]
      ],
      Y: [
        [new Mesh(F(0.5, 0.5), n), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(F(0.5, 0.5), r), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(F(0.75, 1), h), null, [0, Math.PI / 2, 0]]
      ]
    }, N = {
      AXIS: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, P = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), s)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), s), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), s)]
      ]
    }, w = {
      X: [
        [new Mesh(m, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(R, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(m, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(m, n), [0, 0.5, 0]],
        [new Mesh(R, n)],
        [new Mesh(m, n), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(m, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(R, r), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(m, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), E), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), a), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), d.clone())]
      ]
    }, y = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), s), [0, 0, 0]]
      ]
    }, U = {
      X: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(C, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(C, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function x(B) {
      const H = new Object3D();
      for (const q in B)
        for (let st = B[q].length; st--; ) {
          const Q = B[q][st][0].clone(), Ht = B[q][st][1], kt = B[q][st][2], Wt = B[q][st][3], We = B[q][st][4];
          Q.name = q, Q.tag = We, Ht && Q.position.set(Ht[0], Ht[1], Ht[2]), kt && Q.rotation.set(kt[0], kt[1], kt[2]), Wt && Q.scale.set(Wt[0], Wt[1], Wt[2]), Q.updateMatrix();
          const Ce = Q.geometry.clone();
          Ce.applyMatrix4(Q.matrix), Q.geometry = Ce, Q.renderOrder = 1 / 0, Q.position.set(0, 0, 0), Q.rotation.set(0, 0, 0), Q.scale.set(1, 1, 1), H.add(Q);
        }
      return H;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = x(T)), this.add(this.gizmo.rotate = x(S)), this.add(this.gizmo.scale = x(w)), this.add(this.picker.translate = x(O)), this.add(this.picker.rotate = x(P)), this.add(this.picker.scale = x(y)), this.add(this.helper.translate = x(_)), this.add(this.helper.rotate = x(N)), this.add(this.helper.scale = x(U)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const s = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Rs;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let o = 0; o < i.length; o++) {
      const n = i[o];
      n.visible = true, n.rotation.set(0, 0, 0), n.position.copy(this.worldPosition);
      let r;
      if (this.camera.isOrthographicCamera ? r = (this.camera.top - this.camera.bottom) / this.camera.zoom : r = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), n.scale.set(1, 1, 1).multiplyScalar(r * this.size / 4), n.tag === "helper") {
        n.visible = false, n.name === "AXIS" ? (n.visible = !!this.axis, this.axis === "X" && (j.setFromEuler(Is.set(0, 0, 0)), n.quaternion.copy(s).multiply(j), Math.abs(W.copy(De).applyQuaternion(s).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "Y" && (j.setFromEuler(Is.set(0, 0, Math.PI / 2)), n.quaternion.copy(s).multiply(j), Math.abs(W.copy(qt).applyQuaternion(s).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "Z" && (j.setFromEuler(Is.set(0, Math.PI / 2, 0)), n.quaternion.copy(s).multiply(j), Math.abs(W.copy(Ue2).applyQuaternion(s).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "XYZE" && (j.setFromEuler(Is.set(0, Math.PI / 2, 0)), W.copy(this.rotationAxis), n.quaternion.setFromRotationMatrix(Tn.lookAt(Cn, W, qt)), n.quaternion.multiply(j), n.visible = this.dragging), this.axis === "E" && (n.visible = false)) : n.name === "START" ? (n.position.copy(this.worldPositionStart), n.visible = this.dragging) : n.name === "END" ? (n.position.copy(this.worldPosition), n.visible = this.dragging) : n.name === "DELTA" ? (n.position.copy(this.worldPositionStart), n.quaternion.copy(this.worldQuaternionStart), nt.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), nt.applyQuaternion(this.worldQuaternionStart.clone().invert()), n.scale.copy(nt), n.visible = this.dragging) : (n.quaternion.copy(s), this.dragging ? n.position.copy(this.worldPositionStart) : n.position.copy(this.worldPosition), this.axis && (n.visible = this.axis.search(n.name) !== -1));
        continue;
      }
      n.quaternion.copy(s), this.mode === "translate" || this.mode === "scale" ? (n.name === "X" && Math.abs(W.copy(De).applyQuaternion(s).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "Y" && Math.abs(W.copy(qt).applyQuaternion(s).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "Z" && Math.abs(W.copy(Ue2).applyQuaternion(s).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "XY" && Math.abs(W.copy(Ue2).applyQuaternion(s).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "YZ" && Math.abs(W.copy(De).applyQuaternion(s).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "XZ" && Math.abs(W.copy(qt).applyQuaternion(s).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false)) : this.mode === "rotate" && (fs.copy(s), W.copy(this.eye).applyQuaternion(j.copy(s).invert()), n.name.search("E") !== -1 && n.quaternion.setFromRotationMatrix(Tn.lookAt(this.eye, Cn, qt)), n.name === "X" && (j.setFromAxisAngle(De, Math.atan2(-W.y, W.z)), j.multiplyQuaternions(fs, j), n.quaternion.copy(j)), n.name === "Y" && (j.setFromAxisAngle(qt, Math.atan2(W.x, W.z)), j.multiplyQuaternions(fs, j), n.quaternion.copy(j)), n.name === "Z" && (j.setFromAxisAngle(Ue2, Math.atan2(W.y, W.x)), j.multiplyQuaternions(fs, j), n.quaternion.copy(j))), n.visible = n.visible && (n.name.indexOf("X") === -1 || this.showX), n.visible = n.visible && (n.name.indexOf("Y") === -1 || this.showY), n.visible = n.visible && (n.name.indexOf("Z") === -1 || this.showZ), n.visible = n.visible && (n.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), n.material._color = n.material._color || n.material.color.clone(), n.material._opacity = n.material._opacity || n.material.opacity, n.material.color.copy(n.material._color), n.material.opacity = n.material._opacity, this.enabled && this.axis && (n.name === this.axis || this.axis.split("").some(function(a) {
        return n.name === a;
      })) && (n.material.color.setHex(16776960), n.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
};
var xr = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    ), this.isTransformControlsPlane = true, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), ps.copy(De).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), Me.copy(qt).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), we.copy(Ue2).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), W.copy(Me), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            W.copy(this.eye).cross(ps), St.copy(ps).cross(W);
            break;
          case "Y":
            W.copy(this.eye).cross(Me), St.copy(Me).cross(W);
            break;
          case "Z":
            W.copy(this.eye).cross(we), St.copy(we).cross(W);
            break;
          case "XY":
            St.copy(we);
            break;
          case "YZ":
            St.copy(ps);
            break;
          case "XZ":
            W.copy(we), St.copy(Me);
            break;
          case "XYZ":
          case "E":
            St.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        St.set(0, 0, 0);
    }
    St.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (mn.lookAt(nt.set(0, 0, 0), St, W), this.quaternion.setFromRotationMatrix(mn)), super.updateMatrixWorld(e);
  }
};
var Li = class _Li {
  constructor(e, t, s, i, o, n = 5, r = true) {
    I(this, "onDraggingStarted", new D());
    I(this, "onDraggingEnded", new D());
    I(this, "onDisposed", new D());
    I(this, "normal");
    I(this, "origin");
    I(this, "three", new Plane());
    I(this, "components");
    I(this, "world");
    I(this, "_helper");
    I(this, "_visible", true);
    I(this, "_enabled", true);
    I(this, "_controlsActive", false);
    I(this, "_arrowBoundBox", new Mesh());
    I(this, "_planeMesh");
    I(this, "_controls");
    I(this, "_hiddenMaterial", new MeshBasicMaterial({
      visible: false
    }));
    I(this, "update", () => {
      this._enabled && this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    });
    I(this, "changeDrag", (e2) => {
      this._visible = !e2.value, this.preventCameraMovement(), this.notifyDraggingChanged(e2);
    });
    if (this.components = e, this.world = t, !t.renderer)
      throw new Error("The given world must have a renderer!");
    this.normal = i, this.origin = s, t.renderer.setPlane(true, this.three), this._planeMesh = _Li.newPlaneMesh(n, o), this._helper = this.newHelper(), this._controls = this.newTransformControls(), this.three.setFromNormalAndCoplanarPoint(i, s), r && this.toggleControls(true);
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(e) {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    this._enabled = e, this.world.renderer.setPlane(e, this.three);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(e) {
    this._visible = e, this._controls.visible = e, this._helper.visible = e, this.toggleControls(e);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(e) {
    this._planeMesh.material = e;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(e) {
    this._planeMesh.scale.set(e, e, e);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(e, t) {
    this.reset(), this.normal.equals(e) || (this.normal.copy(e), this._helper.lookAt(e)), this.origin.copy(t), this._helper.position.copy(t), this._helper.updateMatrix(), this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false, this.onDraggingStarted.reset(), this.onDraggingEnded.reset(), this._helper.removeFromParent(), this.world.renderer && this.world.renderer.setPlane(false, this.three), this._arrowBoundBox.removeFromParent(), this._arrowBoundBox.geometry.dispose(), this._planeMesh.geometry.dispose(), this._controls.removeFromParent(), this._controls.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  reset() {
    const e = new Vector3(1, 0, 0), t = new Vector3();
    this.normal.equals(e) || (this.normal.copy(e), this._helper.lookAt(e)), this.origin.copy(t), this._helper.position.copy(t), this._helper.updateMatrix();
  }
  toggleControls(e) {
    if (e) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update), this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else
      this._controls.removeEventListener("change", this.update), this._controls.removeEventListener("dragging-changed", this.changeDrag);
    this._controlsActive = e;
  }
  newTransformControls() {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    const e = this.world.camera.three, t = this.world.renderer.three.domElement, s = new Lr(e, t);
    return this.initializeControls(s), this.world.scene.three.add(s), s;
  }
  initializeControls(e) {
    e.attach(this._helper), e.showX = false, e.showY = false, e.setSpace("local"), this.createArrowBoundingBox(), e.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2), this._arrowBoundBox.material = this._hiddenMaterial, this._arrowBoundBox.rotateX(Math.PI / 2), this._arrowBoundBox.updateMatrix(), this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(e) {
    e.value ? this.onDraggingStarted.trigger() : this.onDraggingEnded.trigger();
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const e = new Object3D();
    return e.lookAt(this.normal), e.position.copy(this.origin), this._planeMesh.position.z += 0.01, e.add(this._planeMesh), this.world.scene.three.add(e), e;
  }
  static newPlaneMesh(e, t) {
    const s = new PlaneGeometry(1), i = new Mesh(s, t);
    return i.scale.set(e, e, e), i;
  }
};
var ve = class ve2 extends et {
  constructor(t) {
    super(t);
    I(this, "onBeforeDrag", new D());
    I(this, "onAfterDrag", new D());
    I(this, "onBeforeCreate", new D());
    I(this, "onBeforeCancel", new D());
    I(this, "onAfterCancel", new D());
    I(this, "onBeforeDelete", new D());
    I(this, "onAfterCreate", new D());
    I(this, "onAfterDelete", new D());
    I(this, "onDisposed", new D());
    I(this, "orthogonalY", false);
    I(this, "toleranceOrthogonalY", 0.7);
    I(this, "Type", Li);
    I(this, "list", []);
    I(this, "_material", new MeshBasicMaterial({
      color: 12255487,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    }));
    I(this, "_size", 5);
    I(this, "_enabled", false);
    I(this, "_visible", true);
    I(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    });
    I(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    });
    this.components.add(ve2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const s of this.list)
      s.enabled = t;
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t;
    for (const s of this.list)
      s.visible = t;
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(t) {
    this._material = t;
    for (const s of this.list)
      s.planeMaterial = t;
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(t) {
    this._size = t;
    for (const s of this.list)
      s.size = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    for (const t of this.list)
      t.dispose();
    this.list.length = 0, this._material.dispose(), this.onBeforeCreate.reset(), this.onBeforeCancel.reset(), this.onBeforeDelete.reset(), this.onBeforeDrag.reset(), this.onAfterCreate.reset(), this.onAfterCancel.reset(), this.onAfterDelete.reset(), this.onAfterDrag.reset(), this.onDisposed.trigger(ve2.uuid), this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(t) {
    const o = this.components.get(ze).get(t).castRay();
    o && this.createPlaneFromIntersection(t, o);
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(t, s, i) {
    const o = this.newPlane(t, i, s);
    return this.updateMaterialsAndPlanes(), o;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(t, s) {
    s || (s = this.pickPlane(t)), s && this.deletePlane(s);
  }
  /** Deletes all the existing clipping planes. */
  deleteAll() {
    for (; this.list.length > 0; ) {
      const t = this.list[0];
      this.delete(t.world, t);
    }
  }
  deletePlane(t) {
    const s = this.list.indexOf(t);
    if (s !== -1) {
      if (this.list.splice(s, 1), !t.world.renderer)
        throw new Error("Renderer not found for this plane's world!");
      t.world.renderer.setPlane(false, t.three), t.dispose(), this.updateMaterialsAndPlanes(), this.onAfterDelete.trigger(t);
    }
  }
  pickPlane(t) {
    const i = this.components.get(ze).get(t), o = this.getAllPlaneMeshes(), n = i.castRay(o);
    if (n) {
      const r = n.object;
      return this.list.find((a) => a.meshes.includes(r));
    }
  }
  getAllPlaneMeshes() {
    const t = [];
    for (const s of this.list)
      t.push(...s.meshes);
    return t;
  }
  createPlaneFromIntersection(t, s) {
    var a;
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    const i = s.point.distanceTo(new Vector3(0, 0, 0)), o = (a = s.face) == null ? void 0 : a.normal;
    if (!i || !o)
      return;
    const n = this.getWorldNormal(s, o), r = this.newPlane(t, s.point, n.negate());
    r.visible = this._visible, r.size = this._size, t.renderer.setPlane(true, r.three), this.updateMaterialsAndPlanes();
  }
  getWorldNormal(t, s) {
    const i = t.object;
    let o = t.object.matrixWorld.clone();
    if (i instanceof InstancedMesh && t.instanceId !== void 0) {
      const c = new Matrix4();
      i.getMatrixAt(t.instanceId, c), o = c.multiply(o);
    }
    const r = new Matrix3().getNormalMatrix(o), a = s.clone().applyMatrix3(r).normalize();
    return this.normalizePlaneDirectionY(a), a;
  }
  normalizePlaneDirectionY(t) {
    this.orthogonalY && (t.y > this.toleranceOrthogonalY && (t.x = 0, t.y = 1, t.z = 0), t.y < -this.toleranceOrthogonalY && (t.x = 0, t.y = -1, t.z = 0));
  }
  newPlane(t, s, i) {
    const o = new this.Type(
      this.components,
      t,
      s,
      i,
      this._material
    );
    return o.onDraggingStarted.add(this._onStartDragging), o.onDraggingEnded.add(this._onEndDragging), this.list.push(o), this.onAfterCreate.trigger(o), o;
  }
  updateMaterialsAndPlanes() {
    const t = this.components.get(Ci);
    for (const [s, i] of t.list) {
      if (!i.renderer)
        continue;
      i.renderer.updateClippingPlanes();
      const { clippingPlanes: o } = i.renderer;
      for (const n of i.meshes)
        if (Array.isArray(n.material))
          for (const r of n.material)
            r.clippingPlanes = o;
        else
          n.material.clippingPlanes = o;
    }
  }
};
I(ve, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
var Rn = ve;
function br(l, e, t, s) {
  return new Promise((i, o) => {
    function n() {
      const r = l.clientWaitSync(e, t, 0);
      if (r === l.WAIT_FAILED) {
        o();
        return;
      }
      if (r === l.TIMEOUT_EXPIRED) {
        setTimeout(n, s);
        return;
      }
      i();
    }
    n();
  });
}
async function vr(l, e, t, s, i, o, n) {
  const r = l.fenceSync(l.SYNC_GPU_COMMANDS_COMPLETE, 0);
  l.flush(), await br(l, r, 0, 10), l.deleteSync(r), l.bindBuffer(e, t), l.getBufferSubData(e, s, i, o, n), l.bindBuffer(e, null);
}
async function Br(l, e, t, s, i, o, n, r) {
  const a = l.createBuffer();
  return l.bindBuffer(l.PIXEL_PACK_BUFFER, a), l.bufferData(l.PIXEL_PACK_BUFFER, r.byteLength, l.STREAM_READ), l.readPixels(e, t, s, i, o, n, 0), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), await vr(l, l.PIXEL_PACK_BUFFER, a, 0, r), l.deleteBuffer(a), r;
}
var Yr = class {
  constructor(e, t, s) {
    I(this, "onDisposed", new D());
    I(this, "onViewUpdated", new Ts());
    I(this, "enabled", true);
    I(this, "needsUpdate", false);
    I(this, "renderDebugFrame", false);
    I(this, "components");
    I(this, "world");
    I(this, "renderer");
    I(this, "autoUpdate", true);
    I(this, "updateInterval", 1e3);
    I(this, "worker");
    I(this, "scene", new Scene());
    I(this, "_width", 512);
    I(this, "_height", 512);
    I(this, "_availableColor", 1);
    I(this, "renderTarget");
    I(this, "bufferSize");
    I(this, "_buffer");
    I(this, "_isWorkerBusy", false);
    I(this, "updateVisibility", async (e2) => {
      if (!this.enabled || !this.needsUpdate && !e2 || this._isWorkerBusy)
        return;
      this._isWorkerBusy = true;
      const t2 = this.world.camera.three;
      t2.updateMatrix(), this.renderer.setSize(this._width, this._height), this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, t2);
      const s2 = this.renderer.getContext();
      await Br(
        s2,
        0,
        0,
        this._width,
        this._height,
        s2.RGBA,
        s2.UNSIGNED_BYTE,
        this._buffer
      ), this.renderer.setRenderTarget(null), this.renderDebugFrame && this.renderer.render(this.scene, t2), this.worker.postMessage({
        buffer: this._buffer
      }), this.needsUpdate = false;
    });
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = e, this.applySettings(s), this.world = t, this.renderer = new WebGLRenderer(), this.renderTarget = new WebGLRenderTarget(this._width, this._height), this.bufferSize = this._width * this._height * 4, this._buffer = new Uint8Array(this.bufferSize), this.renderer.clippingPlanes = t.renderer.clippingPlanes;
    const i = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `, o = new Blob([i], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(o));
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    for (const e of this.scene.children)
      e.removeFromParent();
    this.onViewUpdated.reset(), this.worker.terminate(), this.renderer.dispose(), this.renderTarget.dispose(), this._buffer = null, this.onDisposed.reset();
  }
  getAvailableColor() {
    let e = BigInt(this._availableColor.toString());
    const t = [];
    do
      t.unshift(Number(e % 256n)), e /= 256n;
    while (e);
    for (; t.length !== 3; )
      t.unshift(0);
    const [s, i, o] = t, n = `${s}-${i}-${o}`;
    return { r: s, g: i, b: o, code: n };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
  applySettings(e) {
    e && (e.updateInterval !== void 0 && (this.updateInterval = e.updateInterval), e.height !== void 0 && (this._height = e.height), e.width !== void 0 && (this._width = e.width), e.autoUpdate !== void 0 && (this.autoUpdate = e.autoUpdate));
  }
};
var Vr = class extends Yr {
  constructor(t, s, i) {
    super(t, s, i);
    I(this, "onViewUpdated", new D());
    I(this, "threshold", 100);
    I(this, "colorMeshes", /* @__PURE__ */ new Map());
    I(this, "isProcessing", false);
    I(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map());
    I(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map());
    I(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set());
    I(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set());
    I(this, "_intervalID", null);
    I(this, "_transparentMat", new MeshBasicMaterial({
      transparent: true,
      opacity: 0
    }));
    I(this, "handleWorkerMessage", async (t2) => {
      if (this.isProcessing)
        return;
      const s2 = t2.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes), this._currentVisibleMeshes.clear();
      for (const [i2, o] of s2) {
        if (o < this.threshold)
          continue;
        const n = this._colorCodeMeshMap.get(i2);
        n && (this._currentVisibleMeshes.add(n), this._recentlyHiddenMeshes.delete(n));
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      }), this._isWorkerBusy = false;
    });
    this.worker.addEventListener("message", this.handleWorkerMessage), this.autoUpdate && window.setInterval(async () => {
      this.isProcessing || await this.updateVisibility();
    }, this.updateInterval), this.onViewUpdated.add(({ seen: o, unseen: n }) => {
      for (const r of o)
        r.visible = true;
      for (const r of n)
        r.visible = false;
    });
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null), this._currentVisibleMeshes.clear(), this._recentlyHiddenMeshes.clear(), this._meshIDColorCodeMap.clear(), this._transparentMat.dispose(), this._colorCodeMeshMap.clear();
    const t = this.components.get(zt);
    for (const s in this.colorMeshes) {
      const i = this.colorMeshes.get(s);
      i && t.destroy(i, true);
    }
    this.colorMeshes.clear();
  }
  /**
   * Adds a mesh to the culler. When the mesh is not visibile anymore, it will be removed from the scene. When it's visible again, it will be added to the scene.
   * @param mesh - The mesh to add. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   * @returns {void}
   */
  add(t) {
    if (!this.enabled)
      return;
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const s = t instanceof InstancedMesh, { geometry: i, material: o } = t, { colorMaterial: n, code: r } = this.getAvailableMaterial();
    let a;
    if (Array.isArray(o)) {
      let d = true;
      const h = [];
      for (const u of o)
        sn.isTransparent(u) ? h.push(this._transparentMat) : (d = false, h.push(n));
      if (d) {
        n.dispose(), this.isProcessing = false;
        return;
      }
      a = h;
    } else if (sn.isTransparent(o)) {
      n.dispose(), this.isProcessing = false;
      return;
    } else
      a = n;
    this._colorCodeMeshMap.set(r, t), this._meshIDColorCodeMap.set(t.uuid, r);
    const c = s ? t.count : 1, E = new InstancedMesh(i, a, c);
    s ? E.instanceMatrix = t.instanceMatrix : E.setMatrixAt(0, new Matrix4()), t.visible = false, t.updateWorldMatrix(true, false), E.applyMatrix4(t.matrixWorld), E.updateMatrix(), this.scene.add(E), this.colorMeshes.set(t.uuid, E), this.increaseColor(), this.isProcessing = false;
  }
  /**
   * Removes a mesh from the culler, so its visibility is not controlled by the culler anymore.
   * When the mesh is removed, it will be hidden from the scene and its color-coded mesh will be destroyed.
   * @param mesh - The mesh to remove. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   * @returns {void}
   */
  remove(t) {
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const s = this.components.get(zt);
    this._currentVisibleMeshes.delete(t), this._recentlyHiddenMeshes.delete(t);
    const i = this.colorMeshes.get(t.uuid), o = this._meshIDColorCodeMap.get(t.uuid);
    if (!i || !o) {
      this.isProcessing = false, console.log(t.visible);
      return;
    }
    this._colorCodeMeshMap.delete(o), this._meshIDColorCodeMap.delete(t.uuid), this.colorMeshes.delete(t.uuid), i.geometry = void 0, i.material = [], s.destroy(i, true), this._recentlyHiddenMeshes.delete(t), this._currentVisibleMeshes.delete(t), this.isProcessing = false;
  }
  getAvailableMaterial() {
    const { r: t, g: s, b: i, code: o } = this.getAvailableColor(), n = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const r = new Color(`rgb(${t}, ${s}, ${i})`);
    if (!this.world.renderer)
      throw new Error("Renderer not found in the world!");
    const a = this.world.renderer.clippingPlanes, c = new MeshBasicMaterial({
      color: r,
      clippingPlanes: a,
      side: DoubleSide
    });
    return ColorManagement.enabled = n, { colorMaterial: c, code: o };
  }
};
var Be = class Be2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "_enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    t.add(Be2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const [s, i] of this.list)
      i.enabled = t;
  }
  /**
   * Creates a new MeshCullerRenderer for the given world.
   * If a MeshCullerRenderer already exists for the world, it will return the existing one.
   *
   * @param world - The world for which to create the MeshCullerRenderer.
   * @param config - Optional configuration settings for the MeshCullerRenderer.
   *
   * @returns The newly created or existing MeshCullerRenderer for the given world.
   */
  create(t, s) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const i = new Vr(this.components, t, s);
    return this.list.set(t.uuid, i), i;
  }
  /**
   * Deletes the MeshCullerRenderer associated with the given world.
   * If a MeshCullerRenderer exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the MeshCullerRenderer.
   *
   * @returns {void}
   */
  delete(t) {
    const s = this.list.get(t.uuid);
    s && s.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.onDisposed.trigger(Be2.uuid), this.onDisposed.reset();
    for (const [t, s] of this.list)
      s.dispose();
    this.list.clear();
  }
};
I(Be, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
var Ti = Be;
var Gr = class {
  constructor(e) {
    I(this, "onDisposed", new D());
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onResize", new D());
    I(this, "frontOffset", 0);
    I(this, "overrideMaterial", new MeshDepthMaterial());
    I(this, "backgroundColor", new Color(395274));
    I(this, "renderer");
    I(this, "enabled", true);
    I(this, "world");
    I(this, "_lockRotation", true);
    I(this, "_camera");
    I(this, "_plane");
    I(this, "_size", new Vector2(320, 160));
    I(this, "_tempVector1", new Vector3());
    I(this, "_tempVector2", new Vector3());
    I(this, "_tempTarget", new Vector3());
    I(this, "down", new Vector3(0, -1, 0));
    I(this, "updatePlanes", () => {
      if (!this.world.renderer)
        throw new Error("The given world must have a renderer!");
      const e2 = [], t2 = this.world.renderer.three;
      for (const s2 of t2.clippingPlanes)
        e2.push(s2);
      e2.push(this._plane), this.renderer.clippingPlanes = e2;
    });
    if (this.world = e, !this.world.renderer)
      throw new Error("The given world must have a renderer!");
    this.renderer = new WebGLRenderer(), this.renderer.setSize(this._size.x, this._size.y);
    const t = 1, s = this._size.x / this._size.y;
    this._camera = new OrthographicCamera(
      t * s / -2,
      t * s / 2,
      t / 2,
      t / -2
    ), this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes), this._camera.position.set(0, 200, 0), this._camera.zoom = 0.1, this._camera.rotation.x = -Math.PI / 2, this._plane = new Plane(this.down, 200), this.updatePlanes();
  }
  /**
   * Gets or sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   */
  get lockRotation() {
    return this._lockRotation;
  }
  /**
   * Sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   * @param active - If `true`, rotation is locked. If `false`, rotation is not locked.
   */
  set lockRotation(e) {
    this._lockRotation = e, e && (this._camera.rotation.z = 0);
  }
  /**
   * Gets the current zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @returns The current zoom level of the minimap.
   */
  get zoom() {
    return this._camera.zoom;
  }
  /**
   * Sets the zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @param value - The new zoom level of the minimap.
   */
  set zoom(e) {
    this._camera.zoom = e, this._camera.updateProjectionMatrix();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.onResize.reset(), this.overrideMaterial.dispose(), this.renderer.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** Returns the camera used by the MiniMap */
  get() {
    return this._camera;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const e = this.world.scene.three, t = this.world.camera;
    if (!t.hasCameraControls())
      throw new Error("The given world must use camera controls!");
    if (!(e instanceof Scene))
      throw new Error("The given world must have a THREE.Scene as a root!");
    const s = t.controls;
    if (s.getPosition(this._tempVector1), this._camera.position.x = this._tempVector1.x, this._camera.position.z = this._tempVector1.z, this.frontOffset !== 0 && (s.getTarget(this._tempVector2), this._tempVector2.sub(this._tempVector1), this._tempVector2.normalize().multiplyScalar(this.frontOffset), this._camera.position.x += this._tempVector2.x, this._camera.position.z += this._tempVector2.z), !this._lockRotation) {
      s.getTarget(this._tempTarget);
      const o = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = o + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const i = e.background;
    e.background = this.backgroundColor, this.renderer.render(e, this._camera), e.background = i, this.onAfterUpdate.trigger();
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    return this._size;
  }
  /** {@link Resizeable.resize} */
  resize(e = this._size) {
    this._size.copy(e), this.renderer.setSize(e.x, e.y);
    const t = e.x / e.y, s = 1;
    this._camera.left = s * t / -2, this._camera.right = s * t / 2, this._camera.top = s / 2, this._camera.bottom = -s / 2, this._camera.updateProjectionMatrix(), this.onResize.trigger(e);
  }
};
var Ss = class Ss2 extends et {
  constructor(t) {
    super(t);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    this.components.add(Ss2.uuid, this);
  }
  /**
   * Creates a new {@link MiniMap} instance associated with the given world.
   * If a {@link MiniMap} instance already exists for the given world, an error will be thrown.
   *
   * @param world - The {@link World} for which to create a {@link MiniMap} instance.
   * @returns The newly created {@link MiniMap} instance.
   * @throws Will throw an error if a {@link MiniMap} instance already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a minimap!");
    const s = new Gr(t);
    return this.list.set(t.uuid, s), s;
  }
  /**
   * Deletes a {@link MiniMap} instance associated with the given world ID.
   * If a {@link MiniMap} instance does not exist for the given ID, nothing happens.
   *
   * @param id - The unique identifier of the world for which to delete the {@link MiniMap} instance.
   * @returns {void}
   */
  delete(t) {
    const s = this.list.get(t);
    s && s.dispose(), this.list.delete(t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, s] of this.list)
      s.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update() {
    for (const [t, s] of this.list)
      s.update();
  }
};
I(Ss, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
var An = Ss;
var zr = class {
  constructor(e) {
    I(this, "enabled", false);
    I(this, "id", "FirstPerson");
    this.camera = e;
  }
  /** {@link NavigationMode.set} */
  set(e) {
    if (this.enabled = e, e) {
      if (this.camera.projection.current !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const e = this.camera.controls, t = new Vector3();
    e.distance--, e.getPosition(t), e.minDistance = 1, e.maxDistance = 1, e.distance = 1, e.moveTo(
      t.x,
      t.y,
      t.z
    ), e.truckSpeed = 50, e.mouseButtons.wheel = ot.ACTION.DOLLY, e.touches.two = ot.ACTION.TOUCH_ZOOM_TRUCK;
  }
};
var Hr = class {
  constructor(e) {
    I(this, "enabled", true);
    I(this, "id", "Orbit");
    this.camera = e, this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(e) {
    this.enabled = e, e && this.activateOrbitControls();
  }
  activateOrbitControls() {
    const e = this.camera.controls;
    e.minDistance = 1, e.maxDistance = 300;
    const t = new Vector3();
    e.getPosition(t);
    const s = t.length();
    e.distance = s, e.truckSpeed = 2;
    const { rotation: i } = this.camera.three, o = new Vector3(0, 0, -1).applyEuler(i), n = t.addScaledVector(o, s);
    e.moveTo(n.x, n.y, n.z);
  }
};
var kr = class {
  constructor(e) {
    I(this, "enabled", false);
    I(this, "id", "Plan");
    I(this, "mouseAction1");
    I(this, "mouseAction2");
    I(this, "mouseInitialized", false);
    I(this, "defaultAzimuthSpeed");
    I(this, "defaultPolarSpeed");
    this.camera = e, this.defaultAzimuthSpeed = e.controls.azimuthRotateSpeed, this.defaultPolarSpeed = e.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(e) {
    this.enabled = e;
    const t = this.camera.controls;
    t.azimuthRotateSpeed = e ? 0 : this.defaultAzimuthSpeed, t.polarRotateSpeed = e ? 0 : this.defaultPolarSpeed, this.mouseInitialized || (this.mouseAction1 = t.touches.one, this.mouseAction2 = t.touches.two, this.mouseInitialized = true), e ? (t.mouseButtons.left = ot.ACTION.TRUCK, t.touches.one = ot.ACTION.TOUCH_TRUCK, t.touches.two = ot.ACTION.TOUCH_ZOOM) : (t.mouseButtons.left = ot.ACTION.ROTATE, t.touches.one = this.mouseAction1, t.touches.two = this.mouseAction2);
  }
};
var Wr = class {
  constructor(e) {
    I(this, "onChanged", new D());
    I(this, "current", "Perspective");
    I(this, "camera");
    I(this, "matchOrthoDistanceEnabled", false);
    I(this, "_component");
    I(this, "_previousDistance", -1);
    this._component = e, this.camera = e.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(e) {
    this.current !== e && (e === "Orthographic" ? this.setOrthoCamera() : await this.setPerspectiveCamera(), this.onChanged.trigger(this.camera));
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const t = this.current === "Perspective" ? "Orthographic" : "Perspective";
    await this.set(t);
  }
  setOrthoCamera() {
    if (this._component.mode === null || this._component.mode.id === "FirstPerson")
      return;
    this._previousDistance = this._component.controls.distance, this._component.controls.distance = 200;
    const e = this.getPerspectiveDims();
    if (!e)
      return;
    const { width: t, height: s } = e;
    this.setupOrthoCamera(s, t), this.camera = this._component.threeOrtho, this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const e = this._component.currentWorld;
    if (!e || !e.renderer)
      return null;
    const t = new Vector3();
    this._component.threePersp.getWorldDirection(t);
    const s = new Vector3();
    this._component.controls.getTarget(s);
    const o = s.clone().sub(this._component.threePersp.position).dot(t), n = e.renderer.getSize(), r = n.x / n.y, a = this._component.threePersp, c = o * 2 * Math.atan(a.fov * (Math.PI / 180) / 2);
    return { width: c * r, height: c };
  }
  setupOrthoCamera(e, t) {
    this._component.controls.mouseButtons.wheel = ot.ACTION.ZOOM, this._component.controls.mouseButtons.middle = ot.ACTION.ZOOM;
    const s = this._component.threePersp, i = this._component.threeOrtho;
    i.zoom = 1, i.left = t / -2, i.right = t / 2, i.top = e / 2, i.bottom = e / -2, i.updateProjectionMatrix(), i.position.copy(s.position), i.quaternion.copy(s.quaternion), this._component.controls.camera = i;
  }
  getDistance() {
    const e = this._component.threePersp, t = this._component.threeOrtho;
    return (t.top - t.bottom) / t.zoom / (2 * Math.atan(e.fov * (Math.PI / 180) / 2));
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = ot.ACTION.DOLLY, this._component.controls.mouseButtons.middle = ot.ACTION.DOLLY;
    const e = this._component.threePersp, t = this._component.threeOrtho;
    e.position.copy(t.position), e.quaternion.copy(t.quaternion), this._component.controls.mouseButtons.wheel = ot.ACTION.DOLLY, this.matchOrthoDistanceEnabled ? this._component.controls.distance = this.getDistance() : this._component.controls.distance = this._previousDistance, await this._component.controls.zoomTo(1), e.updateProjectionMatrix(), this._component.controls.camera = e, this.camera = e, this.current = "Perspective";
  }
};
var na = class extends He {
  constructor(t) {
    super(t);
    I(this, "projection");
    I(this, "threeOrtho");
    I(this, "threePersp");
    I(this, "_userInputButtons", {});
    I(this, "_frustumSize", 50);
    I(this, "_navigationModes", /* @__PURE__ */ new Map());
    I(this, "_mode", null);
    I(this, "previousSize", null);
    this.threePersp = this.three, this.threeOrtho = this.newOrthoCamera(), this.projection = new Wr(this), this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    }), this.projection.onChanged.add(
      (s) => {
        this.three = s, this.updateAspect();
      }
    ), this.onWorldChanged.add(({ action: s }) => {
      s === "added" && (this._navigationModes.clear(), this._navigationModes.set("Orbit", new Hr(this)), this._navigationModes.set("FirstPerson", new zr(this)), this._navigationModes.set("Plan", new kr(this)), this._mode = this._navigationModes.get("Orbit"), this.mode.set(true, { preventTargetAdjustment: true }), this.currentWorld && this.currentWorld.renderer && (this.previousSize = this.currentWorld.renderer.getSize().clone()));
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode)
      throw new Error("Mode not found, camera not initialized");
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(t) {
    if (this.mode !== null && this.mode.id !== t) {
      if (this.mode.set(false), !this._navigationModes.has(t))
        throw new Error("The specified mode does not exist!");
      this._mode = this._navigationModes.get(t), this.mode.set(true);
    }
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(t, s = 1.5) {
    if (!this.enabled)
      return;
    const i = Number.MAX_VALUE, o = Number.MIN_VALUE, n = new Vector3(i, i, i), r = new Vector3(o, o, o);
    for (const u of t) {
      const p = new Box3().setFromObject(u);
      p.min.x < n.x && (n.x = p.min.x), p.min.y < n.y && (n.y = p.min.y), p.min.z < n.z && (n.z = p.min.z), p.max.x > r.x && (r.x = p.max.x), p.max.y > r.y && (r.y = p.max.y), p.max.z > r.z && (r.z = p.max.z);
    }
    const a = new Box3(n, r), c = new Vector3();
    a.getSize(c);
    const E = new Vector3();
    a.getCenter(E);
    const d = Math.max(c.x, c.y, c.z) * s, h = new Sphere(E, d);
    await this.controls.fitToSphere(h, true);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(t) {
    t ? this.enableUserInput() : this.disableUserInput();
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left, this._userInputButtons.right = this.controls.mouseButtons.right, this._userInputButtons.middle = this.controls.mouseButtons.middle, this._userInputButtons.wheel = this.controls.mouseButtons.wheel, this.controls.mouseButtons.left = 0, this.controls.mouseButtons.right = 0, this.controls.mouseButtons.middle = 0, this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    Object.keys(this._userInputButtons).length !== 0 && (this.controls.mouseButtons.left = this._userInputButtons.left, this.controls.mouseButtons.right = this._userInputButtons.right, this.controls.mouseButtons.middle = this._userInputButtons.middle, this.controls.mouseButtons.wheel = this._userInputButtons.wheel);
  }
  newOrthoCamera() {
    const t = window.innerWidth / window.innerHeight;
    return new OrthographicCamera(
      this._frustumSize * t / -2,
      this._frustumSize * t / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer || !this.previousSize)
      return;
    const t = this.currentWorld.renderer.getSize(), s = this.threeOrtho.top, i = this.threeOrtho.right, o = t.y / this.previousSize.y, n = t.x / this.previousSize.x, r = s * o, a = i * n;
    this.threeOrtho.left = -a, this.threeOrtho.right = a, this.threeOrtho.top = r, this.threeOrtho.bottom = -r, this.threeOrtho.updateProjectionMatrix(), this.previousSize.copy(t);
  }
};
var At = class At2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "onDisposed", new D());
    I(this, "_absoluteMin");
    I(this, "_absoluteMax");
    I(this, "_meshes", []);
    this.components.add(At2.uuid, this), this._absoluteMin = At2.newBound(true), this._absoluteMax = At2.newBound(false);
  }
  /**
   * A static method to calculate the dimensions of a given bounding box.
   *
   * @param bbox - The bounding box to calculate the dimensions for.
   * @returns An object containing the width, height, depth, and center of the bounding box.
   */
  static getDimensions(t) {
    const { min: s, max: i } = t, o = Math.abs(i.x - s.x), n = Math.abs(i.y - s.y), r = Math.abs(i.z - s.z), a = new Vector3();
    return a.subVectors(i, s).divideScalar(2).add(s), { width: o, height: n, depth: r, center: a };
  }
  /**
   * A static method to create a new bounding box boundary.
   *
   * @param positive - A boolean indicating whether to create a boundary for positive or negative values.
   * @returns A new THREE.Vector3 representing the boundary.
   *
   * @remarks
   * This method is used to create a new boundary for calculating bounding boxes.
   * It sets the x, y, and z components of the returned vector to positive or negative infinity,
   * depending on the value of the `positive` parameter.
   *
   * @example
   * ```typescript
   * const positiveBound = BoundingBoxer.newBound(true);
   * console.log(positiveBound); // Output: Vector3 { x: Infinity, y: Infinity, z: Infinity }
   *
   * const negativeBound = BoundingBoxer.newBound(false);
   * console.log(negativeBound); // Output: Vector3 { x: -Infinity, y: -Infinity, z: -Infinity }
   * ```
   */
  static newBound(t) {
    const s = t ? 1 : -1;
    return new Vector3(
      s * Number.MAX_VALUE,
      s * Number.MAX_VALUE,
      s * Number.MAX_VALUE
    );
  }
  /**
   * A static method to calculate the bounding box of a set of points.
   *
   * @param points - An array of THREE.Vector3 representing the points.
   * @param min - An optional THREE.Vector3 representing the minimum bounds. If not provided, it will be calculated.
   * @param max - An optional THREE.Vector3 representing the maximum bounds. If not provided, it will be calculated.
   * @returns A THREE.Box3 representing the bounding box of the given points.
   *
   * @remarks
   * This method calculates the bounding box of a set of points by iterating through each point and updating the minimum and maximum bounds accordingly.
   * If the `min` or `max` parameters are provided, they will be used as the initial bounds. Otherwise, the initial bounds will be set to positive and negative infinity.
   *
   * @example
   * ```typescript
   * const points = [
   *   new THREE.Vector3(1, 2, 3),
   *   new THREE.Vector3(4, 5, 6),
   *   new THREE.Vector3(7, 8, 9),
   * ];
   *
   * const bbox = BoundingBoxer.getBounds(points);
   * console.log(bbox); // Output: Box3 { min: Vector3 { x: 1, y: 2, z: 3 }, max: Vector3 { x: 7, y: 8, z: 9 } }
   * ```
   */
  static getBounds(t, s, i) {
    const o = i || this.newBound(false), n = s || this.newBound(true);
    for (const r of t)
      r.x < n.x && (n.x = r.x), r.y < n.y && (n.y = r.y), r.z < n.z && (n.z = r.z), r.x > o.x && (o.x = r.x), r.y > o.y && (o.y = r.y), r.z > o.z && (o.z = r.z);
    return new Box3(s, i);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(zt);
    for (const s of this._meshes)
      t.destroy(s);
    this._meshes = [], this.onDisposed.trigger(At2.uuid), this.onDisposed.reset();
  }
  /**
   * Returns the bounding box of the calculated fragments.
   *
   * @returns A new THREE.Box3 instance representing the bounding box.
   *
   * @remarks
   * This method clones the internal minimum and maximum vectors and returns a new THREE.Box3 instance.
   * The returned box represents the bounding box of the calculated fragments.
   *
   * @example
   * ```typescript
   * const boundingBox = boundingBoxer.get();
   * console.log(boundingBox); // Output: Box3 { min: Vector3 { x: -10, y: -10, z: -10 }, max: Vector3 { x: 10, y: 10, z: 10 } }
   * ```
   */
  get() {
    const t = this._absoluteMin.clone(), s = this._absoluteMax.clone();
    return new Box3(t, s);
  }
  /**
   * Calculates and returns a sphere that encompasses the entire bounding box.
   *
   * @returns A new THREE.Sphere instance representing the calculated sphere.
   *
   * @remarks
   * This method calculates the center and radius of a sphere that encompasses the entire bounding box.
   * The center is calculated as the midpoint between the minimum and maximum bounds of the bounding box.
   * The radius is calculated as the distance from the center to the minimum bound.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingSphere = boundingBoxer.getSphere();
   * console.log(boundingSphere); // Output: Sphere { center: Vector3 { x: 0, y: 0, z: 0 }, radius: 10 }
   * ```
   */
  getSphere() {
    const t = this._absoluteMin.clone(), s = this._absoluteMax.clone(), i = Math.abs((s.x - t.x) / 2), o = Math.abs((s.y - t.y) / 2), n = Math.abs((s.z - t.z) / 2), r = new Vector3(t.x + i, t.y + o, t.z + n), a = r.distanceTo(t);
    return new Sphere(r, a);
  }
  /**
   * Returns a THREE.Mesh instance representing the bounding box.
   *
   * @returns A new THREE.Mesh instance representing the bounding box.
   *
   * @remarks
   * This method calculates the dimensions of the bounding box using the `getDimensions` method.
   * It then creates a new THREE.BoxGeometry with the calculated dimensions.
   * A new THREE.Mesh is created using the box geometry, and it is added to the `_meshes` array.
   * The position of the mesh is set to the center of the bounding box.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingBoxMesh = boundingBoxer.getMesh();
   * scene.add(boundingBoxMesh);
   * ```
   */
  getMesh() {
    const t = new Box3(this._absoluteMin, this._absoluteMax), s = At2.getDimensions(t), { width: i, height: o, depth: n, center: r } = s, a = new BoxGeometry(i, o, n), c = new Mesh(a);
    return this._meshes.push(c), c.position.copy(r), c;
  }
  /**
   * Resets the internal minimum and maximum vectors to positive and negative infinity, respectively.
   * This method is used to prepare the BoundingBoxer for a new set of fragments.
   *
   * @remarks
   * This method is called when a new set of fragments is added to the BoundingBoxer.
   * It ensures that the bounding box calculations are accurate and up-to-date.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * // ...
   * boundingBoxer.reset();
   * ```
   */
  reset() {
    this._absoluteMin = At2.newBound(true), this._absoluteMax = At2.newBound(false);
  }
  /**
   * Adds a FragmentsGroup to the BoundingBoxer.
   *
   * @param group - The FragmentsGroup to add.
   *
   * @remarks
   * This method iterates through each fragment in the provided FragmentsGroup,
   * and calls the `addMesh` method for each fragment's mesh.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * ```
   */
  add(t) {
    for (const s of t.items)
      this.addMesh(s.mesh);
  }
  /**
   * Adds a mesh to the BoundingBoxer and calculates the bounding box.
   *
   * @param mesh - The mesh to add. It can be an instance of THREE.InstancedMesh, THREE.Mesh, or FRAGS.CurveMesh.
   * @param itemIDs - An optional iterable of numbers representing the item IDs.
   *
   * @remarks
   * This method calculates the bounding box of the provided mesh and updates the internal minimum and maximum vectors.
   * If the mesh is an instance of THREE.InstancedMesh, it calculates the bounding box for each instance.
   * If the mesh is an instance of FRAGS.FragmentMesh and itemIDs are provided, it calculates the bounding box for the specified item IDs.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.addMesh(mesh);
   * ```
   */
  addMesh(t, s) {
    if (!t.geometry.index)
      return;
    const i = At2.getFragmentBounds(t);
    t.updateMatrixWorld();
    const o = t.matrixWorld, n = new Matrix4(), r = t instanceof InstancedMesh, a = /* @__PURE__ */ new Set();
    if (s && t instanceof ae)
      for (const c of s) {
        const E = t.fragment.getInstancesIDs(c);
        if (E)
          for (const d of E)
            a.add(d);
      }
    else
      a.add(0);
    for (const c of a) {
      const E = i.min.clone(), d = i.max.clone();
      r && (t.getMatrixAt(c, n), E.applyMatrix4(n), d.applyMatrix4(n)), E.applyMatrix4(o), d.applyMatrix4(o), E.x < this._absoluteMin.x && (this._absoluteMin.x = E.x), E.y < this._absoluteMin.y && (this._absoluteMin.y = E.y), E.z < this._absoluteMin.z && (this._absoluteMin.z = E.z), E.x > this._absoluteMax.x && (this._absoluteMax.x = E.x), E.y > this._absoluteMax.y && (this._absoluteMax.y = E.y), E.z > this._absoluteMax.z && (this._absoluteMax.z = E.z), d.x > this._absoluteMax.x && (this._absoluteMax.x = d.x), d.y > this._absoluteMax.y && (this._absoluteMax.y = d.y), d.z > this._absoluteMax.z && (this._absoluteMax.z = d.z), d.x < this._absoluteMin.x && (this._absoluteMin.x = d.x), d.y < this._absoluteMin.y && (this._absoluteMin.y = d.y), d.z < this._absoluteMin.z && (this._absoluteMin.z = d.z);
    }
  }
  static getFragmentBounds(t) {
    const s = t.geometry.attributes.position, i = Number.MAX_VALUE, o = -i, n = new Vector3(i, i, i), r = new Vector3(o, o, o);
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const a = Array.from(t.geometry.index.array);
    for (let c = 0; c < a.length; c++) {
      if (c % 3 === 0 && a[c] === 0 && a[c + 1] === 0 && a[c + 2] === 0) {
        c += 2;
        continue;
      }
      const E = a[c], d = s.getX(E), h = s.getY(E), u = s.getZ(E);
      d < n.x && (n.x = d), h < n.y && (n.y = h), u < n.z && (n.z = u), d > r.x && (r.x = d), h > r.y && (r.y = h), u > r.z && (r.z = u);
    }
    return new Box3(n, r);
  }
};
I(At, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
var Fn = At;
var vn = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  3940055652,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014
]);
var Ns = class Ns2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    t.add(Ns2.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(t, s, i = false, o = true) {
    const n = {}, r = new Set(t.GetIfcEntityList(s)), a = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const c of a)
      r.add(c);
    for (const c of r) {
      if (vn.has(c))
        continue;
      const E = a.has(c) && o, d = t.GetLineIDsWithType(s, c);
      for (const h of d) {
        const u = t.GetLine(0, h, E, i);
        n[u.expressID] = u;
      }
    }
    return n;
  }
};
I(Ns, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
var mi = Ns;
var Ls = class Ls2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onFragmentsLoaded", new D());
    I(this, "onFragmentsDisposed", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "groups", /* @__PURE__ */ new Map());
    I(this, "baseCoordinationModel", "");
    I(this, "enabled", true);
    I(this, "_loader", new an());
    this.components.add(Ls2.uuid, this);
  }
  /**
   * Getter for the meshes of all fragments in the FragmentsManager.
   * It iterates over the fragments in the list and pushes their meshes into an array.
   * @returns {THREE.Mesh[]} An array of THREE.Mesh objects representing the fragments.
   */
  get meshes() {
    const t = [];
    for (const [s, i] of this.list)
      t.push(i.mesh);
    return t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, s] of this.groups)
      s.dispose(true);
    this.baseCoordinationModel = "", this.groups.clear(), this.list.clear(), this.onFragmentsLoaded.reset(), this.onFragmentsDisposed.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Dispose of a specific fragment group.
   * This method removes the group from the groups map, deletes all fragments within the group from the list,
   * disposes of the group, and triggers the onFragmentsDisposed event.
   *
   * @param group - The fragment group to be disposed.
   */
  disposeGroup(t) {
    const { uuid: s } = t, i = [];
    for (const o of t.items)
      i.push(o.id), this.list.delete(o.id);
    t.dispose(true), this.groups.delete(t.uuid), this.onFragmentsDisposed.trigger({
      groupID: s,
      fragmentIDs: i
    });
  }
  /**
   * Loads a binary file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(t, s) {
    const o = { ...{ coordinate: true }, ...s }, { coordinate: n, name: r, properties: a, relationsMap: c } = o, E = this._loader.import(t);
    r && (E.name = r);
    for (const d of E.items)
      d.group = E, this.list.set(d.id, d);
    return n && this.coordinate([E]), this.groups.set(E.uuid, E), a && E.setLocalProperties(a), c && this.components.get(ke2).setRelationMap(E, c), this.onFragmentsLoaded.trigger(E), E;
  }
  /**
   * Export the specified fragmentsgroup to binary data.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(t) {
    return this._loader.export(t);
  }
  /**
   * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
   * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
   * @returns A map of model IDs to sets of express IDs.
   */
  getModelIdMap(t) {
    const s = {};
    for (const i in t) {
      const o = this.list.get(i);
      if (!(o && o.group))
        continue;
      const n = o.group;
      n.uuid in s || (s[n.uuid] = /* @__PURE__ */ new Set());
      const r = t[i];
      for (const a of r)
        s[n.uuid].add(a);
    }
    return s;
  }
  /**
   * Converts a map of model IDs to sets of express IDs to a fragment ID map.
   * @param modelIdMap - A map of model IDs to their corresponding express IDs.
   * @returns A fragment ID map.
   * @remarks
   * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
   * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
   * The fragment ID maps are then merged into a single map and returned.
   * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
   */
  modelIdToFragmentIdMap(t) {
    let s = {};
    for (const i in t) {
      const o = this.groups.get(i);
      if (!o)
        continue;
      const n = t[i], r = o.getFragmentMap(n);
      s = { ...s, ...r };
    }
    return s;
  }
  /**
   * Applies coordinate transformation to the provided models.
   * If no models are provided, all groups are used.
   * The first model in the list becomes the base model for coordinate transformation.
   * All other models are then transformed to match the base model's coordinate system.
   *
   * @param models - The models to apply coordinate transformation to.
   * If not provided, all groups are used.
   *
   * @returns {void}
   */
  coordinate(t = Array.from(this.groups.values())) {
    if (this.baseCoordinationModel.length === 0) {
      const o = t.pop();
      if (!o)
        return;
      this.baseCoordinationModel = o.uuid;
    }
    if (!t.length)
      return;
    const i = this.groups.get(this.baseCoordinationModel);
    if (!i) {
      console.log("No base model found for coordination!");
      return;
    }
    for (const o of t)
      o !== i && (o.position.set(0, 0, 0), o.rotation.set(0, 0, 0), o.scale.set(1, 1, 1), o.updateMatrix(), o.applyMatrix4(o.coordinationMatrix.clone().invert()), o.applyMatrix4(i.coordinationMatrix));
  }
};
I(Ls, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var ut = Ls;
var Xr = /* @__PURE__ */ new Map([
  [
    IFCRELAGGREGATES,
    {
      forRelating: "IsDecomposedBy",
      forRelated: "Decomposes"
    }
  ],
  [
    IFCRELASSOCIATESMATERIAL,
    {
      forRelating: "AssociatedTo",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelating: "ClassificationForObjects",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSIGNSTOGROUP,
    {
      forRelating: "IsGroupedBy",
      forRelated: "HasAssignments"
    }
  ],
  [
    IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ]
]);
var Ye = class Ye2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onRelationsIndexed", new D());
    I(this, "relationMaps", {});
    I(this, "enabled", true);
    I(this, "_relToAttributesMap", Xr);
    I(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements"
    ]);
    I(this, "_ifcRels", [
      IFCRELAGGREGATES,
      IFCRELASSOCIATESMATERIAL,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP,
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELDEFINESBYTEMPLATE,
      IFCRELCONTAINEDINSPATIALSTRUCTURE
    ]);
    I(this, "onFragmentsDisposed", (t2) => {
      delete this.relationMaps[t2.groupID];
    });
    this.components.add(Ye2.uuid, this), t.get(ut).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(t, s, i, o) {
    const n = Object.keys(s).find(
      (h) => h.startsWith("Relating")
    ), r = Object.keys(s).find(
      (h) => h.startsWith("Related")
    );
    if (!(n && r))
      return;
    const a = s[n].value, c = s[r].map((h) => h.value), E = t.get(a) ?? /* @__PURE__ */ new Map(), d = this._inverseAttributes.indexOf(o);
    E.set(d, c), t.set(a, E);
    for (const h of c) {
      const u = t.get(h) ?? /* @__PURE__ */ new Map(), p = this._inverseAttributes.indexOf(i), A = u.get(p) ?? [];
      A.push(a), u.set(p, A), t.set(h, u);
    }
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(t, s) {
    this.relationMaps[t.uuid] = s, this.onRelationsIndexed.trigger({
      modelID: t.uuid,
      relationsMap: s
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(t) {
    if (!t.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let s = this.relationMaps[t.uuid];
    if (s)
      return s;
    s = /* @__PURE__ */ new Map();
    for (const i of this._ifcRels) {
      const o = await t.getAllPropertiesOfType(i);
      if (!o)
        continue;
      const n = this._relToAttributesMap.get(i);
      if (!n)
        continue;
      const { forRelated: r, forRelating: a } = n;
      for (const c in o) {
        const E = o[c];
        this.indexRelations(s, E, r, a);
      }
    }
    return this.setRelationMap(t, s), s;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(t, s) {
    const i = /* @__PURE__ */ new Map();
    for (const o of this._ifcRels) {
      const n = this._relToAttributesMap.get(o);
      if (!n)
        continue;
      const { forRelated: r, forRelating: a } = n, c = t.GetLineIDsWithType(s, o);
      for (let E = 0; E < c.size(); E++) {
        const d = await t.properties.getItemProperties(
          s,
          c.get(E)
        );
        this.indexRelations(i, d, r, a);
      }
    }
    return this.onRelationsIndexed.trigger({
      modelID: s.toString(),
      relationsMap: i
    }), i;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity.
   * @param expressID The unique identifier of the entity within the model.
   * @param relationName The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities, or `null` if no relations are found
   * or the specified relation name is not indexed.
   */
  getEntityRelations(t, s, i) {
    const o = this.relationMaps[t.uuid];
    if (!o)
      return null;
    const n = o.get(s), r = this._inverseAttributes.indexOf(i);
    if (!n || r === -1)
      return null;
    const a = n.get(r);
    return a || null;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(t) {
    const s = {};
    for (const [i, o] of t.entries()) {
      s[i] || (s[i] = {});
      for (const [n, r] of o.entries())
        s[i][n] = r;
    }
    return JSON.stringify(s);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(t) {
    const s = this.relationMaps[t.uuid];
    return s ? this.serializeRelations(s) : null;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const t = {};
    for (const s in this.relationMaps) {
      const i = this.relationMaps[s], o = {};
      for (const [n, r] of i.entries()) {
        o[n] || (o[n] = {});
        for (const [a, c] of r.entries())
          o[n][a] = c;
      }
      t[s] = o;
    }
    return JSON.stringify(t);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(t) {
    const s = JSON.parse(t), i = /* @__PURE__ */ new Map();
    for (const o in s) {
      const n = s[o], r = /* @__PURE__ */ new Map();
      for (const a in n)
        r.set(Number(a), n[a]);
      i.set(Number(o), r);
    }
    return i;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.relationMaps = {}, this.components.get(ut).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(Ye2.uuid), this.onDisposed.reset();
  }
};
I(Ye, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
var ke2 = Ye;
var Zr = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};
var oa = class {
  getAll(e, t) {
    const s = {}, i = Object.keys(Zr).map((o) => parseInt(o, 10));
    for (let o = 0; o < i.length; o++) {
      const n = i[o], r = e.GetLineIDsWithType(t, n), a = r.size();
      for (let c = 0; c < a; c++)
        s[r.get(c)] = n;
    }
    return s;
  }
};
var Bn = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
var Kt = class _Kt {
  static async getUnits(e) {
    var n;
    const { IFCUNITASSIGNMENT: t } = web_ifc_api_exports, s = await e.getAllPropertiesOfType(t);
    if (!s)
      return 1;
    const i = Object.keys(s), o = s[parseInt(i[0], 10)];
    for (const r of o.Units) {
      if (r.value === void 0 || r.value === null)
        continue;
      const a = await e.getProperties(r.value);
      if (!a || !a.UnitType || !a.UnitType.value || a.UnitType.value !== "LENGTHUNIT")
        continue;
      let E = 1, d = 1;
      return a.Name.value === "METRE" && (d = 1), a.Name.value === "FOOT" && (d = 0.3048), ((n = a.Prefix) == null ? void 0 : n.value) === "MILLI" && (E = 1e-3), d * E;
    }
    return 1;
  }
  static async findItemByGuid(e, t) {
    var i;
    const s = e.getAllPropertiesIDs();
    for (const o of s) {
      const n = await e.getProperties(o);
      if (n && ((i = n.GlobalId) == null ? void 0 : i.value) === t)
        return n;
    }
    return null;
  }
  static async getRelationMap(e, t, s) {
    var a;
    const o = s ?? (async () => {
    }), n = {}, r = e.getAllPropertiesIDs();
    for (const c of r) {
      const E = await e.getProperties(c);
      if (!E)
        continue;
      const d = E.type === t, h = Object.keys(E).find(
        (C) => C.startsWith("Relating")
      ), u = Object.keys(E).find(
        (C) => C.startsWith("Related")
      );
      if (!(d && h && u))
        continue;
      const p = await e.getProperties((a = E[h]) == null ? void 0 : a.value), A = E[u];
      if (!p || !A || !(A && Array.isArray(A)))
        continue;
      const m = A.map((C) => C.value);
      await o(p.expressID, m), n[p.expressID] = m;
    }
    return n;
  }
  static async getQsetQuantities(e, t, s) {
    const o = s ?? (() => {
    }), n = await e.getProperties(t);
    return !n || n.type !== IFCELEMENTQUANTITY ? null : (n.Quantities ?? [{}]).map((c) => (c.value && o(c.value), c.value)).filter((c) => c !== null);
  }
  static async getPsetProps(e, t, s) {
    const o = s ?? (() => {
    }), n = await e.getProperties(t);
    return !n || n.type !== IFCPROPERTYSET ? null : (n.HasProperties ?? [{}]).map((c) => (c.value && o(c.value), c.value)).filter((c) => c !== null);
  }
  static async getPsetRel(e, t) {
    var r;
    if (!await e.getProperties(t))
      return null;
    const i = await e.getAllPropertiesOfType(
      IFCRELDEFINESBYPROPERTIES
    );
    if (!i)
      return null;
    const o = Object.values(i);
    let n = null;
    for (const a of o)
      ((r = a.RelatingPropertyDefinition) == null ? void 0 : r.value) === t && (n = a.expressID);
    return n;
  }
  static async getQsetRel(e, t) {
    return _Kt.getPsetRel(e, t);
  }
  static async getEntityName(e, t) {
    var n;
    const s = await e.getProperties(t);
    if (!s)
      return { key: null, name: null };
    const i = Object.keys(s).find((r) => r.endsWith("Name")) ?? null, o = i ? (n = s[i]) == null ? void 0 : n.value : null;
    return { key: i, name: o };
  }
  static async getQuantityValue(e, t) {
    const s = await e.getProperties(t);
    if (!s)
      return { key: null, value: null };
    const i = Object.keys(s).find((n) => n.endsWith("Value")) ?? null;
    let o;
    return i === null || s[i] === void 0 || s[i] === null ? o = null : o = s[i].value, { key: i, value: o };
  }
  static isRel(e) {
    return Bn[e].startsWith("IFCREL");
  }
  static async attributeExists(e, t, s) {
    const i = await e.getProperties(t);
    return i ? Object.keys(i).includes(s) : false;
  }
  static async groupEntitiesByType(e, t) {
    var i;
    const s = /* @__PURE__ */ new Map();
    for (const o of t) {
      const n = await e.getProperties(o);
      if (!n)
        continue;
      const r = n.type;
      s.get(r) || s.set(r, /* @__PURE__ */ new Set()), (i = s.get(r)) == null || i.add(o);
    }
    return s;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
};
var Qr = class {
  constructor() {
    I(this, "factor", 1);
    I(this, "complement", 1);
  }
  apply(e) {
    const s = this.getScaleMatrix().multiply(e);
    e.copy(s);
  }
  setUp(e) {
    var o;
    this.factor = 1;
    const t = this.getLengthUnits(e);
    if (!t)
      return;
    const s = t == null, i = t.Name === void 0 || t.Name === null;
    s || i || (t.Name.value === "FOOT" ? this.factor = 0.3048 : ((o = t.Prefix) == null ? void 0 : o.value) === "MILLI" && (this.complement = 1e-3));
  }
  getLengthUnits(e) {
    try {
      const s = e.GetLineIDsWithType(
        0,
        IFCUNITASSIGNMENT
      ).get(0), i = e.GetLine(0, s);
      for (const o of i.Units) {
        if (!o || o.value === null || o.value === void 0)
          continue;
        const n = e.GetLine(0, o.value);
        if (n.UnitType && n.UnitType.value === "LENGTHUNIT")
          return n;
      }
      return null;
    } catch {
      return console.log("Could not get units"), null;
    }
  }
  getScaleMatrix() {
    const e = this.factor;
    return new Matrix4().fromArray([
      e,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      1
    ]);
  }
};
var Yn = class {
  constructor() {
    I(this, "itemsByFloor", {});
    I(this, "_units", new Qr());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(e) {
    this._units.setUp(e), this.cleanUp();
    try {
      const t = e.GetLineIDsWithType(
        0,
        IFCRELCONTAINEDINSPATIALSTRUCTURE
      ), s = /* @__PURE__ */ new Set(), i = e.GetLineIDsWithType(0, IFCSPACE);
      for (let c = 0; c < i.size(); c++)
        s.add(i.get(c));
      const o = e.GetLineIDsWithType(0, IFCRELAGGREGATES), n = o.size();
      for (let c = 0; c < n; c++) {
        const E = o.get(c), d = e.GetLine(0, E);
        if (!d || !d.RelatingObject || !d.RelatedObjects)
          continue;
        const h = d.RelatingObject.value, u = d.RelatedObjects;
        for (const p of u) {
          const A = p.value;
          s.has(A) && (this.itemsByFloor[A] = h);
        }
      }
      const r = {}, a = t.size();
      for (let c = 0; c < a; c++) {
        const E = t.get(c), d = e.GetLine(0, E);
        if (!d || !d.RelatingStructure || !d.RelatedElements)
          continue;
        const h = d.RelatingStructure.value, u = d.RelatedElements;
        if (s.has(h))
          for (const p of u) {
            r[h] || (r[h] = []);
            const A = p.value;
            r[h].push(A);
          }
        else
          for (const p of u) {
            const A = p.value;
            this.itemsByFloor[A] = h;
          }
      }
      for (const c in r) {
        const E = this.itemsByFloor[c];
        if (E !== void 0) {
          const d = r[c];
          for (const h of d)
            this.itemsByFloor[h] = E;
        }
      }
      for (let c = 0; c < n; c++) {
        const E = o.get(c), d = e.GetLine(0, E);
        if (!d || !d.RelatingObject || !d.RelatedObjects)
          continue;
        const h = d.RelatingObject.value, u = d.RelatedObjects;
        for (const p of u) {
          const A = p.value, m = this.itemsByFloor[h];
          m !== void 0 && (this.itemsByFloor[A] = m);
        }
      }
    } catch {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
};
var Pi = class {
  constructor() {
    I(this, "includeProperties", true);
    I(this, "optionalCategories", [IFCSPACE]);
    I(this, "coordinate", true);
    I(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: LogLevel.LOG_LEVEL_OFF
    });
    I(this, "excludedCategories", /* @__PURE__ */ new Set());
    I(this, "saveLocations", false);
    I(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true
      // OPTIMIZE_PROFILES: true,
    });
    I(this, "autoSetWasm", true);
    I(this, "customLocateFileHandler", null);
  }
};
var Vn = class {
  constructor() {
    I(this, "defLineMat", new LineBasicMaterial({ color: 16777215 }));
  }
  read(e) {
    const t = e.GetAllAlignments(0), s = e.GetAllCrossSections2D(0), i = e.GetAllCrossSections3D(0), o = {
      IfcAlignment: t,
      IfcCrossSection2D: s,
      IfcCrossSection3D: i
    };
    return this.get(o);
  }
  get(e) {
    if (e.IfcAlignment) {
      const t = /* @__PURE__ */ new Map();
      for (const s of e.IfcAlignment) {
        const i = new Ne();
        i.absolute = this.getCurves(s.curve3D, i), i.horizontal = this.getCurves(s.horizontal, i), i.vertical = this.getCurves(s.vertical, i), t.set(t.size, i);
      }
      return { alignments: t, coordinationMatrix: new Matrix4() };
    }
  }
  getCurves(e, t) {
    const s = [];
    let i = 0;
    for (const o of e) {
      const n = {};
      if (o.data)
        for (const h of o.data) {
          const [u, p] = h.split(": "), A = parseFloat(p);
          n[u] = A || p;
        }
      const { points: r } = o, a = new Float32Array(r.length * 3);
      for (let h = 0; h < r.length; h++) {
        const { x: u, y: p, z: A } = r[h];
        a[h * 3] = u, a[h * 3 + 1] = p, a[h * 3 + 2] = A || 0;
      }
      const c = new BufferAttribute(a, 3), E = new EdgesGeometry();
      E.setAttribute("position", c);
      const d = new ke(
        i,
        n,
        t,
        E,
        this.defLineMat
      );
      s.push(d.curve), i++;
    }
    return s;
  }
};
var Gn = class {
  getNameInfo(e) {
    var d;
    const t = {}, { arguments: s } = e.GetHeaderLine(0, FILE_NAME) || {};
    if (!s)
      return t;
    const [
      i,
      o,
      n,
      r,
      a,
      c,
      E
    ] = s;
    if (i != null && i.value && (t.name = i.value), o != null && o.value && (t.creationDate = new Date(o.value)), n) {
      t.author = {};
      const [h, u] = n;
      h != null && h.value && (t.author.name = h.value), u != null && u.value && (t.author.email = u.value);
    }
    return (d = r[0]) != null && d.value && (t.organization = r[0].value), a != null && a.value && (t.preprocessorVersion = a == null ? void 0 : a.value), c != null && c.value && (t.originatingSystem = c == null ? void 0 : c.value), E != null && E.value && (t.authorization = E == null ? void 0 : E.value), t;
  }
  getDescriptionInfo(e) {
    var n;
    const t = {}, { arguments: s } = e.GetHeaderLine(0, FILE_DESCRIPTION) || {};
    if (!s)
      return t;
    const [i, o] = s;
    if ((n = i[0]) != null && n.value) {
      const r = i[0].value.match(/\[([^\]]+)\]/);
      r && r[1] && (t.viewDefinition = r[1]);
    }
    return o != null && o.value && (t.implementationLevel = o.value), t;
  }
};
var Ve = class Ve2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onIfcStartedLoading", new D());
    I(this, "onSetup", new D());
    I(this, "settings", new Pi());
    I(this, "webIfc", new IfcAPI2());
    I(this, "enabled", true);
    I(this, "_material", new MeshLambertMaterial());
    I(this, "_spatialTree", new Yn());
    I(this, "_metaData", new Gn());
    I(this, "_fragmentInstances", /* @__PURE__ */ new Map());
    I(this, "_civil", new Vn());
    I(this, "_visitedFragments", /* @__PURE__ */ new Map());
    I(this, "_materialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    }));
    this.components.add(Ve2.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null, this.onDisposed.trigger(Ve2.uuid), this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(t) {
    this.settings = { ...this.settings, ...t }, this.settings.autoSetWasm && await this.autoSetWasm(), this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Optional boolean indicating whether to coordinate the loaded IFC data. Default is true.
   *
   * @returns A Promise that resolves to the FragmentsGroup containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const group = await ifcLoader.load(ifcData);
   * ```
   */
  async load(t, s = true) {
    const i = performance.now();
    this.onIfcStartedLoading.trigger(), await this.readIfcFile(t);
    const o = await this.getAllGeometries(), r = await this.components.get(mi).export(this.webIfc, 0);
    o.setLocalProperties(r), this.cleanUp();
    const a = this.components.get(ut);
    a.groups.set(o.uuid, o);
    for (const c of o.items)
      a.list.set(c.id, c), c.mesh.uuid = c.id, c.group = o;
    return a.onFragmentsLoaded.trigger(o), s && a.coordinate([o]), console.log(`Streaming the IFC took ${performance.now() - i} ms!`), o;
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(t) {
    const { path: s, absolute: i, logLevel: o } = this.settings.wasm;
    return this.webIfc.SetWasmPath(s, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedFragments.clear(), this._fragmentInstances.clear();
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const t = this.webIfc.GetIfcEntityList(0), s = new Re();
    s.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const i = [];
    for (const n of t) {
      if (!this.webIfc.IsIfcElement(n) && n !== IFCSPACE || this.settings.excludedCategories.has(n))
        continue;
      const r = this.webIfc.GetLineIDsWithType(0, n), a = r.size();
      for (let c = 0; c < a; c++) {
        const E = r.get(c);
        i.push(E);
        const d = this._spatialTree.itemsByFloor[E] || 0;
        s.data.set(E, [[], [d, n]]);
      }
    }
    this._spatialTree.cleanUp(), this.webIfc.StreamMeshes(0, i, (n) => {
      this.getMesh(n, s);
    });
    for (const n of this._visitedFragments) {
      const { index: r, fragment: a } = n[1];
      s.keyFragments.set(r, a.id);
    }
    for (const n of s.items) {
      const r = this._fragmentInstances.get(n.id);
      if (!r)
        throw new Error("Fragment not found!");
      const a = [];
      for (const [c, E] of r)
        a.push(E);
      n.add(a);
    }
    const o = this.webIfc.GetCoordinationMatrix(0);
    return s.coordinationMatrix.fromArray(o), s.civilData = this._civil.read(this.webIfc), s;
  }
  getMesh(t, s) {
    const i = t.geometries.size(), o = t.expressID;
    for (let n = 0; n < i; n++) {
      const r = t.geometries.get(n), { x: a, y: c, z: E, w: d } = r.color, h = d !== 1, { geometryExpressID: u } = r, p = `${u}-${h}`;
      if (!this._visitedFragments.has(p)) {
        const T = this.getGeometry(this.webIfc, u), O = h ? this._materialT : this._material, _ = new Ue(T, O, 1);
        s.add(_.mesh), s.items.push(_);
        const S = this._visitedFragments.size;
        this._visitedFragments.set(p, { index: S, fragment: _ });
      }
      const A = new Color().setRGB(a, c, E, "srgb"), m = new Matrix4();
      m.fromArray(r.flatTransformation);
      const C = this._visitedFragments.get(p);
      if (C === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const R = s.data.get(o);
      if (!R)
        throw new Error("Data not found!");
      R[0].push(C.index);
      const { fragment: F } = C;
      this._fragmentInstances.has(F.id) || this._fragmentInstances.set(F.id, /* @__PURE__ */ new Map());
      const f = this._fragmentInstances.get(F.id);
      if (!f)
        throw new Error("Instances not found!");
      if (f.has(o)) {
        const T = f.get(o);
        if (!T)
          throw new Error("Instance not found!");
        T.transforms.push(m), T.colors && T.colors.push(A);
      } else
        f.set(o, { id: o, transforms: [m], colors: [A] });
    }
  }
  getGeometry(t, s) {
    const i = t.GetGeometry(0, s), o = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), n = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), r = new Float32Array(n.length / 2), a = new Float32Array(n.length / 2);
    for (let h = 0; h < n.length; h += 6)
      r[h / 2] = n[h], r[h / 2 + 1] = n[h + 1], r[h / 2 + 2] = n[h + 2], a[h / 2] = n[h + 3], a[h / 2 + 1] = n[h + 4], a[h / 2 + 2] = n[h + 5];
    const c = new BufferGeometry(), E = new BufferAttribute(r, 3), d = new BufferAttribute(a, 3);
    return c.setAttribute("position", E), c.setAttribute("normal", d), c.setIndex(Array.from(o)), i.delete(), c;
  }
  async autoSetWasm() {
    const t = await fetch(
      `https://unpkg.com/@thatopen/components@${pi.release}/package.json`
    );
    if (!t.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const s = await t.json();
    if (!("web-ifc" in s.peerDependencies))
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    else {
      const i = s.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${i}/`, this.settings.wasm.absolute = true;
    }
  }
};
I(Ve, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
var Ri = Ve;
var Bt = class Bt2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onRequestFile", new D());
    I(this, "ifcToExport", null);
    I(this, "onElementToPset", new D());
    I(this, "onPropToPset", new D());
    I(this, "onPsetRemoved", new D());
    I(this, "onDataChanged", new D());
    I(this, "wasm", {
      path: "/",
      absolute: false
    });
    I(this, "enabled", true);
    I(this, "attributeListeners", {});
    I(this, "selectedModel");
    I(this, "changeMap", {});
    this.components.add(Bt2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.selectedModel = void 0, this.attributeListeners = {}, this.changeMap = {}, this.onElementToPset.reset(), this.onPropToPset.reset(), this.onPsetRemoved.reset(), this.onDataChanged.reset(), this.onDisposed.trigger(Bt2.uuid), this.onDisposed.reset();
  }
  /**
   * Static method to retrieve the IFC schema from a given model.
   *
   * @param model - The FragmentsGroup model from which to retrieve the IFC schema.
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @returns The IFC schema associated with the given model.
   */
  static getIFCSchema(t) {
    const s = t.ifcMetadata.schema;
    if (!s)
      throw new Error("IFC Schema not found");
    return s;
  }
  /**
   * Method to set properties data in the model.
   *
   * @param model - The FragmentsGroup model in which to set the properties.
   * @param dataToSave - An array of objects representing the properties to be saved.
   * Each object must have an `expressID` property, which is the express ID of the entity in the model.
   * The rest of the properties will be set as the properties of the entity.
   *
   * @returns {Promise<void>} A promise that resolves when all the properties have been set.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `dataToSave` array.
   */
  async setData(t, ...s) {
    for (const i of s) {
      const o = i.expressID;
      o && (await t.setProperties(o, i), this.registerChange(t, o));
    }
  }
  /**
   * Creates a new Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the Pset.
   * @param name - The name of the Pset.
   * @param description - (Optional) The description of the Pset.
   *
   * @returns A promise that resolves with an object containing the newly created Pset and its relation.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  async newPset(t, s, i) {
    const o = Bt2.getIFCSchema(t), { ownerHistoryHandle: n } = await this.getOwnerHistory(t), r = this.newGUID(t), a = new web_ifc_api_exports[o].IfcLabel(s), c = i ? new web_ifc_api_exports[o].IfcText(i) : null, E = new web_ifc_api_exports[o].IfcPropertySet(
      r,
      n,
      a,
      c,
      []
    );
    E.expressID = this.increaseMaxID(t);
    const d = this.newGUID(t), h = new web_ifc_api_exports[o].IfcRelDefinesByProperties(
      d,
      n,
      null,
      null,
      [],
      new Handle(E.expressID)
    );
    return h.expressID = this.increaseMaxID(t), await this.setData(t, E, h), { pset: E, rel: h };
  }
  /**
   * Removes a Property Set (Pset) from the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the Pset.
   * @param psetID - The express IDs of the Psets to be removed.
   *
   * @returns {Promise<void>} A promise that resolves when all the Psets have been removed.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `psetID` array.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async removePset(t, ...s) {
    for (const i of s) {
      const o = await t.getProperties(i);
      if ((o == null ? void 0 : o.type) !== IFCPROPERTYSET)
        continue;
      const n = await Kt.getPsetRel(t, i);
      if (n && (await t.setProperties(n, null), this.registerChange(t, n)), o) {
        for (const r of o.HasProperties)
          await t.setProperties(r.value, null);
        await t.setProperties(i, null), this.onPsetRemoved.trigger({ model: t, psetID: i }), this.registerChange(t, i);
      }
    }
  }
  /**
   * Creates a new single-value property of type string in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a string property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a string.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleStringProperty(t, s, i, o) {
    return this.newSingleProperty(t, s, i, o);
  }
  /**
   * Creates a new single-value property of type numeric in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a numeric property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a number.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleNumericProperty(t, s, i, o) {
    return this.newSingleProperty(t, s, i, o);
  }
  /**
   * Creates a new single-value property of type boolean in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a boolean property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a boolean.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleBooleanProperty(t, s, i, o) {
    return this.newSingleProperty(t, s, i, o);
  }
  /**
   * Removes a property from a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the property.
   * @param psetID - The express ID of the Pset from which to remove the property.
   * @param propID - The express ID of the property to be removed.
   *
   * @returns {Promise<void>} A promise that resolves when the property has been removed.
   *
   * @throws Will throw an error if the Pset or the property to be removed are not found in the model.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   */
  async removePsetProp(t, s, i) {
    const o = await t.getProperties(s), n = await t.getProperties(i);
    !o || !n || o.type === IFCPROPERTYSET && n && (o.HasProperties = o.HasProperties.filter((r) => r.value !== i), await t.setProperties(i, null), this.registerChange(t, s, i));
  }
  async addElementToPset(t, s, ...i) {
    const o = await Kt.getPsetRel(t, s);
    if (!o)
      return;
    const n = await t.getProperties(o);
    if (n) {
      for (const r of i) {
        const a = new Handle(r);
        n.RelatedObjects.push(a), this.onElementToPset.trigger({
          model: t,
          psetID: s,
          elementID: r
        });
      }
      this.registerChange(t, s);
    }
  }
  /**
   * Adds elements to a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to add the elements.
   * @param psetID - The express ID of the Pset to which to add the elements.
   * @param elementID - The express IDs of the elements to be added.
   *
   * @returns {Promise<void>} A promise that resolves when all the elements have been added.
   *
   * @throws Will throw an error if the Pset or the elements to be added are not found in the model.
   * @throws Will throw an error if the Pset to be added to is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async addPropToPset(t, s, ...i) {
    const o = await t.getProperties(s);
    if (o) {
      for (const n of i) {
        if (o.HasProperties.includes(n))
          continue;
        const r = new Handle(n);
        o.HasProperties.push(r), this.onPropToPset.trigger({ model: t, psetID: s, propID: n });
      }
      this.registerChange(t, s);
    }
  }
  /**
   * Saves the changes made to the model to a new IFC file.
   *
   * @param model - The FragmentsGroup model from which to save the changes.
   * @param ifcToSaveOn - The Uint8Array representing the original IFC file.
   *
   * @returns A promise that resolves with the modified IFC data as a Uint8Array.
   *
   * @throws Will throw an error if any issues occur during the saving process.
   */
  async saveToIfc(t, s) {
    const i = this.components.get(Ri), o = i.webIfc, n = await i.readIfcFile(s), r = this.changeMap[t.uuid] ?? [];
    for (const c of r) {
      const E = await t.getProperties(c);
      if (E)
        try {
          o.WriteLine(n, E);
        } catch {
        }
      else
        try {
          o.DeleteLine(n, c);
        } catch {
        }
    }
    const a = o.SaveModel(n);
    return i.webIfc.CloseModel(n), i.cleanUp(), a;
  }
  /**
   * Sets an attribute listener for a specific attribute of an entity in the model.
   * The listener will trigger an event whenever the attribute's value changes.
   *
   * @param model - The FragmentsGroup model in which to set the attribute listener.
   * @param expressID - The express ID of the entity for which to set the listener.
   * @param attributeName - The name of the attribute for which to set the listener.
   *
   * @returns The event that will be triggered when the attribute's value changes.
   *
   * @throws Will throw an error if the entity with the given expressID doesn't exist.
   * @throws Will throw an error if the attribute is an array or null, and it can't have a listener.
   * @throws Will throw an error if the attribute has a badly defined handle.
   */
  async setAttributeListener(t, s, i) {
    this.attributeListeners[t.uuid] || (this.attributeListeners[t.uuid] = {});
    const o = this.attributeListeners[t.uuid][s] ? this.attributeListeners[t.uuid][s][i] : null;
    if (o)
      return o;
    const n = await t.getProperties(s);
    if (!n)
      throw new Error(`Entity with expressID ${s} doesn't exists.`);
    const r = n[i];
    if (Array.isArray(r) || !r)
      throw new Error(
        `Attribute ${i} is array or null, and it can't have a listener.`
      );
    const a = r.value;
    if (a === void 0 || a == null)
      throw new Error(`Attribute ${i} has a badly defined handle.`);
    const c = new D();
    return Object.defineProperty(n[i], "value", {
      get() {
        return this._value;
      },
      async set(E) {
        this._value = E, c.trigger(E);
      }
    }), n[i].value = a, this.attributeListeners[t.uuid][s] || (this.attributeListeners[t.uuid][s] = {}), this.attributeListeners[t.uuid][s][i] = c, c;
  }
  increaseMaxID(t) {
    return t.ifcMetadata.maxExpressID++, t.ifcMetadata.maxExpressID;
  }
  newGUID(t) {
    const s = Bt2.getIFCSchema(t);
    return new web_ifc_api_exports[s].IfcGloballyUniqueId(Ge.create());
  }
  async getOwnerHistory(t) {
    const s = await t.getAllPropertiesOfType(
      IFCOWNERHISTORY
    );
    if (!s)
      throw new Error("No OwnerHistory was found.");
    const i = Object.keys(s).map((r) => parseInt(r, 10)), o = s[i[0]], n = new Handle(o.expressID);
    return { ownerHistory: o, ownerHistoryHandle: n };
  }
  registerChange(t, ...s) {
    this.changeMap[t.uuid] || (this.changeMap[t.uuid] = /* @__PURE__ */ new Set());
    for (const i of s)
      this.changeMap[t.uuid].add(i), this.onDataChanged.trigger({ model: t, expressID: i });
  }
  async newSingleProperty(t, s, i, o) {
    const n = Bt2.getIFCSchema(t), r = new web_ifc_api_exports[n].IfcIdentifier(i), a = new web_ifc_api_exports[n][s](o), c = new web_ifc_api_exports[n].IfcPropertySingleValue(
      r,
      null,
      a,
      null
    );
    return c.expressID = this.increaseMaxID(t), await this.setData(t, c), c;
  }
};
I(Bt, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
var On = Bt;
var Ps = class Ps2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "list", {});
    I(this, "onDisposed", new D());
    I(this, "onFragmentsDisposed", (t2) => {
      const { groupID: s, fragmentIDs: i } = t2;
      for (const o in this.list) {
        const n = this.list[o], r = Object.keys(n);
        if (r.includes(s))
          delete n[s], Object.values(n).length === 0 && delete this.list[o];
        else
          for (const a of r) {
            const c = n[a];
            for (const E of i)
              delete c[E];
            Object.values(c).length === 0 && delete n[a];
          }
      }
    });
    t.add(Ps2.uuid, this), t.get(ut).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list = {}, this.components.get(ut).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Removes a fragment from the classification based on its unique identifier (guid).
   * This method iterates through all classification systems and classes, and deletes the fragment with the specified guid from the respective group.
   *
   * @param guid - The unique identifier of the fragment to be removed.
   */
  remove(t) {
    for (const s in this.list) {
      const i = this.list[s];
      for (const o in i) {
        const n = i[o];
        delete n[t];
      }
    }
  }
  /**
   * Finds and returns fragments based on the provided filter criteria.
   * If no filter is provided, it returns all fragments.
   *
   * @param filter - An optional object containing filter criteria.
   * The keys of the object represent the classification system names,
   * and the values are arrays of class names to match.
   *
   * @returns A map of fragment GUIDs to their respective express IDs,
   * where the express IDs are filtered based on the provided filter criteria.
   *
   * @throws Will throw an error if the fragments map is malformed.
   */
  find(t) {
    const s = this.components.get(ut);
    if (!t) {
      const r = {};
      for (const [a, c] of s.list)
        r[a] = new Set(c.ids);
      return r;
    }
    const i = Object.keys(t).length, o = {};
    for (const r in t) {
      const a = t[r];
      if (!this.list[r]) {
        console.warn(`Classification ${r} does not exist.`);
        continue;
      }
      for (const c of a) {
        const E = this.list[r][c];
        if (E)
          for (const d in E) {
            o[d] || (o[d] = /* @__PURE__ */ new Map());
            for (const h of E[d]) {
              const u = o[d].get(h);
              u === void 0 ? o[d].set(h, 1) : o[d].set(h, u + 1);
            }
          }
      }
    }
    const n = {};
    for (const r in o) {
      const a = o[r];
      for (const [c, E] of a) {
        if (E === void 0)
          throw new Error("Malformed fragments map!");
        E === i && (n[r] || (n[r] = /* @__PURE__ */ new Set()), n[r].add(c));
      }
    }
    return n;
  }
  /**
   * Classifies fragments based on their modelID.
   *
   * @param modelID - The unique identifier of the model to classify fragments by.
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the fragments in the provided group,
   * and classifies them based on their modelID.
   * The classification is stored in the `list.models` property,
   * with the modelID as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   */
  byModel(t, s) {
    this.list.models || (this.list.models = {});
    const i = this.list.models;
    i[t] || (i[t] = {});
    const o = i[t];
    for (const [n, r] of s.data) {
      const a = r[0];
      for (const c of a) {
        const E = s.keyFragments.get(c);
        E && (o[E] || (o[E] = /* @__PURE__ */ new Set()), o[E].add(n));
      }
    }
  }
  /**
   * Classifies fragments based on their PredefinedType property.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the properties of the fragments in the provided group,
   * and classifies them based on their PredefinedType property.
   * The classification is stored in the `list.predefinedTypes` property,
   * with the PredefinedType as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  async byPredefinedType(t) {
    var o;
    this.list.predefinedTypes || (this.list.predefinedTypes = {});
    const s = this.list.predefinedTypes, i = t.getAllPropertiesIDs();
    for (const n of i) {
      const r = await t.getProperties(n);
      if (!r)
        continue;
      const a = String((o = r.PredefinedType) == null ? void 0 : o.value).toUpperCase();
      s[a] || (s[a] = {});
      const c = s[a];
      for (const [E, d] of t.data) {
        const h = d[0];
        for (const u of h) {
          const p = t.keyFragments.get(u);
          if (!p)
            throw new Error("Fragment ID not found!");
          c[p] || (c[p] = /* @__PURE__ */ new Set()), c[p].add(r.expressID);
        }
      }
    }
  }
  /**
   * Classifies fragments based on their entity type.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their entity type.
   * The classification is stored in the `list.entities` property,
   * with the entity type as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  byEntity(t) {
    this.list.entities || (this.list.entities = {});
    for (const [s, i] of t.data) {
      const n = i[1][1], r = Bn[n];
      this.saveItem(t, "entities", r, s);
    }
  }
  /**
   * Classifies fragments based on a specific IFC relationship.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   * @param ifcRel - The IFC relationship number to classify fragments by.
   * @param systemName - The name of the classification system to store the classification.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on the specified IFC relationship.
   * The classification is stored in the `list` property under the specified system name,
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the IFC relationship is not valid.
   */
  async byIfcRel(t, s, i) {
    Kt.isRel(s) && await Kt.getRelationMap(
      t,
      s,
      async (o, n) => {
        const { name: r } = await Kt.getEntityName(
          t,
          o
        );
        for (const a of n)
          this.saveItem(
            t,
            i,
            r ?? "NO REL NAME",
            a
          );
      }
    );
  }
  /**
   * Classifies fragments based on their spatial structure in the IFC model.
   *
   * @param model - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their spatial structure in the IFC model.
   * The classification is stored in the `list` property under the system name "spatialStructures",
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the model relations do not exist.
   */
  async bySpatialStructure(t) {
    var n;
    const s = this.components.get(ke2), i = s.relationMaps[t.uuid];
    if (!i)
      throw new Error(
        `Classifier: model relations of ${t.name || t.uuid} have to exists to group by spatial structure.`
      );
    const o = "spatialStructures";
    for (const [r] of i) {
      const a = s.getEntityRelations(
        t,
        r,
        "ContainsElements"
      ), c = await t.getProperties(r);
      if (!(a && c))
        continue;
      const E = (n = c.Name) == null ? void 0 : n.value;
      for (const d of a) {
        this.saveItem(t, o, E, d);
        const h = s.getEntityRelations(
          t,
          Number(d),
          "IsDecomposedBy"
        );
        if (h)
          for (const u of h)
            this.saveItem(t, o, E, u);
      }
    }
  }
  /**
   * Sets the color of the specified fragments.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   * @param color - The color to set for the fragments.
   * @param override - A boolean indicating whether to override the existing color of the fragments.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and sets their color using the `setColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  setColor(t, s, i = false) {
    const o = this.components.get(ut);
    for (const n in t) {
      const r = o.list.get(n);
      if (!r)
        continue;
      const a = t[n];
      r.setColor(s, a, i);
    }
  }
  /**
   * Resets the color of the specified fragments to their original color.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and resets their color using the `resetColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  resetColor(t) {
    const s = this.components.get(ut);
    for (const i in t) {
      const o = s.list.get(i);
      if (!o)
        continue;
      const n = t[i];
      o.resetColor(n);
    }
  }
  saveItem(t, s, i, o) {
    this.list[s] || (this.list[s] = {});
    const n = t.data.get(o);
    if (n)
      for (const r of n[0]) {
        const a = t.keyFragments.get(r);
        if (a) {
          const c = this.list[s];
          c[i] || (c[i] = {}), c[i][a] || (c[i][a] = /* @__PURE__ */ new Set()), c[i][a].add(o);
        }
      }
  }
};
I(Ps, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
var Ai = Ps;
var ys = class ys2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "height", 10);
    I(this, "groupName", "spatialStructures");
    I(this, "list", /* @__PURE__ */ new Set());
    t.add(ys2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Sets the explosion state of the fragments.
   *
   * @param active - A boolean indicating whether to activate or deactivate the explosion.
   *
   * @remarks
   * This method applies a vertical transformation to the fragments based on the `active` parameter.
   * If `active` is true, the fragments are moved upwards by a distance determined by the `height` property.
   * If `active` is false, the fragments are moved back to their original position.
   *
   * The method also keeps track of the exploded items using the `list` set.
   *
   * @throws Will throw an error if the `Classifier` or `FragmentsManager` components are not found in the `components` system.
   */
  set(t) {
    if (!this.enabled)
      return;
    const s = this.components.get(Ai), i = this.components.get(ut), o = t ? 1 : -1;
    let n = 0;
    const r = s.list[this.groupName], a = new Matrix4();
    for (const c in r) {
      a.elements[13] = n * o * this.height;
      for (const E in r[c]) {
        const d = i.list.get(E), h = c + E, u = this.list.has(h);
        if (!d || t && u || !t && !u)
          continue;
        t ? this.list.add(h) : this.list.delete(h);
        const p = r[c][E];
        d.applyTransform(p, a);
      }
      n++;
    }
  }
};
I(ys, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
var gn = ys;
var Ms = class Ms2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    this.components.add(Ms2.uuid, this);
  }
  /**
   * Sets the visibility of fragments within the 3D scene.
   * If no `items` parameter is provided, all fragments will be set to the specified visibility.
   * If `items` is provided, only the specified fragments will be affected.
   *
   * @param visible - The visibility state to set for the fragments.
   * @param items - An optional map of fragment IDs and their corresponding sub-fragment IDs to be affected.
   * If not provided, all fragments will be affected.
   *
   * @returns {void}
   */
  set(t, s) {
    const i = this.components.get(ut);
    if (!s) {
      for (const [o, n] of i.list)
        n && (n.setVisibility(t), this.updateCulledVisibility(n));
      return;
    }
    for (const o in s) {
      const n = s[o], r = i.list.get(o);
      r && (r.setVisibility(t, n), this.updateCulledVisibility(r));
    }
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param items - A map of fragment IDs and their corresponding sub-fragment IDs to be isolated.
   * If not provided, all fragments will be isolated.
   *
   * @returns {void}
   */
  isolate(t) {
    this.set(false), this.set(true, t);
  }
  updateCulledVisibility(t) {
    const s = this.components.get(Ti);
    for (const [i, o] of s.list) {
      const n = o.colorMeshes.get(t.id);
      n && (n.count = t.mesh.count);
    }
  }
};
I(Ms, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
var _n = Ms;
var jr = class extends Pi {
  constructor() {
    super(...arguments);
    I(this, "minGeometrySize", 10);
    I(this, "minAssetsSize", 1e3);
  }
};
var ws = class ws2 extends et {
  constructor(t) {
    super(t);
    I(this, "onGeometryStreamed", new D());
    I(this, "onAssetStreamed", new D());
    I(this, "onProgress", new D());
    I(this, "onIfcLoaded", new D());
    I(this, "onDisposed", new D());
    I(this, "settings", new jr());
    I(this, "enabled", true);
    I(this, "webIfc", new IfcAPI2());
    I(this, "_spatialTree", new Yn());
    I(this, "_metaData", new Gn());
    I(this, "_visitedGeometries", /* @__PURE__ */ new Map());
    I(this, "_streamSerializer", new fn());
    I(this, "_geometries", /* @__PURE__ */ new Map());
    I(this, "_geometryCount", 0);
    I(this, "_civil", new Vn());
    I(this, "_groupSerializer", new an());
    I(this, "_assets", []);
    I(this, "_meshesWithHoles", /* @__PURE__ */ new Set());
    this.components.add(ws2.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onIfcLoaded.reset(), this.onGeometryStreamed.reset(), this.onAssetStreamed.reset(), this.webIfc = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * This method streams the IFC file from a given buffer.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   * @example
   * ```typescript
   * const ifcData = await fetch('path/to/ifc/file.ifc');
   * const rawBuffer = await response.arrayBuffer();
   * const ifcBuffer = new Uint8Array(rawBuffer);
   * await ifcGeometryTiler.streamFromBuffer(ifcBuffer);
   * ```
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  /**
   * This method streams the IFC file from a given callback.
   *
   * @param loadCallback - The callback function that will be used to load the IFC file.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: s, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(s, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: s, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(s, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllGeometries() {
    const { minGeometrySize: t, minAssetsSize: s } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const i = this.webIfc.GetIfcEntityList(0), o = [[]], n = new Re();
    n.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let r = 0, a = 0;
    for (const m of i) {
      if (!this.webIfc.IsIfcElement(m) && m !== IFCSPACE || this.settings.excludedCategories.has(m))
        continue;
      const C = this.webIfc.GetLineIDsWithType(0, m), R = C.size();
      for (let F = 0; F < R; F++) {
        r > t && (r = 0, a++, o.push([]));
        const f = C.get(F);
        o[a].push(f);
        const T = this._spatialTree.itemsByFloor[f] || 0;
        n.data.set(f, [[], [T, m]]), r++;
      }
    }
    this._spatialTree.cleanUp();
    let c = 0.01, E = 0;
    for (const m of o) {
      E++, this.webIfc.StreamMeshes(0, m, (R) => {
        this.getMesh(this.webIfc, R, n);
      }), this._geometryCount > t && await this.streamGeometries(), this._assets.length > s && await this.streamAssets();
      const C = E / o.length;
      C > c && (c += 0.01, c = Math.max(c, C), this.onProgress.trigger(Math.round(c * 100) / 100));
    }
    this._geometryCount && await this.streamGeometries(), this._assets.length && await this.streamAssets();
    const { opaque: d, transparent: h } = n.geometryIDs;
    for (const [m, { index: C, uuid: R }] of this._visitedGeometries)
      n.keyFragments.set(C, R), (m > 1 ? d : h).set(m, C);
    const u = n.data.keys();
    for (const m of u) {
      const [C] = n.data.get(m);
      C.length || n.data.delete(m);
    }
    const p = this.webIfc.GetCoordinationMatrix(0);
    n.coordinationMatrix.fromArray(p), n.civilData = this._civil.read(this.webIfc);
    const A = this._groupSerializer.export(n);
    this.onIfcLoaded.trigger(A), n.dispose(true);
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedGeometries.clear(), this._geometries.clear(), this._assets = [], this._meshesWithHoles.clear();
  }
  getMesh(t, s, i) {
    const o = s.geometries.size(), n = s.expressID, r = { id: n, geometries: [] };
    for (let a = 0; a < o; a++) {
      const c = s.geometries.get(a), E = c.geometryExpressID, d = c.color.w === 1 ? 1 : -1, h = E * d;
      if (!this._visitedGeometries.has(h)) {
        this._visitedGeometries.has(E) || this.getGeometry(t, E);
        const T = this._visitedGeometries.size, O = MathUtils.generateUUID();
        this._visitedGeometries.set(h, { uuid: O, index: T });
      }
      const u = this._visitedGeometries.get(h);
      if (u === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const p = i.data.get(n);
      if (!p)
        throw new Error("Data not found!");
      p[0].push(u.index);
      const { x: A, y: m, z: C, w: R } = c.color, F = [A, m, C, R], f = c.flatTransformation;
      r.geometries.push({ color: F, geometryID: E, transformation: f });
    }
    this._assets.push(r);
  }
  getGeometry(t, s) {
    const i = t.GetGeometry(0, s), o = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), n = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), r = new Float32Array(n.length / 2), a = new Float32Array(n.length / 2);
    for (let u = 0; u < n.length; u += 6)
      r[u / 2] = n[u], r[u / 2 + 1] = n[u + 1], r[u / 2 + 2] = n[u + 2], a[u / 2] = n[u + 3], a[u / 2 + 1] = n[u + 4], a[u / 2 + 2] = n[u + 5];
    const c = Tr(r), E = new Float32Array(c.transformation.elements), d = [c.center.x, c.center.y, c.center.z];
    let h = false;
    for (let u = 0; u < r.length - 2; u += 3) {
      const p = r[u], A = r[u + 1], m = r[u + 2], C = a[u], R = a[u + 1], F = a[u + 2];
      if (mr(d, [p, A, m], [C, R, F])) {
        h = true;
        break;
      }
    }
    this._geometries.set(s, {
      position: r,
      normal: a,
      index: o,
      boundingBox: E,
      hasHoles: h
    }), i.delete(), this._geometryCount++;
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets), this._assets = null, this._assets = [];
  }
  async streamGeometries() {
    let t = this._streamSerializer.export(this._geometries), s = {};
    for (const [i, { boundingBox: o, hasHoles: n }] of this._geometries)
      s[i] = { boundingBox: o, hasHoles: n };
    this.onGeometryStreamed.trigger({ data: s, buffer: t }), s = null, t = null, this._geometries.clear(), this._geometryCount = 0;
  }
};
I(ws, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
var Sn = ws;
var qr = class extends Pi {
  constructor() {
    super(...arguments);
    I(this, "propertiesSize", 100);
  }
};
var Kr = class extends et {
  constructor() {
    super(...arguments);
    I(this, "onPropertiesStreamed", new Ts());
    I(this, "onProgress", new Ts());
    I(this, "onIndicesStreamed", new Ts());
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "settings", new qr());
    I(this, "webIfc", new IfcAPI2());
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  /**
   * This method converts properties from an IFC file to tiles given its data as a Uint8Array.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  /**
   * This method converts properties from an IFC file to tiles using a given callback function to read the file.
   *
   * @param loadCallback - A callback function that loads the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: s, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(s, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: s, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(s, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, s = new Set(this.webIfc.GetIfcEntityList(0)), i = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const c of i)
      s.add(c);
    let o = 0.01, n = 0;
    for (const c of s) {
      if (n++, vn.has(c))
        continue;
      const E = i.has(c), d = this.webIfc.GetLineIDsWithType(0, c), h = d.size();
      let u = 0;
      for (let A = 0; A < h - t; A += t) {
        const m = {};
        for (let C = 0; C < t; C++) {
          u++;
          const R = d.get(A + C);
          try {
            const F = this.webIfc.GetLine(0, R, E);
            m[F.expressID] = F;
          } catch {
            console.log(`Could not get property: ${R}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: c, data: m });
      }
      if (u !== h) {
        const A = {};
        for (let m = u; m < h; m++) {
          const C = d.get(m);
          try {
            const R = this.webIfc.GetLine(0, C, E);
            A[R.expressID] = R;
          } catch {
            console.log(`Could not get property: ${C}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: c, data: A });
      }
      const p = n / s.size;
      p > o && (o += 0.01, o = Math.max(o, p), await this.onProgress.trigger(Math.round(o * 100) / 100));
    }
    const a = await this.components.get(ke2).processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(a);
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2();
  }
};
I(Kr, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var Ds = class Ds2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    t.add(Ds2.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(t, s, i, o = false) {
    const n = new Line3(), r = new Vector3();
    return n.set(s, i), n.closestPointToPoint(t, o, r), r.distanceTo(t);
  }
  /**
   * Method to get the face of a mesh that contains a given triangle index.
   * It also returns the edges of the found face and their indices.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param triangleIndex - The index of the triangle within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the edges of the found face and their indices, or null if no face was found.
   */
  getFace(t, s, i) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = /* @__PURE__ */ new Map(), n = t.geometry.index.array, { plane: r } = this.getFaceData(
      s,
      i,
      t
    ), a = [];
    for (let h = 0; h < n.length / 3; h++) {
      const { plane: u, edges: p } = this.getFaceData(h, i, t);
      if (u.equals(r)) {
        a.push({ index: h, edges: p });
        for (const { id: A, points: m, distance: C } of p)
          o.set(A, { points: m, distance: C });
      }
    }
    let c = 0;
    const E = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
    for (const { index: h, edges: u } of a) {
      const p = /* @__PURE__ */ new Map();
      for (const { id: T } of u)
        if (E.has(T)) {
          const O = E.get(T);
          p.set(T, O);
        }
      const A = u.map((T) => T.id);
      if (!p.size) {
        const T = c++;
        for (const { id: O } of u)
          E.set(O, T);
        d.set(T, {
          edges: new Set(A),
          indices: /* @__PURE__ */ new Set([h])
        });
        continue;
      }
      let m = null;
      const C = /* @__PURE__ */ new Set(), R = new Set(A);
      for (const [T, O] of p) {
        m === null ? m = O : O !== m && C.add(O), E.delete(T);
        const { edges: _ } = d.get(O);
        _.delete(T), R.delete(T);
      }
      if (m === null)
        throw new Error("Error computing face!");
      const F = d.get(m), { indices: f } = F;
      f.add(h);
      for (const T of R) {
        E.set(T, m);
        const { edges: O } = F;
        O.add(T);
      }
      for (const T of C) {
        const O = d.get(T), { edges: _, indices: S } = O, N = d.get(m), { edges: P, indices: w } = N;
        for (const y of _)
          P.add(y), E.set(y, m);
        for (const y of S)
          w.add(y);
        d.delete(T);
      }
    }
    for (const [h, { indices: u, edges: p }] of d)
      if (u.has(s)) {
        const A = [];
        for (const m of p) {
          const C = o.get(m);
          A.push(C);
        }
        return { edges: A, indices: u };
      }
    return null;
  }
  /**
   * Method to get the vertices and normal of a mesh face at a given index.
   * It also applies instance transformation if provided.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param faceIndex - The index of the face within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the vertices and normal of the face.
   * @throws Will throw an error if the geometry is not indexed.
   */
  getVerticesAndNormal(t, s, i) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = t.geometry.index.array, n = t.geometry.attributes.position.array, r = t.geometry.attributes.normal.array, a = o[s * 3] * 3, c = o[s * 3 + 1] * 3, E = o[s * 3 + 2] * 3, d = new Vector3(n[a], n[a + 1], n[a + 2]), h = new Vector3(n[c], n[c + 1], n[c + 2]), u = new Vector3(n[E], n[E + 1], n[E + 2]), p = new Vector3(r[a], r[a + 1], r[a + 2]), A = new Vector3(r[c], r[c + 1], r[c + 2]), m = new Vector3(r[E], r[E + 1], r[E + 2]), C = (p.x + A.x + m.x) / 3, R = (p.y + A.y + m.y) / 3, F = (p.z + A.z + m.z) / 3, f = new Vector3(C, R, F);
    if (i !== void 0 && t instanceof InstancedMesh) {
      const T = new Matrix4();
      t.getMatrixAt(i, T);
      const O = new Matrix4();
      O.extractRotation(T), f.applyMatrix4(O), d.applyMatrix4(T), h.applyMatrix4(T), u.applyMatrix4(T);
    }
    return { p1: d, p2: h, p3: u, faceNormal: f };
  }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(t) {
    t.x = Math.trunc(t.x * 1e3) / 1e3, t.y = Math.trunc(t.y * 1e3) / 1e3, t.z = Math.trunc(t.z * 1e3) / 1e3;
  }
  getFaceData(t, s, i) {
    const o = this.getVerticesAndNormal(i, t, s), { p1: n, p2: r, p3: a, faceNormal: c } = o;
    this.round(n), this.round(r), this.round(a), this.round(c);
    const E = [
      { id: `${n.x}|${n.y}|${n.z}`, value: n },
      { id: `${r.x}|${r.y}|${r.z}`, value: r },
      { id: `${a.x}|${a.y}|${a.z}`, value: a }
    ];
    E.sort((F, f) => F.id < f.id ? -1 : F.id > f.id ? 1 : 0);
    const [
      { id: d, value: h },
      { id: u, value: p },
      { id: A, value: m }
    ] = E, C = [
      {
        id: `${d}|${u}`,
        distance: h.distanceTo(p),
        points: [h, p]
      },
      {
        id: `${u}|${A}`,
        distance: p.distanceTo(m),
        points: [p, m]
      },
      {
        id: `${d}|${A}`,
        distance: h.distanceTo(m),
        points: [h, m]
      }
    ], R = new Plane();
    return R.setFromNormalAndCoplanarPoint(c, n), R.constant = Math.round(R.constant * 10) / 10, { plane: R, edges: C };
  }
};
I(Ds, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
var Nn = Ds;

export {
  D,
  Ts,
  Si,
  et,
  Ni,
  ar,
  cr,
  zt,
  lr,
  Tr,
  mr,
  sn,
  Ge,
  ea,
  pi,
  Rr,
  Ar,
  ze,
  Fr,
  sa,
  ia,
  He,
  Ci,
  Nr,
  dn,
  Li,
  Rn,
  Br,
  Yr,
  Vr,
  Ti,
  Gr,
  An,
  zr,
  Hr,
  kr,
  Wr,
  na,
  Fn,
  vn,
  mi,
  ut,
  ke2 as ke,
  Zr,
  oa,
  Bn,
  Kt,
  Pi,
  Ri,
  On,
  Ai,
  gn,
  _n,
  jr,
  Sn,
  qr,
  Kr,
  Nn
};
/*! Bundled license information:

@thatopen/components/dist/index.mjs:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=chunk-W5B2UAA5.js.map
