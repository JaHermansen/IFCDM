var Rs = Object.defineProperty;
var Ms = (i, t, e) => t in i ? Rs(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var tt = (i, t, e) => (Ms(i, typeof t != "symbol" ? t + "" : t, e), e);
const Tt = Math.min, Q = Math.max, _e = Math.round, rt = (i) => ({
  x: i,
  y: i
}), js = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Bs = {
  start: "end",
  end: "start"
};
function Ki(i, t, e) {
  return Q(i, Tt(t, e));
}
function ne(i, t) {
  return typeof i == "function" ? i(t) : i;
}
function Y(i) {
  return i.split("-")[0];
}
function Re(i) {
  return i.split("-")[1];
}
function Rn(i) {
  return i === "x" ? "y" : "x";
}
function Mn(i) {
  return i === "y" ? "height" : "width";
}
function se(i) {
  return ["top", "bottom"].includes(Y(i)) ? "y" : "x";
}
function jn(i) {
  return Rn(se(i));
}
function Ns(i, t, e) {
  e === void 0 && (e = !1);
  const s = Re(i), n = jn(i), r = Mn(n);
  let o = n === "x" ? s === (e ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (o = xe(o)), [o, xe(o)];
}
function Hs(i) {
  const t = xe(i);
  return [ei(i), t, ei(t)];
}
function ei(i) {
  return i.replace(/start|end/g, (t) => Bs[t]);
}
function Ds(i, t, e) {
  const s = ["left", "right"], n = ["right", "left"], r = ["top", "bottom"], o = ["bottom", "top"];
  switch (i) {
    case "top":
    case "bottom":
      return e ? t ? n : s : t ? s : n;
    case "left":
    case "right":
      return t ? r : o;
    default:
      return [];
  }
}
function Fs(i, t, e, s) {
  const n = Re(i);
  let r = Ds(Y(i), e === "start", s);
  return n && (r = r.map((o) => o + "-" + n), t && (r = r.concat(r.map(ei)))), r;
}
function xe(i) {
  return i.replace(/left|right|bottom|top/g, (t) => js[t]);
}
function Vs(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
function Bn(i) {
  return typeof i != "number" ? Vs(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
function Lt(i) {
  const {
    x: t,
    y: e,
    width: s,
    height: n
  } = i;
  return {
    width: s,
    height: n,
    top: e,
    left: t,
    right: t + s,
    bottom: e + n,
    x: t,
    y: e
  };
}
function Zi(i, t, e) {
  let {
    reference: s,
    floating: n
  } = i;
  const r = se(t), o = jn(t), a = Mn(o), l = Y(t), c = r === "y", u = s.x + s.width / 2 - n.width / 2, h = s.y + s.height / 2 - n.height / 2, f = s[a] / 2 - n[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: u,
        y: s.y - n.height
      };
      break;
    case "bottom":
      p = {
        x: u,
        y: s.y + s.height
      };
      break;
    case "right":
      p = {
        x: s.x + s.width,
        y: h
      };
      break;
    case "left":
      p = {
        x: s.x - n.width,
        y: h
      };
      break;
    default:
      p = {
        x: s.x,
        y: s.y
      };
  }
  switch (Re(t)) {
    case "start":
      p[o] -= f * (e && c ? -1 : 1);
      break;
    case "end":
      p[o] += f * (e && c ? -1 : 1);
      break;
  }
  return p;
}
const Us = async (i, t, e) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o
  } = e, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: i,
    floating: t,
    strategy: n
  }), {
    x: u,
    y: h
  } = Zi(c, s, l), f = s, p = {}, b = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: g,
      fn: A
    } = a[v], {
      x: E,
      y: x,
      data: $,
      reset: S
    } = await A({
      x: u,
      y: h,
      initialPlacement: s,
      placement: f,
      strategy: n,
      middlewareData: p,
      rects: c,
      platform: o,
      elements: {
        reference: i,
        floating: t
      }
    });
    u = E ?? u, h = x ?? h, p = {
      ...p,
      [g]: {
        ...p[g],
        ...$
      }
    }, S && b <= 50 && (b++, typeof S == "object" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await o.getElementRects({
      reference: i,
      floating: t,
      strategy: n
    }) : S.rects), {
      x: u,
      y: h
    } = Zi(c, f, l)), v = -1);
  }
  return {
    x: u,
    y: h,
    placement: f,
    strategy: n,
    middlewareData: p
  };
};
async function mi(i, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: s,
    y: n,
    platform: r,
    rects: o,
    elements: a,
    strategy: l
  } = i, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: f = !1,
    padding: p = 0
  } = ne(t, i), b = Bn(p), g = a[f ? h === "floating" ? "reference" : "floating" : h], A = Lt(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(g))) == null || e ? g : g.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), E = h === "floating" ? {
    x: s,
    y: n,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, x = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), $ = await (r.isElement == null ? void 0 : r.isElement(x)) ? await (r.getScale == null ? void 0 : r.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = Lt(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: E,
    offsetParent: x,
    strategy: l
  }) : E);
  return {
    top: (A.top - S.top + b.top) / $.y,
    bottom: (S.bottom - A.bottom + b.bottom) / $.y,
    left: (A.left - S.left + b.left) / $.x,
    right: (S.right - A.right + b.right) / $.x
  };
}
const qs = function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(t) {
      var e, s;
      const {
        placement: n,
        middlewareData: r,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = !0,
        crossAxis: h = !0,
        fallbackPlacements: f,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: v = !0,
        ...g
      } = ne(i, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const A = Y(n), E = Y(a) === a, x = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), $ = f || (E || !v ? [xe(a)] : Hs(a));
      !f && b !== "none" && $.push(...Fs(a, v, b, x));
      const S = [a, ...$], y = await mi(t, g), T = [];
      let z = ((s = r.flip) == null ? void 0 : s.overflows) || [];
      if (u && T.push(y[A]), h) {
        const D = Ns(n, o, x);
        T.push(y[D[0]], y[D[1]]);
      }
      if (z = [...z, {
        placement: n,
        overflows: T
      }], !T.every((D) => D <= 0)) {
        var q, O;
        const D = (((q = r.flip) == null ? void 0 : q.index) || 0) + 1, Ot = S[D];
        if (Ot)
          return {
            data: {
              index: D,
              overflows: z
            },
            reset: {
              placement: Ot
            }
          };
        let Z = (O = z.filter((F) => F.overflows[0] <= 0).sort((F, W) => F.overflows[1] - W.overflows[1])[0]) == null ? void 0 : O.placement;
        if (!Z)
          switch (p) {
            case "bestFit": {
              var St;
              const F = (St = z.map((W) => [W.placement, W.overflows.filter((yt) => yt > 0).reduce((yt, qe) => yt + qe, 0)]).sort((W, yt) => W[1] - yt[1])[0]) == null ? void 0 : St[0];
              F && (Z = F);
              break;
            }
            case "initialPlacement":
              Z = a;
              break;
          }
        if (n !== Z)
          return {
            reset: {
              placement: Z
            }
          };
      }
      return {};
    }
  };
};
function Nn(i) {
  const t = Tt(...i.map((r) => r.left)), e = Tt(...i.map((r) => r.top)), s = Q(...i.map((r) => r.right)), n = Q(...i.map((r) => r.bottom));
  return {
    x: t,
    y: e,
    width: s - t,
    height: n - e
  };
}
function Ws(i) {
  const t = i.slice().sort((n, r) => n.y - r.y), e = [];
  let s = null;
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    !s || r.y - s.y > s.height / 2 ? e.push([r]) : e[e.length - 1].push(r), s = r;
  }
  return e.map((n) => Lt(Nn(n)));
}
const Qs = function(i) {
  return i === void 0 && (i = {}), {
    name: "inline",
    options: i,
    async fn(t) {
      const {
        placement: e,
        elements: s,
        rects: n,
        platform: r,
        strategy: o
      } = t, {
        padding: a = 2,
        x: l,
        y: c
      } = ne(i, t), u = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(s.reference)) || []), h = Ws(u), f = Lt(Nn(u)), p = Bn(a);
      function b() {
        if (h.length === 2 && h[0].left > h[1].right && l != null && c != null)
          return h.find((g) => l > g.left - p.left && l < g.right + p.right && c > g.top - p.top && c < g.bottom + p.bottom) || f;
        if (h.length >= 2) {
          if (se(e) === "y") {
            const O = h[0], St = h[h.length - 1], D = Y(e) === "top", Ot = O.top, Z = St.bottom, F = D ? O.left : St.left, W = D ? O.right : St.right, yt = W - F, qe = Z - Ot;
            return {
              top: Ot,
              bottom: Z,
              left: F,
              right: W,
              width: yt,
              height: qe,
              x: F,
              y: Ot
            };
          }
          const g = Y(e) === "left", A = Q(...h.map((O) => O.right)), E = Tt(...h.map((O) => O.left)), x = h.filter((O) => g ? O.left === E : O.right === A), $ = x[0].top, S = x[x.length - 1].bottom, y = E, T = A, z = T - y, q = S - $;
          return {
            top: $,
            bottom: S,
            left: y,
            right: T,
            width: z,
            height: q,
            x: y,
            y: $
          };
        }
        return f;
      }
      const v = await r.getElementRects({
        reference: {
          getBoundingClientRect: b
        },
        floating: s.floating,
        strategy: o
      });
      return n.reference.x !== v.reference.x || n.reference.y !== v.reference.y || n.reference.width !== v.reference.width || n.reference.height !== v.reference.height ? {
        reset: {
          rects: v
        }
      } : {};
    }
  };
};
async function Ys(i, t) {
  const {
    placement: e,
    platform: s,
    elements: n
  } = i, r = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), o = Y(e), a = Re(e), l = se(e) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = r && l ? -1 : 1, h = ne(t, i);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: b
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...h
  };
  return a && typeof b == "number" && (p = a === "end" ? b * -1 : b), l ? {
    x: p * u,
    y: f * c
  } : {
    x: f * c,
    y: p * u
  };
}
const Hn = function(i) {
  return {
    name: "offset",
    options: i,
    async fn(t) {
      var e, s;
      const {
        x: n,
        y: r,
        placement: o,
        middlewareData: a
      } = t, l = await Ys(t, i);
      return o === ((e = a.offset) == null ? void 0 : e.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: n + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, Gs = function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(t) {
      const {
        x: e,
        y: s,
        placement: n
      } = t, {
        mainAxis: r = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (g) => {
            let {
              x: A,
              y: E
            } = g;
            return {
              x: A,
              y: E
            };
          }
        },
        ...l
      } = ne(i, t), c = {
        x: e,
        y: s
      }, u = await mi(t, l), h = se(Y(n)), f = Rn(h);
      let p = c[f], b = c[h];
      if (r) {
        const g = f === "y" ? "top" : "left", A = f === "y" ? "bottom" : "right", E = p + u[g], x = p - u[A];
        p = Ki(E, p, x);
      }
      if (o) {
        const g = h === "y" ? "top" : "left", A = h === "y" ? "bottom" : "right", E = b + u[g], x = b - u[A];
        b = Ki(E, b, x);
      }
      const v = a.fn({
        ...t,
        [f]: p,
        [h]: b
      });
      return {
        ...v,
        data: {
          x: v.x - e,
          y: v.y - s
        }
      };
    }
  };
};
function ot(i) {
  return Dn(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
function R(i) {
  var t;
  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function mt(i) {
  var t;
  return (t = (Dn(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;
}
function Dn(i) {
  return i instanceof Node || i instanceof R(i).Node;
}
function G(i) {
  return i instanceof Element || i instanceof R(i).Element;
}
function V(i) {
  return i instanceof HTMLElement || i instanceof R(i).HTMLElement;
}
function tn(i) {
  return typeof ShadowRoot > "u" ? !1 : i instanceof ShadowRoot || i instanceof R(i).ShadowRoot;
}
function re(i) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: s,
    display: n
  } = M(i);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + e) && !["inline", "contents"].includes(n);
}
function Xs(i) {
  return ["table", "td", "th"].includes(ot(i));
}
function bi(i) {
  const t = gi(), e = M(i);
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((s) => (e.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (e.contain || "").includes(s));
}
function Js(i) {
  let t = It(i);
  for (; V(t) && !Me(t); ) {
    if (bi(t))
      return t;
    t = It(t);
  }
  return null;
}
function gi() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Me(i) {
  return ["html", "body", "#document"].includes(ot(i));
}
function M(i) {
  return R(i).getComputedStyle(i);
}
function je(i) {
  return G(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.pageXOffset,
    scrollTop: i.pageYOffset
  };
}
function It(i) {
  if (ot(i) === "html")
    return i;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    tn(i) && i.host || // Fallback.
    mt(i)
  );
  return tn(t) ? t.host : t;
}
function Fn(i) {
  const t = It(i);
  return Me(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : V(t) && re(t) ? t : Fn(t);
}
function ii(i, t, e) {
  var s;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const n = Fn(i), r = n === ((s = i.ownerDocument) == null ? void 0 : s.body), o = R(n);
  return r ? t.concat(o, o.visualViewport || [], re(n) ? n : [], o.frameElement && e ? ii(o.frameElement) : []) : t.concat(n, ii(n, [], e));
}
function Vn(i) {
  const t = M(i);
  let e = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const n = V(i), r = n ? i.offsetWidth : e, o = n ? i.offsetHeight : s, a = _e(e) !== r || _e(s) !== o;
  return a && (e = r, s = o), {
    width: e,
    height: s,
    $: a
  };
}
function Un(i) {
  return G(i) ? i : i.contextElement;
}
function Pt(i) {
  const t = Un(i);
  if (!V(t))
    return rt(1);
  const e = t.getBoundingClientRect(), {
    width: s,
    height: n,
    $: r
  } = Vn(t);
  let o = (r ? _e(e.width) : e.width) / s, a = (r ? _e(e.height) : e.height) / n;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const Ks = /* @__PURE__ */ rt(0);
function qn(i) {
  const t = R(i);
  return !gi() || !t.visualViewport ? Ks : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Zs(i, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== R(i) ? !1 : t;
}
function Gt(i, t, e, s) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const n = i.getBoundingClientRect(), r = Un(i);
  let o = rt(1);
  t && (s ? G(s) && (o = Pt(s)) : o = Pt(i));
  const a = Zs(r, e, s) ? qn(r) : rt(0);
  let l = (n.left + a.x) / o.x, c = (n.top + a.y) / o.y, u = n.width / o.x, h = n.height / o.y;
  if (r) {
    const f = R(r), p = s && G(s) ? R(s) : s;
    let b = f, v = b.frameElement;
    for (; v && s && p !== b; ) {
      const g = Pt(v), A = v.getBoundingClientRect(), E = M(v), x = A.left + (v.clientLeft + parseFloat(E.paddingLeft)) * g.x, $ = A.top + (v.clientTop + parseFloat(E.paddingTop)) * g.y;
      l *= g.x, c *= g.y, u *= g.x, h *= g.y, l += x, c += $, b = R(v), v = b.frameElement;
    }
  }
  return Lt({
    width: u,
    height: h,
    x: l,
    y: c
  });
}
const tr = [":popover-open", ":modal"];
function Wn(i) {
  return tr.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return !1;
    }
  });
}
function er(i) {
  let {
    elements: t,
    rect: e,
    offsetParent: s,
    strategy: n
  } = i;
  const r = n === "fixed", o = mt(s), a = t ? Wn(t.floating) : !1;
  if (s === o || a && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = rt(1);
  const u = rt(0), h = V(s);
  if ((h || !h && !r) && ((ot(s) !== "body" || re(o)) && (l = je(s)), V(s))) {
    const f = Gt(s);
    c = Pt(s), u.x = f.x + s.clientLeft, u.y = f.y + s.clientTop;
  }
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + u.x,
    y: e.y * c.y - l.scrollTop * c.y + u.y
  };
}
function ir(i) {
  return Array.from(i.getClientRects());
}
function Qn(i) {
  return Gt(mt(i)).left + je(i).scrollLeft;
}
function nr(i) {
  const t = mt(i), e = je(i), s = i.ownerDocument.body, n = Q(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), r = Q(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let o = -e.scrollLeft + Qn(i);
  const a = -e.scrollTop;
  return M(s).direction === "rtl" && (o += Q(t.clientWidth, s.clientWidth) - n), {
    width: n,
    height: r,
    x: o,
    y: a
  };
}
function sr(i, t) {
  const e = R(i), s = mt(i), n = e.visualViewport;
  let r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;
  if (n) {
    r = n.width, o = n.height;
    const c = gi();
    (!c || c && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function rr(i, t) {
  const e = Gt(i, !0, t === "fixed"), s = e.top + i.clientTop, n = e.left + i.clientLeft, r = V(i) ? Pt(i) : rt(1), o = i.clientWidth * r.x, a = i.clientHeight * r.y, l = n * r.x, c = s * r.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function en(i, t, e) {
  let s;
  if (t === "viewport")
    s = sr(i, e);
  else if (t === "document")
    s = nr(mt(i));
  else if (G(t))
    s = rr(t, e);
  else {
    const n = qn(i);
    s = {
      ...t,
      x: t.x - n.x,
      y: t.y - n.y
    };
  }
  return Lt(s);
}
function Yn(i, t) {
  const e = It(i);
  return e === t || !G(e) || Me(e) ? !1 : M(e).position === "fixed" || Yn(e, t);
}
function or(i, t) {
  const e = t.get(i);
  if (e)
    return e;
  let s = ii(i, [], !1).filter((a) => G(a) && ot(a) !== "body"), n = null;
  const r = M(i).position === "fixed";
  let o = r ? It(i) : i;
  for (; G(o) && !Me(o); ) {
    const a = M(o), l = bi(o);
    !l && a.position === "fixed" && (n = null), (r ? !l && !n : !l && a.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || re(o) && !l && Yn(i, o)) ? s = s.filter((u) => u !== o) : n = a, o = It(o);
  }
  return t.set(i, s), s;
}
function lr(i) {
  let {
    element: t,
    boundary: e,
    rootBoundary: s,
    strategy: n
  } = i;
  const o = [...e === "clippingAncestors" ? or(t, this._c) : [].concat(e), s], a = o[0], l = o.reduce((c, u) => {
    const h = en(t, u, n);
    return c.top = Q(h.top, c.top), c.right = Tt(h.right, c.right), c.bottom = Tt(h.bottom, c.bottom), c.left = Q(h.left, c.left), c;
  }, en(t, a, n));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function ar(i) {
  const {
    width: t,
    height: e
  } = Vn(i);
  return {
    width: t,
    height: e
  };
}
function cr(i, t, e) {
  const s = V(t), n = mt(t), r = e === "fixed", o = Gt(i, !0, r, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = rt(0);
  if (s || !s && !r)
    if ((ot(t) !== "body" || re(n)) && (a = je(t)), s) {
      const h = Gt(t, !0, r, t);
      l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop;
    } else
      n && (l.x = Qn(n));
  const c = o.left + a.scrollLeft - l.x, u = o.top + a.scrollTop - l.y;
  return {
    x: c,
    y: u,
    width: o.width,
    height: o.height
  };
}
function nn(i, t) {
  return !V(i) || M(i).position === "fixed" ? null : t ? t(i) : i.offsetParent;
}
function Gn(i, t) {
  const e = R(i);
  if (!V(i) || Wn(i))
    return e;
  let s = nn(i, t);
  for (; s && Xs(s) && M(s).position === "static"; )
    s = nn(s, t);
  return s && (ot(s) === "html" || ot(s) === "body" && M(s).position === "static" && !bi(s)) ? e : s || Js(i) || e;
}
const ur = async function(i) {
  const t = this.getOffsetParent || Gn, e = this.getDimensions;
  return {
    reference: cr(i.reference, await t(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(i.floating)
    }
  };
};
function hr(i) {
  return M(i).direction === "rtl";
}
const dr = {
  convertOffsetParentRelativeRectToViewportRelativeRect: er,
  getDocumentElement: mt,
  getClippingRect: lr,
  getOffsetParent: Gn,
  getElementRects: ur,
  getClientRects: ir,
  getDimensions: ar,
  getScale: Pt,
  isElement: G,
  isRTL: hr
}, Xn = Gs, Jn = qs, Kn = Qs, Zn = (i, t, e) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: dr,
    ...e
  }, r = {
    ...n.platform,
    _c: s
  };
  return Us(i, t, {
    ...n,
    platform: r
  });
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ge = globalThis, vi = ge.ShadowRoot && (ge.ShadyCSS === void 0 || ge.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, yi = Symbol(), sn = /* @__PURE__ */ new WeakMap();
let ts = class {
  constructor(t, e, s) {
    if (this._$cssResult$ = !0, s !== yi)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (vi && t === void 0) {
      const s = e !== void 0 && e.length === 1;
      s && (t = sn.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), s && sn.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const fr = (i) => new ts(typeof i == "string" ? i : i + "", void 0, yi), C = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((s, n, r) => s + ((o) => {
    if (o._$cssResult$ === !0)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + i[r + 1], i[0]);
  return new ts(e, i, yi);
}, pr = (i, t) => {
  if (vi)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const s = document.createElement("style"), n = ge.litNonce;
      n !== void 0 && s.setAttribute("nonce", n), s.textContent = e.cssText, i.appendChild(s);
    }
}, rn = vi ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const s of t.cssRules)
    e += s.cssText;
  return fr(e);
})(i) : i;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: mr, defineProperty: br, getOwnPropertyDescriptor: gr, getOwnPropertyNames: vr, getOwnPropertySymbols: yr, getPrototypeOf: _r } = Object, it = globalThis, on = it.trustedTypes, xr = on ? on.emptyScript : "", We = it.reactiveElementPolyfillSupport, Ut = (i, t) => i, we = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? xr : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} }, _i = (i, t) => !mr(i, t), ln = { attribute: !0, type: String, converter: we, reflect: !1, hasChanged: _i };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), it.litPropertyMetadata ?? (it.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class kt extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = ln) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const s = Symbol(), n = this.getPropertyDescriptor(t, s, e);
      n !== void 0 && br(this.prototype, t, n);
    }
  }
  static getPropertyDescriptor(t, e, s) {
    const { get: n, set: r } = gr(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return n == null ? void 0 : n.call(this);
    }, set(o) {
      const a = n == null ? void 0 : n.call(this);
      r.call(this, o), this.requestUpdate(t, a, s);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? ln;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Ut("elementProperties")))
      return;
    const t = _r(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Ut("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Ut("properties"))) {
      const e = this.properties, s = [...vr(e), ...yr(e)];
      for (const n of s)
        this.createProperty(n, e[n]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [s, n] of e)
          this.elementProperties.set(s, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, s] of this.elementProperties) {
      const n = this._$Eu(e, s);
      n !== void 0 && this._$Eh.set(n, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const s = new Set(t.flat(1 / 0).reverse());
      for (const n of s)
        e.unshift(rn(n));
    } else
      t !== void 0 && e.push(rn(t));
    return e;
  }
  static _$Eu(t, e) {
    const s = e.attribute;
    return s === !1 ? void 0 : typeof s == "string" ? s : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const s of e.keys())
      this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return pr(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostConnected) == null ? void 0 : s.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostDisconnected) == null ? void 0 : s.call(e);
    });
  }
  attributeChangedCallback(t, e, s) {
    this._$AK(t, s);
  }
  _$EC(t, e) {
    var r;
    const s = this.constructor.elementProperties.get(t), n = this.constructor._$Eu(t, s);
    if (n !== void 0 && s.reflect === !0) {
      const o = (((r = s.converter) == null ? void 0 : r.toAttribute) !== void 0 ? s.converter : we).toAttribute(e, s.type);
      this._$Em = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var r;
    const s = this.constructor, n = s._$Eh.get(t);
    if (n !== void 0 && this._$Em !== n) {
      const o = s.getPropertyOptions(n), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((r = o.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? o.converter : we;
      this._$Em = n, this[n] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, s) {
    if (t !== void 0) {
      if (s ?? (s = this.constructor.getPropertyOptions(t)), !(s.hasChanged ?? _i)(this[t], e))
        return;
      this.P(t, e, s);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, e, s) {
    this._$AL.has(t) || this._$AL.set(t, e), s.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var s;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [r, o] of n)
          o.wrapped !== !0 || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (s = this._$EO) == null || s.forEach((n) => {
        var r;
        return (r = n.hostUpdate) == null ? void 0 : r.call(n);
      }), this.update(e)) : this._$EU();
    } catch (n) {
      throw t = !1, this._$EU(), n;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((s) => {
      var n;
      return (n = s.hostUpdated) == null ? void 0 : n.call(s);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}
kt.elementStyles = [], kt.shadowRootOptions = { mode: "open" }, kt[Ut("elementProperties")] = /* @__PURE__ */ new Map(), kt[Ut("finalized")] = /* @__PURE__ */ new Map(), We == null || We({ ReactiveElement: kt }), (it.reactiveElementVersions ?? (it.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const qt = globalThis, $e = qt.trustedTypes, an = $e ? $e.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, es = "$lit$", et = `lit$${Math.random().toFixed(9).slice(2)}$`, is = "?" + et, wr = `<${is}>`, $t = document, Xt = () => $t.createComment(""), Jt = (i) => i === null || typeof i != "object" && typeof i != "function", ns = Array.isArray, $r = (i) => ns(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function", Qe = `[ 	
\f\r]`, Ft = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, cn = /-->/g, un = />/g, _t = RegExp(`>|${Qe}(?:([^\\s"'>=/]+)(${Qe}*=${Qe}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), hn = /'/g, dn = /"/g, ss = /^(?:script|style|textarea|title)$/i, Cr = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), m = Cr(1), Ct = Symbol.for("lit-noChange"), k = Symbol.for("lit-nothing"), fn = /* @__PURE__ */ new WeakMap(), xt = $t.createTreeWalker($t, 129);
function rs(i, t) {
  if (!Array.isArray(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return an !== void 0 ? an.createHTML(t) : t;
}
const Er = (i, t) => {
  const e = i.length - 1, s = [];
  let n, r = t === 2 ? "<svg>" : "", o = Ft;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let c, u, h = -1, f = 0;
    for (; f < l.length && (o.lastIndex = f, u = o.exec(l), u !== null); )
      f = o.lastIndex, o === Ft ? u[1] === "!--" ? o = cn : u[1] !== void 0 ? o = un : u[2] !== void 0 ? (ss.test(u[2]) && (n = RegExp("</" + u[2], "g")), o = _t) : u[3] !== void 0 && (o = _t) : o === _t ? u[0] === ">" ? (o = n ?? Ft, h = -1) : u[1] === void 0 ? h = -2 : (h = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? _t : u[3] === '"' ? dn : hn) : o === dn || o === hn ? o = _t : o === cn || o === un ? o = Ft : (o = _t, n = void 0);
    const p = o === _t && i[a + 1].startsWith("/>") ? " " : "";
    r += o === Ft ? l + wr : h >= 0 ? (s.push(c), l.slice(0, h) + es + l.slice(h) + et + p) : l + et + (h === -2 ? a : p);
  }
  return [rs(i, r + (i[e] || "<?>") + (t === 2 ? "</svg>" : "")), s];
};
class Kt {
  constructor({ strings: t, _$litType$: e }, s) {
    let n;
    this.parts = [];
    let r = 0, o = 0;
    const a = t.length - 1, l = this.parts, [c, u] = Er(t, e);
    if (this.el = Kt.createElement(c, s), xt.currentNode = this.el.content, e === 2) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (n = xt.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes())
          for (const h of n.getAttributeNames())
            if (h.endsWith(es)) {
              const f = u[o++], p = n.getAttribute(h).split(et), b = /([.?@])?(.*)/.exec(f);
              l.push({ type: 1, index: r, name: b[2], strings: p, ctor: b[1] === "." ? Sr : b[1] === "?" ? Or : b[1] === "@" ? kr : Be }), n.removeAttribute(h);
            } else
              h.startsWith(et) && (l.push({ type: 6, index: r }), n.removeAttribute(h));
        if (ss.test(n.tagName)) {
          const h = n.textContent.split(et), f = h.length - 1;
          if (f > 0) {
            n.textContent = $e ? $e.emptyScript : "";
            for (let p = 0; p < f; p++)
              n.append(h[p], Xt()), xt.nextNode(), l.push({ type: 2, index: ++r });
            n.append(h[f], Xt());
          }
        }
      } else if (n.nodeType === 8)
        if (n.data === is)
          l.push({ type: 2, index: r });
        else {
          let h = -1;
          for (; (h = n.data.indexOf(et, h + 1)) !== -1; )
            l.push({ type: 7, index: r }), h += et.length - 1;
        }
      r++;
    }
  }
  static createElement(t, e) {
    const s = $t.createElement("template");
    return s.innerHTML = t, s;
  }
}
function zt(i, t, e = i, s) {
  var o, a;
  if (t === Ct)
    return t;
  let n = s !== void 0 ? (o = e._$Co) == null ? void 0 : o[s] : e._$Cl;
  const r = Jt(t) ? void 0 : t._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== r && ((a = n == null ? void 0 : n._$AO) == null || a.call(n, !1), r === void 0 ? n = void 0 : (n = new r(i), n._$AT(i, e, s)), s !== void 0 ? (e._$Co ?? (e._$Co = []))[s] = n : e._$Cl = n), n !== void 0 && (t = zt(i, n._$AS(i, t.values), n, s)), t;
}
class Ar {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: s } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? $t).importNode(e, !0);
    xt.currentNode = n;
    let r = xt.nextNode(), o = 0, a = 0, l = s[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new oe(r, r.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (c = new Pr(r, this, t)), this._$AV.push(c), l = s[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = xt.nextNode(), o++);
    }
    return xt.currentNode = $t, n;
  }
  p(t) {
    let e = 0;
    for (const s of this._$AV)
      s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;
  }
}
class oe {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, s, n) {
    this.type = 2, this._$AH = k, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = zt(this, t, e), Jt(t) ? t === k || t == null || t === "" ? (this._$AH !== k && this._$AR(), this._$AH = k) : t !== this._$AH && t !== Ct && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : $r(t) ? this.k(t) : this._(t);
  }
  S(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));
  }
  _(t) {
    this._$AH !== k && Jt(this._$AH) ? this._$AA.nextSibling.data = t : this.T($t.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var r;
    const { values: e, _$litType$: s } = t, n = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = Kt.createElement(rs(s.h, s.h[0]), this.options)), s);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === n)
      this._$AH.p(e);
    else {
      const o = new Ar(n, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = fn.get(t.strings);
    return e === void 0 && fn.set(t.strings, e = new Kt(t)), e;
  }
  k(t) {
    ns(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let s, n = 0;
    for (const r of t)
      n === e.length ? e.push(s = new oe(this.S(Xt()), this.S(Xt()), this, this.options)) : s = e[n], s._$AI(r), n++;
    n < e.length && (this._$AR(s && s._$AB.nextSibling, n), e.length = n);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
}
class Be {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, s, n, r) {
    this.type = 1, this._$AH = k, this._$AN = void 0, this.element = t, this.name = e, this._$AM = n, this.options = r, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = k;
  }
  _$AI(t, e = this, s, n) {
    const r = this.strings;
    let o = !1;
    if (r === void 0)
      t = zt(this, t, e, 0), o = !Jt(t) || t !== this._$AH && t !== Ct, o && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = r[0], l = 0; l < r.length - 1; l++)
        c = zt(this, a[s + l], e, l), c === Ct && (c = this._$AH[l]), o || (o = !Jt(c) || c !== this._$AH[l]), c === k ? t = k : t !== k && (t += (c ?? "") + r[l + 1]), this._$AH[l] = c;
    }
    o && !n && this.j(t);
  }
  j(t) {
    t === k ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class Sr extends Be {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === k ? void 0 : t;
  }
}
class Or extends Be {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== k);
  }
}
class kr extends Be {
  constructor(t, e, s, n, r) {
    super(t, e, s, n, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = zt(this, t, e, 0) ?? k) === Ct)
      return;
    const s = this._$AH, n = t === k && s !== k || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, r = t !== k && (s === k || n);
    n && this.element.removeEventListener(this.name, this, s), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class Pr {
  constructor(t, e, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    zt(this, t);
  }
}
const Ye = qt.litHtmlPolyfillSupport;
Ye == null || Ye(Kt, oe), (qt.litHtmlVersions ?? (qt.litHtmlVersions = [])).push("3.1.3");
const Rt = (i, t, e) => {
  const s = (e == null ? void 0 : e.renderBefore) ?? t;
  let n = s._$litPart$;
  if (n === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    s._$litPart$ = n = new oe(t.insertBefore(Xt(), r), r, void 0, e ?? {});
  }
  return n._$AI(i), n;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let w = class extends kt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Rt(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return Ct;
  }
};
var zn;
w._$litElement$ = !0, w.finalized = !0, (zn = globalThis.litElementHydrateSupport) == null || zn.call(globalThis, { LitElement: w });
const Ge = globalThis.litElementPolyfillSupport;
Ge == null || Ge({ LitElement: w });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.5");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Tr = { attribute: !0, type: String, converter: we, reflect: !1, hasChanged: _i }, Lr = (i = Tr, t, e) => {
  const { kind: s, metadata: n } = e;
  let r = globalThis.litPropertyMetadata.get(n);
  if (r === void 0 && globalThis.litPropertyMetadata.set(n, r = /* @__PURE__ */ new Map()), r.set(e.name, i), s === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, i);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, i), a;
    } };
  }
  if (s === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + s);
};
function d(i) {
  return (t, e) => typeof e == "object" ? Lr(i, t, e) : ((s, n, r) => {
    const o = n.hasOwnProperty(r);
    return n.constructor.createProperty(r, o ? { ...s, wrapped: !0 } : s), o ? Object.getOwnPropertyDescriptor(n, r) : void 0;
  })(i, t, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function le(i) {
  return d({ ...i, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ir = (i) => i.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const os = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, ls = (i) => (...t) => ({ _$litDirective$: i, values: t });
let as = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, s) {
    this._$Ct = t, this._$AM = e, this._$Ci = s;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Wt = (i, t) => {
  var s;
  const e = i._$AN;
  if (e === void 0)
    return !1;
  for (const n of e)
    (s = n._$AO) == null || s.call(n, t, !1), Wt(n, t);
  return !0;
}, Ce = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
}, cs = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), Mr(t);
  }
};
function zr(i) {
  this._$AN !== void 0 ? (Ce(this), this._$AM = i, cs(this)) : this._$AM = i;
}
function Rr(i, t = !1, e = 0) {
  const s = this._$AH, n = this._$AN;
  if (n !== void 0 && n.size !== 0)
    if (t)
      if (Array.isArray(s))
        for (let r = e; r < s.length; r++)
          Wt(s[r], !1), Ce(s[r]);
      else
        s != null && (Wt(s, !1), Ce(s));
    else
      Wt(this, i);
}
const Mr = (i) => {
  i.type == os.CHILD && (i._$AP ?? (i._$AP = Rr), i._$AQ ?? (i._$AQ = zr));
};
class jr extends as {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, s) {
    super._$AT(t, e, s), cs(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    var s, n;
    t !== this.isConnected && (this.isConnected = t, t ? (s = this.reconnected) == null || s.call(this) : (n = this.disconnected) == null || n.call(this)), e && (Wt(this, t), Ce(this));
  }
  setValue(t) {
    if (Ir(this._$Ct))
      this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const nt = () => new Br();
class Br {
}
const Xe = /* @__PURE__ */ new WeakMap(), st = ls(class extends jr {
  render(i) {
    return k;
  }
  update(i, [t]) {
    var s;
    const e = t !== this.Y;
    return e && this.Y !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.Y = t, this.ht = (s = i.options) == null ? void 0 : s.host, this.rt(this.ct = i.element)), k;
  }
  rt(i) {
    if (typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let e = Xe.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Xe.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);
    } else
      this.Y.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.Y == "function" ? (i = Xe.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt
* files at https://github.com/iconify/iconify
*
* Licensed under MIT.
*
* @license MIT
* @version 2.0.0
*/
const us = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Ee = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), ae = Object.freeze({
  ...us,
  ...Ee
}), ni = Object.freeze({
  ...ae,
  body: "",
  hidden: !1
}), Nr = Object.freeze({
  width: null,
  height: null
}), hs = Object.freeze({
  // Dimensions
  ...Nr,
  // Transformations
  ...Ee
});
function Hr(i, t = 0) {
  const e = i.replace(/^-?[0-9.]*/, "");
  function s(n) {
    for (; n < 0; )
      n += 4;
    return n % 4;
  }
  if (e === "") {
    const n = parseInt(i);
    return isNaN(n) ? 0 : s(n);
  } else if (e !== i) {
    let n = 0;
    switch (e) {
      case "%":
        n = 25;
        break;
      case "deg":
        n = 90;
    }
    if (n) {
      let r = parseFloat(i.slice(0, i.length - e.length));
      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? s(r) : 0);
    }
  }
  return t;
}
const Dr = /[\s,]+/;
function Fr(i, t) {
  t.split(Dr).forEach((e) => {
    switch (e.trim()) {
      case "horizontal":
        i.hFlip = !0;
        break;
      case "vertical":
        i.vFlip = !0;
        break;
    }
  });
}
const ds = {
  ...hs,
  preserveAspectRatio: ""
};
function pn(i) {
  const t = {
    ...ds
  }, e = (s, n) => i.getAttribute(s) || n;
  return t.width = e("width", null), t.height = e("height", null), t.rotate = Hr(e("rotate", "")), Fr(t, e("flip", "")), t.preserveAspectRatio = e("preserveAspectRatio", e("preserveaspectratio", "")), t;
}
function Vr(i, t) {
  for (const e in ds)
    if (i[e] !== t[e])
      return !0;
  return !1;
}
const Qt = /^[a-z0-9]+(-[a-z0-9]+)*$/, ce = (i, t, e, s = "") => {
  const n = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (n.length < 2 || n.length > 3)
      return null;
    s = n.shift().slice(1);
  }
  if (n.length > 3 || !n.length)
    return null;
  if (n.length > 1) {
    const a = n.pop(), l = n.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: n.length > 0 ? n[0] : s,
      prefix: l,
      name: a
    };
    return t && !ve(c) ? null : c;
  }
  const r = n[0], o = r.split("-");
  if (o.length > 1) {
    const a = {
      provider: s,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !ve(a) ? null : a;
  }
  if (e && s === "") {
    const a = {
      provider: s,
      prefix: "",
      name: r
    };
    return t && !ve(a, e) ? null : a;
  }
  return null;
}, ve = (i, t) => i ? !!((i.provider === "" || i.provider.match(Qt)) && (t && i.prefix === "" || i.prefix.match(Qt)) && i.name.match(Qt)) : !1;
function Ur(i, t) {
  const e = {};
  !i.hFlip != !t.hFlip && (e.hFlip = !0), !i.vFlip != !t.vFlip && (e.vFlip = !0);
  const s = ((i.rotate || 0) + (t.rotate || 0)) % 4;
  return s && (e.rotate = s), e;
}
function mn(i, t) {
  const e = Ur(i, t);
  for (const s in ni)
    s in Ee ? s in i && !(s in e) && (e[s] = Ee[s]) : s in t ? e[s] = t[s] : s in i && (e[s] = i[s]);
  return e;
}
function qr(i, t) {
  const e = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function r(o) {
    if (e[o])
      return n[o] = [];
    if (!(o in n)) {
      n[o] = null;
      const a = s[o] && s[o].parent, l = a && r(a);
      l && (n[o] = [a].concat(l));
    }
    return n[o];
  }
  return Object.keys(e).concat(Object.keys(s)).forEach(r), n;
}
function Wr(i, t, e) {
  const s = i.icons, n = i.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function o(a) {
    r = mn(
      s[a] || n[a],
      r
    );
  }
  return o(t), e.forEach(o), mn(i, r);
}
function fs(i, t) {
  const e = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return e;
  i.not_found instanceof Array && i.not_found.forEach((n) => {
    t(n, null), e.push(n);
  });
  const s = qr(i);
  for (const n in s) {
    const r = s[n];
    r && (t(n, Wr(i, n, r)), e.push(n));
  }
  return e;
}
const Qr = {
  provider: "",
  aliases: {},
  not_found: {},
  ...us
};
function Je(i, t) {
  for (const e in t)
    if (e in i && typeof i[e] != typeof t[e])
      return !1;
  return !0;
}
function ps(i) {
  if (typeof i != "object" || i === null)
    return null;
  const t = i;
  if (typeof t.prefix != "string" || !i.icons || typeof i.icons != "object" || !Je(i, Qr))
    return null;
  const e = t.icons;
  for (const n in e) {
    const r = e[n];
    if (!n.match(Qt) || typeof r.body != "string" || !Je(
      r,
      ni
    ))
      return null;
  }
  const s = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const n in s) {
    const r = s[n], o = r.parent;
    if (!n.match(Qt) || typeof o != "string" || !e[o] && !s[o] || !Je(
      r,
      ni
    ))
      return null;
  }
  return t;
}
const Ae = /* @__PURE__ */ Object.create(null);
function Yr(i, t) {
  return {
    provider: i,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function lt(i, t) {
  const e = Ae[i] || (Ae[i] = /* @__PURE__ */ Object.create(null));
  return e[t] || (e[t] = Yr(i, t));
}
function xi(i, t) {
  return ps(t) ? fs(t, (e, s) => {
    s ? i.icons[e] = s : i.missing.add(e);
  }) : [];
}
function Gr(i, t, e) {
  try {
    if (typeof e.body == "string")
      return i.icons[t] = { ...e }, !0;
  } catch {
  }
  return !1;
}
function Xr(i, t) {
  let e = [];
  return (typeof i == "string" ? [i] : Object.keys(Ae)).forEach((n) => {
    (typeof n == "string" && typeof t == "string" ? [t] : Object.keys(Ae[n] || {})).forEach((o) => {
      const a = lt(n, o);
      e = e.concat(
        Object.keys(a.icons).map(
          (l) => (n !== "" ? "@" + n + ":" : "") + o + ":" + l
        )
      );
    });
  }), e;
}
let Zt = !1;
function ms(i) {
  return typeof i == "boolean" && (Zt = i), Zt;
}
function te(i) {
  const t = typeof i == "string" ? ce(i, !0, Zt) : i;
  if (t) {
    const e = lt(t.provider, t.prefix), s = t.name;
    return e.icons[s] || (e.missing.has(s) ? null : void 0);
  }
}
function bs(i, t) {
  const e = ce(i, !0, Zt);
  if (!e)
    return !1;
  const s = lt(e.provider, e.prefix);
  return Gr(s, e.name, t);
}
function bn(i, t) {
  if (typeof i != "object")
    return !1;
  if (typeof t != "string" && (t = i.provider || ""), Zt && !t && !i.prefix) {
    let n = !1;
    return ps(i) && (i.prefix = "", fs(i, (r, o) => {
      o && bs(r, o) && (n = !0);
    })), n;
  }
  const e = i.prefix;
  if (!ve({
    provider: t,
    prefix: e,
    name: "a"
  }))
    return !1;
  const s = lt(t, e);
  return !!xi(s, i);
}
function gn(i) {
  return !!te(i);
}
function Jr(i) {
  const t = te(i);
  return t ? {
    ...ae,
    ...t
  } : null;
}
function Kr(i) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, e = /* @__PURE__ */ Object.create(null);
  i.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));
  let s = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((n) => {
    if (s.name === n.name && s.prefix === n.prefix && s.provider === n.provider)
      return;
    s = n;
    const r = n.provider, o = n.prefix, a = n.name, l = e[r] || (e[r] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = lt(r, o));
    let u;
    a in c.icons ? u = t.loaded : o === "" || c.missing.has(a) ? u = t.missing : u = t.pending;
    const h = {
      provider: r,
      prefix: o,
      name: a
    };
    u.push(h);
  }), t;
}
function gs(i, t) {
  i.forEach((e) => {
    const s = e.loaderCallbacks;
    s && (e.loaderCallbacks = s.filter((n) => n.id !== t));
  });
}
function Zr(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = !0, setTimeout(() => {
    i.pendingCallbacksFlag = !1;
    const t = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let e = !1;
    const s = i.provider, n = i.prefix;
    t.forEach((r) => {
      const o = r.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== n)
          return !0;
        const c = l.name;
        if (i.icons[c])
          o.loaded.push({
            provider: s,
            prefix: n,
            name: c
          });
        else if (i.missing.has(c))
          o.missing.push({
            provider: s,
            prefix: n,
            name: c
          });
        else
          return e = !0, !0;
        return !1;
      }), o.pending.length !== a && (e || gs([i], r.id), r.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        r.abort
      ));
    });
  }));
}
let to = 0;
function eo(i, t, e) {
  const s = to++, n = gs.bind(null, e, s);
  if (!t.pending.length)
    return n;
  const r = {
    id: s,
    icons: t,
    callback: i,
    abort: n
  };
  return e.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(r);
  }), n;
}
const si = /* @__PURE__ */ Object.create(null);
function vn(i, t) {
  si[i] = t;
}
function ri(i) {
  return si[i] || si[""];
}
function io(i, t = !0, e = !1) {
  const s = [];
  return i.forEach((n) => {
    const r = typeof n == "string" ? ce(n, t, e) : n;
    r && s.push(r);
  }), s;
}
var no = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function so(i, t, e, s) {
  const n = i.resources.length, r = i.random ? Math.floor(Math.random() * n) : i.index;
  let o;
  if (i.random) {
    let y = i.resources.slice(0);
    for (o = []; y.length > 1; ) {
      const T = Math.floor(Math.random() * y.length);
      o.push(y[T]), y = y.slice(0, T).concat(y.slice(T + 1));
    }
    o = o.concat(y);
  } else
    o = i.resources.slice(r).concat(i.resources.slice(0, r));
  const a = Date.now();
  let l = "pending", c = 0, u, h = null, f = [], p = [];
  typeof s == "function" && p.push(s);
  function b() {
    h && (clearTimeout(h), h = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), b(), f.forEach((y) => {
      y.status === "pending" && (y.status = "aborted");
    }), f = [];
  }
  function g(y, T) {
    T && (p = []), typeof y == "function" && p.push(y);
  }
  function A() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: f.length,
      subscribe: g,
      abort: v
    };
  }
  function E() {
    l = "failed", p.forEach((y) => {
      y(void 0, u);
    });
  }
  function x() {
    f.forEach((y) => {
      y.status === "pending" && (y.status = "aborted");
    }), f = [];
  }
  function $(y, T, z) {
    const q = T !== "success";
    switch (f = f.filter((O) => O !== y), l) {
      case "pending":
        break;
      case "failed":
        if (q || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (T === "abort") {
      u = z, E();
      return;
    }
    if (q) {
      u = z, f.length || (o.length ? S() : E());
      return;
    }
    if (b(), x(), !i.random) {
      const O = i.resources.indexOf(y.resource);
      O !== -1 && O !== i.index && (i.index = O);
    }
    l = "completed", p.forEach((O) => {
      O(z);
    });
  }
  function S() {
    if (l !== "pending")
      return;
    b();
    const y = o.shift();
    if (y === void 0) {
      if (f.length) {
        h = setTimeout(() => {
          b(), l === "pending" && (x(), E());
        }, i.timeout);
        return;
      }
      E();
      return;
    }
    const T = {
      status: "pending",
      resource: y,
      callback: (z, q) => {
        $(T, z, q);
      }
    };
    f.push(T), c++, h = setTimeout(S, i.rotate), e(y, t, T.callback);
  }
  return setTimeout(S), A;
}
function vs(i) {
  const t = {
    ...no,
    ...i
  };
  let e = [];
  function s() {
    e = e.filter((a) => a().status === "pending");
  }
  function n(a, l, c) {
    const u = so(
      t,
      a,
      l,
      (h, f) => {
        s(), c && c(h, f);
      }
    );
    return e.push(u), u;
  }
  function r(a) {
    return e.find((l) => a(l)) || null;
  }
  return {
    query: n,
    find: r,
    setIndex: (a) => {
      t.index = a;
    },
    getIndex: () => t.index,
    cleanup: s
  };
}
function wi(i) {
  let t;
  if (typeof i.resources == "string")
    t = [i.resources];
  else if (t = i.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === !0,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== !1
  };
}
const Ne = /* @__PURE__ */ Object.create(null), Vt = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], ye = [];
for (; Vt.length > 0; )
  Vt.length === 1 || Math.random() > 0.5 ? ye.push(Vt.shift()) : ye.push(Vt.pop());
Ne[""] = wi({
  resources: ["https://api.iconify.design"].concat(ye)
});
function yn(i, t) {
  const e = wi(t);
  return e === null ? !1 : (Ne[i] = e, !0);
}
function He(i) {
  return Ne[i];
}
function ro() {
  return Object.keys(Ne);
}
function _n() {
}
const Ke = /* @__PURE__ */ Object.create(null);
function oo(i) {
  if (!Ke[i]) {
    const t = He(i);
    if (!t)
      return;
    const e = vs(t), s = {
      config: t,
      redundancy: e
    };
    Ke[i] = s;
  }
  return Ke[i];
}
function ys(i, t, e) {
  let s, n;
  if (typeof i == "string") {
    const r = ri(i);
    if (!r)
      return e(void 0, 424), _n;
    n = r.send;
    const o = oo(i);
    o && (s = o.redundancy);
  } else {
    const r = wi(i);
    if (r) {
      s = vs(r);
      const o = i.resources ? i.resources[0] : "", a = ri(o);
      a && (n = a.send);
    }
  }
  return !s || !n ? (e(void 0, 424), _n) : s.query(t, n, e)().abort;
}
const xn = "iconify2", ee = "iconify", _s = ee + "-count", wn = ee + "-version", xs = 36e5, lo = 168, ao = 50;
function oi(i, t) {
  try {
    return i.getItem(t);
  } catch {
  }
}
function $i(i, t, e) {
  try {
    return i.setItem(t, e), !0;
  } catch {
  }
}
function $n(i, t) {
  try {
    i.removeItem(t);
  } catch {
  }
}
function li(i, t) {
  return $i(i, _s, t.toString());
}
function ai(i) {
  return parseInt(oi(i, _s)) || 0;
}
const wt = {
  local: !0,
  session: !0
}, ws = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let Ci = !1;
function co(i) {
  Ci = i;
}
let be = typeof window > "u" ? {} : window;
function $s(i) {
  const t = i + "Storage";
  try {
    if (be && be[t] && typeof be[t].length == "number")
      return be[t];
  } catch {
  }
  wt[i] = !1;
}
function Cs(i, t) {
  const e = $s(i);
  if (!e)
    return;
  const s = oi(e, wn);
  if (s !== xn) {
    if (s) {
      const a = ai(e);
      for (let l = 0; l < a; l++)
        $n(e, ee + l.toString());
    }
    $i(e, wn, xn), li(e, 0);
    return;
  }
  const n = Math.floor(Date.now() / xs) - lo, r = (a) => {
    const l = ee + a.toString(), c = oi(e, l);
    if (typeof c == "string") {
      try {
        const u = JSON.parse(c);
        if (typeof u == "object" && typeof u.cached == "number" && u.cached > n && typeof u.provider == "string" && typeof u.data == "object" && typeof u.data.prefix == "string" && // Valid item: run callback
        t(u, a))
          return !0;
      } catch {
      }
      $n(e, l);
    }
  };
  let o = ai(e);
  for (let a = o - 1; a >= 0; a--)
    r(a) || (a === o - 1 ? (o--, li(e, o)) : ws[i].add(a));
}
function Es() {
  if (!Ci) {
    co(!0);
    for (const i in wt)
      Cs(i, (t) => {
        const e = t.data, s = t.provider, n = e.prefix, r = lt(
          s,
          n
        );
        if (!xi(r, e).length)
          return !1;
        const o = e.lastModified || -1;
        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, o) : o, !0;
      });
  }
}
function uo(i, t) {
  const e = i.lastModifiedCached;
  if (
    // Matches or newer
    e && e >= t
  )
    return e === t;
  if (i.lastModifiedCached = t, e)
    for (const s in wt)
      Cs(s, (n) => {
        const r = n.data;
        return n.provider !== i.provider || r.prefix !== i.prefix || r.lastModified === t;
      });
  return !0;
}
function ho(i, t) {
  Ci || Es();
  function e(s) {
    let n;
    if (!wt[s] || !(n = $s(s)))
      return;
    const r = ws[s];
    let o;
    if (r.size)
      r.delete(o = Array.from(r).shift());
    else if (o = ai(n), o >= ao || !li(n, o + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / xs),
      provider: i.provider,
      data: t
    };
    return $i(
      n,
      ee + o.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !uo(i, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e("local") || e("session"));
}
function Cn() {
}
function fo(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = !0, setTimeout(() => {
    i.iconsLoaderFlag = !1, Zr(i);
  }));
}
function po(i, t) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(t).sort() : i.iconsToLoad = t, i.iconsQueueFlag || (i.iconsQueueFlag = !0, setTimeout(() => {
    i.iconsQueueFlag = !1;
    const { provider: e, prefix: s } = i, n = i.iconsToLoad;
    delete i.iconsToLoad;
    let r;
    if (!n || !(r = ri(e)))
      return;
    r.prepare(e, s, n).forEach((a) => {
      ys(e, a, (l) => {
        if (typeof l != "object")
          a.icons.forEach((c) => {
            i.missing.add(c);
          });
        else
          try {
            const c = xi(
              i,
              l
            );
            if (!c.length)
              return;
            const u = i.pendingIcons;
            u && c.forEach((h) => {
              u.delete(h);
            }), ho(i, l);
          } catch (c) {
            console.error(c);
          }
        fo(i);
      });
    });
  }));
}
const Ei = (i, t) => {
  const e = io(i, !0, ms()), s = Kr(e);
  if (!s.pending.length) {
    let l = !0;
    return t && setTimeout(() => {
      l && t(
        s.loaded,
        s.missing,
        s.pending,
        Cn
      );
    }), () => {
      l = !1;
    };
  }
  const n = /* @__PURE__ */ Object.create(null), r = [];
  let o, a;
  return s.pending.forEach((l) => {
    const { provider: c, prefix: u } = l;
    if (u === a && c === o)
      return;
    o = c, a = u, r.push(lt(c, u));
    const h = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
    h[u] || (h[u] = []);
  }), s.pending.forEach((l) => {
    const { provider: c, prefix: u, name: h } = l, f = lt(c, u), p = f.pendingIcons || (f.pendingIcons = /* @__PURE__ */ new Set());
    p.has(h) || (p.add(h), n[c][u].push(h));
  }), r.forEach((l) => {
    const { provider: c, prefix: u } = l;
    n[c][u].length && po(l, n[c][u]);
  }), t ? eo(t, s, r) : Cn;
}, mo = (i) => new Promise((t, e) => {
  const s = typeof i == "string" ? ce(i, !0) : i;
  if (!s) {
    e(i);
    return;
  }
  Ei([s || i], (n) => {
    if (n.length && s) {
      const r = te(s);
      if (r) {
        t({
          ...ae,
          ...r
        });
        return;
      }
    }
    e(i);
  });
});
function bo(i) {
  try {
    const t = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof t.body == "string")
      return {
        ...t
      };
  } catch {
  }
}
function go(i, t) {
  const e = typeof i == "string" ? ce(i, !0, !0) : null;
  if (!e) {
    const r = bo(i);
    return {
      value: i,
      data: r
    };
  }
  const s = te(e);
  if (s !== void 0 || !e.prefix)
    return {
      value: i,
      name: e,
      data: s
      // could be 'null' -> icon is missing
    };
  const n = Ei([e], () => t(i, e, te(e)));
  return {
    value: i,
    name: e,
    loading: n
  };
}
function Ze(i) {
  return i.hasAttribute("inline");
}
let As = !1;
try {
  As = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function vo(i, t) {
  switch (t) {
    case "svg":
    case "bg":
    case "mask":
      return t;
  }
  return t !== "style" && (As || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
const yo = /(-?[0-9.]*[0-9]+[0-9.]*)/g, _o = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function ci(i, t, e) {
  if (t === 1)
    return i;
  if (e = e || 100, typeof i == "number")
    return Math.ceil(i * t * e) / e;
  if (typeof i != "string")
    return i;
  const s = i.split(yo);
  if (s === null || !s.length)
    return i;
  const n = [];
  let r = s.shift(), o = _o.test(r);
  for (; ; ) {
    if (o) {
      const a = parseFloat(r);
      isNaN(a) ? n.push(r) : n.push(Math.ceil(a * t * e) / e);
    } else
      n.push(r);
    if (r = s.shift(), r === void 0)
      return n.join("");
    o = !o;
  }
}
function xo(i, t = "defs") {
  let e = "";
  const s = i.indexOf("<" + t);
  for (; s >= 0; ) {
    const n = i.indexOf(">", s), r = i.indexOf("</" + t);
    if (n === -1 || r === -1)
      break;
    const o = i.indexOf(">", r);
    if (o === -1)
      break;
    e += i.slice(n + 1, r).trim(), i = i.slice(0, s).trim() + i.slice(o + 1);
  }
  return {
    defs: e,
    content: i
  };
}
function wo(i, t) {
  return i ? "<defs>" + i + "</defs>" + t : t;
}
function $o(i, t, e) {
  const s = xo(i);
  return wo(s.defs, t + s.content + e);
}
const Co = (i) => i === "unset" || i === "undefined" || i === "none";
function Ss(i, t) {
  const e = {
    ...ae,
    ...i
  }, s = {
    ...hs,
    ...t
  }, n = {
    left: e.left,
    top: e.top,
    width: e.width,
    height: e.height
  };
  let r = e.body;
  [e, s].forEach((v) => {
    const g = [], A = v.hFlip, E = v.vFlip;
    let x = v.rotate;
    A ? E ? x += 2 : (g.push(
      "translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"
    ), g.push("scale(-1 1)"), n.top = n.left = 0) : E && (g.push(
      "translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"
    ), g.push("scale(1 -1)"), n.top = n.left = 0);
    let $;
    switch (x < 0 && (x -= Math.floor(x / 4) * 4), x = x % 4, x) {
      case 1:
        $ = n.height / 2 + n.top, g.unshift(
          "rotate(90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
      case 2:
        g.unshift(
          "rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")"
        );
        break;
      case 3:
        $ = n.width / 2 + n.left, g.unshift(
          "rotate(-90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
    }
    x % 2 === 1 && (n.left !== n.top && ($ = n.left, n.left = n.top, n.top = $), n.width !== n.height && ($ = n.width, n.width = n.height, n.height = $)), g.length && (r = $o(
      r,
      '<g transform="' + g.join(" ") + '">',
      "</g>"
    ));
  });
  const o = s.width, a = s.height, l = n.width, c = n.height;
  let u, h;
  o === null ? (h = a === null ? "1em" : a === "auto" ? c : a, u = ci(h, l / c)) : (u = o === "auto" ? l : o, h = a === null ? ci(u, c / l) : a === "auto" ? c : a);
  const f = {}, p = (v, g) => {
    Co(g) || (f[v] = g.toString());
  };
  p("width", u), p("height", h);
  const b = [n.left, n.top, l, c];
  return f.viewBox = b.join(" "), {
    attributes: f,
    viewBox: b,
    body: r
  };
}
function Ai(i, t) {
  let e = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const s in t)
    e += " " + s + '="' + t[s] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + e + ">" + i + "</svg>";
}
function Eo(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Ao(i) {
  return "data:image/svg+xml," + Eo(i);
}
function Os(i) {
  return 'url("' + Ao(i) + '")';
}
const So = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
let Se = So();
function Oo(i) {
  Se = i;
}
function ko() {
  return Se;
}
function Po(i, t) {
  const e = He(i);
  if (!e)
    return 0;
  let s;
  if (!e.maxURL)
    s = 0;
  else {
    let n = 0;
    e.resources.forEach((o) => {
      n = Math.max(n, o.length);
    });
    const r = t + ".json?icons=";
    s = e.maxURL - n - e.path.length - r.length;
  }
  return s;
}
function To(i) {
  return i === 404;
}
const Lo = (i, t, e) => {
  const s = [], n = Po(i, t), r = "icons";
  let o = {
    type: r,
    provider: i,
    prefix: t,
    icons: []
  }, a = 0;
  return e.forEach((l, c) => {
    a += l.length + 1, a >= n && c > 0 && (s.push(o), o = {
      type: r,
      provider: i,
      prefix: t,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), s.push(o), s;
};
function Io(i) {
  if (typeof i == "string") {
    const t = He(i);
    if (t)
      return t.path;
  }
  return "/";
}
const zo = (i, t, e) => {
  if (!Se) {
    e("abort", 424);
    return;
  }
  let s = Io(t.provider);
  switch (t.type) {
    case "icons": {
      const r = t.prefix, a = t.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      s += r + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const r = t.uri;
      s += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      e("abort", 400);
      return;
  }
  let n = 503;
  Se(i + s).then((r) => {
    const o = r.status;
    if (o !== 200) {
      setTimeout(() => {
        e(To(o) ? "abort" : "next", o);
      });
      return;
    }
    return n = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? e("abort", r) : e("next", n);
      });
      return;
    }
    setTimeout(() => {
      e("success", r);
    });
  }).catch(() => {
    e("next", n);
  });
}, Ro = {
  prepare: Lo,
  send: zo
};
function En(i, t) {
  switch (i) {
    case "local":
    case "session":
      wt[i] = t;
      break;
    case "all":
      for (const e in wt)
        wt[e] = t;
      break;
  }
}
const ti = "data-style";
let ks = "";
function Mo(i) {
  ks = i;
}
function An(i, t) {
  let e = Array.from(i.childNodes).find((s) => s.hasAttribute && s.hasAttribute(ti));
  e || (e = document.createElement("style"), e.setAttribute(ti, ti), i.appendChild(e)), e.textContent = ":host{display:inline-block;vertical-align:" + (t ? "-0.125em" : "0") + "}span,svg{display:block}" + ks;
}
function Ps() {
  vn("", Ro), ms(!0);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (Es(), i.IconifyPreload !== void 0) {
      const e = i.IconifyPreload, s = "Invalid IconifyPreload syntax.";
      typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((n) => {
        try {
          // Check if item is an object and not null/array
          (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
          typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
          !bn(n)) && console.error(s);
        } catch {
          console.error(s);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const e = i.IconifyProviders;
      if (typeof e == "object" && e !== null)
        for (const s in e) {
          const n = "IconifyProviders[" + s + "] is invalid.";
          try {
            const r = e[s];
            if (typeof r != "object" || !r || r.resources === void 0)
              continue;
            yn(s, r) || console.error(n);
          } catch {
            console.error(n);
          }
        }
    }
  }
  return {
    enableCache: (e) => En(e, !0),
    disableCache: (e) => En(e, !1),
    iconLoaded: gn,
    iconExists: gn,
    getIcon: Jr,
    listIcons: Xr,
    addIcon: bs,
    addCollection: bn,
    calculateSize: ci,
    buildIcon: Ss,
    iconToHTML: Ai,
    svgToURL: Os,
    loadIcons: Ei,
    loadIcon: mo,
    addAPIProvider: yn,
    appendCustomStyle: Mo,
    _api: {
      getAPIConfig: He,
      setAPIModule: vn,
      sendAPIQuery: ys,
      setFetch: Oo,
      getFetch: ko,
      listAPIProviders: ro
    }
  };
}
const ui = {
  "background-color": "currentColor"
}, Ts = {
  "background-color": "transparent"
}, Sn = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
}, On = {
  "-webkit-mask": ui,
  mask: ui,
  background: Ts
};
for (const i in On) {
  const t = On[i];
  for (const e in Sn)
    t[i + "-" + e] = Sn[e];
}
function kn(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function jo(i, t, e) {
  const s = document.createElement("span");
  let n = i.body;
  n.indexOf("<a") !== -1 && (n += "<!-- " + Date.now() + " -->");
  const r = i.attributes, o = Ai(n, {
    ...r,
    width: t.width + "",
    height: t.height + ""
  }), a = Os(o), l = s.style, c = {
    "--svg": a,
    width: kn(r.width),
    height: kn(r.height),
    ...e ? ui : Ts
  };
  for (const u in c)
    l.setProperty(u, c[u]);
  return s;
}
let Yt;
function Bo() {
  try {
    Yt = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    Yt = null;
  }
}
function No(i) {
  return Yt === void 0 && Bo(), Yt ? Yt.createHTML(i) : i;
}
function Ho(i) {
  const t = document.createElement("span"), e = i.attributes;
  let s = "";
  e.width || (s = "width: inherit;"), e.height || (s += "height: inherit;"), s && (e.style = s);
  const n = Ai(i.body, e);
  return t.innerHTML = No(n), t.firstChild;
}
function hi(i) {
  return Array.from(i.childNodes).find((t) => {
    const e = t.tagName && t.tagName.toUpperCase();
    return e === "SPAN" || e === "SVG";
  });
}
function Pn(i, t) {
  const e = t.icon.data, s = t.customisations, n = Ss(e, s);
  s.preserveAspectRatio && (n.attributes.preserveAspectRatio = s.preserveAspectRatio);
  const r = t.renderedMode;
  let o;
  switch (r) {
    case "svg":
      o = Ho(n);
      break;
    default:
      o = jo(n, {
        ...ae,
        ...e
      }, r === "mask");
  }
  const a = hi(i);
  a ? o.tagName === "SPAN" && a.tagName === o.tagName ? a.setAttribute("style", o.getAttribute("style")) : i.replaceChild(o, a) : i.appendChild(o);
}
function Tn(i, t, e) {
  const s = e && (e.rendered ? e : e.lastRender);
  return {
    rendered: !1,
    inline: t,
    icon: i,
    lastRender: s
  };
}
function Do(i = "iconify-icon") {
  let t, e;
  try {
    t = window.customElements, e = window.HTMLElement;
  } catch {
    return;
  }
  if (!t || !e)
    return;
  const s = t.get(i);
  if (s)
    return s;
  const n = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "observe",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], r = class extends e {
    /**
     * Constructor
     */
    constructor() {
      super();
      // Root
      tt(this, "_shadowRoot");
      // Initialised
      tt(this, "_initialised", !1);
      // Icon state
      tt(this, "_state");
      // Attributes check queued
      tt(this, "_checkQueued", !1);
      // Connected
      tt(this, "_connected", !1);
      // Observer
      tt(this, "_observer", null);
      tt(this, "_visible", !0);
      const l = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), c = Ze(this);
      An(l, c), this._state = Tn({
        value: ""
      }, c), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = !0, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = !1, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return n.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(l) {
      switch (l) {
        case "inline": {
          const c = Ze(this), u = this._state;
          c !== u.inline && (u.inline = c, An(this._shadowRoot, c));
          break;
        }
        case "observer": {
          this.observer ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const l = this.getAttribute("icon");
      if (l && l.slice(0, 1) === "{")
        try {
          return JSON.parse(l);
        } catch {
        }
      return l;
    }
    set icon(l) {
      typeof l == "object" && (l = JSON.stringify(l)), this.setAttribute("icon", l);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return Ze(this);
    }
    set inline(l) {
      l ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(l) {
      l ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const l = this._state;
      if (l.rendered) {
        const c = this._shadowRoot;
        if (l.renderedMode === "svg")
          try {
            c.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        Pn(c, l);
      }
    }
    /**
     * Get status
     */
    get status() {
      const l = this._state;
      return l.rendered ? "rendered" : l.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = !0, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = !1;
      const l = this._state, c = this.getAttribute("icon");
      if (c !== l.icon.value) {
        this._iconChanged(c);
        return;
      }
      if (!l.rendered || !this._visible)
        return;
      const u = this.getAttribute("mode"), h = pn(this);
      (l.attrMode !== u || Vr(l.customisations, h) || !hi(this._shadowRoot)) && this._renderIcon(l.icon, h, u);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(l) {
      const c = go(l, (u, h, f) => {
        const p = this._state;
        if (p.rendered || this.getAttribute("icon") !== u)
          return;
        const b = {
          value: u,
          name: h,
          data: f
        };
        b.data ? this._gotIconData(b) : p.icon = b;
      });
      c.data ? this._gotIconData(c) : this._state = Tn(c, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const l = hi(this._shadowRoot);
        l && this._shadowRoot.removeChild(l);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(l) {
      this._checkQueued = !1, this._renderIcon(l, pn(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(l, c, u) {
      const h = vo(l.data.body, u), f = this._state.inline;
      Pn(this._shadowRoot, this._state = {
        rendered: !0,
        icon: l,
        inline: f,
        customisations: c,
        attrMode: u,
        renderedMode: h
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer)
        try {
          this._observer = new IntersectionObserver((l) => {
            const c = l.some((u) => u.isIntersecting);
            c !== this._visible && (this._visible = c, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = !0, this._connected && this._forceRender());
    }
  };
  n.forEach((a) => {
    a in r.prototype || Object.defineProperty(r.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const o = Ps();
  for (const a in o)
    r[a] = r.prototype[a] = o[a];
  return t.define(i, r), r;
}
Do() || Ps();
var Fo = Object.defineProperty, U = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Fo(t, e, n), n;
}, Bt;
const H = (Bt = class extends w {
  constructor() {
    super(), this.labelHidden = !1, this.active = !1, this.disabled = !1, this.vertical = !1, this.tooltipVisible = !1, this._parent = nt(), this._tooltip = nt(), this._contextMenu = nt(), this._mouseLeave = !1, this.onWindowMouseUp = (t) => {
      const { value: e } = this._contextMenu;
      !this.contains(t.target) && e && (e.visible = !1);
    }, this.mouseLeave = !0, this.addEventListener("click", (t) => t.stopPropagation());
  }
  set mouseLeave(t) {
    this._mouseLeave = t, t && (this.tooltipVisible = !1, clearTimeout(this.timeoutID));
  }
  get mouseLeave() {
    return this._mouseLeave;
  }
  computeTooltipPosition() {
    const { value: t } = this._parent, { value: e } = this._tooltip;
    t && e && Zn(t, e, {
      placement: "bottom",
      middleware: [Hn(10), Kn(), Jn(), Xn({ padding: 5 })]
    }).then((s) => {
      const { x: n, y: r } = s;
      Object.assign(e.style, {
        left: `${n}px`,
        top: `${r}px`
      });
    });
  }
  onMouseEnter() {
    if (!(this.tooltipTitle || this.tooltipText))
      return;
    this.mouseLeave = !1;
    const t = this.tooltipTime ?? 700;
    this.timeoutID = setTimeout(() => {
      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = !0);
    }, t);
  }
  onChildrenClick(t) {
    t.stopPropagation();
    const { value: e } = this._contextMenu;
    e && (e.visible = !e.visible);
  }
  onSlotChange(t) {
    const { value: e } = this._contextMenu, s = t.target.assignedElements();
    for (const n of s) {
      if (!(n instanceof Bt)) {
        n.remove(), console.warn(
          "Only bim-button is allowed inside bim-button. Child has been removed."
        );
        continue;
      }
      n.addEventListener("click", () => e == null ? void 0 : e.updatePosition());
    }
    this.requestUpdate();
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("mouseup", this.onWindowMouseUp);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("mouseup", this.onWindowMouseUp);
  }
  render() {
    const t = m`
      <div ${st(this._tooltip)} class="tooltip">
        ${this.tooltipTitle ? m`<p style="text-wrap: nowrap;">
              <strong>${this.tooltipTitle}</strong>
            </p>` : null}
        ${this.tooltipText ? m`<p style="width: 9rem;">${this.tooltipText}</p>` : null}
      </div>
    `, e = this.children.length > 0;
    return m`
      <style>
        .button {
          border-radius: var(
            --bim-button--bdrs,
            ${e ? "var(--bim-ui_size-4xs) 0 0 var(--bim-ui_size-4xs)" : "var(--bim-ui_size-4xs)"}
          );
        }
        .children {
          border-radius: var(
            --bim-button--bdrs,
            ${e ? "0 var(--bim-ui_size-4xs) var(--bim-ui_size-4xs) 0" : "var(--bim-ui_size-4xs)"}
          );
        }
      </style>
      <div ${st(this._parent)} class="parent">
        ${this.label || this.icon ? m`
              <div
                class="button"
                @mouseenter=${this.onMouseEnter}
                @mouseleave=${() => this.mouseLeave = !0}
              >
                <bim-label
                  .icon=${this.icon}
                  .vertical=${this.vertical}
                  .labelHidden=${this.labelHidden}
                  >${this.label}</bim-label
                >
              </div>
            ` : null}
        ${this.tooltipTitle || this.tooltipText ? t : null}
        ${e ? m`
              <div class="children" @click=${this.onChildrenClick}>
                <bim-icon .icon=${"ic:round-plus"}></bim-icon>
              </div>
            ` : null}
        <bim-context-menu
          ${st(this._contextMenu)}
          style="row-gap: var(--bim-ui_size-4xs)"
        >
          <slot @slotchange=${this.onSlotChange}></slot>
        </bim-context-menu>
      </div>
    `;
  }
}, Bt.styles = C`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      flex: 1;
      pointer-events: none;
    }

    :host(:not([disabled]):hover) {
      cursor: pointer;
    }

    bim-label {
      pointer-events: none;
    }

    .parent {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-icon--c: var(--bim-label--c);
      display: flex;
      height: 100%;
      user-select: none;
      row-gap: 0.125rem;
      column-gap: 0.125rem;
    }

    .button,
    .children {
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      min-height: var(--bim-ui_size-5xl);
      min-width: var(--bim-ui_size-5xl);
      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));
      outline: var(--bim-button--olw) solid var(--bim-button--olc);
    }

    .button {
      flex-grow: 1;
    }

    :host(:not([label-hidden])[label]) .button {
      justify-content: var(--bim-button--jc, center);
    }

    :host(:hover) .button,
    :host(:hover) .children {
      --bim-label--c: var(--bim-ui_main-contrast);
      --bim-icon--c: var(--bim-ui_main-contrast);
      fill: white;
      background-color: var(--bim-ui_main-base);
    }

    :host(:not([label]):not([icon])) .children {
      flex: 1;
    }

    :host([active]) .button {
      --bim-label--c: var(--bim-ui_main-contrast);
      --bim-icon--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }

    :host([vertical]) .parent {
      justify-content: center;
    }

    :host(:not([label-hidden])[label]) .button {
      padding: 0 0.5rem;
    }

    :host([disabled]) .parent {
      background-color: gray;
    }

    .children {
      --bim-icon--fz: var(--bim-ui_size-base);
      padding: 0 0.125rem;
    }

    ::slotted(bim-button) {
      --bim-icon--fz: var(--bim-ui_size-base);
      --bim-button--bgc: var(
        --bim-context-menu--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-button--bdrs: var(--bim-ui_size-4xs);
      --bim-button--olw: 0;
      --bim-button--olc: transparent;
    }

    .tooltip {
      position: absolute;
      padding: 0.75rem;
      z-index: 99;
      display: flex;
      flex-flow: column;
      row-gap: 0.375rem;
      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);
      outline: 1px solid var(--bim-ui_bg-contrast-40);
      font-size: var(--bim-ui_size-xs);
      border-radius: var(--bim-ui_size-4xs);
      background-color: var(--bim-ui_bg-contrast-20);
      color: var(--bim-ui_bg-contrast-100);
    }

    .tooltip p {
      margin: 0;
      padding: 0;
    }

    :host(:not([tooltip-visible])) .tooltip {
      display: none;
    }
  `, Bt);
U([
  d({ type: String, reflect: !0 })
], H.prototype, "label");
U([
  d({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], H.prototype, "labelHidden");
U([
  d({ type: Boolean, reflect: !0 })
], H.prototype, "active");
U([
  d({ type: Boolean, reflect: !0, attribute: "disabled" })
], H.prototype, "disabled");
U([
  d({ type: String, reflect: !0 })
], H.prototype, "icon");
U([
  d({ type: Boolean, reflect: !0 })
], H.prototype, "vertical");
U([
  d({ type: Number, attribute: "tooltip-time", reflect: !0 })
], H.prototype, "tooltipTime");
U([
  d({ type: Boolean, attribute: "tooltip-visible", reflect: !0 })
], H.prototype, "tooltipVisible");
U([
  d({ type: String, attribute: "tooltip-title", reflect: !0 })
], H.prototype, "tooltipTitle");
U([
  d({ type: String, attribute: "tooltip-text", reflect: !0 })
], H.prototype, "tooltipText");
let Vo = H;
var Uo = Object.defineProperty, ue = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Uo(t, e, n), n;
};
const Oi = class Oi extends w {
  constructor() {
    super(...arguments), this.checked = !1, this.inverted = !1, this.onValueChange = new Event("change");
  }
  /**
   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.
   * @type {boolean}
   * @default false
   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\/script>
   * @example
   * const checkbox = document.createElement('bim-checkbox');
   * document.body.appendChild(checkbox);
   * console.log(checkbox.value); // false initially
   */
  get value() {
    return this.checked;
  }
  onChange(t) {
    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);
  }
  render() {
    return m`
      <div class="parent">
        ${this.label ? m`<bim-label .icon="${this.icon}">${this.label}</bim-label> ` : null}
        <input
          type="checkbox"
          aria-label=${this.label || this.name || "Checkbox Input"}
          @change="${this.onChange}"
          .checked="${this.checked}"
        />
      </div>
    `;
  }
};
Oi.styles = C`
    :host {
      display: block;
    }

    .parent {
      display: flex;
      justify-content: space-between;
      height: 1.75rem;
      column-gap: 0.5rem;
      width: 100%;
      align-items: center;
    }

    :host([inverted]) .parent {
      flex-direction: row-reverse;
      justify-content: start;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }
  `;
let at = Oi;
ue([
  d({ type: String, reflect: !0 })
], at.prototype, "icon");
ue([
  d({ type: String, reflect: !0 })
], at.prototype, "name");
ue([
  d({ type: String, reflect: !0 })
], at.prototype, "label");
ue([
  d({ type: Boolean, reflect: !0 })
], at.prototype, "checked");
ue([
  d({ type: Boolean, reflect: !0 })
], at.prototype, "inverted");
var qo = Object.defineProperty, Nt = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && qo(t, e, n), n;
};
const ki = class ki extends w {
  constructor() {
    super(...arguments), this.vertical = !1, this.color = "#bcf124", this._colorInput = nt(), this._textInput = nt(), this.onValueChange = new Event("input"), this.onOpacityInput = (t) => {
      const e = t.target;
      this.opacity = e.value, this.dispatchEvent(this.onValueChange);
    };
  }
  /**
   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.
   * @type {Object}
   * @example
   * const colorInput = document.createElement('bim-color-input');
   * colorInput.value = { color: '#ff0000', opacity: 0.5 };
   */
  set value(t) {
    const { color: e, opacity: s } = t;
    this.color = e, s && (this.opacity = s);
  }
  get value() {
    const t = {
      color: this.color
    };
    return this.opacity && (t.opacity = this.opacity), t;
  }
  onColorInput(t) {
    t.stopPropagation();
    const { value: e } = this._colorInput;
    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  onTextInput(t) {
    t.stopPropagation();
    const { value: e } = this._textInput;
    if (!e)
      return;
    const { value: s } = e;
    let n = s.replace(/[^a-fA-F0-9]/g, "");
    n.startsWith("#") || (n = `#${n}`), e.value = n.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  /**
   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.
   * If the color input element is not available, the function does nothing.
   */
  focus() {
    const { value: t } = this._colorInput;
    t && t.click();
  }
  render() {
    return m`
      <div class="parent">
        <bim-input
          .label=${this.label}
          .icon=${this.icon}
          .vertical="${this.vertical}"
        >
          <div class="color-container">
            <div
              style="display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;"
            >
              <input
                ${st(this._colorInput)}
                @input="${this.onColorInput}"
                type="color"
                aria-label=${this.label || this.name || "Color Input"}
                value="${this.color}"
              />
              <div
                @click=${this.focus}
                class="sample"
                style="background-color: ${this.color}"
              ></div>
              <input
                ${st(this._textInput)}
                @input="${this.onTextInput}"
                value="${this.color}"
                type="text"
                aria-label=${this.label || this.name || "Text Color Input"}
              />
            </div>
            ${this.opacity !== void 0 ? m`<bim-number-input
                  @change=${this.onOpacityInput}
                  slider
                  suffix="%"
                  min="0"
                  value=${this.opacity}
                  max="100"
                ></bim-number-input>` : null}
          </div>
        </bim-input>
      </div>
    `;
  }
};
ki.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    .parent {
      display: flex;
      gap: 0.375rem;
    }

    .color-container {
      position: relative;
      outline: none;
      display: flex;
      height: 100%;
      gap: 0.5rem;
      justify-content: flex-start;
      align-items: center;
      flex: 1;
      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));
    }

    .color-container input[type="color"] {
      position: absolute;
      bottom: -0.25rem;
      visibility: hidden;
      width: 0;
      height: 0;
    }

    .color-container .sample {
      width: 1rem;
      height: 1rem;
      border-radius: 0.125rem;
      background-color: #fff;
    }

    .color-container input[type="text"] {
      height: 100%;
      flex: 1;
      width: 3.25rem;
      text-transform: uppercase;
      font-size: 0.75rem;
      background-color: transparent;
      padding: 0%;
      outline: none;
      border: none;
      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));
    }

    bim-number-input {
      flex-grow: 0;
    }
  `;
let X = ki;
Nt([
  d({ type: String, reflect: !0 })
], X.prototype, "name");
Nt([
  d({ type: String, reflect: !0 })
], X.prototype, "label");
Nt([
  d({ type: String, reflect: !0 })
], X.prototype, "icon");
Nt([
  d({ type: Boolean, reflect: !0 })
], X.prototype, "vertical");
Nt([
  d({ type: Number, reflect: !0 })
], X.prototype, "opacity");
Nt([
  d({ type: String, reflect: !0 })
], X.prototype, "color");
const Wo = C`
  ::-webkit-scrollbar {
    width: 0.4rem;
    height: 0.4rem;
    overflow: hidden;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 0.25rem;
    background-color: var(
      --bim-scrollbar--c,
      color-mix(in lab, var(--bim-ui_main-base), white 15%)
    );
  }

  ::-webkit-scrollbar-track {
    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));
  }
`, Qo = C`
  :root {
    /* Grayscale Colors */
    --bim-ui_gray-0: hsl(210 10% 5%);
    --bim-ui_gray-1: hsl(210 10% 10%);
    --bim-ui_gray-2: hsl(210 10% 20%);
    --bim-ui_gray-4: hsl(210 10% 40%);
    --bim-ui_gray-6: hsl(210 10% 60%);
    --bim-ui_gray-8: hsl(210 10% 80%);
    --bim-ui_gray-9: hsl(210 10% 90%);
    --bim-ui_gray-10: hsl(210 10% 95%);

    /* Brand Colors */
    --bim-ui_main-base: #6528d7;
    --bim-ui_accent-base: #bcf124;

    /* Brand Colors Contrasts */
    --bim-ui_main-contrast: var(--bim-ui_gray-10);
    --bim-ui_accent-contrast: var(--bim-ui_gray-0);

    /* Sizes */
    --bim-ui_size-4xs: 0.375rem;
    --bim-ui_size-3xs: 0.5rem;
    --bim-ui_size-2xs: 0.625rem;
    --bim-ui_size-xs: 0.75rem;
    --bim-ui_size-sm: 0.875rem;
    --bim-ui_size-base: 1rem;
    --bim-ui_size-lg: 1.125rem;
    --bim-ui_size-xl: 1.25rem;
    --bim-ui_size-2xl: 1.375rem;
    --bim-ui_size-3xl: 1.5rem;
    --bim-ui_size-4xl: 1.625rem;
    --bim-ui_size-5xl: 1.75rem;
    --bim-ui_size-6xl: 1.875rem;
    --bim-ui_size-7xl: 2rem;
    --bim-ui_size-8xl: 2.125rem;
    --bim-ui_size-9xl: 2.25rem;
  }

  /* Background Colors */
  @media (prefers-color-scheme: dark) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-0);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-10);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
      --bim-ui_accent-base: #6528d7;
    }
  }

  html.bim-ui-dark {
    --bim-ui_bg-base: var(--bim-ui_gray-0);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
  }

  html.bim-ui-light {
    --bim-ui_bg-base: var(--bim-ui_gray-10);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
    --bim-ui_accent-base: #6528d7;
  }
`, At = {
  scrollbar: Wo,
  globalStyles: Qo
};
var Yo = Object.defineProperty, Go = Object.getOwnPropertyDescriptor, Xo = (i, t, e, s) => {
  for (var n = Go(t, e), r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Yo(t, e, n), n;
};
const Pi = class Pi extends w {
  constructor() {
    super(...arguments), this._visible = !1, this._middleware = {
      name: "middleware",
      async fn(t) {
        const { right: e, top: s } = await mi(t);
        return t.x -= Math.sign(e) === 1 ? e + 5 : 0, t.y -= Math.sign(s) === 1 ? s + 5 : 0, t;
      }
    };
  }
  get visible() {
    return this._visible;
  }
  set visible(t) {
    this._visible = t, t && this.updatePosition();
  }
  /**
   * Asynchronously updates the position of the context menu relative to a target element.
   * If no target element is provided, it attempts to use the parent node as the target.
   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,
   * which considers various adjustments like offset, inline positioning, flipping, and shifting
   * to ensure the context menu is properly placed relative to the target element.
   *
   * @param [target] - The target element relative to which the context menu should be positioned.
   *                                 If not provided, the parent node is used as the target.
   * @returns A promise that resolves once the position has been updated. This method
   *                          does not explicitly return a value but updates the context menu's style
   *                          properties to position it on the screen.
   */
  async updatePosition(t) {
    const e = t || this.parentNode;
    if (!e) {
      this.visible = !1, console.warn("No target element found for context-menu.");
      return;
    }
    const s = await Zn(e, this, {
      placement: "right",
      middleware: [
        Hn(10),
        Kn(),
        Jn(),
        Xn({ padding: 5 }),
        this._middleware
      ]
    }), { x: n, y: r } = s;
    this.style.left = `${n}px`, this.style.top = `${r}px`;
  }
  render() {
    return m` <slot></slot> `;
  }
};
Pi.styles = [
  At.scrollbar,
  C`
      :host {
        --bim-label--fz: var(--bim-ui_size-xs);
        position: absolute;
        top: 0;
        left: 0;
        z-index: 999;
        overflow: auto;
        max-height: 20rem;
        min-width: 3rem;
        flex-direction: column;
        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        border-radius: var(--bim-ui_size-4xs);
        background-color: var(
          --bim-context-menu--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      :host([visible]) {
        display: flex;
      }

      :host(:not([visible])) {
        display: none;
      }
    `
];
let Oe = Pi;
Xo([
  d({ type: Boolean, reflect: !0 })
], Oe.prototype, "visible");
class Jo extends w {
  constructor() {
    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = !1, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {
      if (!this.useObserver)
        return;
      for (const s of t)
        this.elements.add(s);
      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);
      for (const s of e)
        s.remove();
      this.observeLastElement();
    };
  }
  set visibleElements(t) {
    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();
  }
  get visibleElements() {
    return this._visibleElements;
  }
  getLazyObserver() {
    if (!this.useObserver)
      return null;
    if (this._lazyLoadObserver)
      return this._lazyLoadObserver;
    const t = new IntersectionObserver(
      (e) => {
        const s = e[0];
        if (!s.isIntersecting)
          return;
        const n = s.target;
        t.unobserve(n);
        const r = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, o = [...this.elements][r];
        o && (this.visibleElements = [...this.visibleElements, o], t.observe(o));
      },
      { threshold: 0.5 }
    );
    return t;
  }
  observeLastElement() {
    const t = this.getLazyObserver();
    if (!t)
      return;
    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, s = [...this.elements][e];
    s && t.observe(s);
  }
  resetVisibleElements() {
    const t = this.getLazyObserver();
    if (t) {
      for (const e of this.elements)
        t.unobserve(e);
      this.visibleElements = [], this.observeLastElement();
    }
  }
  /**
   * Creates a new UI component instance based on the provided template and initial state.
   *
   * @template T - The type of the UI component element.
   * @template S - The type of the component state.
   *
   * @param template - The component template function (stateless or stateful).
   * @param initialState - The initial state of the component (optional for stateless components).
   * @returns The created UI component element or an array containing the element and a function to update its state.
   */
  static create(t, e) {
    const s = document.createDocumentFragment();
    if (t.length === 0)
      return Rt(t(), s), s.firstElementChild;
    if (!e)
      throw new Error(
        "UIComponent: Initial state is required for statefull components."
      );
    let n = e;
    const r = t, o = (l) => (n = { ...n, ...l }, Rt(r(n), s), n);
    return o(e), [s.firstElementChild, o];
  }
}
const ke = (i, t = !0) => {
  let e = {};
  for (const s of i.children) {
    const n = s, r = n.getAttribute("name") || n.getAttribute("label");
    if (r) {
      if ("value" in n) {
        const o = n.value;
        if (typeof o == "object" && !Array.isArray(o) && Object.keys(o).length === 0)
          continue;
        e[r] = n.value;
      } else if (t) {
        const o = ke(n);
        if (Object.keys(o).length === 0)
          continue;
        e[r] = o;
      }
    } else
      t && (e = { ...e, ...ke(n) });
  }
  return e;
}, De = (i) => i === "true" || i === "false" ? i === "true" : i && !isNaN(Number(i)) && i.trim() !== "" ? Number(i) : i, Ko = [">=", "<=", "=", ">", "<", "?", "/", "#"];
function Ln(i) {
  const t = Ko.find(
    (a) => i.split(a).length === 2
  ), e = i.split(t).map((a) => a.trim()), [s, n] = e, r = n.startsWith("'") && n.endsWith("'") ? n.replace(/'/g, "") : De(n);
  return { key: s, condition: t, value: r };
}
const di = (i) => {
  try {
    const t = [], e = i.split(/&(?![^()]*\))/).map((s) => s.trim());
    for (const s of e) {
      const n = !s.startsWith("(") && !s.endsWith(")"), r = s.startsWith("(") && s.endsWith(")");
      if (n) {
        const o = Ln(s);
        t.push(o);
      }
      if (r) {
        const c = {
          operator: "&",
          queries: s.replace(/^(\()|(\))$/g, "").split("&").map((u) => u.trim()).map((u, h) => {
            const f = Ln(u);
            return h > 0 && (f.operator = "&"), f;
          })
        };
        t.push(c);
      }
    }
    return t;
  } catch {
    return null;
  }
}, In = (i, t, e) => {
  let s = !1;
  switch (t) {
    case "=":
      s = i === e;
      break;
    case "?":
      s = String(i).includes(String(e));
      break;
    case "<":
      (typeof i == "number" || typeof e == "number") && (s = i < e);
      break;
    case "<=":
      (typeof i == "number" || typeof e == "number") && (s = i <= e);
      break;
    case ">":
      (typeof i == "number" || typeof e == "number") && (s = i > e);
      break;
    case ">=":
      (typeof i == "number" || typeof e == "number") && (s = i >= e);
      break;
    case "/":
      s = String(i).startsWith(String(e));
      break;
  }
  return s;
};
var Zo = Object.defineProperty, tl = Object.getOwnPropertyDescriptor, bt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? tl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Zo(t, e, n), n;
};
const Ti = class Ti extends w {
  constructor() {
    super(...arguments), this.checked = !1, this.checkbox = !1, this.noMark = !1, this.vertical = !1;
  }
  get value() {
    return this._value !== void 0 ? this._value : this.label ? De(this.label) : this.label;
  }
  set value(t) {
    this._value = t;
  }
  render() {
    return m`
      <div class="parent" .title=${this.label ?? ""}>
        ${this.img || this.icon || this.label ? m` <div style="display: flex; column-gap: 0.375rem">
              ${this.checkbox && !this.noMark ? m`<bim-checkbox
                    style="pointer-events: none"
                    .checked=${this.checked}
                  ></bim-checkbox>` : null}
              <bim-label
                .vertical=${this.vertical}
                .icon=${this.icon}
                .img=${this.img}
                >${this.label}</bim-label
              >
            </div>` : null}
        ${!this.checkbox && !this.noMark && this.checked ? m`<svg
              xmlns="http://www.w3.org/2000/svg"
              height="1.125rem"
              viewBox="0 0 24 24"
              width="1.125rem"
              fill="#FFFFFF"
            >
              <path d="M0 0h24v24H0z" fill="none" />
              <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
            </svg>` : null}
        <slot></slot>
      </div>
    `;
  }
};
Ti.styles = C`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      box-sizing: border-box;
      flex: 1;
      padding: 0rem 0.5rem;
      border-radius: var(--bim-ui_size-4xs);
    }

    :host(:hover) {
      cursor: pointer;
      background-color: color-mix(
        in lab,
        var(--bim-selector--bgc, var(--bim-ui_bg-contrast-20)),
        var(--bim-ui_main-base) 10%
      );
    }

    :host([checked]) {
      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    :host([checked]) svg {
      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    .parent {
      box-sizing: border-box;
      display: flex;
      justify-content: var(--bim-option--jc, space-between);
      column-gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
      height: 100%;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }

    bim-label {
      pointer-events: none;
    }
  `;
let P = Ti;
bt([
  d({ type: String, reflect: !0 })
], P.prototype, "img", 2);
bt([
  d({ type: String, reflect: !0 })
], P.prototype, "label", 2);
bt([
  d({ type: String, reflect: !0 })
], P.prototype, "icon", 2);
bt([
  d({ type: Boolean, reflect: !0 })
], P.prototype, "checked", 2);
bt([
  d({ type: Boolean, reflect: !0 })
], P.prototype, "checkbox", 2);
bt([
  d({ type: Boolean, attribute: "no-mark", reflect: !0 })
], P.prototype, "noMark", 2);
bt([
  d({
    converter: {
      fromAttribute(i) {
        return i && De(i);
      }
    }
  })
], P.prototype, "value", 1);
bt([
  d({ type: Boolean, reflect: !0 })
], P.prototype, "vertical", 2);
var el = Object.defineProperty, il = Object.getOwnPropertyDescriptor, gt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? il(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && el(t, e, n), n;
};
const Li = class Li extends Jo {
  constructor() {
    super(), this.multiple = !1, this.required = !1, this.vertical = !1, this._inputContainer = nt(), this._listElement = nt(), this._visible = !1, this._value = [], this.onValueChange = new Event("change"), this.onWindowMouseUp = (t) => {
      this.visible && (this.contains(t.target) || (this.visible = !1));
    }, this.onOptionClick = (t) => {
      const e = t.target, s = this._value.includes(e);
      if (!this.multiple && !this.required && !s)
        this._value = [e];
      else if (!this.multiple && !this.required && s)
        this._value = [];
      else if (!this.multiple && this.required && !s)
        this._value = [e];
      else if (this.multiple && !this.required && !s)
        this._value = [...this._value, e];
      else if (this.multiple && !this.required && s)
        this._value = this._value.filter((n) => n !== e);
      else if (this.multiple && this.required && !s)
        this._value = [...this._value, e];
      else if (this.multiple && this.required && s) {
        const n = this._value.filter((r) => r !== e);
        n.length !== 0 && (this._value = n);
      }
      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
    }, this.useObserver = !0;
  }
  set visible(t) {
    this._visible = t, t || this.resetVisibleElements();
  }
  get visible() {
    return this._visible;
  }
  /**
   * The selected values in the dropdown.
   * @type {any[]}
   * @example
   * const dropdown = document.createElement('bim-dropdown');
   * dropdown.value = ['option1', 'option2'];
   */
  set value(t) {
    if (this.required && Object.keys(t).length === 0)
      return;
    const e = [];
    for (const s of t) {
      const n = this.findOption(s);
      if (n && (e.push(n), !this.multiple && Object.keys(t).length > 1))
        break;
    }
    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
  }
  get value() {
    return this._value.filter(
      (e) => e instanceof P && e.checked
    ).map((e) => e.value);
  }
  get _options() {
    const t = [...this.elements];
    for (const e of this.children)
      e instanceof P && t.push(e);
    return t;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    this.observe(e);
    for (const s of e) {
      if (!(s instanceof P)) {
        s.remove();
        continue;
      }
      s.removeEventListener("click", this.onOptionClick), s.addEventListener("click", this.onOptionClick);
    }
  }
  updateOptionsState() {
    for (const t of this._options)
      t instanceof P && (this._value.includes(t) ? t.checked = !0 : t.checked = !1);
  }
  findOption(t) {
    return this._options.find((s) => s instanceof P ? s.label === t || s.value === t : !1);
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("mouseup", this.onWindowMouseUp);
  }
  firstUpdated() {
    for (const t of this.children)
      t instanceof P && t.checked && this._value.push(t);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("mouseup", this.onWindowMouseUp);
  }
  render() {
    let t, e, s;
    if (this._value.length === 0)
      t = "Select an option...";
    else if (this._value.length === 1) {
      const n = this._value[0];
      t = (n == null ? void 0 : n.label) || (n == null ? void 0 : n.value), e = n == null ? void 0 : n.img, s = n == null ? void 0 : n.icon;
    } else
      t = `Multiple (${this._value.length})`;
    return m`
      <bim-input
        title=${this.label ?? ""}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        <div
          ${st(this._inputContainer)}
          class="input"
          @click=${() => this.visible = !this.visible}
        >
          <bim-label
            .img=${e}
            .icon=${s}
            style="overflow: hidden;"
            >${t}</bim-label
          >
          <svg
            style="flex-shrink: 0"
            xmlns="http://www.w3.org/2000/svg"
            height="1.125rem"
            viewBox="0 0 24 24"
            width="1.125rem"
            fill="#9ca3af"
          >
            <path d="M0 0h24v24H0V0z" fill="none" />
            <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
          </svg>
        </div>
        <bim-context-menu ${st(this._listElement)} .visible=${this.visible}>
          <slot @slotchange=${this.onSlotChange}></slot>
          ${this.visibleElements.map((n) => n)}
        </bim-context-menu>
      </bim-input>
    `;
  }
};
Li.styles = [
  At.scrollbar,
  C`
      :host {
        --bim-input--bgc: var(
          --bim-dropdown--bgc,
          var(--bim-ui_bg-contrast-20)
        );
        --bim-input--olw: var(--bim-dropdown--olw, 2px);
        --bim-input--olc: var(--bim-dropdown--olc, transparent);
        --bim-input--bdrs: var(--bim-dropdown--bdrs, var(--bim-ui_size-4xs));
        flex: 1;
        display: block;
      }

      :host([visible]) {
        --bim-input--olc: var(
          --bim-dropdownfocus--c,
          var(--bim-ui_accent-base)
        );
      }

      .input {
        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));
        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));
        height: 100%;
        display: flex;
        flex: 1;
        overflow: hidden;
        column-gap: 0.25rem;
        outline: none;
        cursor: pointer;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
let B = Li;
gt([
  d({ type: String, reflect: !0 })
], B.prototype, "name", 2);
gt([
  d({ type: String, reflect: !0 })
], B.prototype, "icon", 2);
gt([
  d({ type: String, reflect: !0 })
], B.prototype, "label", 2);
gt([
  d({ type: Boolean, reflect: !0 })
], B.prototype, "multiple", 2);
gt([
  d({ type: Boolean, reflect: !0 })
], B.prototype, "required", 2);
gt([
  d({ type: Boolean, reflect: !0 })
], B.prototype, "vertical", 2);
gt([
  d({ type: Boolean, reflect: !0 })
], B.prototype, "visible", 1);
gt([
  le()
], B.prototype, "_value", 2);
var nl = Object.defineProperty, Ls = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && nl(t, e, n), n;
};
const Ii = class Ii extends w {
  constructor() {
    super(...arguments), this.floating = !1, this.layouts = {};
  }
  // private isVerticalArea(area: string) {
  //   const { rows } = this;
  //   const row = rows.find((row) => row.includes(area));
  //   if (!row)
  //     throw new Error(
  //       `${area} wasn't defined in the grid-template of this bim-grid`,
  //     );
  //   const index = rows.indexOf(row);
  //   const abovePanel = index > 0 && rows[index - 1].includes(area);
  //   const belowPanel =
  //     index < rows.length - 1 && rows[index + 1].includes(area);
  //   return abovePanel || belowPanel;
  // }
  getUniqueAreasFromTemplate(t) {
    const n = t.split(`
`).map((o) => o.trim()).map((o) => o.split('"')[1]).filter((o) => o !== void 0).flatMap((o) => o.split(/\s+/));
    return [...new Set(n)].filter((o) => o !== "");
  }
  firstUpdated() {
    this._onLayoutChange = new Event("layoutchange");
  }
  render() {
    if (this.layout) {
      if (this.layouts[this.layout]) {
        this.innerHTML = "";
        const t = this.layouts[this.layout], s = this.getUniqueAreasFromTemplate(t.template).map((n) => {
          const r = t.elements[n];
          return r && (r.style.gridArea = n), r;
        }).filter((n) => !!n);
        this.style.gridTemplate = t.template, this._onLayoutChange && this.dispatchEvent(this._onLayoutChange), this.append(...s);
      }
    } else
      this.innerHTML = "", this.style.gridTemplate = "", this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);
    return m`<slot></slot>`;
  }
};
Ii.styles = C`
    :host {
      display: grid;
      height: 100%;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }

    /* :host(:not([layout])) {
      display: none;
    } */

    :host([floating]) {
      --bim-panel--bdrs: var(--bim-ui_size-4xs);
      background-color: transparent;
      padding: 1rem;
      gap: 1rem;
      position: absolute;
      pointer-events: none;
      top: 0px;
      left: 0px;
    }

    :host(:not([floating])) {
      --bim-panel--bdrs: 0;
      background-color: var(--bim-ui_bg-contrast-20);
      gap: 1px;
    }
  `;
let ie = Ii;
Ls([
  d({ type: Boolean, reflect: !0 })
], ie.prototype, "floating");
Ls([
  d({ type: String, reflect: !0 })
], ie.prototype, "layout");
const ze = class ze extends w {
  render() {
    return m`
      <iconify-icon .icon=${this.icon} height="none"></iconify-icon>
    `;
  }
};
ze.styles = C`
    :host {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
    }

    iconify-icon {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
      color: var(--bim-icon--c);
    }
  `, ze.properties = {
  icon: { type: String }
};
let fi = ze;
var sl = Object.defineProperty, Fe = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && sl(t, e, n), n;
};
const zi = class zi extends w {
  constructor() {
    super(...arguments), this.vertical = !1, this.onValueChange = new Event("change");
  }
  get value() {
    const t = {};
    for (const e of this.children) {
      const s = e;
      "value" in s ? t[s.name || s.label] = s.value : "checked" in s && (t[s.name || s.label] = s.checked);
    }
    return t;
  }
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((a) => {
        const l = a;
        return l.name === s || l.label === s;
      });
      if (!n)
        continue;
      const r = n, o = t[s];
      typeof o == "boolean" ? r.checked = o : r.value = o;
    }
  }
  render() {
    return m`
      <div class="parent">
        ${this.label || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="input">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
zi.styles = C`
    :host {
      flex: 1;
      display: block;
    }

    .parent {
      display: flex;
      flex-wrap: wrap;
      column-gap: 1rem;
      row-gap: 0.375rem;
      user-select: none;
      flex: 1;
    }

    :host(:not([vertical])) .parent {
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .input {
      overflow: hidden;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.75rem;
      min-width: 3rem;
      gap: var(--bim-input--g, var(--bim-ui_size-4xs));
      padding: var(--bim-input--p, 0);
      background-color: var(--bim-input--bgc, transparent);
      outline: var(--bim-input--olw, 2px) solid
        var(--bim-input--olc, transparent);
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    :host(:not([vertical])) .input {
      flex: 1;
      justify-content: flex-end;
    }

    :host(:not([vertical])[label]) .input {
      max-width: fit-content;
    }
  `;
let Et = zi;
Fe([
  d({ type: String, reflect: !0 })
], Et.prototype, "name");
Fe([
  d({ type: String, reflect: !0 })
], Et.prototype, "label");
Fe([
  d({ type: String, reflect: !0 })
], Et.prototype, "icon");
Fe([
  d({ type: Boolean, reflect: !0 })
], Et.prototype, "vertical");
var rl = Object.defineProperty, he = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && rl(t, e, n), n;
};
const Ri = class Ri extends w {
  constructor() {
    super(...arguments), this.labelHidden = !1, this.iconHidden = !1, this.vertical = !1;
  }
  get value() {
    return this.textContent ? De(this.textContent) : this.textContent;
  }
  render() {
    return m`
      <div class="parent" .title=${this.textContent ?? ""}>
        ${this.img ? m`<img .src=${this.img} .alt=${this.textContent || ""} />` : null}
        ${!this.iconHidden && this.icon ? m`<bim-icon .icon=${this.icon}></bim-icon>` : null}
        <p><slot></slot></p>
      </div>
    `;
  }
};
Ri.styles = C`
    :host {
      --bim-icon--c: var(--bim-label--c);
      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));
      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));
      overflow: hidden;
      display: block;
      white-space: nowrap;
      line-height: 1.1rem;
    }

    .parent {
      display: flex;
      align-items: center;
      column-gap: 0.25rem;
      row-gap: 0.125rem;
      user-select: none;
      height: 100%;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .parent p {
      margin: 0;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    :host([label-hidden]) .parent p,
    :host(:empty) .parent p {
      display: none;
    }

    img {
      height: 100%;
      aspect-ratio: 1;
      border-radius: 100%;
      margin-right: 0.125rem;
    }

    :host(:not([vertical])) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.5)
      );
    }

    :host([vertical]) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)
      );
    }
  `;
let ct = Ri;
he([
  d({ type: String, reflect: !0 })
], ct.prototype, "img");
he([
  d({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], ct.prototype, "labelHidden");
he([
  d({ type: String, reflect: !0 })
], ct.prototype, "icon");
he([
  d({ type: Boolean, attribute: "icon-hidden", reflect: !0 })
], ct.prototype, "iconHidden");
he([
  d({ type: Boolean, reflect: !0 })
], ct.prototype, "vertical");
var ol = Object.defineProperty, ll = Object.getOwnPropertyDescriptor, j = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? ll(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && ol(t, e, n), n;
};
const Mi = class Mi extends w {
  constructor() {
    super(...arguments), this._value = 0, this.vertical = !1, this.slider = !1, this._input = nt(), this.onValueChange = new Event("change");
  }
  set value(t) {
    this.setValue(t.toString());
  }
  get value() {
    return this._value;
  }
  onChange(t) {
    t.stopPropagation();
    const { value: e } = this._input;
    e && this.setValue(e.value);
  }
  setValue(t) {
    const { value: e } = this._input;
    let s = t;
    if (s = s.replace(/[^0-9.-]/g, ""), s = s.replace(/(\..*)\./g, "$1"), s.endsWith(".") || (s.lastIndexOf("-") > 0 && (s = s[0] + s.substring(1).replace(/-/g, "")), s === "-" || s === "-0"))
      return;
    let n = Number(s);
    Number.isNaN(n) || (n = this.min !== void 0 ? Math.max(n, this.min) : n, n = this.max !== void 0 ? Math.min(n, this.max) : n, this.value !== n && (this._value = n, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));
  }
  onBlur() {
    const { value: t } = this._input;
    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());
  }
  onSliderMouseDown(t) {
    document.body.style.cursor = "w-resize";
    const { clientX: e } = t, s = this.value;
    let n = !1;
    const r = (l) => {
      var v;
      n = !0;
      const { clientX: c } = l, u = this.step ?? 1, h = ((v = u.toString().split(".")[1]) == null ? void 0 : v.length) || 0, f = 1 / (this.sensitivity ?? 1), p = (c - e) / f;
      if (Math.floor(Math.abs(p)) !== Math.abs(p))
        return;
      const b = s + p * u;
      this.setValue(b.toFixed(h));
    }, o = () => {
      this.slider = !0, this.removeEventListener("blur", o);
    }, a = () => {
      document.removeEventListener("mousemove", r), document.body.style.cursor = "default", n ? n = !1 : (this.addEventListener("blur", o), this.slider = !1, requestAnimationFrame(() => this.focus())), document.removeEventListener("mouseup", a);
    };
    document.addEventListener("mousemove", r), document.addEventListener("mouseup", a);
  }
  onFocus(t) {
    t.stopPropagation();
    const e = (s) => {
      s.key === "Escape" && (this.blur(), window.removeEventListener("keydown", e));
    };
    window.addEventListener("keydown", e);
  }
  connectedCallback() {
    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);
  }
  /**
   * Sets focus to the input element of the number input component.
   * This method is useful for programmatically focusing the input element, for example,
   * in response to a user action or to emphasize the input in the UI.
   *
   * If the input element reference is not available (not yet rendered or disconnected),
   * this method will do nothing.
   */
  focus() {
    const { value: t } = this._input;
    t && t.focus();
  }
  render() {
    const t = m`
      ${this.pref || this.icon ? m`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            .icon=${this.icon}
            >${this.pref}</bim-label
          >` : null}
      <input
        ${st(this._input)}
        type="text"
        aria-label=${this.label || this.name || "Number Input"}
        size="1"
        @input=${(a) => a.stopPropagation()}
        @change=${this.onChange}
        @blur=${this.onBlur}
        @focus=${this.onFocus}
        .value=${this.value.toString()}
      />
      ${this.suffix ? m`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            >${this.suffix}</bim-label
          >` : null}
    `, e = this.min ?? -1 / 0, s = this.max ?? 1 / 0, n = 100 * (this.value - e) / (s - e), r = m`
      <style>
        .slider-indicator {
          width: ${`${n}%`};
        }
      </style>
      <div class="slider" @mousedown=${this.onSliderMouseDown}>
        <div class="slider-indicator"></div>
        ${this.pref || this.icon ? m`<bim-label
              style="z-index: 1; margin-right: 0.125rem"
              .icon=${this.icon}
              >${`${this.pref}: `}</bim-label
            >` : null}
        <bim-label style="z-index: 1;">${this.value}</bim-label>
        ${this.suffix ? m`<bim-label style="z-index: 1;">${this.suffix}</bim-label>` : null}
      </div>
    `, o = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : ""}${this.value}${this.suffix ?? ""}`;
    return m`
      <bim-input
        title=${o}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        ${this.slider ? r : t}
      </bim-input>
    `;
  }
};
Mi.styles = C`
    :host {
      --bim-input--bgc: var(
        --bim-number-input--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-number-input--olc, transparent);
      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));
      --bim-input--p: 0 0.375rem;
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(
        --bim-number-inputfocus--c,
        var(--bim-ui_accent-base)
      );
    }

    :host(:not([slider])) bim-label {
      --bim-label--c: var(
        --bim-number-input_affixes--c,
        var(--bim-ui_bg-contrast-60)
      );
      --bim-label--fz: var(
        --bim-number-input_affixes--fz,
        var(--bim-ui_size-xs)
      );
    }

    p {
      margin: 0;
      padding: 0;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      padding: 0;
      flex-grow: 1;
      text-align: right;
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));
      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([suffix]:not([pref])) input {
      text-align: left;
    }

    :host([slider]) {
      --bim-input--p: 0;
    }

    :host([slider]) .slider {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
    }

    .slider {
      position: relative;
      display: flex;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 0 0.5rem;
    }

    .slider-indicator {
      height: 100%;
      background-color: var(--bim-ui_main-base);
      position: absolute;
      top: 0;
      left: 0;
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    bim-input {
      display: flex;
    }

    bim-label {
      pointer-events: none;
    }
  `;
let L = Mi;
j([
  d({ type: String, reflect: !0 })
], L.prototype, "name", 2);
j([
  d({ type: String, reflect: !0 })
], L.prototype, "icon", 2);
j([
  d({ type: String, reflect: !0 })
], L.prototype, "label", 2);
j([
  d({ type: String, reflect: !0 })
], L.prototype, "pref", 2);
j([
  d({ type: Number, reflect: !0 })
], L.prototype, "min", 2);
j([
  d({ type: Number, reflect: !0 })
], L.prototype, "value", 1);
j([
  d({ type: Number, reflect: !0 })
], L.prototype, "step", 2);
j([
  d({ type: Number, reflect: !0 })
], L.prototype, "sensitivity", 2);
j([
  d({ type: Number, reflect: !0 })
], L.prototype, "max", 2);
j([
  d({ type: String, reflect: !0 })
], L.prototype, "suffix", 2);
j([
  d({ type: Boolean, reflect: !0 })
], L.prototype, "vertical", 2);
j([
  d({ type: Boolean, reflect: !0 })
], L.prototype, "slider", 2);
var al = Object.defineProperty, cl = Object.getOwnPropertyDescriptor, de = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? cl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && al(t, e, n), n;
};
const ji = class ji extends w {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this._hidden = !1, this.headerHidden = !1, this.activationButton = document.createElement("bim-button");
  }
  set hidden(t) {
    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  /**
   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.
   *
   * @type {Record<string, any>}
   * @default {}
   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * console.log(panel.value); // Logs the current value object of the panel
   */
  get value() {
    return ke(this);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.
   *
   * @type {Record<string, any>}
   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => this.hidden = !this.hidden;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.activationButton.remove();
  }
  /**
   * Collapses all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,
   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections
   * within the panel, making the panel more compact or to hide details that are not immediately necessary.
   */
  collapseSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = !0;
  }
  /**
   * Expands all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,
   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,
   * making the panel more informative or to display details that are necessary for the user.
   */
  expandSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = !1;
  }
  render() {
    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, m`
      <div class="parent">
        ${this.label || this.name || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="sections">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
ji.styles = [
  At.scrollbar,
  C`
      :host {
        display: flex;
        border-radius: var(--bim-ui_size-base);
        background-color: var(--bim-ui_bg-base);
        overflow: auto;
      }

      :host([hidden]) {
        display: none;
      }

      .parent {
        display: flex;
        flex: 1;
        flex-direction: column;
        pointer-events: auto;
        overflow: auto;
      }

      .parent bim-label {
        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));
        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));
        font-weight: 600;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([header-hidden]) .parent bim-label {
        display: none;
      }

      .sections {
        display: flex;
        flex-direction: column;
        overflow: auto;
      }

      ::slotted(bim-panel-section:not(:last-child)) {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }
    `
];
let ut = ji;
de([
  d({ type: String, reflect: !0 })
], ut.prototype, "icon", 2);
de([
  d({ type: String, reflect: !0 })
], ut.prototype, "name", 2);
de([
  d({ type: String, reflect: !0 })
], ut.prototype, "label", 2);
de([
  d({ type: Boolean, reflect: !0 })
], ut.prototype, "hidden", 1);
de([
  d({ type: Boolean, attribute: "header-hidden", reflect: !0 })
], ut.prototype, "headerHidden", 2);
var ul = Object.defineProperty, fe = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && ul(t, e, n), n;
};
const Bi = class Bi extends w {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change");
  }
  /**
   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.
   * @type {Record<string, any>}
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * console.log(section.value); // Logs the current value object
   */
  get value() {
    return ke(this);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.
   * @type {Record<string, any>}
   * @default undefined
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  onHeaderClick() {
    this.fixed || (this.collapsed = !this.collapsed);
  }
  render() {
    const t = this.label || this.icon || this.name || this.fixed, e = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`, s = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" />
    </svg>`, n = this.collapsed ? e : s, r = m`
      <div
        class="header"
        title=${this.label ?? ""}
        @click=${this.onHeaderClick}
      >
        ${this.label || this.icon || this.name ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        ${this.fixed ? null : n}
      </div>
    `;
    return m`
      <div class="parent">
        ${t ? r : null}
        <div class="components">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Bi.styles = [
  At.scrollbar,
  C`
      :host {
        display: block;
        pointer-events: auto;
      }

      :host(:not([fixed])) .header:hover {
        --bim-label--c: var(--bim-ui_accent-base);
        color: var(--bim-ui_accent-base);
        cursor: pointer;
      }

      :host(:not([fixed])) .header:hover svg {
        fill: var(--bim-ui_accent-base);
      }

      .header {
        --bim-label--fz: var(--bim-ui_size-sm);
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        height: 1.5rem;
        padding: 0.75rem 1rem;
      }

      .header svg {
        fill: var(--bim-ui_bg-contrast-80);
      }

      .title {
        display: flex;
        align-items: center;
        column-gap: 0.5rem;
      }

      .title p {
        font-size: var(--bim-ui_size-sm);
      }

      .components {
        display: flex;
        flex-direction: column;
        row-gap: 0.75rem;
        padding: 0.125rem 1rem 1rem;
      }

      :host(:not([fixed])[collapsed]) .components {
        display: none;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
let ht = Bi;
fe([
  d({ type: String, reflect: !0 })
], ht.prototype, "icon");
fe([
  d({ type: String, reflect: !0 })
], ht.prototype, "label");
fe([
  d({ type: String, reflect: !0 })
], ht.prototype, "name");
fe([
  d({ type: Boolean, reflect: !0 })
], ht.prototype, "fixed");
fe([
  d({ type: Boolean, reflect: !0 })
], ht.prototype, "collapsed");
var hl = Object.defineProperty, pe = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && hl(t, e, n), n;
};
const Ni = class Ni extends w {
  constructor() {
    super(...arguments), this.vertical = !1, this.onValueChange = new Event("change"), this._canEmitEvents = !1, this._value = document.createElement("bim-option"), this.onOptionClick = (t) => {
      this._value = t.target, this.dispatchEvent(this.onValueChange);
      for (const e of this.children)
        e instanceof P && (e.checked = e === t.target);
    };
  }
  get _options() {
    return [...this.querySelectorAll("bim-option")];
  }
  /**
   * Sets the value of the selector.
   * It finds the matching option based on the provided value and sets it as the selected option.
   * If no matching option is found, it does nothing.
   *
   * @param value - The value to set for the selector.
   */
  set value(t) {
    const e = this.findOption(t);
    if (e) {
      for (const s of this._options)
        s.checked = s === e;
      this._value = e, this._canEmitEvents && this.dispatchEvent(this.onValueChange);
    }
  }
  get value() {
    return this._value.value;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    for (const s of e)
      s instanceof P && (s.noMark = !0, s.removeEventListener("click", this.onOptionClick), s.addEventListener("click", this.onOptionClick));
  }
  findOption(t) {
    return this._options.find((s) => s instanceof P ? s.label === t || s.value === t : !1);
  }
  firstUpdated() {
    const t = [...this.children].find(
      (e) => e instanceof P && e.checked
    );
    t && (this._value = t);
  }
  render() {
    return m`
      <bim-input
        .vertical=${this.vertical}
        .label=${this.label}
        .icon=${this.icon}
      >
        <slot @slotchange=${this.onSlotChange}></slot>
      </bim-input>
    `;
  }
};
Ni.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      --bim-input--g: 0;
      --bim-option--jc: center;
      flex: 1;
      display: block;
    }

    ::slotted(bim-option) {
      border-radius: 0;
    }

    ::slotted(bim-option[checked]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }
  `;
let dt = Ni;
pe([
  d({ type: String, reflect: !0 })
], dt.prototype, "name");
pe([
  d({ type: String, reflect: !0 })
], dt.prototype, "icon");
pe([
  d({ type: String, reflect: !0 })
], dt.prototype, "label");
pe([
  d({ type: Boolean, reflect: !0 })
], dt.prototype, "vertical");
pe([
  le()
], dt.prototype, "_value");
var dl = Object.defineProperty, fl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && dl(t, e, n), n;
};
const Hi = class Hi extends w {
  constructor() {
    super(...arguments), this.column = "", this.columnIndex = 0, this.rowData = {};
  }
  get data() {
    return this.column ? this.rowData[this.column] : null;
  }
  render() {
    return m`
      <style>
        :host {
          grid-area: ${this.column ?? "unset"};
        }
      </style>
      <slot></slot>
    `;
  }
};
Hi.styles = C`
    :host {
      padding: 0.25rem 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([data-column-index="0"]:not([data-cell-header])) {
      justify-content: normal;
    }

    :host([data-column-index="0"]:not([data-cell-header]))
      ::slotted(bim-label) {
      text-align: left;
    }

    ::slotted(*) {
      --bim-input--bgc: transparent;
      --bim-input--olc: var(--bim-ui_bg-contrast-20);
      --bim-input--olw: 1px;
    }

    ::slotted(bim-input) {
      --bim-input--olw: 0;
    }

    ::slotted(bim-label) {
      white-space: normal;
      text-align: center;
    }
  `;
let Pe = Hi;
fl([
  d({ type: String, reflect: !0 })
], Pe.prototype, "column");
var pl = Object.defineProperty, ml = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && pl(t, e, n), n;
};
const Di = class Di extends w {
  constructor() {
    super(...arguments), this._groups = [], this.data = [], this.table = this.closest("bim-table");
  }
  toggleGroups(t, e = !1) {
    for (const s of this._groups)
      s.childrenHidden = typeof t > "u" ? !s.childrenHidden : !t, e && s.toggleChildren(t, e);
  }
  render() {
    return this._groups = [], m`
      <slot></slot>
      ${this.data.map((t) => {
      const e = document.createElement(
        "bim-table-group"
      );
      return this._groups.push(e), e.table = this.table, e.data = t, e;
    })}
    `;
  }
};
Di.styles = C`
    :host {
      position: relative;
      grid-area: Children;
    }

    :host([hidden]) {
      display: none;
    }

    ::slotted(.branch.branch-vertical) {
      top: 0;
      bottom: 1.125rem;
    }
  `;
let Te = Di;
ml([
  d({ type: Array, attribute: !1 })
], Te.prototype, "data");
var bl = Object.defineProperty, gl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && bl(t, e, n), n;
};
const Fi = class Fi extends w {
  constructor() {
    super(...arguments), this.data = { data: {} }, this.childrenHidden = !0, this.table = this.closest("bim-table");
  }
  connectedCallback() {
    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = !1 : this.childrenHidden = !0;
  }
  toggleChildren(t, e = !1) {
    this._children && (this.childrenHidden = typeof t > "u" ? !this.childrenHidden : !t, e && this._children.toggleGroups(t, e));
  }
  render() {
    var f, p;
    const t = ((f = this.table) == null ? void 0 : f.getGroupIndentation(this.data)) ?? 0, e = m`
      <style>
        .branch-vertical {
          left: ${t + 0.5625}rem;
        }
      </style>
      <div class="branch branch-vertical"></div>
    `, s = document.createDocumentFragment();
    Rt(e, s);
    const n = document.createElement("div");
    n.classList.add("branch", "branch-horizontal"), n.style.left = `${t - 1 + 0.5625}rem`;
    const r = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    r.setAttribute("height", "9.5"), r.setAttribute("width", "7.5"), r.setAttribute("viewBox", "0 0 4.6666672 7.3333333");
    const o = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    o.setAttribute(
      "d",
      "m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z"
    ), r.append(o);
    const a = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    a.setAttribute("height", "6.5"), a.setAttribute("width", "9.5"), a.setAttribute("viewBox", "0 0 5.9111118 5.0175439");
    const l = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    l.setAttribute(
      "d",
      "M -0.33616196,1.922522 2.253838,4.5125219 c 0.39,0.39 1.02,0.39 1.41,0 L 6.2538379,1.922522 c 0.6200001,-0.63 0.18,-1.71000007 -0.7099999,-1.71000007 H 0.37383804 c -0.89999997,0 -1.33999997,1.08000007 -0.71,1.71000007 z"
    ), a.append(l);
    const c = document.createElement("div");
    c.addEventListener("click", (b) => {
      b.stopPropagation(), this.toggleChildren();
    }), c.classList.add("caret"), c.style.left = `${0.125 + t}rem`, this.childrenHidden ? c.append(r) : c.append(a);
    const u = document.createElement("bim-table-row");
    this.data.children && !this.childrenHidden && u.append(s), u.table = this.table, u.data = this.data.data, (p = this.table) == null || p.dispatchEvent(
      new CustomEvent("rowcreated", { detail: { row: u } })
    ), this.data.children && u.append(c), t !== 0 && (!this.data.children || this.childrenHidden) && u.append(n);
    let h;
    if (this.data.children) {
      h = document.createElement("bim-table-children"), this._children = h, h.table = this.table, h.data = this.data.children;
      const b = document.createDocumentFragment();
      Rt(e, b), h.append(b);
    }
    return m`
      <div class="parent">${u} ${this.childrenHidden ? null : h}</div>
    `;
  }
};
Fi.styles = C`
    :host {
      position: relative;
    }

    .parent {
      display: grid;
      grid-template-areas: "Data" "Children";
    }

    .branch {
      position: absolute;
      z-index: 1;
    }

    .branch-vertical {
      border-left: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .branch-horizontal {
      top: 50%;
      width: 1rem;
      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .caret {
      position: absolute;
      z-index: 2;
      transform: translateY(-50%) rotate(0deg);
      top: 50%;
      display: flex;
      width: 0.95rem;
      height: 0.95rem;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }

    .caret svg {
      fill: var(--bim-ui_bg-contrast-60);
    }
  `;
let Le = Fi;
gl([
  d({ type: Boolean, attribute: "children-hidden", reflect: !0 })
], Le.prototype, "childrenHidden");
var vl = Object.defineProperty, me = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && vl(t, e, n), n;
};
const Vi = class Vi extends w {
  constructor() {
    super(...arguments), this.columns = [], this.hiddenColumns = [], this.data = {}, this.isHeader = !1, this.table = this.closest("bim-table"), this.onTableColumnsChange = () => {
      this.table && (this.columns = this.table.columns);
    }, this.onTableColumnsHidden = () => {
      this.table && (this.hiddenColumns = this.table.hiddenColumns);
    }, this._observer = new IntersectionObserver(
      (t) => {
        this._intersecting = t[0].isIntersecting;
      },
      { rootMargin: "36px" }
    );
  }
  get _columnNames() {
    return this.columns.filter(
      (s) => !this.hiddenColumns.includes(s.name)
    ).map((s) => s.name);
  }
  get _columnWidths() {
    return this.columns.filter(
      (s) => !this.hiddenColumns.includes(s.name)
    ).map((s) => s.width);
  }
  connectedCallback() {
    super.connectedCallback(), this._observer.observe(this), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener("columnschange", this.onTableColumnsChange), this.table.addEventListener("columnshidden", this.onTableColumnsHidden));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer.unobserve(this), this.table && (this.columns = [], this.hiddenColumns = [], this.table.removeEventListener("columnschange", this.onTableColumnsChange), this.table.removeEventListener("columnshidden", this.onTableColumnsHidden));
  }
  compute() {
    var n, r, o;
    const t = ((n = this.table) == null ? void 0 : n.getRowIndentation(this.data)) ?? 0, e = this.isHeader ? this.data : ((r = this.table) == null ? void 0 : r.computeRowDeclaration(this.data)) ?? this.data, s = [];
    for (const a in e) {
      if (this.hiddenColumns.includes(a))
        continue;
      const l = e[a];
      let c;
      if (typeof l == "string" || typeof l == "boolean" || typeof l == "number" ? (c = document.createElement("bim-label"), c.textContent = String(l)) : l instanceof HTMLElement ? c = l : (c = document.createDocumentFragment(), Rt(l, c)), !c)
        continue;
      const u = document.createElement("bim-table-cell");
      u.append(c), u.column = a, this._columnNames.indexOf(a) === 0 && !this.isHeader && (u.style.marginLeft = `${t + 0.125}rem`);
      const h = this._columnNames.indexOf(a);
      u.setAttribute("data-column-index", String(h)), u.toggleAttribute("data-cell-header", this.isHeader), u.rowData = this.data, (o = this.table) == null || o.dispatchEvent(
        new CustomEvent("cellcreated", {
          detail: { cell: u }
        })
      ), s.push(u);
    }
    return this.style.gridTemplateAreas = `"${this._columnNames.join(" ")}"`, this.style.gridTemplateColumns = `${this._columnWidths.join(" ")}`, m`
      ${s}
      <slot></slot>
    `;
  }
  render() {
    return m`${this._intersecting ? this.compute() : m``}`;
  }
};
Vi.styles = C`
    :host {
      position: relative;
      grid-area: Data;
      display: grid;
      min-height: 2.25rem;
    }

    ::slotted(.branch.branch-vertical) {
      top: 50%;
      bottom: 0;
    }
  `;
let ft = Vi;
me([
  d({ attribute: !1 })
], ft.prototype, "columns");
me([
  d({ attribute: !1 })
], ft.prototype, "hiddenColumns");
me([
  d({ attribute: !1 })
], ft.prototype, "data");
me([
  d({ type: Boolean, attribute: "is-header", reflect: !0 })
], ft.prototype, "isHeader");
me([
  le()
], ft.prototype, "_intersecting");
var yl = Object.defineProperty, _l = Object.getOwnPropertyDescriptor, Ht = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? _l(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && yl(t, e, n), n;
};
const Ui = class Ui extends w {
  constructor() {
    super(...arguments), this._columnsChange = new Event("columnschange"), this._filteredData = [], this.headersHidden = !1, this.minColWidth = "4rem", this._columns = [], this._textDelimiters = {
      comma: ",",
      tab: "	"
    }, this._queryString = null, this._data = [], this.expanded = !1, this.preserveStructureOnFilter = !1, this.indentationInText = !1, this.dataTransform = {}, this._onColumnsHidden = new Event("columnshidden"), this._hiddenColumns = [], this._stringFilterFunction = (t, e) => Object.values(e.data).some((n) => String(n).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {
      let s = !1;
      const n = di(t) ?? [];
      for (const r of n) {
        if ("queries" in r) {
          s = !1;
          break;
        }
        const { condition: o, value: a } = r;
        let { key: l } = r;
        if (l.startsWith("[") && l.endsWith("]")) {
          const c = l.replace("[", "").replace("]", "");
          l = c, s = Object.keys(e.data).filter((f) => f.includes(c)).map(
            (f) => In(e.data[f], o, a)
          ).some((f) => f);
        } else
          s = In(e.data[l], o, a);
        if (!s)
          break;
      }
      return s;
    };
  }
  set columns(t) {
    const e = [];
    for (const s of t) {
      const n = typeof s == "string" ? { name: s, width: `minmax(${this.minColWidth}, 1fr)` } : s;
      e.push(n);
    }
    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(this._columnsChange);
  }
  get columns() {
    return this._columns;
  }
  get _headerRowData() {
    const t = {};
    for (const e of this.columns)
      if (typeof e == "string")
        t[e] = e;
      else {
        const { name: s } = e;
        t[s] = s;
      }
    return t;
  }
  /**
   * Getter for the `value` property.
   * Returns the filtered data if a search string is provided, otherwise returns the original data.
   *
   * @example
   * ```typescript
   * const tableValue = table.value;
   * console.log(tableValue); // Output: The filtered or original data.
   * ```
   */
  get value() {
    return this._filteredData;
  }
  /**
   * Sets the search string for filtering the table data.
   * This property allows you to filter the table data based on a search string.
   * If a search string is provided, the table will only display rows that match the search criteria.
   * The search criteria can be a simple string or a complex query.
   * If a simple string is provided, the table will filter rows based on the string's presence in any column.
   * If a complex query is provided, the table will filter rows based on the query's conditions and values.
   *
   * @example
   * ```typescript
   * table.queryString = "example";
   * ```
   *
   * @example
   * ```typescript
   * table.queryString = "column1="Jhon Doe" & column2=20";
   * ```
   */
  set queryString(t) {
    this._queryString = t && t.trim() !== "" ? t.trim() : null, this.updateFilteredData();
  }
  get queryString() {
    return this._queryString;
  }
  set data(t) {
    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);
  }
  get data() {
    return this._data;
  }
  get dataAsync() {
    return new Promise((t) => {
      setTimeout(() => {
        t(this.data);
      });
    });
  }
  set hiddenColumns(t) {
    this._hiddenColumns = t, setTimeout(() => {
      this.dispatchEvent(this._onColumnsHidden);
    });
  }
  get hiddenColumns() {
    return this._hiddenColumns;
  }
  updateFilteredData() {
    this.queryString ? (di(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = !0)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);
  }
  computeMissingColumns(t) {
    let e = !1;
    for (const s of t) {
      const { children: n, data: r } = s;
      for (const o in r)
        this._columns.map((l) => typeof l == "string" ? l : l.name).includes(o) || (this._columns.push({
          name: o,
          width: `minmax(${this.minColWidth}, 1fr)`
        }), e = !0);
      if (n) {
        const o = this.computeMissingColumns(n);
        o && !e && (e = o);
      }
    }
    return e;
  }
  generateText(t = "comma", e = this.value, s = "", n = !0) {
    const r = this._textDelimiters[t];
    let o = "";
    const a = this.columns.map((l) => l.name);
    if (n) {
      this.indentationInText && (o += `Indentation${r}`);
      const l = `${a.join(r)}
`;
      o += l;
    }
    for (const [l, c] of e.entries()) {
      const { data: u, children: h } = c, f = this.indentationInText ? `${s}${l + 1}${r}` : "", p = a.map((v) => u[v] ?? ""), b = `${f}${p.join(r)}
`;
      o += b, h && (o += this.generateText(
        t,
        c.children,
        `${s}${l + 1}.`,
        !1
      ));
    }
    return o;
  }
  /**
   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.
   *
   * @returns A string containing the CSV representation of the table data.
   *
   * @example
   * ```typescript
   * const csvData = table.csv;
   * console.log(csvData); // Output: "Column 1,Column 2\nValue 1,Value 2\nValue 3,Value 4"
   * ```
   */
  get csv() {
    return this.generateText("comma");
  }
  /**
   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.
   *
   * @returns A string containing the TSV representation of the table data.
   *
   * @example
   * ```typescript
   * const tsvData = table.tsv;
   * console.log(tsvData); // Output: "Column 1\tColumn 2\nValue 1\tValue 2\nValue 3\tValue 4"
   * ```
   */
  get tsv() {
    return this.generateText("tab");
  }
  computeRowDeclaration(t) {
    const e = {};
    for (const s in t) {
      const n = this.dataTransform[s];
      n ? e[s] = n(t[s], t) : e[s] = t[s];
    }
    return e;
  }
  /**
   * The `downloadData` method is used to download the table data in different formats.
   *
   * @param fileName - The name of the downloaded file. Default is "BIM Table Data".
   * @param format - The format of the downloaded file. Can be "json", "tsv", or "csv". Default is "json".
   *
   * @returns - This method does not return any value.
   *
   * @example
   * ```typescript
   * table.downloadData("MyTableData", "tsv");
   * ```
   */
  downloadData(t = "BIM Table Data", e = "json") {
    let s = null;
    if (e === "json" && (s = new File(
      [JSON.stringify(this.value, void 0, 2)],
      `${t}.json`
    )), e === "csv" && (s = new File([this.csv], `${t}.csv`)), e === "tsv" && (s = new File([this.tsv], `${t}.tsv`)), !s)
      return;
    const n = document.createElement("a");
    n.href = URL.createObjectURL(s), n.download = s.name, n.click(), URL.revokeObjectURL(n.href);
  }
  getRowIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n.data === t)
        return s;
      if (n.children) {
        const r = this.getRowIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  getGroupIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n === t)
        return s;
      if (n.children) {
        const r = this.getGroupIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  connectedCallback() {
    super.connectedCallback(), this.dispatchEvent(new Event("connected"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispatchEvent(new Event("disconnected"));
  }
  filter(t, e = this.filterFunction ?? this._stringFilterFunction, s = this.data) {
    const n = [];
    for (const r of s)
      if (e(t, r)) {
        if (this.preserveStructureOnFilter) {
          const a = { data: r.data };
          if (r.children) {
            const l = this.filter(
              t,
              e,
              r.children
            );
            l.length && (a.children = l);
          }
          n.push(a);
        } else if (n.push({ data: r.data }), r.children) {
          const a = this.filter(
            t,
            e,
            r.children
          );
          n.push(...a);
        }
      } else if (r.children) {
        const a = this.filter(
          t,
          e,
          r.children
        );
        this.preserveStructureOnFilter && a.length ? n.push({
          data: r.data,
          children: a
        }) : n.push(...a);
      }
    return n;
  }
  render() {
    const t = document.createElement("bim-table-row");
    t.table = this, t.isHeader = !0, t.data = this._headerRowData, t.style.gridArea = "Header", t.style.position = "sticky", t.style.top = "0", t.style.zIndex = "5";
    const e = document.createElement("bim-table-children");
    return e.table = this, e.data = this.value, e.style.gridArea = "Body", e.style.backgroundColor = "transparent", m`
      <div class="parent">
        ${this.headersHidden ? null : t}
        <div style="overflow-x: hidden; grid-area: Body">${e}</div>
      </div>
    `;
  }
};
Ui.styles = [
  At.scrollbar,
  C`
      :host {
        --bim-button--bgc: transparent;
        position: relative;
        overflow: auto;
        display: block;
        pointer-events: auto;
      }

      .parent {
        display: grid;
        grid-template:
          "Header" auto
          "Body" 1fr
          "Footer" auto;
        overflow: auto;
        height: 100%;
      }

      .parent > bim-table-row[is-header] {
        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));
        background-color: var(
          --bim-table_header--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      .controls {
        display: flex;
        gap: 0.375rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }
    `
];
let J = Ui;
Ht([
  le()
], J.prototype, "_filteredData", 2);
Ht([
  d({
    type: Boolean,
    attribute: "headers-hidden",
    reflect: !0
  })
], J.prototype, "headersHidden", 2);
Ht([
  d({ type: String, attribute: "min-col-width", reflect: !0 })
], J.prototype, "minColWidth", 2);
Ht([
  d({ type: Array, attribute: !1 })
], J.prototype, "columns", 1);
Ht([
  d({ type: Array, attribute: !1 })
], J.prototype, "data", 1);
Ht([
  d({ type: Boolean, reflect: !0 })
], J.prototype, "expanded", 2);
var xl = Object.defineProperty, wl = Object.getOwnPropertyDescriptor, Ve = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? wl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && xl(t, e, n), n;
};
const qi = class qi extends w {
  constructor() {
    super(...arguments), this._defaultName = "__unnamed__", this.name = this._defaultName, this._hidden = !1;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  connectedCallback() {
    super.connectedCallback();
    const { parentElement: t } = this;
    if (t && this.name === this._defaultName) {
      const e = [...t.children].indexOf(this);
      this.name = `${this._defaultName}${e}`;
    }
  }
  render() {
    return m` <slot></slot> `;
  }
};
qi.styles = C`
    :host {
      display: block;
      height: 100%;
    }

    :host([hidden]) {
      display: none;
    }
  `;
let I = qi;
Ve([
  d({ type: String, reflect: !0 })
], I.prototype, "name", 2);
Ve([
  d({ type: String, reflect: !0 })
], I.prototype, "label", 2);
Ve([
  d({ type: String, reflect: !0 })
], I.prototype, "icon", 2);
Ve([
  d({ type: Boolean, reflect: !0 })
], I.prototype, "hidden", 1);
var $l = Object.defineProperty, Cl = Object.getOwnPropertyDescriptor, Dt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Cl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && $l(t, e, n), n;
};
const Wi = class Wi extends w {
  constructor() {
    super(...arguments), this._switchers = [], this.bottom = !1, this.switchersHidden = !1, this.floating = !1, this.switchersFull = !1, this.onTabHiddenChange = (t) => {
      const e = t.target;
      e instanceof I && !e.hidden && (e.removeEventListener("hiddenchange", this.onTabHiddenChange), this.tab = e.name, e.addEventListener("hiddenchange", this.onTabHiddenChange));
    };
  }
  set tab(t) {
    this._tab = t;
    const e = [...this.children], s = e.find(
      (n) => n instanceof I && n.name === t
    );
    for (const n of e) {
      if (!(n instanceof I))
        continue;
      n.hidden = s !== n;
      const r = this.getTabSwitcher(n.name);
      r && r.toggleAttribute("data-active", !n.hidden);
    }
  }
  get tab() {
    return this._tab;
  }
  getTabSwitcher(t) {
    return this._switchers.find(
      (s) => s.getAttribute("data-name") === t
    );
  }
  createSwitchers() {
    this._switchers = [];
    for (const t of this.children) {
      if (!(t instanceof I))
        continue;
      const e = document.createElement("div");
      e.addEventListener("click", () => {
        this.tab === t.name ? this.toggleAttribute("tab", !1) : this.tab = t.name;
      }), e.setAttribute("data-name", t.name), e.className = "switcher";
      const s = document.createElement("bim-label");
      s.textContent = t.label ?? "", s.icon = t.icon, e.append(s), this._switchers.push(e);
    }
  }
  onSlotChange(t) {
    this.createSwitchers();
    const e = t.target.assignedElements(), s = e.find((n) => n instanceof I ? this.tab ? n.name === this.tab : !n.hidden : !1);
    s && s instanceof I && (this.tab = s.name);
    for (const n of e) {
      if (!(n instanceof I)) {
        n.remove();
        continue;
      }
      n.removeEventListener("hiddenchange", this.onTabHiddenChange), s !== n && (n.hidden = !0), n.addEventListener("hiddenchange", this.onTabHiddenChange);
    }
  }
  render() {
    return m`
      <div class="parent">
        <div class="switchers">${this._switchers}</div>
        <div class="content">
          <slot @slotchange=${this.onSlotChange}></slot>
        </div>
      </div>
    `;
  }
};
Wi.styles = [
  At.scrollbar,
  C`
      * {
        box-sizing: border-box;
      }

      :host {
        background-color: var(--bim-ui_bg-base);
        display: block;
        overflow: auto;
      }

      .parent {
        display: grid;
        grid-template: "switchers" auto "content" 1fr;
        height: 100%;
      }

      :host([bottom]) .parent {
        grid-template: "content" 1fr "switchers" auto;
      }

      .switchers {
        display: flex;
        height: 2.25rem;
        font-weight: 600;
        grid-area: switchers;
      }

      .switcher {
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        background-color: var(--bim-ui_bg-base);
        cursor: pointer;
        pointer-events: auto;
        padding: 0rem 0.75rem;
        display: flex;
        justify-content: center;
      }

      :host([switchers-full]) .switcher {
        flex: 1;
      }

      .switcher:hover,
      .switcher[data-active] {
        --bim-label--c: var(--bim-ui_main-contrast);
        background-color: var(--bim-ui_main-base);
      }

      .switchers bim-label {
        pointer-events: none;
      }

      :host([switchers-hidden]) .switchers {
        display: none;
      }

      .content {
        grid-area: content;
        overflow: auto;
      }

      :host(:not([bottom])) .content {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([bottom]) .content {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host(:not([tab])) .content {
        display: none;
      }

      :host([floating]) {
        background-color: transparent;
      }

      :host([floating]) .switchers {
        justify-self: center;
        overflow: auto;
      }

      :host([floating]:not([bottom])) .switchers {
        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]) .switchers {
        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]:not([tab])) .switchers {
        border-radius: var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]:not([tab])) .switchers {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) .content {
        border: 1px solid var(--bim-ui_bg-contrast-20);
        border-radius: var(--bim-ui_size-2xs);
        background-color: var(--bim-ui_bg-base);
      }
    `
];
let K = Wi;
Dt([
  le()
], K.prototype, "_switchers", 2);
Dt([
  d({ type: Boolean, reflect: !0 })
], K.prototype, "bottom", 2);
Dt([
  d({ type: Boolean, attribute: "switchers-hidden", reflect: !0 })
], K.prototype, "switchersHidden", 2);
Dt([
  d({ type: Boolean, reflect: !0 })
], K.prototype, "floating", 2);
Dt([
  d({ type: String, reflect: !0 })
], K.prototype, "tab", 1);
Dt([
  d({ type: Boolean, attribute: "switchers-full", reflect: !0 })
], K.prototype, "switchersFull", 2);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const El = (i) => i ?? k;
var Al = Object.defineProperty, Sl = Object.getOwnPropertyDescriptor, vt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Sl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Al(t, e, n), n;
};
const Qi = class Qi extends w {
  constructor() {
    super(...arguments), this._inputTypes = [
      "date",
      "datetime-local",
      "email",
      "month",
      "password",
      "search",
      "tel",
      "text",
      "time",
      "url",
      "week"
    ], this.value = "", this.vertical = !1, this._type = "text", this.onValueChange = new Event("input");
  }
  set type(t) {
    this._inputTypes.includes(t) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  /**
   * Gets the query value derived from the current input value.
   * The `getQuery` function is assumed to be a utility function that takes a string as input
   * and returns a processed query value based on the input.
   *
   * @returns The processed query value derived from the current input value.
   *
   * @example
   * ```typescript
   * const textInput = new TextInput();
   * textInput.value = "Key?Value";
   * console.log(textInput.query);
   * ```
   */
  get query() {
    return di(this.value);
  }
  onInputChange(t) {
    t.stopPropagation();
    const e = t.target;
    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {
      this.value = e.value, this.dispatchEvent(this.onValueChange);
    }, this.debounce);
  }
  focus() {
    setTimeout(() => {
      var e;
      const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("input");
      t == null || t.focus();
    });
  }
  render() {
    return m`
      <bim-input
        .name=${this.name}
        .icon=${this.icon}
        .label=${this.label}
        .vertical=${this.vertical}
      >
        <input
          aria-label=${this.label || this.name || "Text Input"}
          .type=${this.type}
          .value=${this.value}
          placeholder=${El(this.placeholder)}
          @input=${this.onInputChange}
        />
      </bim-input>
    `;
  }
};
Qi.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      width: 100%;
      height: 100%;
      padding: 0 var(--bim-ui_size-3xs);
      border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));
      color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host(:focus) {
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    /* :host([disabled]) {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
    } */
  `;
let N = Qi;
vt([
  d({ type: String, reflect: !0 })
], N.prototype, "icon", 2);
vt([
  d({ type: String, reflect: !0 })
], N.prototype, "label", 2);
vt([
  d({ type: String, reflect: !0 })
], N.prototype, "name", 2);
vt([
  d({ type: String, reflect: !0 })
], N.prototype, "placeholder", 2);
vt([
  d({ type: String, reflect: !0 })
], N.prototype, "value", 2);
vt([
  d({ type: Boolean, reflect: !0 })
], N.prototype, "vertical", 2);
vt([
  d({ type: Number, reflect: !0 })
], N.prototype, "debounce", 2);
vt([
  d({ type: String, reflect: !0 })
], N.prototype, "type", 1);
var Ol = Object.defineProperty, kl = Object.getOwnPropertyDescriptor, Is = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? kl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Ol(t, e, n), n;
};
const Yi = class Yi extends w {
  constructor() {
    super(...arguments), this.rows = 2, this._vertical = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      this.vertical ? e.setAttribute("label-hidden", "") : e.removeAttribute("label-hidden");
  }
  render() {
    return m`
      <style>
        .parent {
          grid-auto-flow: ${this.vertical ? "row" : "column"};
          grid-template-rows: repeat(${this.rows}, 1fr);
        }
      </style>
      <div class="parent">
        <slot @slotchange=${this.updateChildren}></slot>
      </div>
    `;
  }
};
Yi.styles = C`
    .parent {
      display: grid;
      gap: 0.25rem;
    }

    ::slotted(bim-button[label]:not([vertical])) {
      --bim-button--jc: flex-start;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }
  `;
let Mt = Yi;
Is([
  d({ type: Number, reflect: !0 })
], Mt.prototype, "rows", 2);
Is([
  d({ type: Boolean, reflect: !0 })
], Mt.prototype, "vertical", 1);
var Pl = Object.defineProperty, Tl = Object.getOwnPropertyDescriptor, Ue = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Tl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Pl(t, e, n), n;
};
const Gi = class Gi extends w {
  constructor() {
    super(...arguments), this._vertical = !1, this._labelHidden = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  set labelHidden(t) {
    this._labelHidden = t, this.updateChildren();
  }
  get labelHidden() {
    return this._labelHidden;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      e instanceof Mt && (e.vertical = this.vertical), e.toggleAttribute("label-hidden", this.vertical);
  }
  render() {
    return m`
      <div class="parent">
        <div class="children">
          <slot @slotchange=${this.updateChildren}></slot>
        </div>
        ${!this.labelHidden && (this.label || this.icon) ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
      </div>
    `;
  }
};
Gi.styles = C`
    :host {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-label--c: var(--bim-ui_bg-contrast-60);
      display: block;
      flex: 1;
    }

    :host(:not([vertical])) ::slotted(bim-button[vertical]) {
      --bim-icon--fz: var(--bim-ui_size-5xl);
      min-height: 3.75rem;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }

    .parent {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      height: 100%;
      box-sizing: border-box;
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: row-reverse;
    }

    :host([vertical]) .parent > bim-label {
      writing-mode: tb;
    }

    .children {
      display: flex;
      gap: 0.25rem;
    }

    :host([vertical]) .children {
      flex-direction: column;
    }
  `;
let pt = Gi;
Ue([
  d({ type: String, reflect: !0 })
], pt.prototype, "label", 2);
Ue([
  d({ type: String, reflect: !0 })
], pt.prototype, "icon", 2);
Ue([
  d({ type: Boolean, reflect: !0 })
], pt.prototype, "vertical", 1);
Ue([
  d({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], pt.prototype, "labelHidden", 1);
const _ = class _ {
  static set config(t) {
    this._config = { ..._._config, ...t };
  }
  static get config() {
    return _._config;
  }
  static addGlobalStyles() {
    let t = document.querySelector("style[id='bim-ui']");
    if (t)
      return;
    t = document.createElement("style"), t.id = "bim-ui", t.textContent = At.globalStyles.cssText;
    const e = document.head.firstChild;
    e ? document.head.insertBefore(t, e) : document.head.append(t);
  }
  static defineCustomElement(t, e) {
    customElements.get(t) || customElements.define(t, e);
  }
  /**
   * @deprecated Use `Manager.init()` instead.
   */
  static registerComponents() {
    _.init();
  }
  /**
   * Initializes the BIM UI library by defining custom elements.
   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.
   *
   * @example
   * ```typescript
   * import { Manager } from "@thatopen/ui";
   * Manager.init();
   * ```
   */
  static init() {
    _.addGlobalStyles(), _.defineCustomElement("bim-button", Vo), _.defineCustomElement("bim-checkbox", at), _.defineCustomElement("bim-color-input", X), _.defineCustomElement("bim-context-menu", Oe), _.defineCustomElement("bim-dropdown", B), _.defineCustomElement("bim-grid", ie), _.defineCustomElement("bim-icon", fi), _.defineCustomElement("bim-input", Et), _.defineCustomElement("bim-label", ct), _.defineCustomElement("bim-number-input", L), _.defineCustomElement("bim-option", P), _.defineCustomElement("bim-panel", ut), _.defineCustomElement("bim-panel-section", ht), _.defineCustomElement("bim-selector", dt), _.defineCustomElement("bim-table", J), _.defineCustomElement("bim-tabs", K), _.defineCustomElement("bim-tab", I), _.defineCustomElement("bim-table-cell", Pe), _.defineCustomElement("bim-table-children", Te), _.defineCustomElement("bim-table-group", Le), _.defineCustomElement("bim-table-row", ft), _.defineCustomElement("bim-text-input", N), _.defineCustomElement("bim-toolbar", jt), _.defineCustomElement("bim-toolbar-group", Mt), _.defineCustomElement(
      "bim-toolbar-section",
      pt
    ), _.defineCustomElement("bim-viewport", Ie);
  }
  static newRandomId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let e = "";
    for (let s = 0; s < 10; s++) {
      const n = Math.floor(Math.random() * t.length);
      e += t.charAt(n);
    }
    return e;
  }
};
_._config = {
  sectionLabelOnVerticalToolbar: !1
  // draggableToolbars: true,
  // draggablePanels: true,
};
let pi = _;
var Ll = Object.defineProperty, Il = Object.getOwnPropertyDescriptor, Si = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Il(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Ll(t, e, n), n;
};
const Xi = class Xi extends w {
  constructor() {
    super(...arguments), this.labelsHidden = !1, this._vertical = !1, this._hidden = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateSections();
  }
  get vertical() {
    return this._vertical;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  // private setActivationButton() {
  //   this.activationButton.draggable = Manager.config.draggableToolbars;
  //   this.activationButton.addEventListener(
  //     "click",
  //     () => (this.hidden = !this.hidden),
  //   );
  //   this.activationButton.setAttribute("data-ui-manager-id", this._managerID);
  //   this.activationButton.addEventListener("dragstart", (e) => {
  //     const id = this.getAttribute("data-ui-manager-id");
  //     if (e.dataTransfer && id) {
  //       e.dataTransfer.setData("id", id);
  //       e.dataTransfer.effectAllowed = "move";
  //     }
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       if (container === this.parentElement) continue;
  //       container.dropping = true;
  //     }
  //   });
  //   this.activationButton.addEventListener("dragend", (e) => {
  //     if (e.dataTransfer) e.dataTransfer.clearData();
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       container.dropping = false;
  //     }
  //   });
  // }
  updateSections() {
    const t = this.children;
    for (const e of t)
      e instanceof pt && (e.labelHidden = this.vertical && !pi.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);
  }
  // firstUpdated() {
  //   this.setAttribute("data-ui-manager-id", this._managerID);
  // }
  render() {
    return m`
      <div class="parent">
        <slot @slotchange=${this.updateSections}></slot>
      </div>
    `;
  }
};
Xi.styles = C`
    :host {
      --bim-button--bgc: transparent;
      background-color: var(--bim-ui_bg-base);
      border-radius: var(--bim-ui_size-2xs);
      display: block;
    }

    :host([hidden]) {
      display: none;
    }

    .parent {
      display: flex;
      width: min-content;
      pointer-events: auto;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    :host([vertical]) {
      width: min-content;
      border-radius: var(--bim-ui_size-2xs);
      border: 1px solid var(--bim-ui_bg-contrast-20);
    }

    ::slotted(bim-toolbar-section:not(:last-child)) {
      border-right: 1px solid var(--bim-ui_bg-contrast-20);
      border-bottom: none;
    }

    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {
      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      border-right: none;
    }
  `;
let jt = Xi;
Si([
  d({ type: String, reflect: !0 })
], jt.prototype, "icon", 2);
Si([
  d({ type: Boolean, attribute: "labels-hidden", reflect: !0 })
], jt.prototype, "labelsHidden", 2);
Si([
  d({ type: Boolean, reflect: !0 })
], jt.prototype, "vertical", 1);
var zl = Object.defineProperty, Rl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && zl(t, e, n), n;
};
const Ji = class Ji extends w {
  constructor() {
    super(), this._onResize = new Event("resize"), new ResizeObserver(() => {
      setTimeout(() => {
        this.dispatchEvent(this._onResize);
      });
    }).observe(this);
  }
  render() {
    return m`
      <div class="parent">
        <slot></slot>
      </div>
    `;
  }
};
Ji.styles = C`
    :host {
      display: grid;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .parent {
      overflow: hidden;
      position: relative;
    }
  `;
let Ie = Ji;
Rl([
  d({ type: String, reflect: !0 })
], Ie.prototype, "name");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const zs = "important", Ml = " !" + zs, Dl = ls(class extends as {
  constructor(i) {
    var t;
    if (super(i), i.type !== os.ATTRIBUTE || i.name !== "style" || ((t = i.strings) == null ? void 0 : t.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return Object.keys(i).reduce((t, e) => {
      const s = i[e];
      return s == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s};`;
    }, "");
  }
  update(i, [t]) {
    const { style: e } = i.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const s of this.ft)
      t[s] == null && (this.ft.delete(s), s.includes("-") ? e.removeProperty(s) : e[s] = null);
    for (const s in t) {
      const n = t[s];
      if (n != null) {
        this.ft.add(s);
        const r = typeof n == "string" && n.endsWith(Ml);
        s.includes("-") || r ? e.setProperty(s, r ? n.slice(0, -11) : n, r ? zs : "") : e[s] = n;
      }
    }
    return Ct;
  }
});
export {
  Vo as Button,
  at as Checkbox,
  X as ColorInput,
  Jo as Component,
  Oe as ContextMenu,
  B as Dropdown,
  ie as Grid,
  fi as Icon,
  Et as Input,
  ct as Label,
  pi as Manager,
  L as NumberInput,
  P as Option,
  ut as Panel,
  ht as PanelSection,
  dt as Selector,
  I as Tab,
  J as Table,
  Pe as TableCell,
  Te as TableChildren,
  Le as TableGroup,
  ft as TableRow,
  K as Tabs,
  N as TextInput,
  jt as Toolbar,
  Mt as ToolbarGroup,
  pt as ToolbarSection,
  Ie as Viewport,
  m as html,
  st as ref,
  Dl as styleMap
};
