import { Fragment, FragmentsGroup } from "@thatopen/fragments";
import * as THREE from "three";
import * as FRAGS from "@thatopen/fragments";
import { Component, Components, Event, Disposable } from "../../core";
import { RelationsMap } from "../../ifc/IfcRelationsIndexer/src/types";
/**
 * Component to load, delete and manage [fragments](https://github.com/ThatOpen/engine_fragment) efficiently. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/FragmentsManager). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/FragmentsManager).
 */
export declare class FragmentsManager extends Component implements Disposable {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "fef46874-46a3-461b-8c44-2922ab77c806";
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event<unknown>;
    /**
     * Event triggered when fragments are loaded.
     */
    readonly onFragmentsLoaded: Event<FragmentsGroup>;
    /**
     * Event triggered when fragments are disposed.
     */
    readonly onFragmentsDisposed: Event<{
        groupID: string;
        fragmentIDs: string[];
    }>;
    /**
     * Map containing all loaded fragments.
     * The key is the fragment's unique identifier, and the value is the fragment itself.
     */
    readonly list: Map<string, Fragment>;
    /**
     * Map containing all loaded fragment groups.
     * The key is the group's unique identifier, and the value is the group itself.
     */
    readonly groups: Map<string, FragmentsGroup>;
    baseCoordinationModel: string;
    /** {@link Component.enabled} */
    enabled: boolean;
    private _loader;
    /**
     * Getter for the meshes of all fragments in the FragmentsManager.
     * It iterates over the fragments in the list and pushes their meshes into an array.
     * @returns {THREE.Mesh[]} An array of THREE.Mesh objects representing the fragments.
     */
    get meshes(): THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>[];
    constructor(components: Components);
    /** {@link Disposable.dispose} */
    dispose(): void;
    /**
     * Dispose of a specific fragment group.
     * This method removes the group from the groups map, deletes all fragments within the group from the list,
     * disposes of the group, and triggers the onFragmentsDisposed event.
     *
     * @param group - The fragment group to be disposed.
     */
    disposeGroup(group: FragmentsGroup): void;
    /**
     * Loads a binary file that contain fragment geometry.
     * @param data - The binary data to load.
     * @param config - Optional configuration for loading.
     * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
     * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
     * @returns The loaded FragmentsGroup.
     */
    load(data: Uint8Array, config?: Partial<{
        coordinate: boolean;
        name: string;
        properties: FRAGS.IfcProperties;
        relationsMap: RelationsMap;
    }>): FragmentsGroup;
    /**
     * Export the specified fragmentsgroup to binary data.
     * @param group - the fragments group to be exported.
     * @returns the exported data as binary buffer.
     */
    export(group: FragmentsGroup): Uint8Array;
    /**
     * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
     * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
     * @returns A map of model IDs to sets of express IDs.
     */
    getModelIdMap(fragmentIdMap: FRAGS.FragmentIdMap): {
        [modelID: string]: Set<number>;
    };
    /**
     * Converts a map of model IDs to sets of express IDs to a fragment ID map.
     * @param modelIdMap - A map of model IDs to their corresponding express IDs.
     * @returns A fragment ID map.
     * @remarks
     * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
     * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
     * The fragment ID maps are then merged into a single map and returned.
     * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
     */
    modelIdToFragmentIdMap(modelIdMap: {
        [modelID: string]: Set<number>;
    }): FRAGS.FragmentIdMap;
    /**
     * Applies coordinate transformation to the provided models.
     * If no models are provided, all groups are used.
     * The first model in the list becomes the base model for coordinate transformation.
     * All other models are then transformed to match the base model's coordinate system.
     *
     * @param models - The models to apply coordinate transformation to.
     * If not provided, all groups are used.
     *
     * @returns {void}
     */
    coordinate(models?: FragmentsGroup[]): void;
}
