"use strict";var De=Object.defineProperty;var Ue=(a,t,s)=>t in a?De(a,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[t]=s;var S=(a,t,s)=>(Ue(a,typeof t!="symbol"?t+"":t,s),s);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const v=require("three");function ze(a){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const s in a)if(s!=="default"){const e=Object.getOwnPropertyDescriptor(a,s);Object.defineProperty(t,s,e.get?e:{enumerable:!0,get:()=>a[s]})}}return t.default=a,Object.freeze(t)}const L=ze(v);class Ns extends L.InstancedMesh{constructor(s,e,i,n){super(s,e,i);S(this,"fragment");S(this,"material");S(this,"geometry");if(Array.isArray(e)||(e=[e]),this.material=e,!s.index)throw new Error("The geometry for fragments must be indexed!");this.geometry=s,this.fragment=n;const r=s.index.count;s.groups.length||s.groups.push({start:0,count:r,materialIndex:0})}exportData(){const s=this.geometry.attributes.position.array,e=this.geometry.attributes.normal.array,i=Array.from(this.geometry.index.array),n=[];for(const f of this.geometry.groups){const l=f.materialIndex||0,{start:b,count:h}=f;n.push(b,h,l)}const r=[];if(Array.isArray(this.material))for(const f of this.material){const l=f.opacity,b=f.transparent?1:0,h=new L.Color(f.color).toArray();r.push(l,b,...h)}const o=Array.from(this.instanceMatrix.array);let c;return this.instanceColor!==null?c=Array.from(this.instanceColor.array):c=[],{position:s,normal:e,index:i,groups:n,materials:r,matrices:o,colors:c}}}const Fe=0,Ee=1,Ge=2,oe=2,Cs=1.25,ce=1,gs=6*4+4+4,Vs=65535,Re=Math.pow(2,-24),Ps=Symbol("SKIP_GENERATION");function Ne(a){return a.index?a.index.count:a.attributes.position.count}function Kt(a){return Ne(a)/3}function ke(a,t=ArrayBuffer){return a>65535?new Uint32Array(new t(4*a)):new Uint16Array(new t(2*a))}function qe(a,t){if(!a.index){const s=a.attributes.position.count,e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=ke(s,e);a.setIndex(new v.BufferAttribute(i,1));for(let n=0;n<s;n++)i[n]=n}}function Ce(a){const t=Kt(a),s=a.drawRange,e=s.start/3,i=(s.start+s.count)/3,n=Math.max(0,e),r=Math.min(t,i)-n;return[{offset:Math.floor(n),count:Math.floor(r)}]}function Pe(a){if(!a.groups||!a.groups.length)return Ce(a);const t=[],s=new Set,e=a.drawRange,i=e.start/3,n=(e.start+e.count)/3;for(const o of a.groups){const c=o.start/3,f=(o.start+o.count)/3;s.add(Math.max(i,c)),s.add(Math.min(n,f))}const r=Array.from(s.values()).sort((o,c)=>o-c);for(let o=0;o<r.length-1;o++){const c=r[o],f=r[o+1];t.push({offset:Math.floor(c),count:Math.floor(f-c)})}return t}function je(a){if(a.groups.length===0)return!1;const t=Kt(a),s=Pe(a).sort((n,r)=>n.offset-r.offset),e=s[s.length-1];e.count=Math.min(t-e.offset,e.count);let i=0;return s.forEach(({count:n})=>i+=n),t!==i}function R(a,t,s){return s.min.x=t[a],s.min.y=t[a+1],s.min.z=t[a+2],s.max.x=t[a+3],s.max.y=t[a+4],s.max.z=t[a+5],s}function Ke(a){a[0]=a[1]=a[2]=1/0,a[3]=a[4]=a[5]=-1/0}function ae(a){let t=-1,s=-1/0;for(let e=0;e<3;e++){const i=a[e+3]-a[e];i>s&&(s=i,t=e)}return t}function fe(a,t){t.set(a)}function le(a,t,s){let e,i;for(let n=0;n<3;n++){const r=n+3;e=a[n],i=t[n],s[n]=e<i?e:i,e=a[r],i=t[r],s[r]=e>i?e:i}}function is(a,t,s){for(let e=0;e<3;e++){const i=t[a+2*e],n=t[a+2*e+1],r=i-n,o=i+n;r<s[e]&&(s[e]=r),o>s[e+3]&&(s[e+3]=o)}}function Ht(a){const t=a[3]-a[0],s=a[4]-a[1],e=a[5]-a[2];return 2*(t*s+s*e+e*t)}function Ms(a,t,s,e,i=null){let n=1/0,r=1/0,o=1/0,c=-1/0,f=-1/0,l=-1/0,b=1/0,h=1/0,u=1/0,_=-1/0,x=-1/0,y=-1/0;const d=i!==null;for(let p=t*6,I=(t+s)*6;p<I;p+=6){const m=a[p+0],g=a[p+1],A=m-g,C=m+g;A<n&&(n=A),C>c&&(c=C),d&&m<b&&(b=m),d&&m>_&&(_=m);const w=a[p+2],P=a[p+3],V=w-P,B=w+P;V<r&&(r=V),B>f&&(f=B),d&&w<h&&(h=w),d&&w>x&&(x=w);const F=a[p+4],M=a[p+5],T=F-M,O=F+M;T<o&&(o=T),O>l&&(l=O),d&&F<u&&(u=F),d&&F>y&&(y=F)}e[0]=n,e[1]=r,e[2]=o,e[3]=c,e[4]=f,e[5]=l,d&&(i[0]=b,i[1]=h,i[2]=u,i[3]=_,i[4]=x,i[5]=y)}function $e(a,t,s,e){let i=1/0,n=1/0,r=1/0,o=-1/0,c=-1/0,f=-1/0;for(let l=t*6,b=(t+s)*6;l<b;l+=6){const h=a[l+0];h<i&&(i=h),h>o&&(o=h);const u=a[l+2];u<n&&(n=u),u>c&&(c=u);const _=a[l+4];_<r&&(r=_),_>f&&(f=_)}e[0]=i,e[1]=n,e[2]=r,e[3]=o,e[4]=c,e[5]=f}function He(a,t){Ke(t);const s=a.attributes.position,e=a.index?a.index.array:null,i=Kt(a),n=new Float32Array(i*6),r=s.normalized,o=s.array,c=s.offset||0;let f=3;s.isInterleavedBufferAttribute&&(f=s.data.stride);const l=["getX","getY","getZ"];for(let b=0;b<i;b++){const h=b*3,u=b*6;let _=h+0,x=h+1,y=h+2;e&&(_=e[_],x=e[x],y=e[y]),r||(_=_*f+c,x=x*f+c,y=y*f+c);for(let d=0;d<3;d++){let p,I,m;r?(p=s[l[d]](_),I=s[l[d]](x),m=s[l[d]](y)):(p=o[_+d],I=o[x+d],m=o[y+d]);let g=p;I<g&&(g=I),m<g&&(g=m);let A=p;I>A&&(A=I),m>A&&(A=m);const C=(A-g)/2,w=d*2;n[u+w+0]=g+C,n[u+w+1]=C+(Math.abs(g)+C)*Re,g<t[d]&&(t[d]=g),A>t[d+3]&&(t[d+3]=A)}}return n}const at=32,Xe=(a,t)=>a.candidate-t.candidate,mt=new Array(at).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),ns=new Float32Array(6);function Ye(a,t,s,e,i,n){let r=-1,o=0;if(n===Fe)r=ae(t),r!==-1&&(o=(t[r]+t[r+3])/2);else if(n===Ee)r=ae(a),r!==-1&&(o=Ze(s,e,i,r));else if(n===Ge){const c=Ht(a);let f=Cs*i;const l=e*6,b=(e+i)*6;for(let h=0;h<3;h++){const u=t[h],y=(t[h+3]-u)/at;if(i<at/4){const d=[...mt];d.length=i;let p=0;for(let m=l;m<b;m+=6,p++){const g=d[p];g.candidate=s[m+2*h],g.count=0;const{bounds:A,leftCacheBounds:C,rightCacheBounds:w}=g;for(let P=0;P<3;P++)w[P]=1/0,w[P+3]=-1/0,C[P]=1/0,C[P+3]=-1/0,A[P]=1/0,A[P+3]=-1/0;is(m,s,A)}d.sort(Xe);let I=i;for(let m=0;m<I;m++){const g=d[m];for(;m+1<I&&d[m+1].candidate===g.candidate;)d.splice(m+1,1),I--}for(let m=l;m<b;m+=6){const g=s[m+2*h];for(let A=0;A<I;A++){const C=d[A];g>=C.candidate?is(m,s,C.rightCacheBounds):(is(m,s,C.leftCacheBounds),C.count++)}}for(let m=0;m<I;m++){const g=d[m],A=g.count,C=i-g.count,w=g.leftCacheBounds,P=g.rightCacheBounds;let V=0;A!==0&&(V=Ht(w)/c);let B=0;C!==0&&(B=Ht(P)/c);const F=ce+Cs*(V*A+B*C);F<f&&(r=h,f=F,o=g.candidate)}}else{for(let I=0;I<at;I++){const m=mt[I];m.count=0,m.candidate=u+y+I*y;const g=m.bounds;for(let A=0;A<3;A++)g[A]=1/0,g[A+3]=-1/0}for(let I=l;I<b;I+=6){let A=~~((s[I+2*h]-u)/y);A>=at&&(A=at-1);const C=mt[A];C.count++,is(I,s,C.bounds)}const d=mt[at-1];fe(d.bounds,d.rightCacheBounds);for(let I=at-2;I>=0;I--){const m=mt[I],g=mt[I+1];le(m.bounds,g.rightCacheBounds,m.rightCacheBounds)}let p=0;for(let I=0;I<at-1;I++){const m=mt[I],g=m.count,A=m.bounds,w=mt[I+1].rightCacheBounds;g!==0&&(p===0?fe(A,ns):le(A,ns,ns)),p+=g;let P=0,V=0;p!==0&&(P=Ht(ns)/c);const B=i-p;B!==0&&(V=Ht(w)/c);const F=ce+Cs*(P*p+V*B);F<f&&(r=h,f=F,o=m.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:r,pos:o}}function Ze(a,t,s,e){let i=0;for(let n=t,r=t+s;n<r;n++)i+=a[n*6+e*2];return i/s}class rs{constructor(){}}function Je(a,t,s,e,i,n){let r=e,o=e+i-1;const c=n.pos,f=n.axis*2;for(;;){for(;r<=o&&s[r*6+f]<c;)r++;for(;r<=o&&s[o*6+f]>=c;)o--;if(r<o){for(let l=0;l<3;l++){let b=t[r*3+l];t[r*3+l]=t[o*3+l],t[o*3+l]=b}for(let l=0;l<6;l++){let b=s[r*6+l];s[r*6+l]=s[o*6+l],s[o*6+l]=b}r++,o--}else return r}}function We(a,t,s,e,i,n){let r=e,o=e+i-1;const c=n.pos,f=n.axis*2;for(;;){for(;r<=o&&s[r*6+f]<c;)r++;for(;r<=o&&s[o*6+f]>=c;)o--;if(r<o){let l=a[r];a[r]=a[o],a[o]=l;for(let b=0;b<6;b++){let h=s[r*6+b];s[r*6+b]=s[o*6+b],s[o*6+b]=h}r++,o--}else return r}}function Qe(a,t){const s=(a.index?a.index.count:a.attributes.position.count)/3,e=s>2**16,i=e?4:2,n=t?new SharedArrayBuffer(s*i):new ArrayBuffer(s*i),r=e?new Uint32Array(n):new Uint16Array(n);for(let o=0,c=r.length;o<c;o++)r[o]=o;return r}function ti(a,t){const s=a.geometry,e=s.index?s.index.array:null,i=t.maxDepth,n=t.verbose,r=t.maxLeafTris,o=t.strategy,c=t.onProgress,f=Kt(s),l=a._indirectBuffer;let b=!1;const h=new Float32Array(6),u=new Float32Array(6),_=He(s,h),x=t.indirect?We:Je,y=[],d=t.indirect?Ce(s):Pe(s);if(d.length===1){const m=d[0],g=new rs;g.boundingData=h,$e(_,m.offset,m.count,u),I(g,m.offset,m.count,u),y.push(g)}else for(let m of d){const g=new rs;g.boundingData=new Float32Array(6),Ms(_,m.offset,m.count,g.boundingData,u),I(g,m.offset,m.count,u),y.push(g)}return y;function p(m){c&&c(m/f)}function I(m,g,A,C=null,w=0){if(!b&&w>=i&&(b=!0,n&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),A<=r||w>=i)return p(g+A),m.offset=g,m.count=A,m;const P=Ye(m.boundingData,C,_,g,A,o);if(P.axis===-1)return p(g+A),m.offset=g,m.count=A,m;const V=x(l,e,_,g,A,P);if(V===g||V===g+A)p(g+A),m.offset=g,m.count=A;else{m.splitAxis=P.axis;const B=new rs,F=g,M=V-g;m.left=B,B.boundingData=new Float32Array(6),Ms(_,F,M,B.boundingData,u),I(B,F,M,u,w+1);const T=new rs,O=V,D=A-M;m.right=T,T.boundingData=new Float32Array(6),Ms(_,O,D,T.boundingData,u),I(T,O,D,u,w+1)}return m}}function si(a,t){const s=a.geometry;t.indirect&&(a._indirectBuffer=Qe(s,t.useSharedArrayBuffer),je(s)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),a._indirectBuffer||qe(s,t);const e=ti(a,t);let i,n,r;const o=[],c=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let b=0;b<e.length;b++){const h=e[b];let u=f(h);const _=new c(gs*u);i=new Float32Array(_),n=new Uint32Array(_),r=new Uint16Array(_),l(0,h),o.push(_)}a._roots=o;return;function f(b){return b.count?1:1+f(b.left)+f(b.right)}function l(b,h){const u=b/4,_=b/2,x=!!h.count,y=h.boundingData;for(let d=0;d<6;d++)i[u+d]=y[d];if(x){const d=h.offset,p=h.count;return n[u+6]=d,r[_+14]=p,r[_+15]=Vs,b+gs}else{const d=h.left,p=h.right,I=h.splitAxis;let m;if(m=l(b+gs,d),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[u+6]=m/4,m=l(m,p),n[u+7]=I,m}}}class ut{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,s){let e=1/0,i=-1/0;for(let n=0,r=t.length;n<r;n++){const c=t[n][s];e=c<e?c:e,i=c>i?c:i}this.min=e,this.max=i}setFromPoints(t,s){let e=1/0,i=-1/0;for(let n=0,r=s.length;n<r;n++){const o=s[n],c=t.dot(o);e=c<e?c:e,i=c>i?c:i}this.min=e,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ut.prototype.setFromBox=function(){const a=new v.Vector3;return function(s,e){const i=e.min,n=e.max;let r=1/0,o=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){a.x=i.x*c+n.x*(1-c),a.y=i.y*f+n.y*(1-f),a.z=i.z*l+n.z*(1-l);const b=s.dot(a);r=Math.min(b,r),o=Math.max(b,o)}this.min=r,this.max=o}}();const ei=function(){const a=new v.Vector3,t=new v.Vector3,s=new v.Vector3;return function(i,n,r){const o=i.start,c=a,f=n.start,l=t;s.subVectors(o,f),a.subVectors(i.end,i.start),t.subVectors(n.end,n.start);const b=s.dot(l),h=l.dot(c),u=l.dot(l),_=s.dot(c),y=c.dot(c)*u-h*h;let d,p;y!==0?d=(b*h-_*u)/y:d=0,p=(b+d*h)/u,r.x=d,r.y=p}}(),Qs=function(){const a=new v.Vector2,t=new v.Vector3,s=new v.Vector3;return function(i,n,r,o){ei(i,n,a);let c=a.x,f=a.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,r),n.at(f,o);return}else if(c>=0&&c<=1){f<0?n.at(0,o):n.at(1,o),i.closestPointToPoint(o,!0,r);return}else if(f>=0&&f<=1){c<0?i.at(0,r):i.at(1,r),n.closestPointToPoint(r,!0,o);return}else{let l;c<0?l=i.start:l=i.end;let b;f<0?b=n.start:b=n.end;const h=t,u=s;if(i.closestPointToPoint(b,!0,t),n.closestPointToPoint(l,!0,s),h.distanceToSquared(b)<=u.distanceToSquared(l)){r.copy(h),o.copy(b);return}else{r.copy(l),o.copy(u);return}}}}(),ii=function(){const a=new v.Vector3,t=new v.Vector3,s=new v.Plane,e=new v.Line3;return function(n,r){const{radius:o,center:c}=n,{a:f,b:l,c:b}=r;if(e.start=f,e.end=l,e.closestPointToPoint(c,!0,a).distanceTo(c)<=o||(e.start=f,e.end=b,e.closestPointToPoint(c,!0,a).distanceTo(c)<=o)||(e.start=l,e.end=b,e.closestPointToPoint(c,!0,a).distanceTo(c)<=o))return!0;const x=r.getPlane(s);if(Math.abs(x.distanceToPoint(c))<=o){const d=x.projectPoint(c,t);if(r.containsPoint(d))return!0}return!1}}(),ni=1e-15;function Bs(a){return Math.abs(a)<ni}class rt extends v.Triangle{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new v.Vector3),this.satBounds=new Array(4).fill().map(()=>new ut),this.points=[this.a,this.b,this.c],this.sphere=new v.Sphere,this.plane=new v.Plane,this.needsUpdate=!0}intersectsSphere(t){return ii(t,this)}update(){const t=this.a,s=this.b,e=this.c,i=this.points,n=this.satAxes,r=this.satBounds,o=n[0],c=r[0];this.getNormal(o),c.setFromPoints(o,i);const f=n[1],l=r[1];f.subVectors(t,s),l.setFromPoints(f,i);const b=n[2],h=r[2];b.subVectors(s,e),h.setFromPoints(b,i);const u=n[3],_=r[3];u.subVectors(e,t),_.setFromPoints(u,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}rt.prototype.closestPointToSegment=function(){const a=new v.Vector3,t=new v.Vector3,s=new v.Line3;return function(i,n=null,r=null){const{start:o,end:c}=i,f=this.points;let l,b=1/0;for(let h=0;h<3;h++){const u=(h+1)%3;s.start.copy(f[h]),s.end.copy(f[u]),Qs(s,i,a,t),l=a.distanceToSquared(t),l<b&&(b=l,n&&n.copy(a),r&&r.copy(t))}return this.closestPointToPoint(o,a),l=o.distanceToSquared(a),l<b&&(b=l,n&&n.copy(a),r&&r.copy(o)),this.closestPointToPoint(c,a),l=c.distanceToSquared(a),l<b&&(b=l,n&&n.copy(a),r&&r.copy(c)),Math.sqrt(b)}}();rt.prototype.intersectsTriangle=function(){const a=new rt,t=new Array(3),s=new Array(3),e=new ut,i=new ut,n=new v.Vector3,r=new v.Vector3,o=new v.Vector3,c=new v.Vector3,f=new v.Vector3,l=new v.Line3,b=new v.Line3,h=new v.Line3,u=new v.Vector3;function _(x,y,d){const p=x.points;let I=0,m=-1;for(let g=0;g<3;g++){const{start:A,end:C}=l;A.copy(p[g]),C.copy(p[(g+1)%3]),l.delta(r);const w=Bs(y.distanceToPoint(A));if(Bs(y.normal.dot(r))&&w){d.copy(l),I=2;break}const P=y.intersectLine(l,u);if(!P&&w&&u.copy(A),(P||w)&&!Bs(u.distanceTo(C))){if(I<=1)(I===1?d.start:d.end).copy(u),w&&(m=I);else if(I>=2){(m===1?d.start:d.end).copy(u),I=2;break}if(I++,I===2&&m===-1)break}}return I}return function(y,d=null,p=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(a.copy(y),a.update(),y=a);const I=this.plane,m=y.plane;if(Math.abs(I.normal.dot(m.normal))>1-1e-10){const g=this.satBounds,A=this.satAxes;s[0]=y.a,s[1]=y.b,s[2]=y.c;for(let P=0;P<4;P++){const V=g[P],B=A[P];if(e.setFromPoints(B,s),V.isSeparated(e))return!1}const C=y.satBounds,w=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let P=0;P<4;P++){const V=C[P],B=w[P];if(e.setFromPoints(B,t),V.isSeparated(e))return!1}for(let P=0;P<4;P++){const V=A[P];for(let B=0;B<4;B++){const F=w[B];if(n.crossVectors(V,F),e.setFromPoints(n,t),i.setFromPoints(n,s),e.isSeparated(i))return!1}}return d&&(p||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const g=_(this,m,b);if(g===1&&y.containsPoint(b.end))return d&&(d.start.copy(b.end),d.end.copy(b.end)),!0;if(g!==2)return!1;const A=_(y,I,h);if(A===1&&this.containsPoint(h.end))return d&&(d.start.copy(h.end),d.end.copy(h.end)),!0;if(A!==2)return!1;if(b.delta(o),h.delta(c),o.dot(c)<0){let M=h.start;h.start=h.end,h.end=M}const C=b.start.dot(o),w=b.end.dot(o),P=h.start.dot(o),V=h.end.dot(o),B=w<P,F=C<V;return C!==V&&P!==w&&B===F?!1:(d&&(f.subVectors(b.start,h.start),f.dot(o)>0?d.start.copy(b.start):d.start.copy(h.start),f.subVectors(b.end,h.end),f.dot(o)<0?d.end.copy(b.end):d.end.copy(h.end)),!0)}}}();rt.prototype.distanceToPoint=function(){const a=new v.Vector3;return function(s){return this.closestPointToPoint(s,a),s.distanceTo(a)}}();rt.prototype.distanceToTriangle=function(){const a=new v.Vector3,t=new v.Vector3,s=["a","b","c"],e=new v.Line3,i=new v.Line3;return function(r,o=null,c=null){const f=o||c?e:null;if(this.intersectsTriangle(r,f))return(o||c)&&(o&&f.getCenter(o),c&&f.getCenter(c)),0;let l=1/0;for(let b=0;b<3;b++){let h;const u=s[b],_=r[u];this.closestPointToPoint(_,a),h=_.distanceToSquared(a),h<l&&(l=h,o&&o.copy(a),c&&c.copy(_));const x=this[u];r.closestPointToPoint(x,a),h=x.distanceToSquared(a),h<l&&(l=h,o&&o.copy(x),c&&c.copy(a))}for(let b=0;b<3;b++){const h=s[b],u=s[(b+1)%3];e.set(this[h],this[u]);for(let _=0;_<3;_++){const x=s[_],y=s[(_+1)%3];i.set(r[x],r[y]),Qs(e,i,a,t);const d=a.distanceToSquared(t);d<l&&(l=d,o&&o.copy(a),c&&c.copy(t))}}return Math.sqrt(l)}}();class H{constructor(t,s,e){this.isOrientedBox=!0,this.min=new v.Vector3,this.max=new v.Vector3,this.matrix=new v.Matrix4,this.invMatrix=new v.Matrix4,this.points=new Array(8).fill().map(()=>new v.Vector3),this.satAxes=new Array(3).fill().map(()=>new v.Vector3),this.satBounds=new Array(3).fill().map(()=>new ut),this.alignedSatBounds=new Array(3).fill().map(()=>new ut),this.needsUpdate=!1,t&&this.min.copy(t),s&&this.max.copy(s),e&&this.matrix.copy(e)}set(t,s,e){this.min.copy(t),this.max.copy(s),this.matrix.copy(e),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}H.prototype.update=function(){return function(){const t=this.matrix,s=this.min,e=this.max,i=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let b=0;b<=1;b++){const h=1*f|2*l|4*b,u=i[h];u.x=f?e.x:s.x,u.y=l?e.y:s.y,u.z=b?e.z:s.z,u.applyMatrix4(t)}const n=this.satBounds,r=this.satAxes,o=i[0];for(let f=0;f<3;f++){const l=r[f],b=n[f],h=1<<f,u=i[h];l.subVectors(o,u),b.setFromPoints(l,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();H.prototype.intersectsBox=function(){const a=new ut;return function(s){this.needsUpdate&&this.update();const e=s.min,i=s.max,n=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(a.min=e.x,a.max=i.x,o[0].isSeparated(a)||(a.min=e.y,a.max=i.y,o[1].isSeparated(a))||(a.min=e.z,a.max=i.z,o[2].isSeparated(a)))return!1;for(let c=0;c<3;c++){const f=r[c],l=n[c];if(a.setFromBox(f,s),l.isSeparated(a))return!1}return!0}}();H.prototype.intersectsTriangle=function(){const a=new rt,t=new Array(3),s=new ut,e=new ut,i=new v.Vector3;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(a.copy(r),a.update(),r=a);const o=this.satBounds,c=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let h=0;h<3;h++){const u=o[h],_=c[h];if(s.setFromPoints(_,t),u.isSeparated(s))return!1}const f=r.satBounds,l=r.satAxes,b=this.points;for(let h=0;h<3;h++){const u=f[h],_=l[h];if(s.setFromPoints(_,b),u.isSeparated(s))return!1}for(let h=0;h<3;h++){const u=c[h];for(let _=0;_<4;_++){const x=l[_];if(i.crossVectors(u,x),s.setFromPoints(i,t),e.setFromPoints(i,b),s.isSeparated(e))return!1}}return!0}}();H.prototype.closestPointToPoint=function(){return function(t,s){return this.needsUpdate&&this.update(),s.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),s}}();H.prototype.distanceToPoint=function(){const a=new v.Vector3;return function(s){return this.closestPointToPoint(s,a),s.distanceTo(a)}}();H.prototype.distanceToBox=function(){const a=["x","y","z"],t=new Array(12).fill().map(()=>new v.Line3),s=new Array(12).fill().map(()=>new v.Line3),e=new v.Vector3,i=new v.Vector3;return function(r,o=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||f)&&(r.getCenter(i),this.closestPointToPoint(i,e),r.closestPointToPoint(e,i),c&&c.copy(e),f&&f.copy(i)),0;const l=o*o,b=r.min,h=r.max,u=this.points;let _=1/0;for(let y=0;y<8;y++){const d=u[y];i.copy(d).clamp(b,h);const p=d.distanceToSquared(i);if(p<_&&(_=p,c&&c.copy(d),f&&f.copy(i),p<l))return Math.sqrt(p)}let x=0;for(let y=0;y<3;y++)for(let d=0;d<=1;d++)for(let p=0;p<=1;p++){const I=(y+1)%3,m=(y+2)%3,g=d<<I|p<<m,A=1<<y|d<<I|p<<m,C=u[g],w=u[A];t[x].set(C,w);const V=a[y],B=a[I],F=a[m],M=s[x],T=M.start,O=M.end;T[V]=b[V],T[B]=d?b[B]:h[B],T[F]=p?b[F]:h[B],O[V]=h[V],O[B]=d?b[B]:h[B],O[F]=p?b[F]:h[B],x++}for(let y=0;y<=1;y++)for(let d=0;d<=1;d++)for(let p=0;p<=1;p++){i.x=y?h.x:b.x,i.y=d?h.y:b.y,i.z=p?h.z:b.z,this.closestPointToPoint(i,e);const I=i.distanceToSquared(e);if(I<_&&(_=I,c&&c.copy(e),f&&f.copy(i),I<l))return Math.sqrt(I)}for(let y=0;y<12;y++){const d=t[y];for(let p=0;p<12;p++){const I=s[p];Qs(d,I,e,i);const m=e.distanceToSquared(i);if(m<_&&(_=m,c&&c.copy(e),f&&f.copy(i),m<l))return Math.sqrt(m)}}return Math.sqrt(_)}}();class te{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ri extends te{constructor(){super(()=>new rt)}}const Q=new ri;function Z(a,t){return t[a+15]===65535}function J(a,t){return t[a+6]}function tt(a,t){return t[a+14]}function st(a){return a+8}function et(a,t){return t[a+6]}function Me(a,t){return t[a+7]}class oi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let s=null;this.setBuffer=e=>{s&&t.push(s),s=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{s=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const G=new oi;let xt,jt;const Lt=[],os=new te(()=>new v.Box3);function ci(a,t,s,e,i,n){xt=os.getPrimitive(),jt=os.getPrimitive(),Lt.push(xt,jt),G.setBuffer(a._roots[t]);const r=ks(0,a.geometry,s,e,i,n);G.clearBuffer(),os.releasePrimitive(xt),os.releasePrimitive(jt),Lt.pop(),Lt.pop();const o=Lt.length;return o>0&&(jt=Lt[o-1],xt=Lt[o-2]),r}function ks(a,t,s,e,i=null,n=0,r=0){const{float32Array:o,uint16Array:c,uint32Array:f}=G;let l=a*2;if(Z(l,c)){const h=J(a,f),u=tt(l,c);return R(a,o,xt),e(h,u,!1,r,n+a,xt)}else{let V=function(F){const{uint16Array:M,uint32Array:T}=G;let O=F*2;for(;!Z(O,M);)F=st(F),O=F*2;return J(F,T)},B=function(F){const{uint16Array:M,uint32Array:T}=G;let O=F*2;for(;!Z(O,M);)F=et(F,T),O=F*2;return J(F,T)+tt(O,M)};const h=st(a),u=et(a,f);let _=h,x=u,y,d,p,I;if(i&&(p=xt,I=jt,R(_,o,p),R(x,o,I),y=i(p),d=i(I),d<y)){_=u,x=h;const F=y;y=d,d=F,p=I}p||(p=xt,R(_,o,p));const m=Z(_*2,c),g=s(p,m,y,r+1,n+_);let A;if(g===oe){const F=V(_),T=B(_)-F;A=e(F,T,!0,r+1,n+_,p)}else A=g&&ks(_,t,s,e,i,n,r+1);if(A)return!0;I=jt,R(x,o,I);const C=Z(x*2,c),w=s(I,C,d,r+1,n+x);let P;if(w===oe){const F=V(x),T=B(x)-F;P=e(F,T,!0,r+1,n+x,I)}else P=w&&ks(x,t,s,e,i,n,r+1);return!!P}}const Xt=new v.Vector3,Ss=new v.Vector3;function ai(a,t,s={},e=0,i=1/0){const n=e*e,r=i*i;let o=1/0,c=null;if(a.shapecast({boundsTraverseOrder:l=>(Xt.copy(t).clamp(l.min,l.max),Xt.distanceToSquared(t)),intersectsBounds:(l,b,h)=>h<o&&h<r,intersectsTriangle:(l,b)=>{l.closestPointToPoint(t,Xt);const h=t.distanceToSquared(Xt);return h<o&&(Ss.copy(Xt),o=h,c=b),h<n}}),o===1/0)return null;const f=Math.sqrt(o);return s.point?s.point.copy(Ss):s.point=Ss.clone(),s.distance=f,s.faceIndex=c,s}const Dt=new v.Vector3,Ut=new v.Vector3,zt=new v.Vector3,cs=new v.Vector2,as=new v.Vector2,fs=new v.Vector2,he=new v.Vector3,be=new v.Vector3,ue=new v.Vector3,ls=new v.Vector3;function fi(a,t,s,e,i,n){let r;return n===v.BackSide?r=a.intersectTriangle(e,s,t,!0,i):r=a.intersectTriangle(t,s,e,n!==v.DoubleSide,i),r===null?null:{distance:a.origin.distanceTo(i),point:i.clone()}}function li(a,t,s,e,i,n,r,o,c){Dt.fromBufferAttribute(t,n),Ut.fromBufferAttribute(t,r),zt.fromBufferAttribute(t,o);const f=fi(a,Dt,Ut,zt,ls,c);if(f){e&&(cs.fromBufferAttribute(e,n),as.fromBufferAttribute(e,r),fs.fromBufferAttribute(e,o),f.uv=v.Triangle.getInterpolation(ls,Dt,Ut,zt,cs,as,fs,new v.Vector2)),i&&(cs.fromBufferAttribute(i,n),as.fromBufferAttribute(i,r),fs.fromBufferAttribute(i,o),f.uv1=v.Triangle.getInterpolation(ls,Dt,Ut,zt,cs,as,fs,new v.Vector2)),s&&(he.fromBufferAttribute(s,n),be.fromBufferAttribute(s,r),ue.fromBufferAttribute(s,o),f.normal=v.Triangle.getInterpolation(ls,Dt,Ut,zt,he,be,ue,new v.Vector3),f.normal.dot(a.direction)>0&&f.normal.multiplyScalar(-1));const l={a:n,b:r,c:o,normal:new v.Vector3,materialIndex:0};v.Triangle.getNormal(Dt,Ut,zt,l.normal),f.face=l,f.faceIndex=n}return f}function vs(a,t,s,e,i){const n=e*3;let r=n+0,o=n+1,c=n+2;const f=a.index;a.index&&(r=f.getX(r),o=f.getX(o),c=f.getX(c));const{position:l,normal:b,uv:h,uv1:u}=a.attributes,_=li(s,l,b,h,u,r,o,c,t);return _?(_.faceIndex=e,i&&i.push(_),_):null}function k(a,t,s,e){const i=a.a,n=a.b,r=a.c;let o=t,c=t+1,f=t+2;s&&(o=s.getX(o),c=s.getX(c),f=s.getX(f)),i.x=e.getX(o),i.y=e.getY(o),i.z=e.getZ(o),n.x=e.getX(c),n.y=e.getY(c),n.z=e.getZ(c),r.x=e.getX(f),r.y=e.getY(f),r.z=e.getZ(f)}function hi(a,t,s,e,i,n){const{geometry:r,_indirectBuffer:o}=a;for(let c=e,f=e+i;c<f;c++)vs(r,t,s,c,n)}function bi(a,t,s,e,i){const{geometry:n,_indirectBuffer:r}=a;let o=1/0,c=null;for(let f=e,l=e+i;f<l;f++){let b;b=vs(n,t,s,f),b&&b.distance<o&&(c=b,o=b.distance)}return c}function ui(a,t,s,e,i,n,r){const{geometry:o}=s,{index:c}=o,f=o.attributes.position;for(let l=a,b=t+a;l<b;l++){let h;if(h=l,k(r,h*3,c,f),r.needsUpdate=!0,e(r,h,i,n))return!0}return!1}function di(a,t=null){t&&Array.isArray(t)&&(t=new Set(t));const s=a.geometry,e=s.index?s.index.array:null,i=s.attributes.position;let n,r,o,c,f=0;const l=a._roots;for(let h=0,u=l.length;h<u;h++)n=l[h],r=new Uint32Array(n),o=new Uint16Array(n),c=new Float32Array(n),b(0,f),f+=n.byteLength;function b(h,u,_=!1){const x=h*2;if(o[x+15]===Vs){const d=r[h+6],p=o[x+14];let I=1/0,m=1/0,g=1/0,A=-1/0,C=-1/0,w=-1/0;for(let P=3*d,V=3*(d+p);P<V;P++){let B=e[P];const F=i.getX(B),M=i.getY(B),T=i.getZ(B);F<I&&(I=F),F>A&&(A=F),M<m&&(m=M),M>C&&(C=M),T<g&&(g=T),T>w&&(w=T)}return c[h+0]!==I||c[h+1]!==m||c[h+2]!==g||c[h+3]!==A||c[h+4]!==C||c[h+5]!==w?(c[h+0]=I,c[h+1]=m,c[h+2]=g,c[h+3]=A,c[h+4]=C,c[h+5]=w,!0):!1}else{const d=h+8,p=r[h+6],I=d+u,m=p+u;let g=_,A=!1,C=!1;t?g||(A=t.has(I),C=t.has(m),g=!A&&!C):(A=!0,C=!0);const w=g||A,P=g||C;let V=!1;w&&(V=b(d,u,g));let B=!1;P&&(B=b(p,u,g));const F=V||B;if(F)for(let M=0;M<3;M++){const T=d+M,O=p+M,D=c[T],$=c[T+3],X=c[O],Y=c[O+3];c[h+M]=D<X?D:X,c[h+M+3]=$>Y?$:Y}return F}}}const de=new v.Box3;function wt(a,t,s,e){return R(a,t,de),s.intersectBox(de,e)}function _i(a,t,s,e,i,n){const{geometry:r,_indirectBuffer:o}=a;for(let c=e,f=e+i;c<f;c++){let l=o?o[c]:c;vs(r,t,s,l,n)}}function pi(a,t,s,e,i){const{geometry:n,_indirectBuffer:r}=a;let o=1/0,c=null;for(let f=e,l=e+i;f<l;f++){let b;b=vs(n,t,s,r?r[f]:f),b&&b.distance<o&&(c=b,o=b.distance)}return c}function mi(a,t,s,e,i,n,r){const{geometry:o}=s,{index:c}=o,f=o.attributes.position;for(let l=a,b=t+a;l<b;l++){let h;if(h=s.resolveTriangleIndex(l),k(r,h*3,c,f),r.needsUpdate=!0,e(r,h,i,n))return!0}return!1}const _e=new v.Vector3;function yi(a,t,s,e,i){G.setBuffer(a._roots[t]),qs(0,a,s,e,i),G.clearBuffer()}function qs(a,t,s,e,i){const{float32Array:n,uint16Array:r,uint32Array:o}=G,c=a*2;if(Z(c,r)){const l=J(a,o),b=tt(c,r);hi(t,s,e,l,b,i)}else{const l=st(a);wt(l,n,e,_e)&&qs(l,t,s,e,i);const b=et(a,o);wt(b,n,e,_e)&&qs(b,t,s,e,i)}}const pe=new v.Vector3,gi=["x","y","z"];function Ii(a,t,s,e){G.setBuffer(a._roots[t]);const i=js(0,a,s,e);return G.clearBuffer(),i}function js(a,t,s,e){const{float32Array:i,uint16Array:n,uint32Array:r}=G;let o=a*2;if(Z(o,n)){const f=J(a,r),l=tt(o,n);return bi(t,s,e,f,l)}else{const f=Me(a,r),l=gi[f],h=e.direction[l]>=0;let u,_;h?(u=st(a),_=et(a,r)):(u=et(a,r),_=st(a));const y=wt(u,i,e,pe)?js(u,t,s,e):null;if(y){const I=y.point[l];if(h?I<=i[_+f]:I>=i[_+f+3])return y}const p=wt(_,i,e,pe)?js(_,t,s,e):null;return y&&p?y.distance<=p.distance?y:p:y||p||null}}const hs=new v.Box3,Et=new rt,Gt=new rt,Yt=new v.Matrix4,me=new H,bs=new H;function xi(a,t,s,e){G.setBuffer(a._roots[t]);const i=Ks(0,a,s,e);return G.clearBuffer(),i}function Ks(a,t,s,e,i=null){const{float32Array:n,uint16Array:r,uint32Array:o}=G;let c=a*2;if(i===null&&(s.boundingBox||s.computeBoundingBox(),me.set(s.boundingBox.min,s.boundingBox.max,e),i=me),Z(c,r)){const l=t.geometry,b=l.index,h=l.attributes.position,u=s.index,_=s.attributes.position,x=J(a,o),y=tt(c,r);if(Yt.copy(e).invert(),s.boundsTree)return R(a,n,bs),bs.matrix.copy(Yt),bs.needsUpdate=!0,s.boundsTree.shapecast({intersectsBounds:p=>bs.intersectsBox(p),intersectsTriangle:p=>{p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let I=x*3,m=(y+x)*3;I<m;I+=3)if(k(Gt,I,b,h),Gt.needsUpdate=!0,p.intersectsTriangle(Gt))return!0;return!1}});for(let d=x*3,p=(y+x)*3;d<p;d+=3){k(Et,d,b,h),Et.a.applyMatrix4(Yt),Et.b.applyMatrix4(Yt),Et.c.applyMatrix4(Yt),Et.needsUpdate=!0;for(let I=0,m=u.count;I<m;I+=3)if(k(Gt,I,u,_),Gt.needsUpdate=!0,Et.intersectsTriangle(Gt))return!0}}else{const l=a+8,b=o[a+6];return R(l,n,hs),!!(i.intersectsBox(hs)&&Ks(l,t,s,e,i)||(R(b,n,hs),i.intersectsBox(hs)&&Ks(b,t,s,e,i)))}}const us=new v.Matrix4,Ts=new H,Zt=new H,wi=new v.Vector3,Ai=new v.Vector3,Vi=new v.Vector3,vi=new v.Vector3;function Fi(a,t,s,e={},i={},n=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Ts.set(t.boundingBox.min,t.boundingBox.max,s),Ts.needsUpdate=!0;const o=a.geometry,c=o.attributes.position,f=o.index,l=t.attributes.position,b=t.index,h=Q.getPrimitive(),u=Q.getPrimitive();let _=wi,x=Ai,y=null,d=null;i&&(y=Vi,d=vi);let p=1/0,I=null,m=null;return us.copy(s).invert(),Zt.matrix.copy(us),a.shapecast({boundsTraverseOrder:g=>Ts.distanceToBox(g),intersectsBounds:(g,A,C)=>C<p&&C<r?(A&&(Zt.min.copy(g.min),Zt.max.copy(g.max),Zt.needsUpdate=!0),!0):!1,intersectsRange:(g,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:w=>Zt.distanceToBox(w),intersectsBounds:(w,P,V)=>V<p&&V<r,intersectsRange:(w,P)=>{for(let V=w,B=w+P;V<B;V++){k(u,3*V,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let F=g,M=g+A;F<M;F++){k(h,3*F,f,c),h.needsUpdate=!0;const T=h.distanceToTriangle(u,_,y);if(T<p&&(x.copy(_),d&&d.copy(y),p=T,I=F,m=V),T<n)return!0}}}});{const C=Kt(t);for(let w=0,P=C;w<P;w++){k(u,3*w,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let V=g,B=g+A;V<B;V++){k(h,3*V,f,c),h.needsUpdate=!0;const F=h.distanceToTriangle(u,_,y);if(F<p&&(x.copy(_),d&&d.copy(y),p=F,I=V,m=w),F<n)return!0}}}}}),Q.releasePrimitive(h),Q.releasePrimitive(u),p===1/0?null:(e.point?e.point.copy(x):e.point=x.clone(),e.distance=p,e.faceIndex=I,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(us),x.applyMatrix4(us),i.distance=x.sub(i.point).length(),i.faceIndex=m),e)}function Ci(a,t=null){t&&Array.isArray(t)&&(t=new Set(t));const s=a.geometry,e=s.index?s.index.array:null,i=s.attributes.position;let n,r,o,c,f=0;const l=a._roots;for(let h=0,u=l.length;h<u;h++)n=l[h],r=new Uint32Array(n),o=new Uint16Array(n),c=new Float32Array(n),b(0,f),f+=n.byteLength;function b(h,u,_=!1){const x=h*2;if(o[x+15]===Vs){const d=r[h+6],p=o[x+14];let I=1/0,m=1/0,g=1/0,A=-1/0,C=-1/0,w=-1/0;for(let P=d,V=d+p;P<V;P++){const B=3*a.resolveTriangleIndex(P);for(let F=0;F<3;F++){let M=B+F;M=e?e[M]:M;const T=i.getX(M),O=i.getY(M),D=i.getZ(M);T<I&&(I=T),T>A&&(A=T),O<m&&(m=O),O>C&&(C=O),D<g&&(g=D),D>w&&(w=D)}}return c[h+0]!==I||c[h+1]!==m||c[h+2]!==g||c[h+3]!==A||c[h+4]!==C||c[h+5]!==w?(c[h+0]=I,c[h+1]=m,c[h+2]=g,c[h+3]=A,c[h+4]=C,c[h+5]=w,!0):!1}else{const d=h+8,p=r[h+6],I=d+u,m=p+u;let g=_,A=!1,C=!1;t?g||(A=t.has(I),C=t.has(m),g=!A&&!C):(A=!0,C=!0);const w=g||A,P=g||C;let V=!1;w&&(V=b(d,u,g));let B=!1;P&&(B=b(p,u,g));const F=V||B;if(F)for(let M=0;M<3;M++){const T=d+M,O=p+M,D=c[T],$=c[T+3],X=c[O],Y=c[O+3];c[h+M]=D<X?D:X,c[h+M+3]=$>Y?$:Y}return F}}}const ye=new v.Vector3;function Pi(a,t,s,e,i){G.setBuffer(a._roots[t]),$s(0,a,s,e,i),G.clearBuffer()}function $s(a,t,s,e,i){const{float32Array:n,uint16Array:r,uint32Array:o}=G,c=a*2;if(Z(c,r)){const l=J(a,o),b=tt(c,r);_i(t,s,e,l,b,i)}else{const l=st(a);wt(l,n,e,ye)&&$s(l,t,s,e,i);const b=et(a,o);wt(b,n,e,ye)&&$s(b,t,s,e,i)}}const ge=new v.Vector3,Mi=["x","y","z"];function Bi(a,t,s,e){G.setBuffer(a._roots[t]);const i=Hs(0,a,s,e);return G.clearBuffer(),i}function Hs(a,t,s,e){const{float32Array:i,uint16Array:n,uint32Array:r}=G;let o=a*2;if(Z(o,n)){const f=J(a,r),l=tt(o,n);return pi(t,s,e,f,l)}else{const f=Me(a,r),l=Mi[f],h=e.direction[l]>=0;let u,_;h?(u=st(a),_=et(a,r)):(u=et(a,r),_=st(a));const y=wt(u,i,e,ge)?Hs(u,t,s,e):null;if(y){const I=y.point[l];if(h?I<=i[_+f]:I>=i[_+f+3])return y}const p=wt(_,i,e,ge)?Hs(_,t,s,e):null;return y&&p?y.distance<=p.distance?y:p:y||p||null}}const ds=new v.Box3,Rt=new rt,Nt=new rt,Jt=new v.Matrix4,Ie=new H,_s=new H;function Si(a,t,s,e){G.setBuffer(a._roots[t]);const i=Xs(0,a,s,e);return G.clearBuffer(),i}function Xs(a,t,s,e,i=null){const{float32Array:n,uint16Array:r,uint32Array:o}=G;let c=a*2;if(i===null&&(s.boundingBox||s.computeBoundingBox(),Ie.set(s.boundingBox.min,s.boundingBox.max,e),i=Ie),Z(c,r)){const l=t.geometry,b=l.index,h=l.attributes.position,u=s.index,_=s.attributes.position,x=J(a,o),y=tt(c,r);if(Jt.copy(e).invert(),s.boundsTree)return R(a,n,_s),_s.matrix.copy(Jt),_s.needsUpdate=!0,s.boundsTree.shapecast({intersectsBounds:p=>_s.intersectsBox(p),intersectsTriangle:p=>{p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let I=x,m=y+x;I<m;I++)if(k(Nt,3*t.resolveTriangleIndex(I),b,h),Nt.needsUpdate=!0,p.intersectsTriangle(Nt))return!0;return!1}});for(let d=x,p=y+x;d<p;d++){const I=t.resolveTriangleIndex(d);k(Rt,3*I,b,h),Rt.a.applyMatrix4(Jt),Rt.b.applyMatrix4(Jt),Rt.c.applyMatrix4(Jt),Rt.needsUpdate=!0;for(let m=0,g=u.count;m<g;m+=3)if(k(Nt,m,u,_),Nt.needsUpdate=!0,Rt.intersectsTriangle(Nt))return!0}}else{const l=a+8,b=o[a+6];return R(l,n,ds),!!(i.intersectsBox(ds)&&Xs(l,t,s,e,i)||(R(b,n,ds),i.intersectsBox(ds)&&Xs(b,t,s,e,i)))}}const ps=new v.Matrix4,Os=new H,Wt=new H,Ti=new v.Vector3,Oi=new v.Vector3,Li=new v.Vector3,Di=new v.Vector3;function Ui(a,t,s,e={},i={},n=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Os.set(t.boundingBox.min,t.boundingBox.max,s),Os.needsUpdate=!0;const o=a.geometry,c=o.attributes.position,f=o.index,l=t.attributes.position,b=t.index,h=Q.getPrimitive(),u=Q.getPrimitive();let _=Ti,x=Oi,y=null,d=null;i&&(y=Li,d=Di);let p=1/0,I=null,m=null;return ps.copy(s).invert(),Wt.matrix.copy(ps),a.shapecast({boundsTraverseOrder:g=>Os.distanceToBox(g),intersectsBounds:(g,A,C)=>C<p&&C<r?(A&&(Wt.min.copy(g.min),Wt.max.copy(g.max),Wt.needsUpdate=!0),!0):!1,intersectsRange:(g,A)=>{if(t.boundsTree){const C=t.boundsTree;return C.shapecast({boundsTraverseOrder:w=>Wt.distanceToBox(w),intersectsBounds:(w,P,V)=>V<p&&V<r,intersectsRange:(w,P)=>{for(let V=w,B=w+P;V<B;V++){const F=C.resolveTriangleIndex(V);k(u,3*F,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let M=g,T=g+A;M<T;M++){const O=a.resolveTriangleIndex(M);k(h,3*O,f,c),h.needsUpdate=!0;const D=h.distanceToTriangle(u,_,y);if(D<p&&(x.copy(_),d&&d.copy(y),p=D,I=M,m=V),D<n)return!0}}}})}else{const C=Kt(t);for(let w=0,P=C;w<P;w++){k(u,3*w,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let V=g,B=g+A;V<B;V++){const F=a.resolveTriangleIndex(V);k(h,3*F,f,c),h.needsUpdate=!0;const M=h.distanceToTriangle(u,_,y);if(M<p&&(x.copy(_),d&&d.copy(y),p=M,I=V,m=w),M<n)return!0}}}}}),Q.releasePrimitive(h),Q.releasePrimitive(u),p===1/0?null:(e.point?e.point.copy(x):e.point=x.clone(),e.distance=p,e.faceIndex=I,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(ps),x.applyMatrix4(ps),i.distance=x.sub(i.point).length(),i.faceIndex=m),e)}function zi(){return typeof SharedArrayBuffer<"u"}const Qt=new G.constructor,ws=new G.constructor,yt=new te(()=>new v.Box3),kt=new v.Box3,qt=new v.Box3,Ls=new v.Box3,Ds=new v.Box3;let Us=!1;function Ei(a,t,s,e){if(Us)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Us=!0;const i=a._roots,n=t._roots;let r,o=0,c=0;const f=new v.Matrix4().copy(s).invert();for(let l=0,b=i.length;l<b;l++){Qt.setBuffer(i[l]),c=0;const h=yt.getPrimitive();R(0,Qt.float32Array,h),h.applyMatrix4(f);for(let u=0,_=n.length;u<_&&(ws.setBuffer(n[l]),r=it(0,0,s,f,e,o,c,0,0,h),ws.clearBuffer(),c+=n[u].length,!r);u++);if(yt.releasePrimitive(h),Qt.clearBuffer(),o+=i[l].length,r)break}return Us=!1,r}function it(a,t,s,e,i,n=0,r=0,o=0,c=0,f=null,l=!1){let b,h;l?(b=ws,h=Qt):(b=Qt,h=ws);const u=b.float32Array,_=b.uint32Array,x=b.uint16Array,y=h.float32Array,d=h.uint32Array,p=h.uint16Array,I=a*2,m=t*2,g=Z(I,x),A=Z(m,p);let C=!1;if(A&&g)l?C=i(J(t,d),tt(t*2,p),J(a,_),tt(a*2,x),c,r+t,o,n+a):C=i(J(a,_),tt(a*2,x),J(t,d),tt(t*2,p),o,n+a,c,r+t);else if(A){const w=yt.getPrimitive();R(t,y,w),w.applyMatrix4(s);const P=st(a),V=et(a,_);R(P,u,kt),R(V,u,qt);const B=w.intersectsBox(kt),F=w.intersectsBox(qt);C=B&&it(t,P,e,s,i,r,n,c,o+1,w,!l)||F&&it(t,V,e,s,i,r,n,c,o+1,w,!l),yt.releasePrimitive(w)}else{const w=st(t),P=et(t,d);R(w,y,Ls),R(P,y,Ds);const V=f.intersectsBox(Ls),B=f.intersectsBox(Ds);if(V&&B)C=it(a,w,s,e,i,n,r,o,c+1,f,l)||it(a,P,s,e,i,n,r,o,c+1,f,l);else if(V)if(g)C=it(a,w,s,e,i,n,r,o,c+1,f,l);else{const F=yt.getPrimitive();F.copy(Ls).applyMatrix4(s);const M=st(a),T=et(a,_);R(M,u,kt),R(T,u,qt);const O=F.intersectsBox(kt),D=F.intersectsBox(qt);C=O&&it(w,M,e,s,i,r,n,c,o+1,F,!l)||D&&it(w,T,e,s,i,r,n,c,o+1,F,!l),yt.releasePrimitive(F)}else if(B)if(g)C=it(a,P,s,e,i,n,r,o,c+1,f,l);else{const F=yt.getPrimitive();F.copy(Ds).applyMatrix4(s);const M=st(a),T=et(a,_);R(M,u,kt),R(T,u,qt);const O=F.intersectsBox(kt),D=F.intersectsBox(qt);C=O&&it(P,M,e,s,i,r,n,c,o+1,F,!l)||D&&it(P,T,e,s,i,r,n,c,o+1,F,!l),yt.releasePrimitive(F)}}return C}const ms=new H,xe=new v.Box3;class se{static serialize(t,s={}){s={cloneBuffers:!0,...s};const e=t.geometry,i=t._roots,n=t._indirectBuffer,r=e.getIndex();let o;return s.cloneBuffers?o={roots:i.map(c=>c.slice()),index:r.array.slice(),indirectBuffer:n?n.slice():null}:o={roots:i,index:r.array,indirectBuffer:n},o}static deserialize(t,s,e={}){e={setIndex:!0,indirect:!!t.indirectBuffer,...e};const{index:i,roots:n,indirectBuffer:r}=t,o=new se(s,{...e,[Ps]:!0});if(o._roots=n,o._indirectBuffer=r||null,e.setIndex){const c=s.getIndex();if(c===null){const f=new v.BufferAttribute(t.index,1,!1);s.setIndex(f)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(t,s={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(s=Object.assign({strategy:Fe,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Ps]:!1},s),s.useSharedArrayBuffer&&!zi())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,s[Ps]||(si(this,s),!t.boundingBox&&s.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new v.Box3)));const{_indirectBuffer:e}=this;this.resolveTriangleIndex=s.indirect?i=>e[i]:i=>i}refit(t=null){return(this.indirect?Ci:di)(this,t)}traverse(t,s=0){const e=this._roots[s],i=new Uint32Array(e),n=new Uint16Array(e);r(0);function r(o,c=0){const f=o*2,l=n[f+15]===Vs;if(l){const b=i[o+6],h=n[f+14];t(c,l,new Float32Array(e,o*4,6),b,h)}else{const b=o+gs/4,h=i[o+6],u=i[o+7];t(c,l,new Float32Array(e,o*4,6),u)||(r(b,c+1),r(h,c+1))}}}raycast(t,s=v.FrontSide){const e=this._roots,i=this.geometry,n=[],r=s.isMaterial,o=Array.isArray(s),c=i.groups,f=r?s.side:s,l=this.indirect?Pi:yi;for(let b=0,h=e.length;b<h;b++){const u=o?s[c[b].materialIndex].side:f,_=n.length;if(l(this,b,u,t,n),o){const x=c[b].materialIndex;for(let y=_,d=n.length;y<d;y++)n[y].face.materialIndex=x}}return n}raycastFirst(t,s=v.FrontSide){const e=this._roots,i=this.geometry,n=s.isMaterial,r=Array.isArray(s);let o=null;const c=i.groups,f=n?s.side:s,l=this.indirect?Bi:Ii;for(let b=0,h=e.length;b<h;b++){const u=r?s[c[b].materialIndex].side:f,_=l(this,b,u,t);_!=null&&(o==null||_.distance<o.distance)&&(o=_,r&&(_.face.materialIndex=c[b].materialIndex))}return o}intersectsGeometry(t,s){let e=!1;const i=this._roots,n=this.indirect?Si:xi;for(let r=0,o=i.length;r<o&&(e=n(this,r,t,s),!e);r++);return e}shapecast(t){const s=Q.getPrimitive(),e=this.indirect?mi:ui;let{boundsTraverseOrder:i,intersectsBounds:n,intersectsRange:r,intersectsTriangle:o}=t;if(r&&o){const b=r;r=(h,u,_,x,y)=>b(h,u,_,x,y)?!0:e(h,u,this,o,_,x,s)}else r||(o?r=(b,h,u,_)=>e(b,h,this,o,u,_,s):r=(b,h,u)=>u);let c=!1,f=0;const l=this._roots;for(let b=0,h=l.length;b<h;b++){const u=l[b];if(c=ci(this,b,n,r,i,f),c)break;f+=u.byteLength}return Q.releasePrimitive(s),c}bvhcast(t,s,e){let{intersectsRanges:i,intersectsTriangles:n}=e;const r=Q.getPrimitive(),o=this.geometry.index,c=this.geometry.attributes.position,f=this.indirect?_=>{const x=this.resolveTriangleIndex(_);k(r,x*3,o,c)}:_=>{k(r,_*3,o,c)},l=Q.getPrimitive(),b=t.geometry.index,h=t.geometry.attributes.position,u=t.indirect?_=>{const x=t.resolveTriangleIndex(_);k(l,x*3,b,h)}:_=>{k(l,_*3,b,h)};if(n){const _=(x,y,d,p,I,m,g,A)=>{for(let C=d,w=d+p;C<w;C++){u(C),l.a.applyMatrix4(s),l.b.applyMatrix4(s),l.c.applyMatrix4(s),l.needsUpdate=!0;for(let P=x,V=x+y;P<V;P++)if(f(P),r.needsUpdate=!0,n(r,l,P,C,I,m,g,A))return!0}return!1};if(i){const x=i;i=function(y,d,p,I,m,g,A,C){return x(y,d,p,I,m,g,A,C)?!0:_(y,d,p,I,m,g,A,C)}}else i=_}return Ei(this,t,s,i)}intersectsBox(t,s){return ms.set(t.min,t.max,s),ms.needsUpdate=!0,this.shapecast({intersectsBounds:e=>ms.intersectsBox(e),intersectsTriangle:e=>ms.intersectsTriangle(e)})}intersectsSphere(t){return this.shapecast({intersectsBounds:s=>t.intersectsBox(s),intersectsTriangle:s=>s.intersectsSphere(t)})}closestPointToGeometry(t,s,e={},i={},n=0,r=1/0){return(this.indirect?Ui:Fi)(this,t,s,e,i,n,r)}closestPointToPoint(t,s={},e=0,i=1/0){return ai(this,t,s,e,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{R(0,new Float32Array(e),xe),t.union(xe)}),t}}function we(a,t,s){return a===null||(a.point.applyMatrix4(t.matrixWorld),a.distance=a.point.distanceTo(s.ray.origin),a.object=t,a.distance<s.near||a.distance>s.far)?null:a}const zs=new v.Ray,Ae=new v.Matrix4,Gi=v.Mesh.prototype.raycast;function Ri(a,t){if(this.geometry.boundsTree){if(this.material===void 0)return;Ae.copy(this.matrixWorld).invert(),zs.copy(a.ray).applyMatrix4(Ae);const s=this.geometry.boundsTree;if(a.firstHitOnly===!0){const e=we(s.raycastFirst(zs,this.material),this,a);e&&t.push(e)}else{const e=s.raycast(zs,this.material);for(let i=0,n=e.length;i<n;i++){const r=we(e[i],this,a);r&&t.push(r)}}}else Gi.call(this,a,t)}function Ni(a){return this.boundsTree=new se(this,a),this.boundsTree}function ki(){this.boundsTree=null}const ts=class ts{static apply(t){ts.initialized||(v.BufferGeometry.prototype.computeBoundsTree=Ni,v.BufferGeometry.prototype.disposeBoundsTree=ki,v.Mesh.prototype.raycast=Ri,ts.initialized=!0),t.boundsTree||t.computeBoundsTree()}static dispose(t){t&&t.disposeBoundsTree&&t.disposeBoundsTree()}};S(ts,"initialized",!1);let As=ts,ee=class{constructor(t,s,e){S(this,"ids",new Set);S(this,"itemToInstances",new Map);S(this,"instanceToItem",new Map);S(this,"hiddenItems",new Set);S(this,"id");S(this,"mesh");S(this,"capacity",0);S(this,"capacityOffset",10);S(this,"group");S(this,"_originalColors",new Map);S(this,"_settingVisibility",!1);this.mesh=new Ns(t,s,e,this),this.id=this.mesh.uuid,this.capacity=e,this.mesh.count=0,this.mesh.geometry.index.count&&As.apply(this.mesh.geometry)}get uniqueVertices(){const t=[],s=this.mesh.geometry.getAttribute("position");if(!s)return t;const e=new Set;for(let i=0;i<s.count;i++){const n=s.getX(i),r=s.getY(i),o=s.getZ(i),c=`${n},${r},${o}`;e.has(c)||(e.add(c),t.push(new L.Vector3(n,r,o)))}return t}dispose(t=!0){if(this.clear(),this.group=void 0,this._originalColors.clear(),this.mesh){if(t){for(const s of this.mesh.material)s.dispose();this.mesh.material=[],As.dispose(this.mesh.geometry),this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.geometry=null}this.mesh.removeFromParent(),this.mesh.userData={},this.mesh.dispose(),this.mesh.fragment=null,this.mesh=null}}get(t){const s=this.getInstancesIDs(t);if(!s)throw new Error("Item not found!");const e=[],i=[];for(const r of s){const o=new L.Matrix4;if(this.mesh.getMatrixAt(r,o),e.push(o),this.mesh.instanceColor){const c=new L.Color;this.mesh.getColorAt(r,c),i.push(c)}}const n=i.length?i:void 0;return{id:t,transforms:e,colors:n}}getItemID(t){return this.instanceToItem.get(t)||null}getInstancesIDs(t){return this.itemToInstances.get(t)||null}update(){this.mesh.instanceColor&&(this.mesh.instanceColor.needsUpdate=!0),this.mesh.instanceMatrix.needsUpdate=!0}add(t){var i;let s=0;for(const n of t)s+=n.transforms.length;const e=this.mesh.count+s;if(e>this.capacity){const n=e+this.capacityOffset,r=new Ns(this.mesh.geometry,this.mesh.material,n,this);r.count=this.mesh.count,this.capacity=n;const o=this.mesh;(i=o.parent)==null||i.add(r),o.removeFromParent(),this.mesh=r;const c=new L.Matrix4;for(let f=0;f<o.instanceMatrix.count;f++)o.getMatrixAt(f,c),r.setMatrixAt(f,c);if(o.instanceColor){const f=new L.Color;for(let l=0;l<o.instanceColor.count;l++)o.getColorAt(l,f),r.setColorAt(l,f)}o.dispose()}for(let n=0;n<t.length;n++){const{transforms:r,colors:o,id:c}=t[n];this.itemToInstances.has(c)||this.itemToInstances.set(c,new Set);const f=this.itemToInstances.get(c);this.ids.add(c);for(let l=0;l<r.length;l++){const b=r[l],h=this.mesh.count;if(this.mesh.setMatrixAt(h,b),o){const u=o[l];this.mesh.setColorAt(h,u)}f.add(h),this.instanceToItem.set(h,c),this.mesh.count++}}this.update()}remove(t){if(this.mesh.count!==0){for(const s of t){const e=this.itemToInstances.get(s);if(e===void 0)throw new Error("Instances not found!");for(const i of e){if(this.mesh.count===0)throw new Error("Error with mesh count!");this.putLast(i),this.instanceToItem.delete(i),this.mesh.count--}this.itemToInstances.delete(s),this.ids.delete(s)}this.update()}}clear(){this.hiddenItems.clear(),this.ids.clear(),this.instanceToItem.clear(),this.itemToInstances.clear(),this.mesh.count=0}setVisibility(t,s=this.ids){if(!this._settingVisibility){if(this._settingVisibility=!0,t)for(const e of s){if(!this.ids.has(e))throw new Error(`This item doesn't exist here: ${e}`);if(!this.hiddenItems.has(e))continue;const i=this.itemToInstances.get(e);if(!i)throw new Error("Instances not found!");for(const n of new Set(i))this.mesh.count++,this.putLast(n);this.hiddenItems.delete(e)}else for(const e of s){if(!this.ids.has(e))throw new Error(`This item doesn't exist here: ${e}`);if(this.hiddenItems.has(e))continue;const i=this.itemToInstances.get(e);if(!i)throw new Error("Instances not found!");for(const n of new Set(i))this.putLast(n),this.mesh.count--;this.hiddenItems.add(e)}this.update(),this._settingVisibility=!1}}setColor(t,s=this.ids,e=!1){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const i of s){if(!this.ids.has(i))throw new Error(`This item doesn't exist here: ${i}`);const n=this.itemToInstances.get(i);if(!n)throw new Error("Instances not found!");const r=this._originalColors.has(i);r||this._originalColors.set(i,new Map);const o=this._originalColors.get(i);for(const c of new Set(n)){if(!r){const f=new L.Color;this.mesh.getColorAt(c,f),o.set(c,f)}this.mesh.setColorAt(c,t),e&&o.set(c,t)}}this.mesh.instanceColor.needsUpdate=!0}resetColor(t=this.ids){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const s of t){if(!this.ids.has(s))throw new Error(`This item doesn't exist here: ${s}`);const e=this.itemToInstances.get(s);if(!e)throw new Error("Instances not found!");const i=this._originalColors.get(s);if(i)for(const n of new Set(e)){const r=i.get(n);if(!r)throw new Error("Original color not found!");this.mesh.setColorAt(n,r)}}this.mesh.instanceColor.needsUpdate=!0}applyTransform(t,s){const e=new L.Matrix4;for(const i of t){const n=this.getInstancesIDs(i);if(n!==null)for(const r of n)this.mesh.getMatrixAt(r,e),e.premultiply(s),this.mesh.setMatrixAt(r,e)}this.update()}exportData(){const t=this.mesh.exportData(),s=Array.from(this.ids),e=this.id;return{...t,ids:s,id:e}}putLast(t){if(this.mesh.count===0)return;const s=this.instanceToItem.get(t),e=this.mesh.count-1;if(e===t)return;const i=this.instanceToItem.get(e);if(s===void 0||i===void 0)throw new Error("Keys not found");if(s!==i){const o=this.itemToInstances.get(s),c=this.itemToInstances.get(i);if(!o||!c)throw new Error("Instances not found");if(!o.has(t)||!c.has(e))throw new Error("Malformed fragment structure");o.delete(t),c.delete(e),o.add(e),c.add(t),this.instanceToItem.set(t,i),this.instanceToItem.set(e,s)}const n=new L.Matrix4,r=new L.Matrix4;if(this.mesh.getMatrixAt(t,n),this.mesh.getMatrixAt(e,r),this.mesh.setMatrixAt(t,r),this.mesh.setMatrixAt(e,n),this.mesh.instanceColor!==null){const o=new L.Color,c=new L.Color;this.mesh.getColorAt(t,o),this.mesh.getColorAt(e,c),this.mesh.setColorAt(t,c),this.mesh.setColorAt(e,o);const f=this._originalColors.get(s);if(f){const b=f.get(t);b&&(f.delete(t),f.set(e,b))}const l=this._originalColors.get(i);if(l){const b=l.get(e);b&&(l.delete(e),l.set(t,b))}}}};const Es=2,ct=4,bt=4,W=4,gt=new Int32Array(2),Ve=new Float32Array(gt.buffer),ve=new Float64Array(gt.buffer),ys=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;var Ys;(function(a){a[a.UTF8_BYTES=1]="UTF8_BYTES",a[a.UTF16_STRING=2]="UTF16_STRING"})(Ys||(Ys={}));class Tt{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Tt(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return gt[0]=this.readInt32(t),Ve[0]}readFloat64(t){return gt[ys?0:1]=this.readInt32(t),gt[ys?1:0]=this.readInt32(t+4),ve[0]}writeInt8(t,s){this.bytes_[t]=s}writeUint8(t,s){this.bytes_[t]=s}writeInt16(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8}writeUint16(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8}writeInt32(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8,this.bytes_[t+2]=s>>16,this.bytes_[t+3]=s>>24}writeUint32(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8,this.bytes_[t+2]=s>>16,this.bytes_[t+3]=s>>24}writeInt64(t,s){this.writeInt32(t,Number(BigInt.asIntN(32,s))),this.writeInt32(t+4,Number(BigInt.asIntN(32,s>>BigInt(32))))}writeUint64(t,s){this.writeUint32(t,Number(BigInt.asUintN(32,s))),this.writeUint32(t+4,Number(BigInt.asUintN(32,s>>BigInt(32))))}writeFloat32(t,s){Ve[0]=s,this.writeInt32(t,gt[0])}writeFloat64(t,s){ve[0]=s,this.writeInt32(t,gt[ys?0:1]),this.writeInt32(t+4,gt[ys?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+ct+bt)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let s=0;s<bt;s++)t+=String.fromCharCode(this.readInt8(this.position_+ct+s));return t}__offset(t,s){const e=t-this.readInt32(t);return s<this.readInt16(e)?this.readInt16(e+s):0}__union(t,s){return t.bb_pos=s+this.readInt32(s),t.bb=this,t}__string(t,s){t+=this.readInt32(t);const e=this.readInt32(t);t+=ct;const i=this.bytes_.subarray(t,t+e);return s===Ys.UTF8_BYTES?i:this.text_decoder_.decode(i)}__union_with_string(t,s){return typeof t=="string"?this.__string(s):this.__union(t,s)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+ct}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(t.length!=bt)throw new Error("FlatBuffers: file identifier must be length "+bt);for(let s=0;s<bt;s++)if(t.charCodeAt(s)!=this.readInt8(this.position()+ct+s))return!1;return!0}createScalarList(t,s){const e=[];for(let i=0;i<s;++i){const n=t(i);n!==null&&e.push(n)}return e}createObjList(t,s){const e=[];for(let i=0;i<s;++i){const n=t(i);n!==null&&e.push(n.unpack())}return e}}class ss{constructor(t){this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder;let s;t?s=t:s=1024,this.bb=Tt.allocate(s),this.space=s}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,s){t>this.minalign&&(this.minalign=t);const e=~(this.bb.capacity()-this.space+s)+1&t-1;for(;this.space<e+t+s;){const i=this.bb.capacity();this.bb=ss.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(e)}pad(t){for(let s=0;s<t;s++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,s,e){(this.force_defaults||s!=e)&&(this.addInt8(s),this.slot(t))}addFieldInt16(t,s,e){(this.force_defaults||s!=e)&&(this.addInt16(s),this.slot(t))}addFieldInt32(t,s,e){(this.force_defaults||s!=e)&&(this.addInt32(s),this.slot(t))}addFieldInt64(t,s,e){(this.force_defaults||s!==e)&&(this.addInt64(s),this.slot(t))}addFieldFloat32(t,s,e){(this.force_defaults||s!=e)&&(this.addFloat32(s),this.slot(t))}addFieldFloat64(t,s,e){(this.force_defaults||s!=e)&&(this.addFloat64(s),this.slot(t))}addFieldOffset(t,s,e){(this.force_defaults||s!=e)&&(this.addOffset(s),this.slot(t))}addFieldStruct(t,s,e){s!=e&&(this.nested(s),this.slot(t))}nested(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")}slot(t){this.vtable!==null&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const s=t.capacity();if(s&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const e=s<<1,i=Tt.allocate(e);return i.setPosition(e-s),i.bytes().set(t.bytes(),e-s),i}addOffset(t){this.prep(ct,0),this.writeInt32(this.offset()-t+ct)}startObject(t){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=t;for(let s=0;s<t;s++)this.vtable[s]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let s=this.vtable_in_use-1;for(;s>=0&&this.vtable[s]==0;s--);const e=s+1;for(;s>=0;s--)this.addInt16(this.vtable[s]!=0?t-this.vtable[s]:0);const i=2;this.addInt16(t-this.object_start);const n=(e+i)*Es;this.addInt16(n);let r=0;const o=this.space;t:for(s=0;s<this.vtables.length;s++){const c=this.bb.capacity()-this.vtables[s];if(n==this.bb.readInt16(c)){for(let f=Es;f<n;f+=Es)if(this.bb.readInt16(o+f)!=this.bb.readInt16(c+f))continue t;r=this.vtables[s];break}}return r?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,r-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,s,e){const i=e?W:0;if(s){const n=s;if(this.prep(this.minalign,ct+bt+i),n.length!=bt)throw new Error("FlatBuffers: file identifier must be length "+bt);for(let r=bt-1;r>=0;r--)this.writeInt8(n.charCodeAt(r))}this.prep(this.minalign,ct+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,s){this.finish(t,s,!0)}requiredField(t,s){const e=this.bb.capacity()-t,i=e-this.bb.readInt32(e);if(!(s<this.bb.readInt16(i)&&this.bb.readInt16(i+s)!=0))throw new Error("FlatBuffers: field "+s+" must be set")}startVector(t,s,e){this.notNested(),this.vector_num_elems=s,this.prep(ct,t*s),this.prep(e,t*s)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const s=this.createString(t);return this.string_maps.set(t,s),s}createString(t){if(t==null)return 0;let s;t instanceof Uint8Array?s=t:s=this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,s.length,1),this.bb.setPosition(this.space-=s.length);for(let e=0,i=this.space,n=this.bb.bytes();e<s.length;e++)n[i++]=s[e];return this.endVector()}createObjectOffset(t){return t===null?0:typeof t=="string"?this.createString(t):t.pack(this)}createObjectOffsetList(t){const s=[];for(let e=0;e<t.length;++e){const i=t[e];if(i!==null)s.push(this.createObjectOffset(i));else throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.")}return s}createStructOffsetList(t,s){return s(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}let Is=class Mt{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new Mt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+W),(s||new Mt).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return Mt.startCivilCurve(t),Mt.addPoints(t,s),Mt.addData(t,e),Mt.endCivilCurve(t)}},Be=class ft{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new ft).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+W),(s||new ft).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Is).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new Is).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new Is).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,i,n){return ft.startAlignment(t),ft.addVertical(t,s),ft.addHorizontal(t,e),ft.addAbsolute(t,i),ft.addInitialPk(t,n),ft.endAlignment(t)}},Se=class Bt{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new Bt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+W),(s||new Bt).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Be).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return Bt.startCivilData(t),Bt.addAlignments(t,s),Bt.addCoordinationMatrix(t,e),Bt.endCivilData(t)}},Zs=class j{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new j).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+W),(s||new j).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,i,n,r,o,c,f,l,b,h,u){return j.startFragment(t),j.addPosition(t,s),j.addNormal(t,e),j.addIndex(t,i),j.addGroups(t,n),j.addMaterials(t,r),j.addMatrices(t,o),j.addColors(t,c),j.addItemsSize(t,f),j.addIds(t,l),j.addId(t,b),j.addCapacity(t,h),j.addCapacityOffset(t,u),j.endFragment(t)}},Gs=class Js{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new Js).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+W),(s||new Js).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Zs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new Se).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,34);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,34);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(18)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addId(t,s){t.addFieldOffset(9,s,0)}static addName(t,s){t.addFieldOffset(10,s,0)}static addIfcName(t,s){t.addFieldOffset(11,s,0)}static addIfcDescription(t,s){t.addFieldOffset(12,s,0)}static addIfcSchema(t,s){t.addFieldOffset(13,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(14,s,0)}static addBoundingBox(t,s){t.addFieldOffset(15,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(16,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class qi{constructor(){S(this,"version",1);S(this,"fragmentIDSeparator","|")}import(t){const s=new Tt(t),e=Gs.getRootAsFragmentsGroup(s),i=this.constructFragmentGroup(e),n=e.itemsLength();for(let r=0;r<n;r++){const o=e.items(r);if(!o)continue;const c=this.constructGeometry(o),f=this.constructMaterials(o),l=o.capacity(),b=new ee(c,f,l);b.capacityOffset=o.capacityOffset(),this.setInstances(o,b),this.setID(o,b),i.items.push(b),i.add(b.mesh)}return i}export(t){const s=new ss(1024),e=[],i=Gs,n=Zs;let r=null;if(t.civilData){const q=[],E=Be,z=Se;for(const[ot,dt]of t.civilData.alignments){const{absolute:Ot,horizontal:_t,vertical:At}=dt,Vt=this.saveCivilCurves(_t,s),vt=this.saveCivilCurves(At,s),Ft=this.saveCivilCurves(Ot,s),Ct=E.createHorizontalVector(s,Vt),Pt=E.createVerticalVector(s,vt),pt=E.createAbsoluteVector(s,Ft);E.startAlignment(s),E.addHorizontal(s,Ct),E.addVertical(s,Pt),E.addAbsolute(s,pt),E.addInitialPk(s,dt.initialKP);const $t=E.endAlignment(s);q.push($t)}const U=z.createAlignmentsVector(s,q),K=z.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);z.startCivilData(s),z.addAlignments(s,U),z.addCoordinationMatrix(s,K),r=z.endCivilData(s)}for(const q of t.items){const E=q.exportData(),z=[];for(const Pt of q.ids){const pt=q.getInstancesIDs(Pt);if(!pt)throw new Error("Instances not found!");z.push(pt.size)}const U=n.createPositionVector(s,E.position),K=n.createNormalVector(s,E.normal),ot=n.createIndexVector(s,E.index),dt=n.createGroupsVector(s,E.groups),Ot=n.createMaterialsVector(s,E.materials),_t=n.createMatricesVector(s,E.matrices),At=n.createColorsVector(s,E.colors),Vt=n.createIdsVector(s,E.ids),vt=n.createItemsSizeVector(s,z),Ft=s.createString(E.id);n.startFragment(s),n.addPosition(s,U),n.addNormal(s,K),n.addIndex(s,ot),n.addGroups(s,dt),n.addMaterials(s,Ot),n.addMatrices(s,_t),n.addColors(s,At),n.addIds(s,Vt),n.addItemsSize(s,vt),n.addId(s,Ft),n.addCapacity(s,q.capacity),n.addCapacityOffset(s,q.capacityOffset);const Ct=Zs.endFragment(s);e.push(Ct)}const o=i.createItemsVector(s,e),c=i.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let f="";for(const q of t.keyFragments.values())f.length&&(f+=this.fragmentIDSeparator),f+=q;const l=s.createString(f),b=[],h=[],u=[],_=[],x=[];let y=0,d=0;for(const[q,[E,z]]of t.data){b.push(y),u.push(d),x.push(q);for(const U of E)h.push(U);for(const U of z)_.push(U);y+=E.length,d+=z.length}const p=[],I=[];for(const[q,E]of t.geometryIDs.opaque)p.push(q,E);for(const[q,E]of t.geometryIDs.transparent)I.push(q,E);const m=s.createString(t.uuid),g=s.createString(t.name),A=s.createString(t.ifcMetadata.name),C=s.createString(t.ifcMetadata.description),w=s.createString(t.ifcMetadata.schema),P=i.createItemsKeysIndicesVector(s,b),V=i.createItemsKeysVector(s,h),B=i.createItemsRelsIndicesVector(s,u),F=i.createItemsRelsVector(s,_),M=i.createIdsVector(s,x),T=i.createOpaqueGeometriesIdsVector(s,p),O=i.createTransparentGeometriesIdsVector(s,I),{min:D,max:$}=t.boundingBox,X=[D.x,D.y,D.z,$.x,$.y,$.z],Y=i.createBoundingBoxVector(s,X);i.startFragmentsGroup(s),i.addId(s,m),i.addName(s,g),i.addIfcName(s,A),i.addIfcDescription(s,C),i.addIfcSchema(s,w),i.addMaxExpressId(s,t.ifcMetadata.maxExpressID),i.addItems(s,o),i.addFragmentKeys(s,l),i.addIds(s,M),i.addItemsKeysIndices(s,P),i.addItemsKeys(s,V),i.addItemsRelsIndices(s,B),i.addItemsRels(s,F),i.addCoordinationMatrix(s,c),i.addBoundingBox(s,Y),i.addOpaqueGeometriesIds(s,T),i.addTransparentGeometriesIds(s,O),r!==null&&i.addCivil(s,r);const Fs=Gs.endFragmentsGroup(s);return s.finish(Fs),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),i=t.colorsArray(),n=t.idsArray(),r=t.itemsSizeArray();if(!e||!n||!r)throw new Error("Error: Can't load empty fragment!");const o=[];let c=0;for(let f=0;f<r.length;f++){const l=n[f],b=r[f],h=[],u=[];for(let x=0;x<b;x++){const y=c*16,d=e.subarray(y,y+17),p=new L.Matrix4().fromArray(d);if(h.push(p),i){const I=c*3,[m,g,A]=i.subarray(I,I+4),C=new L.Color(m,g,A);u.push(C)}c++}const _=u.length?u:void 0;o.push({id:l,transforms:h,colors:_})}s.add(o)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let i=0;i<s.length;i+=5){const n=s[i],r=!!s[i+1],o=s[i+2],c=s[i+3],f=s[i+4],l=new L.Color(o,c,f),b=new L.MeshLambertMaterial({color:l,opacity:n,transparent:r});e.push(b)}return e}constructFragmentGroup(t){const s=new ie,e=t.civil();if(e){const w=e.coordinationMatrixArray(),P=new L.Matrix4;w&&P.fromArray(w),s.civilData={alignments:new Map,coordinationMatrix:P};const V=e.alignmentsLength();for(let B=0;B<V;B++){const F=new L.LineBasicMaterial({color:16777215}),M=new ne,T=e.alignments(B);if(!T)throw new Error("Alignment not found!");const O=T.horizontalLength();M.horizontal=this.constructCivilCurves(T,M,"horizontal",O,F);const D=T.verticalLength();M.vertical=this.constructCivilCurves(T,M,"vertical",D,F);const $=T.horizontalLength();M.absolute=this.constructCivilCurves(T,M,"absolute",$,F),M.initialKP=T.initialPk(),s.civilData.alignments.set(B,M)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=new L.Matrix4().elements,n=t.coordinationMatrixArray()||i,r=t.idsArray()||new Uint32Array,o=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,f=t.itemsRelsArray()||new Uint32Array,l=t.itemsRelsIndicesArray()||new Uint32Array,h=(t.fragmentKeys()||"").split(this.fragmentIDSeparator);this.setGroupData(s,r,o,c,0),this.setGroupData(s,r,l,f,1);const u=t.opaqueGeometriesIdsArray()||new Uint32Array,_=t.transparentGeometriesIdsArray()||new Uint32Array,x=new Map;for(let w=0;w<u.length-1;w+=2){const P=u[w],V=u[w+1];x.set(P,V)}const y=new Map;for(let w=0;w<_.length-1;w+=2){const P=_[w],V=_[w+1];y.set(P,V)}s.geometryIDs={opaque:x,transparent:y};const d=t.boundingBoxArray()||[0,0,0,0,0,0],[p,I,m,g,A,C]=d;s.boundingBox.min.set(p,I,m),s.boundingBox.max.set(g,A,C);for(let w=0;w<h.length;w++)s.keyFragments.set(w,h[w]);return n.length===16&&s.coordinationMatrix.fromArray(n),s}setGroupData(t,s,e,i,n){for(let r=0;r<e.length;r++){const o=s[r],c=e[r],f=e[r+1]||i.length,l=[];for(let h=c;h<f;h++)l.push(i[h]);t.data.has(o)||t.data.set(o,[[],[]]);const b=t.data.get(o);b&&(b[n]=l)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,i=t.indexArray(),n=t.groupsArray();if(!i)throw new Error("Index not found!");const r=new L.BufferGeometry;if(r.setIndex(Array.from(i)),r.setAttribute("position",new L.BufferAttribute(s,3)),r.setAttribute("normal",new L.BufferAttribute(e,3)),n)for(let o=0;o<n.length;o+=3){const c=n[o],f=n[o+1],l=n[o+2];r.addGroup(c,f,l)}return r}constructCivilCurves(t,s,e,i,n){const r=[];for(let o=0;o<i;o++){const c=t[e](o);if(!c)throw new Error("Curve not found!");const f=c.pointsArray();if(f===null)throw new Error("Curve points not found!");let l={};const b=c.data();b&&(l=JSON.parse(b));const h=new L.EdgesGeometry,u=new L.BufferAttribute(f,3);h.setAttribute("position",u);const _=[];for(let y=0;y<f.length/3-1;y++)_.push(y,y+1);h.setIndex(_);const x=new re(o,l,s,h,n);r.push(x.curve)}return r}saveCivilCurves(t,s){const e=Is,i=[];for(const n of t){const o=n.mesh.geometry.attributes.position.array,c=e.createPointsVector(s,o),f=s.createString(JSON.stringify(n.data));e.startCivilCurve(s),e.addPoints(s,c),e.addData(s,f);const l=e.endCivilCurve(s);i.push(l)}return i}}let xs=class St{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new St).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+W),(s||new St).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return St.startCivilCurve(t),St.addPoints(t,s),St.addData(t,e),St.endCivilCurve(t)}},Te=class lt{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new lt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+W),(s||new lt).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,i,n){return lt.startAlignment(t),lt.addVertical(t,s),lt.addHorizontal(t,e),lt.addAbsolute(t,i),lt.addInitialPk(t,n),lt.endAlignment(t)}};class ht{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new ht).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+W),(s||new ht).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Te).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return ht.startCivilData(t),ht.addAlignments(t,s),ht.addCoordinationMatrix(t,e),ht.endCivilData(t)}}class N{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new N).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+W),(s||new N).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,i,n,r,o,c,f,l,b,h,u){return N.startFragment(t),N.addPosition(t,s),N.addNormal(t,e),N.addIndex(t,i),N.addGroups(t,n),N.addMaterials(t,r),N.addMatrices(t,o),N.addColors(t,c),N.addItemsSize(t,f),N.addIds(t,l),N.addId(t,b),N.addCapacity(t,h),N.addCapacityOffset(t,u),N.endFragment(t)}}let Rs=class Ws{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new Ws).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+W),(s||new Ws).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new N).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new ht).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}globalIds(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,32);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,40);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,40);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,40);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(19)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addGlobalIds(t,s){t.addFieldOffset(9,s,0)}static addId(t,s){t.addFieldOffset(10,s,0)}static addName(t,s){t.addFieldOffset(11,s,0)}static addIfcName(t,s){t.addFieldOffset(12,s,0)}static addIfcDescription(t,s){t.addFieldOffset(13,s,0)}static addIfcSchema(t,s){t.addFieldOffset(14,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(15,s,0)}static addBoundingBox(t,s){t.addFieldOffset(16,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(18,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class ji{constructor(){S(this,"version",2);S(this,"separator","|")}import(t){const s=new Tt(t),e=Rs.getRootAsFragmentsGroup(s),i=this.constructFragmentGroup(e),n=e.itemsLength();for(let r=0;r<n;r++){const o=e.items(r);if(!o)continue;const c=this.constructGeometry(o),f=this.constructMaterials(o),l=o.capacity(),b=new ee(c,f,l);b.capacityOffset=o.capacityOffset(),this.setInstances(o,b),this.setID(o,b),i.items.push(b),i.add(b.mesh)}return i}export(t){const s=new ss(1024),e=[],i=Rs,n=N;let r=null;if(t.civilData){const z=[],U=Te,K=ht;for(const[Ot,_t]of t.civilData.alignments){const{absolute:At,horizontal:Vt,vertical:vt}=_t,Ft=this.saveCivilCurves(Vt,s),Ct=this.saveCivilCurves(vt,s),Pt=this.saveCivilCurves(At,s),pt=U.createHorizontalVector(s,Ft),$t=U.createVerticalVector(s,Ct),es=U.createAbsoluteVector(s,Pt);U.startAlignment(s),U.addHorizontal(s,pt),U.addVertical(s,$t),U.addAbsolute(s,es),U.addInitialPk(s,_t.initialKP);const Le=U.endAlignment(s);z.push(Le)}const ot=K.createAlignmentsVector(s,z),dt=K.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);K.startCivilData(s),K.addAlignments(s,ot),K.addCoordinationMatrix(s,dt),r=K.endCivilData(s)}for(const z of t.items){const U=z.exportData(),K=[];for(const $t of z.ids){const es=z.getInstancesIDs($t);if(!es)throw new Error("Instances not found!");K.push(es.size)}const ot=n.createPositionVector(s,U.position),dt=n.createNormalVector(s,U.normal),Ot=n.createIndexVector(s,U.index),_t=n.createGroupsVector(s,U.groups),At=n.createMaterialsVector(s,U.materials),Vt=n.createMatricesVector(s,U.matrices),vt=n.createColorsVector(s,U.colors),Ft=n.createIdsVector(s,U.ids),Ct=n.createItemsSizeVector(s,K),Pt=s.createString(U.id);n.startFragment(s),n.addPosition(s,ot),n.addNormal(s,dt),n.addIndex(s,Ot),n.addGroups(s,_t),n.addMaterials(s,At),n.addMatrices(s,Vt),n.addColors(s,vt),n.addIds(s,Ft),n.addItemsSize(s,Ct),n.addId(s,Pt),n.addCapacity(s,z.capacity),n.addCapacityOffset(s,z.capacityOffset);const pt=N.endFragment(s);e.push(pt)}const o=i.createItemsVector(s,e),c=i.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let f="";for(const z of t.keyFragments.values())f.length&&(f+=this.separator),f+=z;let l="";for(const[z]of t.globalToExpressIDs)l.length&&(l+=this.separator),l+=z;const b=s.createString(f),h=s.createString(l),u=[],_=[],x=[],y=[],d=[];let p=0,I=0;for(const[z,[U,K]]of t.data){u.push(p),x.push(I),d.push(z);for(const ot of U)_.push(ot);for(const ot of K)y.push(ot);p+=U.length,I+=K.length}const m=[],g=[];for(const[z,U]of t.geometryIDs.opaque)m.push(z,U);for(const[z,U]of t.geometryIDs.transparent)g.push(z,U);const A=s.createString(t.uuid),C=s.createString(t.name),w=s.createString(t.ifcMetadata.name),P=s.createString(t.ifcMetadata.description),V=s.createString(t.ifcMetadata.schema),B=i.createItemsKeysIndicesVector(s,u),F=i.createItemsKeysVector(s,_),M=i.createItemsRelsIndicesVector(s,x),T=i.createItemsRelsVector(s,y),O=i.createIdsVector(s,d),D=i.createOpaqueGeometriesIdsVector(s,m),$=i.createTransparentGeometriesIdsVector(s,g),{min:X,max:Y}=t.boundingBox,Fs=[X.x,X.y,X.z,Y.x,Y.y,Y.z],q=i.createBoundingBoxVector(s,Fs);i.startFragmentsGroup(s),i.addId(s,A),i.addName(s,C),i.addIfcName(s,w),i.addIfcDescription(s,P),i.addIfcSchema(s,V),i.addMaxExpressId(s,t.ifcMetadata.maxExpressID),i.addItems(s,o),i.addFragmentKeys(s,b),i.addGlobalIds(s,h),i.addIds(s,O),i.addItemsKeysIndices(s,B),i.addItemsKeys(s,F),i.addItemsRelsIndices(s,M),i.addItemsRels(s,T),i.addCoordinationMatrix(s,c),i.addBoundingBox(s,q),i.addOpaqueGeometriesIds(s,D),i.addTransparentGeometriesIds(s,$),r!==null&&i.addCivil(s,r);const E=Rs.endFragmentsGroup(s);return s.finish(E),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),i=t.colorsArray(),n=t.idsArray(),r=t.itemsSizeArray();if(!e||!n||!r)throw new Error("Error: Can't load empty fragment!");const o=[];let c=0;for(let f=0;f<r.length;f++){const l=n[f],b=r[f],h=[],u=[];for(let x=0;x<b;x++){const y=c*16,d=e.subarray(y,y+17),p=new L.Matrix4().fromArray(d);if(h.push(p),i){const I=c*3,[m,g,A]=i.subarray(I,I+4),C=new L.Color(m,g,A);u.push(C)}c++}const _=u.length?u:void 0;o.push({id:l,transforms:h,colors:_})}s.add(o)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let i=0;i<s.length;i+=5){const n=s[i],r=!!s[i+1],o=s[i+2],c=s[i+3],f=s[i+4],l=new L.Color(o,c,f),b=new L.MeshLambertMaterial({color:l,opacity:n,transparent:r});e.push(b)}return e}constructFragmentGroup(t){const s=new ie,e=t.civil();if(e){const V=e.coordinationMatrixArray(),B=new L.Matrix4;V&&B.fromArray(V),s.civilData={alignments:new Map,coordinationMatrix:B};const F=e.alignmentsLength();for(let M=0;M<F;M++){const T=new L.LineBasicMaterial({color:16777215}),O=new ne,D=e.alignments(M);if(!D)throw new Error("Alignment not found!");const $=D.horizontalLength();O.horizontal=this.constructCivilCurves(D,O,"horizontal",$,T);const X=D.verticalLength();O.vertical=this.constructCivilCurves(D,O,"vertical",X,T);const Y=D.horizontalLength();O.absolute=this.constructCivilCurves(D,O,"absolute",Y,T),O.initialKP=D.initialPk(),s.civilData.alignments.set(M,O)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=new L.Matrix4().elements,n=t.coordinationMatrixArray()||i,r=t.idsArray()||new Uint32Array,o=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,f=t.itemsRelsArray()||new Uint32Array,l=t.itemsRelsIndicesArray()||new Uint32Array,h=(t.fragmentKeys()||"").split(this.separator),_=(t.globalIds()||"").split(this.separator);this.setGroupData(s,r,o,c,0),this.setGroupData(s,r,l,f,1);const x=t.opaqueGeometriesIdsArray()||new Uint32Array,y=t.transparentGeometriesIdsArray()||new Uint32Array,d=new Map;for(let V=0;V<x.length-1;V+=2){const B=x[V],F=x[V+1];d.set(B,F)}const p=new Map;for(let V=0;V<y.length-1;V+=2){const B=y[V],F=y[V+1];p.set(B,F)}s.geometryIDs={opaque:d,transparent:p};const I=t.boundingBoxArray()||[0,0,0,0,0,0],[m,g,A,C,w,P]=I;s.boundingBox.min.set(m,g,A),s.boundingBox.max.set(C,w,P);for(let V=0;V<h.length;V++)s.keyFragments.set(V,h[V]);n.length===16&&s.coordinationMatrix.fromArray(n);for(let V=0;V<r.length;V++)s.globalToExpressIDs.set(_[V],r[V]);return s}setGroupData(t,s,e,i,n){for(let r=0;r<e.length;r++){const o=s[r],c=e[r],f=e[r+1]||i.length,l=[];for(let h=c;h<f;h++)l.push(i[h]);t.data.has(o)||t.data.set(o,[[],[]]);const b=t.data.get(o);b&&(b[n]=l)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,i=t.indexArray(),n=t.groupsArray();if(!i)throw new Error("Index not found!");const r=new L.BufferGeometry;if(r.setIndex(Array.from(i)),r.setAttribute("position",new L.BufferAttribute(s,3)),r.setAttribute("normal",new L.BufferAttribute(e,3)),n)for(let o=0;o<n.length;o+=3){const c=n[o],f=n[o+1],l=n[o+2];r.addGroup(c,f,l)}return r}constructCivilCurves(t,s,e,i,n){const r=[];for(let o=0;o<i;o++){const c=t[e](o);if(!c)throw new Error("Curve not found!");const f=c.pointsArray();if(f===null)throw new Error("Curve points not found!");let l={};const b=c.data();b&&(l=JSON.parse(b));const h=new L.EdgesGeometry,u=new L.BufferAttribute(f,3);h.setAttribute("position",u);const _=[];for(let y=0;y<f.length/3-1;y++)_.push(y,y+1);h.setIndex(_);const x=new re(o,l,s,h,n);r.push(x.curve)}return r}saveCivilCurves(t,s){const e=xs,i=[];for(const n of t){const o=n.mesh.geometry.attributes.position.array,c=e.createPointsVector(s,o),f=s.createString(JSON.stringify(n.data));e.startCivilCurve(s),e.addPoints(s,c),e.addData(s,f);const l=e.endCivilCurve(s);i.push(l)}return i}}class Ki{constructor(){S(this,"parsers",[new ji,new qi]);S(this,"version","auto")}import(t){const s=this.parsers.length-1;if(this.version==="auto"){for(let r=0;r<this.parsers.length;r++){const c=this.parsers[r].import(t);if(Object.keys(c).length!==0){if(r!==0){const f=this.parsers.length-r;this.warnVersion(f,s)}return c}}throw new Error("No valid parser found for this file")}this.checkCurrentVersionValid(s);const e=this.parsers.length-this.version,n=this.parsers[e].import(t);if(Object.keys(n).length===0)throw new Error(`The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`);return n}export(t){const s=this.parsers.length-1;if(this.version==="auto")return this.parsers[this.parsers.length-1].export(t);this.checkCurrentVersionValid(s);const e=this.parsers.length-this.version;return this.parsers[e].export(t)}checkCurrentVersionValid(t){if(this.version!=="auto"){if(this.version!==t&&this.warnVersion(this.version,t),Number.isInteger(this.version))throw new Error("Invalid version. Non-automatic versions must an integer.");if(this.version<1||this.version>t)throw new Error(`Invalid version. Versions range from 1 to ${t}.`)}}warnVersion(t,s){console.warn(`This fragment file version is ${t}. The latest version is ${s}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`)}}class ie extends L.Group{constructor(){super(...arguments);S(this,"items",[]);S(this,"boundingBox",new L.Box3);S(this,"coordinationMatrix",new L.Matrix4);S(this,"keyFragments",new Map);S(this,"globalToExpressIDs",new Map);S(this,"data",new Map);S(this,"geometryIDs",{opaque:new Map,transparent:new Map});S(this,"ifcMetadata",{name:"",description:"",schema:"IFC2X3",maxExpressID:0});S(this,"civilData");S(this,"streamSettings",{baseUrl:"",baseFileName:"",ids:new Map,types:new Map});S(this,"_properties")}get hasProperties(){const s=this._properties!==void 0,e=this.streamSettings.ids.size!==0;return s||e}getFragmentMap(s){const e={};for(const i of s){const n=this.data.get(i);if(n)for(const r of n[0]){const o=this.keyFragments.get(r);o!==void 0&&(e[o]||(e[o]=new Set),e[o].add(i))}}return e}getItemVertices(s){const e=[],i=this.getFragmentMap([s]);for(const n in i){const r=this.items.find(c=>c.id===n);if(!r)continue;const o=r.getInstancesIDs(s);if(o)for(const c of o){const f=new L.Matrix4;r.mesh.getMatrixAt(c,f);for(const l of r.uniqueVertices){const b=l.clone().applyMatrix4(f);e.push(b)}}}return e}dispose(s=!0){for(const e of this.items)e.dispose(s);if(this.coordinationMatrix=new L.Matrix4,this.keyFragments.clear(),this.data.clear(),this._properties={},this.removeFromParent(),this.items=[],this.civilData){const{alignments:e}=this.civilData;for(const[i,n]of e)this.disposeAlignment(n.vertical),this.disposeAlignment(n.horizontal),this.disposeAlignment(n.absolute)}this.civilData=void 0}setLocalProperties(s){this._properties=s}getLocalProperties(){return this._properties}getAllPropertiesIDs(){return this._properties?Object.keys(this._properties).map(s=>parseInt(s,10)):Array.from(this.streamSettings.ids.keys())}getAllPropertiesTypes(){if(this._properties){const s=new Set;for(const e in this._properties){const i=this._properties[e];i.type!==void 0&&s.add(i.type)}return Array.from(s)}return Array.from(this.streamSettings.types.keys())}async getProperties(s){if(this._properties)return this._properties[s]||null;const e=this.getPropsURL(s),i=await this.getPropertiesData(e);return i?i[s]:null}async setProperties(s,e){if(this._properties){e!==null?this._properties[s]=e:delete this._properties[s];return}throw new Error("Writing streamed properties not supported yet!")}async getAllPropertiesOfType(s){if(this._properties){const r={};let o=!1;for(const c in this._properties){const f=this._properties[c];f.type===s&&(r[f.expressID]=f,o=!0)}return o?r:null}const{types:e}=this.streamSettings,i=e.get(s);if(i===void 0)return null;const n={};for(const r of i){const o=this.constructFileName(r),c=this.constructURL(o),f=await this.getPropertiesData(c);for(const l in f)n[parseInt(l,10)]=f[l]}return n}getPropsURL(s){const{ids:e}=this.streamSettings,i=e.get(s);if(i===void 0)throw new Error("ID not found");const n=this.constructFileName(i);return this.constructURL(n)}async getPropertiesData(s){return(await fetch(s)).json()}constructFileName(s){const{baseFileName:e}=this.streamSettings;return`${e}-${s}`}constructURL(s){const{baseUrl:e}=this.streamSettings;return`${e}${s}`}disposeAlignment(s){for(const e of s)if(e.mesh.geometry.dispose(),Array.isArray(e.mesh.material))for(const i of e.mesh.material)i.dispose();else e.mesh.material.dispose();s.length=0}}class ne{constructor(){S(this,"vertical",[]);S(this,"horizontal",[]);S(this,"absolute",[]);S(this,"initialKP",0)}getLength(t){let s=0;for(const e of this[t])s+=e.getLength();return s}getPointAt(t,s){const e=this.getCurveAt(t,s);return e.curve.getPointAt(e.percentage)}getPercentageAt(t,s,e=.01){const i=this[s];let n=0;for(const r of i){const o=r.getPercentageAt(t,e),c=r.getLength();if(o!==null){const f=n+o*c,l=this.getLength(s);return f/l}n+=c}return null}getCurveAt(t,s){t<0?t=0:t>1&&(t=1);const e=this[s],n=this.getLength(s)*t;let r=0;for(const o of e){const c=o.getLength();if(r+c>=n){const l=(n-r)/c;return{curve:o,percentage:l}}r+=c}throw new Error("Could not compute point!")}}class Oe{constructor(t,s,e,i){S(this,"index");S(this,"mesh");S(this,"data");S(this,"alignment");this.index=t,this.mesh=s,this.data=e,this.alignment=i}get _index(){return this.mesh.geometry.index}get _pos(){return this.mesh.geometry.attributes.position.array}getLength(){let t=0;for(let s=0;s<this._index.array.length-1;s+=2){const{startPoint:e,endPoint:i}=this.getSegment(s);t+=e.distanceTo(i)}return t}getPointAt(t){const{startPoint:s,endPoint:e,distanceToStart:i}=this.getSegmentAt(t),n=e.clone();return n.sub(s),n.normalize(),n.multiplyScalar(i),n.add(s),n}getSegmentAt(t){t<0?t=0:t>1&&(t=1);const e=this.getLength()*t;let i=0;for(let n=0;n<this._index.array.length-1;n+=2){const{startPoint:r,endPoint:o}=this.getSegment(n),c=r.distanceTo(o);if(i+c>=e)return{distanceToStart:e-i,index:n,startPoint:r,endPoint:o};i+=c}throw new Error("Could not compute point")}getPercentageAt(t,s=.01){let e=0;for(let i=0;i<this._index.array.length-1;i+=2){const{startPoint:n,endPoint:r}=this.getSegment(i),o=n.distanceTo(r),c=t.distanceTo(n),f=t.distanceTo(r);if(c+f-o<=s){const h=e+c,u=this.getLength();return h/u}e+=o}return null}getSegment(t){const s=this._index.array[t]*3,e=this._index.array[t+1]*3,i=new L.Vector3(this._pos[s],this._pos[s+1],this._pos[s+2]),n=new L.Vector3(this._pos[e],this._pos[e+1],this._pos[e+2]);return{startPoint:i,endPoint:n}}}class re extends L.LineSegments{constructor(s,e,i,n,r){super(n,r);S(this,"curve");this.curve=new Oe(s,this,e,i)}}class nt{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsStreamedGeometry(t,s){return(s||new nt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometry(t,s){return t.setPosition(t.position()+W),(s||new nt).__init(t.readInt32(t.position())+t.position(),t)}geometryId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}position(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startStreamedGeometry(t){t.startObject(4)}static addGeometryId(t,s){t.addFieldInt32(0,s,0)}static addPosition(t,s){t.addFieldOffset(1,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(2,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(3,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static endStreamedGeometry(t){return t.endObject()}static createStreamedGeometry(t,s,e,i,n){return nt.startStreamedGeometry(t),nt.addGeometryId(t,s),nt.addPosition(t,e),nt.addNormal(t,i),nt.addIndex(t,n),nt.endStreamedGeometry(t)}}class It{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsStreamedGeometries(t,s){return(s||new It).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometries(t,s){return t.setPosition(t.position()+W),(s||new It).__init(t.readInt32(t.position())+t.position(),t)}geometries(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new nt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}geometriesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startStreamedGeometries(t){t.startObject(1)}static addGeometries(t,s){t.addFieldOffset(0,s,0)}static createGeometriesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startGeometriesVector(t,s){t.startVector(4,s,4)}static endStreamedGeometries(t){return t.endObject()}static finishStreamedGeometriesBuffer(t,s){t.finish(s)}static finishSizePrefixedStreamedGeometriesBuffer(t,s){t.finish(s,void 0,!0)}static createStreamedGeometries(t,s){return It.startStreamedGeometries(t),It.addGeometries(t,s),It.endStreamedGeometries(t)}}class $i{import(t){const s=new Tt(t),e=It.getRootAsStreamedGeometries(s),i=new Map,n=e.geometriesLength();for(let r=0;r<n;r++){const o=e.geometries(r);if(!o)continue;const c=o.geometryId();if(c===null)throw new Error("Error finding ID!");const f=o.positionArray(),l=o.normalArray(),b=o.indexArray();!f||!l||!b||i.set(c,{position:f,normal:l,index:b})}return i}export(t){const s=new ss(1024),e=[],i=It,n=nt;for(const[c,{index:f,position:l,normal:b}]of t){const h=n.createIndexVector(s,f),u=n.createPositionVector(s,l),_=n.createNormalVector(s,b);n.startStreamedGeometry(s),n.addGeometryId(s,c),n.addIndex(s,h),n.addPosition(s,u),n.addNormal(s,_);const x=n.endStreamedGeometry(s);e.push(x)}const r=i.createGeometriesVector(s,e);i.startStreamedGeometries(s),i.addGeometries(s,r);const o=i.endStreamedGeometries(s);return s.finish(o),s.asUint8Array()}}exports.Alignment=ne;exports.CivilCurve=Oe;exports.CurveMesh=re;exports.Fragment=ee;exports.FragmentMesh=Ns;exports.FragmentsGroup=ie;exports.Serializer=Ki;exports.StreamSerializer=$i;
