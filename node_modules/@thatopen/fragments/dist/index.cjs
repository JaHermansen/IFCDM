"use strict";var Ee=Object.defineProperty;var Ge=(a,t,s)=>t in a?Ee(a,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[t]=s;var S=(a,t,s)=>(Ge(a,typeof t!="symbol"?t+"":t,s),s);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const V=require("three");function Re(a){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const s in a)if(s!=="default"){const e=Object.getOwnPropertyDescriptor(a,s);Object.defineProperty(t,s,e.get?e:{enumerable:!0,get:()=>a[s]})}}return t.default=a,Object.freeze(t)}const O=Re(V);class qs extends O.InstancedMesh{constructor(s,e,i,n){super(s,e,i);S(this,"fragment");S(this,"material");S(this,"geometry");if(Array.isArray(e)||(e=[e]),this.material=e,!s.index)throw new Error("The geometry for fragments must be indexed!");this.geometry=s,this.fragment=n;const o=s.index.count;s.groups.length||s.groups.push({start:0,count:o,materialIndex:0})}exportData(){const s=this.geometry.attributes.position.array,e=this.geometry.attributes.normal.array,i=Array.from(this.geometry.index.array),n=[];for(const f of this.geometry.groups){const l=f.materialIndex||0,{start:b,count:h}=f;n.push(b,h,l)}const o=[];if(Array.isArray(this.material))for(const f of this.material){const l=f.opacity,b=f.transparent?1:0,h=new O.Color(f.color).toArray();o.push(l,b,...h)}const r=Array.from(this.instanceMatrix.array);let c;return this.instanceColor!==null?c=Array.from(this.instanceColor.array):c=[],{position:s,normal:e,index:i,groups:n,materials:o,matrices:r,colors:c}}clone(s){throw new Error("Fragment meshes can't be cloned directly. Use mesh.fragment.clone instead!")}}const Ce=0,Ne=1,ke=2,ce=2,Ps=1.25,ae=1,Is=6*4+4+4,Fs=65535,qe=Math.pow(2,-24),Ss=Symbol("SKIP_GENERATION");function Ke(a){return a.index?a.index.count:a.attributes.position.count}function $t(a){return Ke(a)/3}function je(a,t=ArrayBuffer){return a>65535?new Uint32Array(new t(4*a)):new Uint16Array(new t(2*a))}function $e(a,t){if(!a.index){const s=a.attributes.position.count,e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=je(s,e);a.setIndex(new V.BufferAttribute(i,1));for(let n=0;n<s;n++)i[n]=n}}function Me(a){const t=$t(a),s=a.drawRange,e=s.start/3,i=(s.start+s.count)/3,n=Math.max(0,e),o=Math.min(t,i)-n;return[{offset:Math.floor(n),count:Math.floor(o)}]}function Pe(a){if(!a.groups||!a.groups.length)return Me(a);const t=[],s=new Set,e=a.drawRange,i=e.start/3,n=(e.start+e.count)/3;for(const r of a.groups){const c=r.start/3,f=(r.start+r.count)/3;s.add(Math.max(i,c)),s.add(Math.min(n,f))}const o=Array.from(s.values()).sort((r,c)=>r-c);for(let r=0;r<o.length-1;r++){const c=o[r],f=o[r+1];t.push({offset:Math.floor(c),count:Math.floor(f-c)})}return t}function He(a){if(a.groups.length===0)return!1;const t=$t(a),s=Pe(a).sort((n,o)=>n.offset-o.offset),e=s[s.length-1];e.count=Math.min(t-e.offset,e.count);let i=0;return s.forEach(({count:n})=>i+=n),t!==i}function R(a,t,s){return s.min.x=t[a],s.min.y=t[a+1],s.min.z=t[a+2],s.max.x=t[a+3],s.max.y=t[a+4],s.max.z=t[a+5],s}function Xe(a){a[0]=a[1]=a[2]=1/0,a[3]=a[4]=a[5]=-1/0}function fe(a){let t=-1,s=-1/0;for(let e=0;e<3;e++){const i=a[e+3]-a[e];i>s&&(s=i,t=e)}return t}function le(a,t){t.set(a)}function he(a,t,s){let e,i;for(let n=0;n<3;n++){const o=n+3;e=a[n],i=t[n],s[n]=e<i?e:i,e=a[o],i=t[o],s[o]=e>i?e:i}}function os(a,t,s){for(let e=0;e<3;e++){const i=t[a+2*e],n=t[a+2*e+1],o=i-n,r=i+n;o<s[e]&&(s[e]=o),r>s[e+3]&&(s[e+3]=r)}}function Xt(a){const t=a[3]-a[0],s=a[4]-a[1],e=a[5]-a[2];return 2*(t*s+s*e+e*t)}function Bs(a,t,s,e,i=null){let n=1/0,o=1/0,r=1/0,c=-1/0,f=-1/0,l=-1/0,b=1/0,h=1/0,d=1/0,_=-1/0,I=-1/0,y=-1/0;const u=i!==null;for(let p=t*6,w=(t+s)*6;p<w;p+=6){const m=a[p+0],g=a[p+1],A=m-g,C=m+g;A<n&&(n=A),C>c&&(c=C),u&&m<b&&(b=m),u&&m>_&&(_=m);const x=a[p+2],M=a[p+3],v=x-M,B=x+M;v<o&&(o=v),B>f&&(f=B),u&&x<h&&(h=x),u&&x>I&&(I=x);const F=a[p+4],P=a[p+5],T=F-P,D=F+P;T<r&&(r=T),D>l&&(l=D),u&&F<d&&(d=F),u&&F>y&&(y=F)}e[0]=n,e[1]=o,e[2]=r,e[3]=c,e[4]=f,e[5]=l,u&&(i[0]=b,i[1]=h,i[2]=d,i[3]=_,i[4]=I,i[5]=y)}function Ye(a,t,s,e){let i=1/0,n=1/0,o=1/0,r=-1/0,c=-1/0,f=-1/0;for(let l=t*6,b=(t+s)*6;l<b;l+=6){const h=a[l+0];h<i&&(i=h),h>r&&(r=h);const d=a[l+2];d<n&&(n=d),d>c&&(c=d);const _=a[l+4];_<o&&(o=_),_>f&&(f=_)}e[0]=i,e[1]=n,e[2]=o,e[3]=r,e[4]=c,e[5]=f}function Ze(a,t){Xe(t);const s=a.attributes.position,e=a.index?a.index.array:null,i=$t(a),n=new Float32Array(i*6),o=s.normalized,r=s.array,c=s.offset||0;let f=3;s.isInterleavedBufferAttribute&&(f=s.data.stride);const l=["getX","getY","getZ"];for(let b=0;b<i;b++){const h=b*3,d=b*6;let _=h+0,I=h+1,y=h+2;e&&(_=e[_],I=e[I],y=e[y]),o||(_=_*f+c,I=I*f+c,y=y*f+c);for(let u=0;u<3;u++){let p,w,m;o?(p=s[l[u]](_),w=s[l[u]](I),m=s[l[u]](y)):(p=r[_+u],w=r[I+u],m=r[y+u]);let g=p;w<g&&(g=w),m<g&&(g=m);let A=p;w>A&&(A=w),m>A&&(A=m);const C=(A-g)/2,x=u*2;n[d+x+0]=g+C,n[d+x+1]=C+(Math.abs(g)+C)*qe,g<t[u]&&(t[u]=g),A>t[u+3]&&(t[u+3]=A)}}return n}const ft=32,Je=(a,t)=>a.candidate-t.candidate,yt=new Array(ft).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),rs=new Float32Array(6);function We(a,t,s,e,i,n){let o=-1,r=0;if(n===Ce)o=fe(t),o!==-1&&(r=(t[o]+t[o+3])/2);else if(n===Ne)o=fe(a),o!==-1&&(r=Qe(s,e,i,o));else if(n===ke){const c=Xt(a);let f=Ps*i;const l=e*6,b=(e+i)*6;for(let h=0;h<3;h++){const d=t[h],y=(t[h+3]-d)/ft;if(i<ft/4){const u=[...yt];u.length=i;let p=0;for(let m=l;m<b;m+=6,p++){const g=u[p];g.candidate=s[m+2*h],g.count=0;const{bounds:A,leftCacheBounds:C,rightCacheBounds:x}=g;for(let M=0;M<3;M++)x[M]=1/0,x[M+3]=-1/0,C[M]=1/0,C[M+3]=-1/0,A[M]=1/0,A[M+3]=-1/0;os(m,s,A)}u.sort(Je);let w=i;for(let m=0;m<w;m++){const g=u[m];for(;m+1<w&&u[m+1].candidate===g.candidate;)u.splice(m+1,1),w--}for(let m=l;m<b;m+=6){const g=s[m+2*h];for(let A=0;A<w;A++){const C=u[A];g>=C.candidate?os(m,s,C.rightCacheBounds):(os(m,s,C.leftCacheBounds),C.count++)}}for(let m=0;m<w;m++){const g=u[m],A=g.count,C=i-g.count,x=g.leftCacheBounds,M=g.rightCacheBounds;let v=0;A!==0&&(v=Xt(x)/c);let B=0;C!==0&&(B=Xt(M)/c);const F=ae+Ps*(v*A+B*C);F<f&&(o=h,f=F,r=g.candidate)}}else{for(let w=0;w<ft;w++){const m=yt[w];m.count=0,m.candidate=d+y+w*y;const g=m.bounds;for(let A=0;A<3;A++)g[A]=1/0,g[A+3]=-1/0}for(let w=l;w<b;w+=6){let A=~~((s[w+2*h]-d)/y);A>=ft&&(A=ft-1);const C=yt[A];C.count++,os(w,s,C.bounds)}const u=yt[ft-1];le(u.bounds,u.rightCacheBounds);for(let w=ft-2;w>=0;w--){const m=yt[w],g=yt[w+1];he(m.bounds,g.rightCacheBounds,m.rightCacheBounds)}let p=0;for(let w=0;w<ft-1;w++){const m=yt[w],g=m.count,A=m.bounds,x=yt[w+1].rightCacheBounds;g!==0&&(p===0?le(A,rs):he(A,rs,rs)),p+=g;let M=0,v=0;p!==0&&(M=Xt(rs)/c);const B=i-p;B!==0&&(v=Xt(x)/c);const F=ae+Ps*(M*p+v*B);F<f&&(o=h,f=F,r=m.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:o,pos:r}}function Qe(a,t,s,e){let i=0;for(let n=t,o=t+s;n<o;n++)i+=a[n*6+e*2];return i/s}class cs{constructor(){}}function ti(a,t,s,e,i,n){let o=e,r=e+i-1;const c=n.pos,f=n.axis*2;for(;;){for(;o<=r&&s[o*6+f]<c;)o++;for(;o<=r&&s[r*6+f]>=c;)r--;if(o<r){for(let l=0;l<3;l++){let b=t[o*3+l];t[o*3+l]=t[r*3+l],t[r*3+l]=b}for(let l=0;l<6;l++){let b=s[o*6+l];s[o*6+l]=s[r*6+l],s[r*6+l]=b}o++,r--}else return o}}function si(a,t,s,e,i,n){let o=e,r=e+i-1;const c=n.pos,f=n.axis*2;for(;;){for(;o<=r&&s[o*6+f]<c;)o++;for(;o<=r&&s[r*6+f]>=c;)r--;if(o<r){let l=a[o];a[o]=a[r],a[r]=l;for(let b=0;b<6;b++){let h=s[o*6+b];s[o*6+b]=s[r*6+b],s[r*6+b]=h}o++,r--}else return o}}function ei(a,t){const s=(a.index?a.index.count:a.attributes.position.count)/3,e=s>2**16,i=e?4:2,n=t?new SharedArrayBuffer(s*i):new ArrayBuffer(s*i),o=e?new Uint32Array(n):new Uint16Array(n);for(let r=0,c=o.length;r<c;r++)o[r]=r;return o}function ii(a,t){const s=a.geometry,e=s.index?s.index.array:null,i=t.maxDepth,n=t.verbose,o=t.maxLeafTris,r=t.strategy,c=t.onProgress,f=$t(s),l=a._indirectBuffer;let b=!1;const h=new Float32Array(6),d=new Float32Array(6),_=Ze(s,h),I=t.indirect?si:ti,y=[],u=t.indirect?Me(s):Pe(s);if(u.length===1){const m=u[0],g=new cs;g.boundingData=h,Ye(_,m.offset,m.count,d),w(g,m.offset,m.count,d),y.push(g)}else for(let m of u){const g=new cs;g.boundingData=new Float32Array(6),Bs(_,m.offset,m.count,g.boundingData,d),w(g,m.offset,m.count,d),y.push(g)}return y;function p(m){c&&c(m/f)}function w(m,g,A,C=null,x=0){if(!b&&x>=i&&(b=!0,n&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),A<=o||x>=i)return p(g+A),m.offset=g,m.count=A,m;const M=We(m.boundingData,C,_,g,A,r);if(M.axis===-1)return p(g+A),m.offset=g,m.count=A,m;const v=I(l,e,_,g,A,M);if(v===g||v===g+A)p(g+A),m.offset=g,m.count=A;else{m.splitAxis=M.axis;const B=new cs,F=g,P=v-g;m.left=B,B.boundingData=new Float32Array(6),Bs(_,F,P,B.boundingData,d),w(B,F,P,d,x+1);const T=new cs,D=v,L=A-P;m.right=T,T.boundingData=new Float32Array(6),Bs(_,D,L,T.boundingData,d),w(T,D,L,d,x+1)}return m}}function ni(a,t){const s=a.geometry;t.indirect&&(a._indirectBuffer=ei(s,t.useSharedArrayBuffer),He(s)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),a._indirectBuffer||$e(s,t);const e=ii(a,t);let i,n,o;const r=[],c=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let b=0;b<e.length;b++){const h=e[b];let d=f(h);const _=new c(Is*d);i=new Float32Array(_),n=new Uint32Array(_),o=new Uint16Array(_),l(0,h),r.push(_)}a._roots=r;return;function f(b){return b.count?1:1+f(b.left)+f(b.right)}function l(b,h){const d=b/4,_=b/2,I=!!h.count,y=h.boundingData;for(let u=0;u<6;u++)i[d+u]=y[u];if(I){const u=h.offset,p=h.count;return n[d+6]=u,o[_+14]=p,o[_+15]=Fs,b+Is}else{const u=h.left,p=h.right,w=h.splitAxis;let m;if(m=l(b+Is,u),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[d+6]=m/4,m=l(m,p),n[d+7]=w,m}}}class ut{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,s){let e=1/0,i=-1/0;for(let n=0,o=t.length;n<o;n++){const c=t[n][s];e=c<e?c:e,i=c>i?c:i}this.min=e,this.max=i}setFromPoints(t,s){let e=1/0,i=-1/0;for(let n=0,o=s.length;n<o;n++){const r=s[n],c=t.dot(r);e=c<e?c:e,i=c>i?c:i}this.min=e,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ut.prototype.setFromBox=function(){const a=new V.Vector3;return function(s,e){const i=e.min,n=e.max;let o=1/0,r=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){a.x=i.x*c+n.x*(1-c),a.y=i.y*f+n.y*(1-f),a.z=i.z*l+n.z*(1-l);const b=s.dot(a);o=Math.min(b,o),r=Math.max(b,r)}this.min=o,this.max=r}}();const oi=function(){const a=new V.Vector3,t=new V.Vector3,s=new V.Vector3;return function(i,n,o){const r=i.start,c=a,f=n.start,l=t;s.subVectors(r,f),a.subVectors(i.end,i.start),t.subVectors(n.end,n.start);const b=s.dot(l),h=l.dot(c),d=l.dot(l),_=s.dot(c),y=c.dot(c)*d-h*h;let u,p;y!==0?u=(b*h-_*d)/y:u=0,p=(b+u*h)/d,o.x=u,o.y=p}}(),se=function(){const a=new V.Vector2,t=new V.Vector3,s=new V.Vector3;return function(i,n,o,r){oi(i,n,a);let c=a.x,f=a.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,o),n.at(f,r);return}else if(c>=0&&c<=1){f<0?n.at(0,r):n.at(1,r),i.closestPointToPoint(r,!0,o);return}else if(f>=0&&f<=1){c<0?i.at(0,o):i.at(1,o),n.closestPointToPoint(o,!0,r);return}else{let l;c<0?l=i.start:l=i.end;let b;f<0?b=n.start:b=n.end;const h=t,d=s;if(i.closestPointToPoint(b,!0,t),n.closestPointToPoint(l,!0,s),h.distanceToSquared(b)<=d.distanceToSquared(l)){o.copy(h),r.copy(b);return}else{o.copy(l),r.copy(d);return}}}}(),ri=function(){const a=new V.Vector3,t=new V.Vector3,s=new V.Plane,e=new V.Line3;return function(n,o){const{radius:r,center:c}=n,{a:f,b:l,c:b}=o;if(e.start=f,e.end=l,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r||(e.start=f,e.end=b,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r)||(e.start=l,e.end=b,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r))return!0;const I=o.getPlane(s);if(Math.abs(I.distanceToPoint(c))<=r){const u=I.projectPoint(c,t);if(o.containsPoint(u))return!0}return!1}}(),ci=1e-15;function Ts(a){return Math.abs(a)<ci}class rt extends V.Triangle{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new V.Vector3),this.satBounds=new Array(4).fill().map(()=>new ut),this.points=[this.a,this.b,this.c],this.sphere=new V.Sphere,this.plane=new V.Plane,this.needsUpdate=!0}intersectsSphere(t){return ri(t,this)}update(){const t=this.a,s=this.b,e=this.c,i=this.points,n=this.satAxes,o=this.satBounds,r=n[0],c=o[0];this.getNormal(r),c.setFromPoints(r,i);const f=n[1],l=o[1];f.subVectors(t,s),l.setFromPoints(f,i);const b=n[2],h=o[2];b.subVectors(s,e),h.setFromPoints(b,i);const d=n[3],_=o[3];d.subVectors(e,t),_.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(r,t),this.needsUpdate=!1}}rt.prototype.closestPointToSegment=function(){const a=new V.Vector3,t=new V.Vector3,s=new V.Line3;return function(i,n=null,o=null){const{start:r,end:c}=i,f=this.points;let l,b=1/0;for(let h=0;h<3;h++){const d=(h+1)%3;s.start.copy(f[h]),s.end.copy(f[d]),se(s,i,a,t),l=a.distanceToSquared(t),l<b&&(b=l,n&&n.copy(a),o&&o.copy(t))}return this.closestPointToPoint(r,a),l=r.distanceToSquared(a),l<b&&(b=l,n&&n.copy(a),o&&o.copy(r)),this.closestPointToPoint(c,a),l=c.distanceToSquared(a),l<b&&(b=l,n&&n.copy(a),o&&o.copy(c)),Math.sqrt(b)}}();rt.prototype.intersectsTriangle=function(){const a=new rt,t=new Array(3),s=new Array(3),e=new ut,i=new ut,n=new V.Vector3,o=new V.Vector3,r=new V.Vector3,c=new V.Vector3,f=new V.Vector3,l=new V.Line3,b=new V.Line3,h=new V.Line3,d=new V.Vector3;function _(I,y,u){const p=I.points;let w=0,m=-1;for(let g=0;g<3;g++){const{start:A,end:C}=l;A.copy(p[g]),C.copy(p[(g+1)%3]),l.delta(o);const x=Ts(y.distanceToPoint(A));if(Ts(y.normal.dot(o))&&x){u.copy(l),w=2;break}const M=y.intersectLine(l,d);if(!M&&x&&d.copy(A),(M||x)&&!Ts(d.distanceTo(C))){if(w<=1)(w===1?u.start:u.end).copy(d),x&&(m=w);else if(w>=2){(m===1?u.start:u.end).copy(d),w=2;break}if(w++,w===2&&m===-1)break}}return w}return function(y,u=null,p=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(a.copy(y),a.update(),y=a);const w=this.plane,m=y.plane;if(Math.abs(w.normal.dot(m.normal))>1-1e-10){const g=this.satBounds,A=this.satAxes;s[0]=y.a,s[1]=y.b,s[2]=y.c;for(let M=0;M<4;M++){const v=g[M],B=A[M];if(e.setFromPoints(B,s),v.isSeparated(e))return!1}const C=y.satBounds,x=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let M=0;M<4;M++){const v=C[M],B=x[M];if(e.setFromPoints(B,t),v.isSeparated(e))return!1}for(let M=0;M<4;M++){const v=A[M];for(let B=0;B<4;B++){const F=x[B];if(n.crossVectors(v,F),e.setFromPoints(n,t),i.setFromPoints(n,s),e.isSeparated(i))return!1}}return u&&(p||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),u.start.set(0,0,0),u.end.set(0,0,0)),!0}else{const g=_(this,m,b);if(g===1&&y.containsPoint(b.end))return u&&(u.start.copy(b.end),u.end.copy(b.end)),!0;if(g!==2)return!1;const A=_(y,w,h);if(A===1&&this.containsPoint(h.end))return u&&(u.start.copy(h.end),u.end.copy(h.end)),!0;if(A!==2)return!1;if(b.delta(r),h.delta(c),r.dot(c)<0){let P=h.start;h.start=h.end,h.end=P}const C=b.start.dot(r),x=b.end.dot(r),M=h.start.dot(r),v=h.end.dot(r),B=x<M,F=C<v;return C!==v&&M!==x&&B===F?!1:(u&&(f.subVectors(b.start,h.start),f.dot(r)>0?u.start.copy(b.start):u.start.copy(h.start),f.subVectors(b.end,h.end),f.dot(r)<0?u.end.copy(b.end):u.end.copy(h.end)),!0)}}}();rt.prototype.distanceToPoint=function(){const a=new V.Vector3;return function(s){return this.closestPointToPoint(s,a),s.distanceTo(a)}}();rt.prototype.distanceToTriangle=function(){const a=new V.Vector3,t=new V.Vector3,s=["a","b","c"],e=new V.Line3,i=new V.Line3;return function(o,r=null,c=null){const f=r||c?e:null;if(this.intersectsTriangle(o,f))return(r||c)&&(r&&f.getCenter(r),c&&f.getCenter(c)),0;let l=1/0;for(let b=0;b<3;b++){let h;const d=s[b],_=o[d];this.closestPointToPoint(_,a),h=_.distanceToSquared(a),h<l&&(l=h,r&&r.copy(a),c&&c.copy(_));const I=this[d];o.closestPointToPoint(I,a),h=I.distanceToSquared(a),h<l&&(l=h,r&&r.copy(I),c&&c.copy(a))}for(let b=0;b<3;b++){const h=s[b],d=s[(b+1)%3];e.set(this[h],this[d]);for(let _=0;_<3;_++){const I=s[_],y=s[(_+1)%3];i.set(o[I],o[y]),se(e,i,a,t);const u=a.distanceToSquared(t);u<l&&(l=u,r&&r.copy(a),c&&c.copy(t))}}return Math.sqrt(l)}}();class X{constructor(t,s,e){this.isOrientedBox=!0,this.min=new V.Vector3,this.max=new V.Vector3,this.matrix=new V.Matrix4,this.invMatrix=new V.Matrix4,this.points=new Array(8).fill().map(()=>new V.Vector3),this.satAxes=new Array(3).fill().map(()=>new V.Vector3),this.satBounds=new Array(3).fill().map(()=>new ut),this.alignedSatBounds=new Array(3).fill().map(()=>new ut),this.needsUpdate=!1,t&&this.min.copy(t),s&&this.max.copy(s),e&&this.matrix.copy(e)}set(t,s,e){this.min.copy(t),this.max.copy(s),this.matrix.copy(e),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}X.prototype.update=function(){return function(){const t=this.matrix,s=this.min,e=this.max,i=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let b=0;b<=1;b++){const h=1*f|2*l|4*b,d=i[h];d.x=f?e.x:s.x,d.y=l?e.y:s.y,d.z=b?e.z:s.z,d.applyMatrix4(t)}const n=this.satBounds,o=this.satAxes,r=i[0];for(let f=0;f<3;f++){const l=o[f],b=n[f],h=1<<f,d=i[h];l.subVectors(r,d),b.setFromPoints(l,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();X.prototype.intersectsBox=function(){const a=new ut;return function(s){this.needsUpdate&&this.update();const e=s.min,i=s.max,n=this.satBounds,o=this.satAxes,r=this.alignedSatBounds;if(a.min=e.x,a.max=i.x,r[0].isSeparated(a)||(a.min=e.y,a.max=i.y,r[1].isSeparated(a))||(a.min=e.z,a.max=i.z,r[2].isSeparated(a)))return!1;for(let c=0;c<3;c++){const f=o[c],l=n[c];if(a.setFromBox(f,s),l.isSeparated(a))return!1}return!0}}();X.prototype.intersectsTriangle=function(){const a=new rt,t=new Array(3),s=new ut,e=new ut,i=new V.Vector3;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(a.copy(o),a.update(),o=a);const r=this.satBounds,c=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let h=0;h<3;h++){const d=r[h],_=c[h];if(s.setFromPoints(_,t),d.isSeparated(s))return!1}const f=o.satBounds,l=o.satAxes,b=this.points;for(let h=0;h<3;h++){const d=f[h],_=l[h];if(s.setFromPoints(_,b),d.isSeparated(s))return!1}for(let h=0;h<3;h++){const d=c[h];for(let _=0;_<4;_++){const I=l[_];if(i.crossVectors(d,I),s.setFromPoints(i,t),e.setFromPoints(i,b),s.isSeparated(e))return!1}}return!0}}();X.prototype.closestPointToPoint=function(){return function(t,s){return this.needsUpdate&&this.update(),s.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),s}}();X.prototype.distanceToPoint=function(){const a=new V.Vector3;return function(s){return this.closestPointToPoint(s,a),s.distanceTo(a)}}();X.prototype.distanceToBox=function(){const a=["x","y","z"],t=new Array(12).fill().map(()=>new V.Line3),s=new Array(12).fill().map(()=>new V.Line3),e=new V.Vector3,i=new V.Vector3;return function(o,r=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||f)&&(o.getCenter(i),this.closestPointToPoint(i,e),o.closestPointToPoint(e,i),c&&c.copy(e),f&&f.copy(i)),0;const l=r*r,b=o.min,h=o.max,d=this.points;let _=1/0;for(let y=0;y<8;y++){const u=d[y];i.copy(u).clamp(b,h);const p=u.distanceToSquared(i);if(p<_&&(_=p,c&&c.copy(u),f&&f.copy(i),p<l))return Math.sqrt(p)}let I=0;for(let y=0;y<3;y++)for(let u=0;u<=1;u++)for(let p=0;p<=1;p++){const w=(y+1)%3,m=(y+2)%3,g=u<<w|p<<m,A=1<<y|u<<w|p<<m,C=d[g],x=d[A];t[I].set(C,x);const v=a[y],B=a[w],F=a[m],P=s[I],T=P.start,D=P.end;T[v]=b[v],T[B]=u?b[B]:h[B],T[F]=p?b[F]:h[B],D[v]=h[v],D[B]=u?b[B]:h[B],D[F]=p?b[F]:h[B],I++}for(let y=0;y<=1;y++)for(let u=0;u<=1;u++)for(let p=0;p<=1;p++){i.x=y?h.x:b.x,i.y=u?h.y:b.y,i.z=p?h.z:b.z,this.closestPointToPoint(i,e);const w=i.distanceToSquared(e);if(w<_&&(_=w,c&&c.copy(e),f&&f.copy(i),w<l))return Math.sqrt(w)}for(let y=0;y<12;y++){const u=t[y];for(let p=0;p<12;p++){const w=s[p];se(u,w,e,i);const m=e.distanceToSquared(i);if(m<_&&(_=m,c&&c.copy(e),f&&f.copy(i),m<l))return Math.sqrt(m)}}return Math.sqrt(_)}}();class ee{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ai extends ee{constructor(){super(()=>new rt)}}const tt=new ai;function J(a,t){return t[a+15]===65535}function W(a,t){return t[a+6]}function st(a,t){return t[a+14]}function et(a){return a+8}function it(a,t){return t[a+6]}function Se(a,t){return t[a+7]}class fi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let s=null;this.setBuffer=e=>{s&&t.push(s),s=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{s=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const G=new fi;let xt,jt;const Lt=[],as=new ee(()=>new V.Box3);function li(a,t,s,e,i,n){xt=as.getPrimitive(),jt=as.getPrimitive(),Lt.push(xt,jt),G.setBuffer(a._roots[t]);const o=Ks(0,a.geometry,s,e,i,n);G.clearBuffer(),as.releasePrimitive(xt),as.releasePrimitive(jt),Lt.pop(),Lt.pop();const r=Lt.length;return r>0&&(jt=Lt[r-1],xt=Lt[r-2]),o}function Ks(a,t,s,e,i=null,n=0,o=0){const{float32Array:r,uint16Array:c,uint32Array:f}=G;let l=a*2;if(J(l,c)){const h=W(a,f),d=st(l,c);return R(a,r,xt),e(h,d,!1,o,n+a,xt)}else{let v=function(F){const{uint16Array:P,uint32Array:T}=G;let D=F*2;for(;!J(D,P);)F=et(F),D=F*2;return W(F,T)},B=function(F){const{uint16Array:P,uint32Array:T}=G;let D=F*2;for(;!J(D,P);)F=it(F,T),D=F*2;return W(F,T)+st(D,P)};const h=et(a),d=it(a,f);let _=h,I=d,y,u,p,w;if(i&&(p=xt,w=jt,R(_,r,p),R(I,r,w),y=i(p),u=i(w),u<y)){_=d,I=h;const F=y;y=u,u=F,p=w}p||(p=xt,R(_,r,p));const m=J(_*2,c),g=s(p,m,y,o+1,n+_);let A;if(g===ce){const F=v(_),T=B(_)-F;A=e(F,T,!0,o+1,n+_,p)}else A=g&&Ks(_,t,s,e,i,n,o+1);if(A)return!0;w=jt,R(I,r,w);const C=J(I*2,c),x=s(w,C,u,o+1,n+I);let M;if(x===ce){const F=v(I),T=B(I)-F;M=e(F,T,!0,o+1,n+I,w)}else M=x&&Ks(I,t,s,e,i,n,o+1);return!!M}}const Yt=new V.Vector3,Ds=new V.Vector3;function hi(a,t,s={},e=0,i=1/0){const n=e*e,o=i*i;let r=1/0,c=null;if(a.shapecast({boundsTraverseOrder:l=>(Yt.copy(t).clamp(l.min,l.max),Yt.distanceToSquared(t)),intersectsBounds:(l,b,h)=>h<r&&h<o,intersectsTriangle:(l,b)=>{l.closestPointToPoint(t,Yt);const h=t.distanceToSquared(Yt);return h<r&&(Ds.copy(Yt),r=h,c=b),h<n}}),r===1/0)return null;const f=Math.sqrt(r);return s.point?s.point.copy(Ds):s.point=Ds.clone(),s.distance=f,s.faceIndex=c,s}const Ut=new V.Vector3,zt=new V.Vector3,Et=new V.Vector3,fs=new V.Vector2,ls=new V.Vector2,hs=new V.Vector2,be=new V.Vector3,de=new V.Vector3,ue=new V.Vector3,bs=new V.Vector3;function bi(a,t,s,e,i,n){let o;return n===V.BackSide?o=a.intersectTriangle(e,s,t,!0,i):o=a.intersectTriangle(t,s,e,n!==V.DoubleSide,i),o===null?null:{distance:a.origin.distanceTo(i),point:i.clone()}}function di(a,t,s,e,i,n,o,r,c){Ut.fromBufferAttribute(t,n),zt.fromBufferAttribute(t,o),Et.fromBufferAttribute(t,r);const f=bi(a,Ut,zt,Et,bs,c);if(f){e&&(fs.fromBufferAttribute(e,n),ls.fromBufferAttribute(e,o),hs.fromBufferAttribute(e,r),f.uv=V.Triangle.getInterpolation(bs,Ut,zt,Et,fs,ls,hs,new V.Vector2)),i&&(fs.fromBufferAttribute(i,n),ls.fromBufferAttribute(i,o),hs.fromBufferAttribute(i,r),f.uv1=V.Triangle.getInterpolation(bs,Ut,zt,Et,fs,ls,hs,new V.Vector2)),s&&(be.fromBufferAttribute(s,n),de.fromBufferAttribute(s,o),ue.fromBufferAttribute(s,r),f.normal=V.Triangle.getInterpolation(bs,Ut,zt,Et,be,de,ue,new V.Vector3),f.normal.dot(a.direction)>0&&f.normal.multiplyScalar(-1));const l={a:n,b:o,c:r,normal:new V.Vector3,materialIndex:0};V.Triangle.getNormal(Ut,zt,Et,l.normal),f.face=l,f.faceIndex=n}return f}function Cs(a,t,s,e,i){const n=e*3;let o=n+0,r=n+1,c=n+2;const f=a.index;a.index&&(o=f.getX(o),r=f.getX(r),c=f.getX(c));const{position:l,normal:b,uv:h,uv1:d}=a.attributes,_=di(s,l,b,h,d,o,r,c,t);return _?(_.faceIndex=e,i&&i.push(_),_):null}function q(a,t,s,e){const i=a.a,n=a.b,o=a.c;let r=t,c=t+1,f=t+2;s&&(r=s.getX(r),c=s.getX(c),f=s.getX(f)),i.x=e.getX(r),i.y=e.getY(r),i.z=e.getZ(r),n.x=e.getX(c),n.y=e.getY(c),n.z=e.getZ(c),o.x=e.getX(f),o.y=e.getY(f),o.z=e.getZ(f)}function ui(a,t,s,e,i,n){const{geometry:o,_indirectBuffer:r}=a;for(let c=e,f=e+i;c<f;c++)Cs(o,t,s,c,n)}function _i(a,t,s,e,i){const{geometry:n,_indirectBuffer:o}=a;let r=1/0,c=null;for(let f=e,l=e+i;f<l;f++){let b;b=Cs(n,t,s,f),b&&b.distance<r&&(c=b,r=b.distance)}return c}function pi(a,t,s,e,i,n,o){const{geometry:r}=s,{index:c}=r,f=r.attributes.position;for(let l=a,b=t+a;l<b;l++){let h;if(h=l,q(o,h*3,c,f),o.needsUpdate=!0,e(o,h,i,n))return!0}return!1}function mi(a,t=null){t&&Array.isArray(t)&&(t=new Set(t));const s=a.geometry,e=s.index?s.index.array:null,i=s.attributes.position;let n,o,r,c,f=0;const l=a._roots;for(let h=0,d=l.length;h<d;h++)n=l[h],o=new Uint32Array(n),r=new Uint16Array(n),c=new Float32Array(n),b(0,f),f+=n.byteLength;function b(h,d,_=!1){const I=h*2;if(r[I+15]===Fs){const u=o[h+6],p=r[I+14];let w=1/0,m=1/0,g=1/0,A=-1/0,C=-1/0,x=-1/0;for(let M=3*u,v=3*(u+p);M<v;M++){let B=e[M];const F=i.getX(B),P=i.getY(B),T=i.getZ(B);F<w&&(w=F),F>A&&(A=F),P<m&&(m=P),P>C&&(C=P),T<g&&(g=T),T>x&&(x=T)}return c[h+0]!==w||c[h+1]!==m||c[h+2]!==g||c[h+3]!==A||c[h+4]!==C||c[h+5]!==x?(c[h+0]=w,c[h+1]=m,c[h+2]=g,c[h+3]=A,c[h+4]=C,c[h+5]=x,!0):!1}else{const u=h+8,p=o[h+6],w=u+d,m=p+d;let g=_,A=!1,C=!1;t?g||(A=t.has(w),C=t.has(m),g=!A&&!C):(A=!0,C=!0);const x=g||A,M=g||C;let v=!1;x&&(v=b(u,d,g));let B=!1;M&&(B=b(p,d,g));const F=v||B;if(F)for(let P=0;P<3;P++){const T=u+P,D=p+P,L=c[T],H=c[T+3],Y=c[D],Z=c[D+3];c[h+P]=L<Y?L:Y,c[h+P+3]=H>Z?H:Z}return F}}}const _e=new V.Box3;function At(a,t,s,e){return R(a,t,_e),s.intersectBox(_e,e)}function yi(a,t,s,e,i,n){const{geometry:o,_indirectBuffer:r}=a;for(let c=e,f=e+i;c<f;c++){let l=r?r[c]:c;Cs(o,t,s,l,n)}}function gi(a,t,s,e,i){const{geometry:n,_indirectBuffer:o}=a;let r=1/0,c=null;for(let f=e,l=e+i;f<l;f++){let b;b=Cs(n,t,s,o?o[f]:f),b&&b.distance<r&&(c=b,r=b.distance)}return c}function wi(a,t,s,e,i,n,o){const{geometry:r}=s,{index:c}=r,f=r.attributes.position;for(let l=a,b=t+a;l<b;l++){let h;if(h=s.resolveTriangleIndex(l),q(o,h*3,c,f),o.needsUpdate=!0,e(o,h,i,n))return!0}return!1}const pe=new V.Vector3;function Ii(a,t,s,e,i){G.setBuffer(a._roots[t]),js(0,a,s,e,i),G.clearBuffer()}function js(a,t,s,e,i){const{float32Array:n,uint16Array:o,uint32Array:r}=G,c=a*2;if(J(c,o)){const l=W(a,r),b=st(c,o);ui(t,s,e,l,b,i)}else{const l=et(a);At(l,n,e,pe)&&js(l,t,s,e,i);const b=it(a,r);At(b,n,e,pe)&&js(b,t,s,e,i)}}const me=new V.Vector3,xi=["x","y","z"];function Ai(a,t,s,e){G.setBuffer(a._roots[t]);const i=$s(0,a,s,e);return G.clearBuffer(),i}function $s(a,t,s,e){const{float32Array:i,uint16Array:n,uint32Array:o}=G;let r=a*2;if(J(r,n)){const f=W(a,o),l=st(r,n);return _i(t,s,e,f,l)}else{const f=Se(a,o),l=xi[f],h=e.direction[l]>=0;let d,_;h?(d=et(a),_=it(a,o)):(d=it(a,o),_=et(a));const y=At(d,i,e,me)?$s(d,t,s,e):null;if(y){const w=y.point[l];if(h?w<=i[_+f]:w>=i[_+f+3])return y}const p=At(_,i,e,me)?$s(_,t,s,e):null;return y&&p?y.distance<=p.distance?y:p:y||p||null}}const ds=new V.Box3,Gt=new rt,Rt=new rt,Zt=new V.Matrix4,ye=new X,us=new X;function vi(a,t,s,e){G.setBuffer(a._roots[t]);const i=Hs(0,a,s,e);return G.clearBuffer(),i}function Hs(a,t,s,e,i=null){const{float32Array:n,uint16Array:o,uint32Array:r}=G;let c=a*2;if(i===null&&(s.boundingBox||s.computeBoundingBox(),ye.set(s.boundingBox.min,s.boundingBox.max,e),i=ye),J(c,o)){const l=t.geometry,b=l.index,h=l.attributes.position,d=s.index,_=s.attributes.position,I=W(a,r),y=st(c,o);if(Zt.copy(e).invert(),s.boundsTree)return R(a,n,us),us.matrix.copy(Zt),us.needsUpdate=!0,s.boundsTree.shapecast({intersectsBounds:p=>us.intersectsBox(p),intersectsTriangle:p=>{p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let w=I*3,m=(y+I)*3;w<m;w+=3)if(q(Rt,w,b,h),Rt.needsUpdate=!0,p.intersectsTriangle(Rt))return!0;return!1}});for(let u=I*3,p=(y+I)*3;u<p;u+=3){q(Gt,u,b,h),Gt.a.applyMatrix4(Zt),Gt.b.applyMatrix4(Zt),Gt.c.applyMatrix4(Zt),Gt.needsUpdate=!0;for(let w=0,m=d.count;w<m;w+=3)if(q(Rt,w,d,_),Rt.needsUpdate=!0,Gt.intersectsTriangle(Rt))return!0}}else{const l=a+8,b=r[a+6];return R(l,n,ds),!!(i.intersectsBox(ds)&&Hs(l,t,s,e,i)||(R(b,n,ds),i.intersectsBox(ds)&&Hs(b,t,s,e,i)))}}const _s=new V.Matrix4,Os=new X,Jt=new X,Vi=new V.Vector3,Fi=new V.Vector3,Ci=new V.Vector3,Mi=new V.Vector3;function Pi(a,t,s,e={},i={},n=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Os.set(t.boundingBox.min,t.boundingBox.max,s),Os.needsUpdate=!0;const r=a.geometry,c=r.attributes.position,f=r.index,l=t.attributes.position,b=t.index,h=tt.getPrimitive(),d=tt.getPrimitive();let _=Vi,I=Fi,y=null,u=null;i&&(y=Ci,u=Mi);let p=1/0,w=null,m=null;return _s.copy(s).invert(),Jt.matrix.copy(_s),a.shapecast({boundsTraverseOrder:g=>Os.distanceToBox(g),intersectsBounds:(g,A,C)=>C<p&&C<o?(A&&(Jt.min.copy(g.min),Jt.max.copy(g.max),Jt.needsUpdate=!0),!0):!1,intersectsRange:(g,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:x=>Jt.distanceToBox(x),intersectsBounds:(x,M,v)=>v<p&&v<o,intersectsRange:(x,M)=>{for(let v=x,B=x+M;v<B;v++){q(d,3*v,b,l),d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let F=g,P=g+A;F<P;F++){q(h,3*F,f,c),h.needsUpdate=!0;const T=h.distanceToTriangle(d,_,y);if(T<p&&(I.copy(_),u&&u.copy(y),p=T,w=F,m=v),T<n)return!0}}}});{const C=$t(t);for(let x=0,M=C;x<M;x++){q(d,3*x,b,l),d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let v=g,B=g+A;v<B;v++){q(h,3*v,f,c),h.needsUpdate=!0;const F=h.distanceToTriangle(d,_,y);if(F<p&&(I.copy(_),u&&u.copy(y),p=F,w=v,m=x),F<n)return!0}}}}}),tt.releasePrimitive(h),tt.releasePrimitive(d),p===1/0?null:(e.point?e.point.copy(I):e.point=I.clone(),e.distance=p,e.faceIndex=w,i&&(i.point?i.point.copy(u):i.point=u.clone(),i.point.applyMatrix4(_s),I.applyMatrix4(_s),i.distance=I.sub(i.point).length(),i.faceIndex=m),e)}function Si(a,t=null){t&&Array.isArray(t)&&(t=new Set(t));const s=a.geometry,e=s.index?s.index.array:null,i=s.attributes.position;let n,o,r,c,f=0;const l=a._roots;for(let h=0,d=l.length;h<d;h++)n=l[h],o=new Uint32Array(n),r=new Uint16Array(n),c=new Float32Array(n),b(0,f),f+=n.byteLength;function b(h,d,_=!1){const I=h*2;if(r[I+15]===Fs){const u=o[h+6],p=r[I+14];let w=1/0,m=1/0,g=1/0,A=-1/0,C=-1/0,x=-1/0;for(let M=u,v=u+p;M<v;M++){const B=3*a.resolveTriangleIndex(M);for(let F=0;F<3;F++){let P=B+F;P=e?e[P]:P;const T=i.getX(P),D=i.getY(P),L=i.getZ(P);T<w&&(w=T),T>A&&(A=T),D<m&&(m=D),D>C&&(C=D),L<g&&(g=L),L>x&&(x=L)}}return c[h+0]!==w||c[h+1]!==m||c[h+2]!==g||c[h+3]!==A||c[h+4]!==C||c[h+5]!==x?(c[h+0]=w,c[h+1]=m,c[h+2]=g,c[h+3]=A,c[h+4]=C,c[h+5]=x,!0):!1}else{const u=h+8,p=o[h+6],w=u+d,m=p+d;let g=_,A=!1,C=!1;t?g||(A=t.has(w),C=t.has(m),g=!A&&!C):(A=!0,C=!0);const x=g||A,M=g||C;let v=!1;x&&(v=b(u,d,g));let B=!1;M&&(B=b(p,d,g));const F=v||B;if(F)for(let P=0;P<3;P++){const T=u+P,D=p+P,L=c[T],H=c[T+3],Y=c[D],Z=c[D+3];c[h+P]=L<Y?L:Y,c[h+P+3]=H>Z?H:Z}return F}}}const ge=new V.Vector3;function Bi(a,t,s,e,i){G.setBuffer(a._roots[t]),Xs(0,a,s,e,i),G.clearBuffer()}function Xs(a,t,s,e,i){const{float32Array:n,uint16Array:o,uint32Array:r}=G,c=a*2;if(J(c,o)){const l=W(a,r),b=st(c,o);yi(t,s,e,l,b,i)}else{const l=et(a);At(l,n,e,ge)&&Xs(l,t,s,e,i);const b=it(a,r);At(b,n,e,ge)&&Xs(b,t,s,e,i)}}const we=new V.Vector3,Ti=["x","y","z"];function Di(a,t,s,e){G.setBuffer(a._roots[t]);const i=Ys(0,a,s,e);return G.clearBuffer(),i}function Ys(a,t,s,e){const{float32Array:i,uint16Array:n,uint32Array:o}=G;let r=a*2;if(J(r,n)){const f=W(a,o),l=st(r,n);return gi(t,s,e,f,l)}else{const f=Se(a,o),l=Ti[f],h=e.direction[l]>=0;let d,_;h?(d=et(a),_=it(a,o)):(d=it(a,o),_=et(a));const y=At(d,i,e,we)?Ys(d,t,s,e):null;if(y){const w=y.point[l];if(h?w<=i[_+f]:w>=i[_+f+3])return y}const p=At(_,i,e,we)?Ys(_,t,s,e):null;return y&&p?y.distance<=p.distance?y:p:y||p||null}}const ps=new V.Box3,Nt=new rt,kt=new rt,Wt=new V.Matrix4,Ie=new X,ms=new X;function Oi(a,t,s,e){G.setBuffer(a._roots[t]);const i=Zs(0,a,s,e);return G.clearBuffer(),i}function Zs(a,t,s,e,i=null){const{float32Array:n,uint16Array:o,uint32Array:r}=G;let c=a*2;if(i===null&&(s.boundingBox||s.computeBoundingBox(),Ie.set(s.boundingBox.min,s.boundingBox.max,e),i=Ie),J(c,o)){const l=t.geometry,b=l.index,h=l.attributes.position,d=s.index,_=s.attributes.position,I=W(a,r),y=st(c,o);if(Wt.copy(e).invert(),s.boundsTree)return R(a,n,ms),ms.matrix.copy(Wt),ms.needsUpdate=!0,s.boundsTree.shapecast({intersectsBounds:p=>ms.intersectsBox(p),intersectsTriangle:p=>{p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let w=I,m=y+I;w<m;w++)if(q(kt,3*t.resolveTriangleIndex(w),b,h),kt.needsUpdate=!0,p.intersectsTriangle(kt))return!0;return!1}});for(let u=I,p=y+I;u<p;u++){const w=t.resolveTriangleIndex(u);q(Nt,3*w,b,h),Nt.a.applyMatrix4(Wt),Nt.b.applyMatrix4(Wt),Nt.c.applyMatrix4(Wt),Nt.needsUpdate=!0;for(let m=0,g=d.count;m<g;m+=3)if(q(kt,m,d,_),kt.needsUpdate=!0,Nt.intersectsTriangle(kt))return!0}}else{const l=a+8,b=r[a+6];return R(l,n,ps),!!(i.intersectsBox(ps)&&Zs(l,t,s,e,i)||(R(b,n,ps),i.intersectsBox(ps)&&Zs(b,t,s,e,i)))}}const ys=new V.Matrix4,Ls=new X,Qt=new X,Li=new V.Vector3,Ui=new V.Vector3,zi=new V.Vector3,Ei=new V.Vector3;function Gi(a,t,s,e={},i={},n=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Ls.set(t.boundingBox.min,t.boundingBox.max,s),Ls.needsUpdate=!0;const r=a.geometry,c=r.attributes.position,f=r.index,l=t.attributes.position,b=t.index,h=tt.getPrimitive(),d=tt.getPrimitive();let _=Li,I=Ui,y=null,u=null;i&&(y=zi,u=Ei);let p=1/0,w=null,m=null;return ys.copy(s).invert(),Qt.matrix.copy(ys),a.shapecast({boundsTraverseOrder:g=>Ls.distanceToBox(g),intersectsBounds:(g,A,C)=>C<p&&C<o?(A&&(Qt.min.copy(g.min),Qt.max.copy(g.max),Qt.needsUpdate=!0),!0):!1,intersectsRange:(g,A)=>{if(t.boundsTree){const C=t.boundsTree;return C.shapecast({boundsTraverseOrder:x=>Qt.distanceToBox(x),intersectsBounds:(x,M,v)=>v<p&&v<o,intersectsRange:(x,M)=>{for(let v=x,B=x+M;v<B;v++){const F=C.resolveTriangleIndex(v);q(d,3*F,b,l),d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let P=g,T=g+A;P<T;P++){const D=a.resolveTriangleIndex(P);q(h,3*D,f,c),h.needsUpdate=!0;const L=h.distanceToTriangle(d,_,y);if(L<p&&(I.copy(_),u&&u.copy(y),p=L,w=P,m=v),L<n)return!0}}}})}else{const C=$t(t);for(let x=0,M=C;x<M;x++){q(d,3*x,b,l),d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let v=g,B=g+A;v<B;v++){const F=a.resolveTriangleIndex(v);q(h,3*F,f,c),h.needsUpdate=!0;const P=h.distanceToTriangle(d,_,y);if(P<p&&(I.copy(_),u&&u.copy(y),p=P,w=v,m=x),P<n)return!0}}}}}),tt.releasePrimitive(h),tt.releasePrimitive(d),p===1/0?null:(e.point?e.point.copy(I):e.point=I.clone(),e.distance=p,e.faceIndex=w,i&&(i.point?i.point.copy(u):i.point=u.clone(),i.point.applyMatrix4(ys),I.applyMatrix4(ys),i.distance=I.sub(i.point).length(),i.faceIndex=m),e)}function Ri(){return typeof SharedArrayBuffer<"u"}const ts=new G.constructor,vs=new G.constructor,gt=new ee(()=>new V.Box3),qt=new V.Box3,Kt=new V.Box3,Us=new V.Box3,zs=new V.Box3;let Es=!1;function Ni(a,t,s,e){if(Es)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Es=!0;const i=a._roots,n=t._roots;let o,r=0,c=0;const f=new V.Matrix4().copy(s).invert();for(let l=0,b=i.length;l<b;l++){ts.setBuffer(i[l]),c=0;const h=gt.getPrimitive();R(0,ts.float32Array,h),h.applyMatrix4(f);for(let d=0,_=n.length;d<_&&(vs.setBuffer(n[l]),o=nt(0,0,s,f,e,r,c,0,0,h),vs.clearBuffer(),c+=n[d].length,!o);d++);if(gt.releasePrimitive(h),ts.clearBuffer(),r+=i[l].length,o)break}return Es=!1,o}function nt(a,t,s,e,i,n=0,o=0,r=0,c=0,f=null,l=!1){let b,h;l?(b=vs,h=ts):(b=ts,h=vs);const d=b.float32Array,_=b.uint32Array,I=b.uint16Array,y=h.float32Array,u=h.uint32Array,p=h.uint16Array,w=a*2,m=t*2,g=J(w,I),A=J(m,p);let C=!1;if(A&&g)l?C=i(W(t,u),st(t*2,p),W(a,_),st(a*2,I),c,o+t,r,n+a):C=i(W(a,_),st(a*2,I),W(t,u),st(t*2,p),r,n+a,c,o+t);else if(A){const x=gt.getPrimitive();R(t,y,x),x.applyMatrix4(s);const M=et(a),v=it(a,_);R(M,d,qt),R(v,d,Kt);const B=x.intersectsBox(qt),F=x.intersectsBox(Kt);C=B&&nt(t,M,e,s,i,o,n,c,r+1,x,!l)||F&&nt(t,v,e,s,i,o,n,c,r+1,x,!l),gt.releasePrimitive(x)}else{const x=et(t),M=it(t,u);R(x,y,Us),R(M,y,zs);const v=f.intersectsBox(Us),B=f.intersectsBox(zs);if(v&&B)C=nt(a,x,s,e,i,n,o,r,c+1,f,l)||nt(a,M,s,e,i,n,o,r,c+1,f,l);else if(v)if(g)C=nt(a,x,s,e,i,n,o,r,c+1,f,l);else{const F=gt.getPrimitive();F.copy(Us).applyMatrix4(s);const P=et(a),T=it(a,_);R(P,d,qt),R(T,d,Kt);const D=F.intersectsBox(qt),L=F.intersectsBox(Kt);C=D&&nt(x,P,e,s,i,o,n,c,r+1,F,!l)||L&&nt(x,T,e,s,i,o,n,c,r+1,F,!l),gt.releasePrimitive(F)}else if(B)if(g)C=nt(a,M,s,e,i,n,o,r,c+1,f,l);else{const F=gt.getPrimitive();F.copy(zs).applyMatrix4(s);const P=et(a),T=it(a,_);R(P,d,qt),R(T,d,Kt);const D=F.intersectsBox(qt),L=F.intersectsBox(Kt);C=D&&nt(M,P,e,s,i,o,n,c,r+1,F,!l)||L&&nt(M,T,e,s,i,o,n,c,r+1,F,!l),gt.releasePrimitive(F)}}return C}const gs=new X,xe=new V.Box3;class ie{static serialize(t,s={}){s={cloneBuffers:!0,...s};const e=t.geometry,i=t._roots,n=t._indirectBuffer,o=e.getIndex();let r;return s.cloneBuffers?r={roots:i.map(c=>c.slice()),index:o.array.slice(),indirectBuffer:n?n.slice():null}:r={roots:i,index:o.array,indirectBuffer:n},r}static deserialize(t,s,e={}){e={setIndex:!0,indirect:!!t.indirectBuffer,...e};const{index:i,roots:n,indirectBuffer:o}=t,r=new ie(s,{...e,[Ss]:!0});if(r._roots=n,r._indirectBuffer=o||null,e.setIndex){const c=s.getIndex();if(c===null){const f=new V.BufferAttribute(t.index,1,!1);s.setIndex(f)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return r}get indirect(){return!!this._indirectBuffer}constructor(t,s={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(s=Object.assign({strategy:Ce,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Ss]:!1},s),s.useSharedArrayBuffer&&!Ri())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,s[Ss]||(ni(this,s),!t.boundingBox&&s.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new V.Box3)));const{_indirectBuffer:e}=this;this.resolveTriangleIndex=s.indirect?i=>e[i]:i=>i}refit(t=null){return(this.indirect?Si:mi)(this,t)}traverse(t,s=0){const e=this._roots[s],i=new Uint32Array(e),n=new Uint16Array(e);o(0);function o(r,c=0){const f=r*2,l=n[f+15]===Fs;if(l){const b=i[r+6],h=n[f+14];t(c,l,new Float32Array(e,r*4,6),b,h)}else{const b=r+Is/4,h=i[r+6],d=i[r+7];t(c,l,new Float32Array(e,r*4,6),d)||(o(b,c+1),o(h,c+1))}}}raycast(t,s=V.FrontSide){const e=this._roots,i=this.geometry,n=[],o=s.isMaterial,r=Array.isArray(s),c=i.groups,f=o?s.side:s,l=this.indirect?Bi:Ii;for(let b=0,h=e.length;b<h;b++){const d=r?s[c[b].materialIndex].side:f,_=n.length;if(l(this,b,d,t,n),r){const I=c[b].materialIndex;for(let y=_,u=n.length;y<u;y++)n[y].face.materialIndex=I}}return n}raycastFirst(t,s=V.FrontSide){const e=this._roots,i=this.geometry,n=s.isMaterial,o=Array.isArray(s);let r=null;const c=i.groups,f=n?s.side:s,l=this.indirect?Di:Ai;for(let b=0,h=e.length;b<h;b++){const d=o?s[c[b].materialIndex].side:f,_=l(this,b,d,t);_!=null&&(r==null||_.distance<r.distance)&&(r=_,o&&(_.face.materialIndex=c[b].materialIndex))}return r}intersectsGeometry(t,s){let e=!1;const i=this._roots,n=this.indirect?Oi:vi;for(let o=0,r=i.length;o<r&&(e=n(this,o,t,s),!e);o++);return e}shapecast(t){const s=tt.getPrimitive(),e=this.indirect?wi:pi;let{boundsTraverseOrder:i,intersectsBounds:n,intersectsRange:o,intersectsTriangle:r}=t;if(o&&r){const b=o;o=(h,d,_,I,y)=>b(h,d,_,I,y)?!0:e(h,d,this,r,_,I,s)}else o||(r?o=(b,h,d,_)=>e(b,h,this,r,d,_,s):o=(b,h,d)=>d);let c=!1,f=0;const l=this._roots;for(let b=0,h=l.length;b<h;b++){const d=l[b];if(c=li(this,b,n,o,i,f),c)break;f+=d.byteLength}return tt.releasePrimitive(s),c}bvhcast(t,s,e){let{intersectsRanges:i,intersectsTriangles:n}=e;const o=tt.getPrimitive(),r=this.geometry.index,c=this.geometry.attributes.position,f=this.indirect?_=>{const I=this.resolveTriangleIndex(_);q(o,I*3,r,c)}:_=>{q(o,_*3,r,c)},l=tt.getPrimitive(),b=t.geometry.index,h=t.geometry.attributes.position,d=t.indirect?_=>{const I=t.resolveTriangleIndex(_);q(l,I*3,b,h)}:_=>{q(l,_*3,b,h)};if(n){const _=(I,y,u,p,w,m,g,A)=>{for(let C=u,x=u+p;C<x;C++){d(C),l.a.applyMatrix4(s),l.b.applyMatrix4(s),l.c.applyMatrix4(s),l.needsUpdate=!0;for(let M=I,v=I+y;M<v;M++)if(f(M),o.needsUpdate=!0,n(o,l,M,C,w,m,g,A))return!0}return!1};if(i){const I=i;i=function(y,u,p,w,m,g,A,C){return I(y,u,p,w,m,g,A,C)?!0:_(y,u,p,w,m,g,A,C)}}else i=_}return Ni(this,t,s,i)}intersectsBox(t,s){return gs.set(t.min,t.max,s),gs.needsUpdate=!0,this.shapecast({intersectsBounds:e=>gs.intersectsBox(e),intersectsTriangle:e=>gs.intersectsTriangle(e)})}intersectsSphere(t){return this.shapecast({intersectsBounds:s=>t.intersectsBox(s),intersectsTriangle:s=>s.intersectsSphere(t)})}closestPointToGeometry(t,s,e={},i={},n=0,o=1/0){return(this.indirect?Gi:Pi)(this,t,s,e,i,n,o)}closestPointToPoint(t,s={},e=0,i=1/0){return hi(this,t,s,e,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{R(0,new Float32Array(e),xe),t.union(xe)}),t}}function Ae(a,t,s){return a===null||(a.point.applyMatrix4(t.matrixWorld),a.distance=a.point.distanceTo(s.ray.origin),a.object=t,a.distance<s.near||a.distance>s.far)?null:a}const Gs=new V.Ray,ve=new V.Matrix4,ki=V.Mesh.prototype.raycast;function qi(a,t){if(this.geometry.boundsTree){if(this.material===void 0)return;ve.copy(this.matrixWorld).invert(),Gs.copy(a.ray).applyMatrix4(ve);const s=this.geometry.boundsTree;if(a.firstHitOnly===!0){const e=Ae(s.raycastFirst(Gs,this.material),this,a);e&&t.push(e)}else{const e=s.raycast(Gs,this.material);for(let i=0,n=e.length;i<n;i++){const o=Ae(e[i],this,a);o&&t.push(o)}}}else ki.call(this,a,t)}function Ki(a){return this.boundsTree=new ie(this,a),this.boundsTree}function ji(){this.boundsTree=null}const ss=class ss{static apply(t){ss.initialized||(V.BufferGeometry.prototype.computeBoundsTree=Ki,V.BufferGeometry.prototype.disposeBoundsTree=ji,V.Mesh.prototype.raycast=qi,ss.initialized=!0),t.boundsTree||t.computeBoundsTree()}static dispose(t){t&&t.disposeBoundsTree&&t.disposeBoundsTree()}};S(ss,"initialized",!1);let Vs=ss,ne=class Be{constructor(t,s,e){S(this,"ids",new Set);S(this,"itemToInstances",new Map);S(this,"instanceToItem",new Map);S(this,"hiddenItems",new Set);S(this,"id");S(this,"mesh");S(this,"capacity",0);S(this,"capacityOffset",10);S(this,"group");S(this,"_originalColors",new Map);S(this,"_settingVisibility",!1);this.mesh=new qs(t,s,e,this),this.id=this.mesh.uuid,this.capacity=e,this.mesh.count=0,this.mesh.geometry.index.count&&Vs.apply(this.mesh.geometry)}get uniqueVertices(){const t=[],s=this.mesh.geometry.getAttribute("position");if(!s)return t;const e=new Set;for(let i=0;i<s.count;i++){const n=s.getX(i),o=s.getY(i),r=s.getZ(i),c=`${n},${o},${r}`;e.has(c)||(e.add(c),t.push(new O.Vector3(n,o,r)))}return t}dispose(t=!0){if(this.clear(),this.group=void 0,this._originalColors.clear(),this.mesh){if(t){for(const s of this.mesh.material)s.dispose();this.mesh.material=[],Vs.dispose(this.mesh.geometry),this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.geometry=null}this.mesh.removeFromParent(),this.mesh.userData={},this.mesh.dispose(),this.mesh.fragment=null,this.mesh=null}}get(t){const s=this.getInstancesIDs(t);if(!s)throw new Error("Item not found!");const e=[],i=[];for(const o of s){const r=new O.Matrix4;if(this.mesh.getMatrixAt(o,r),e.push(r),this.mesh.instanceColor){const c=new O.Color;this.mesh.getColorAt(o,c),i.push(c)}}const n=i.length?i:void 0;return{id:t,transforms:e,colors:n}}getItemID(t){return this.instanceToItem.get(t)||null}getInstancesIDs(t){return this.itemToInstances.get(t)||null}update(){this.mesh.instanceColor&&(this.mesh.instanceColor.needsUpdate=!0),this.mesh.instanceMatrix.needsUpdate=!0}add(t){var i;let s=0;for(const n of t)s+=n.transforms.length;const e=this.mesh.count+s;if(e>this.capacity){const n=e+this.capacityOffset,o=new qs(this.mesh.geometry,this.mesh.material,n,this);o.count=this.mesh.count,this.capacity=n;const r=this.mesh;(i=r.parent)==null||i.add(o),r.removeFromParent(),this.mesh=o;const c=new O.Matrix4;for(let f=0;f<r.instanceMatrix.count;f++)r.getMatrixAt(f,c),o.setMatrixAt(f,c);if(r.instanceColor){const f=new O.Color;for(let l=0;l<r.instanceColor.count;l++)r.getColorAt(l,f),o.setColorAt(l,f)}r.dispose()}for(let n=0;n<t.length;n++){const{transforms:o,colors:r,id:c}=t[n];this.itemToInstances.has(c)||this.itemToInstances.set(c,new Set);const f=this.itemToInstances.get(c);this.ids.add(c);for(let l=0;l<o.length;l++){const b=o[l],h=this.mesh.count;if(this.mesh.setMatrixAt(h,b),r){const d=r[l];this.mesh.setColorAt(h,d)}f.add(h),this.instanceToItem.set(h,c),this.mesh.count++}}this.update()}remove(t){if(this.mesh.count!==0){for(const s of t){const e=this.itemToInstances.get(s);if(e===void 0)throw new Error("Instances not found!");for(const i of e){if(this.mesh.count===0)throw new Error("Error with mesh count!");this.putLast(i),this.instanceToItem.delete(i),this.mesh.count--}this.itemToInstances.delete(s),this.ids.delete(s)}this.update()}}clear(){this.hiddenItems.clear(),this.ids.clear(),this.instanceToItem.clear(),this.itemToInstances.clear(),this.mesh.count=0}setVisibility(t,s=this.ids){if(!this._settingVisibility){if(this._settingVisibility=!0,t)for(const e of s){if(!this.ids.has(e)||!this.hiddenItems.has(e))continue;const i=this.itemToInstances.get(e);if(!i)throw new Error("Instances not found!");for(const n of new Set(i))this.mesh.count++,this.putLast(n);this.hiddenItems.delete(e)}else for(const e of s){if(!this.ids.has(e)||this.hiddenItems.has(e))continue;const i=this.itemToInstances.get(e);if(!i)throw new Error("Instances not found!");for(const n of new Set(i))this.putLast(n),this.mesh.count--;this.hiddenItems.add(e)}this.update(),this._settingVisibility=!1}}setColor(t,s=this.ids,e=!1){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const i of s){if(!this.ids.has(i))continue;const n=this.itemToInstances.get(i);if(!n)throw new Error("Instances not found!");const o=this._originalColors.has(i);o||this._originalColors.set(i,new Map);const r=this._originalColors.get(i);for(const c of new Set(n)){if(!o){const f=new O.Color;this.mesh.getColorAt(c,f),r.set(c,f)}this.mesh.setColorAt(c,t),e&&r.set(c,t)}}this.mesh.instanceColor.needsUpdate=!0}resetColor(t=this.ids){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const s of t){if(!this.ids.has(s))continue;const e=this.itemToInstances.get(s);if(!e)throw new Error("Instances not found!");const i=this._originalColors.get(s);if(i)for(const n of new Set(e)){const o=i.get(n);if(!o)throw new Error("Original color not found!");this.mesh.setColorAt(n,o)}}this.mesh.instanceColor.needsUpdate=!0}applyTransform(t,s){const e=new O.Matrix4;for(const i of t){const n=this.getInstancesIDs(i);if(n!==null)for(const o of n)this.mesh.getMatrixAt(o,e),e.premultiply(s),this.mesh.setMatrixAt(o,e)}this.update()}exportData(){const t=this.mesh.exportData(),s=Array.from(this.ids),e=this.id;return{...t,ids:s,id:e}}clone(t=this.ids){const s=new Be(this.mesh.geometry,this.mesh.material,this.capacity),e=[];for(const i of t){const n=this.getInstancesIDs(i);if(n===null)continue;const o=[],r=[];for(const c of n){const f=new O.Matrix4,l=new O.Color;this.mesh.getMatrixAt(c,f),this.mesh.getColorAt(c,l),o.push(f),r.push(l)}e.push({id:i,transforms:o,colors:r})}return s.add(e),s}putLast(t){if(this.mesh.count===0)return;const s=this.instanceToItem.get(t),e=this.mesh.count-1;if(e===t)return;const i=this.instanceToItem.get(e);if(s===void 0||i===void 0)throw new Error("Keys not found");if(s!==i){const r=this.itemToInstances.get(s),c=this.itemToInstances.get(i);if(!r||!c)throw new Error("Instances not found");if(!r.has(t)||!c.has(e))throw new Error("Malformed fragment structure");r.delete(t),c.delete(e),r.add(e),c.add(t),this.instanceToItem.set(t,i),this.instanceToItem.set(e,s)}const n=new O.Matrix4,o=new O.Matrix4;if(this.mesh.getMatrixAt(t,n),this.mesh.getMatrixAt(e,o),this.mesh.setMatrixAt(t,o),this.mesh.setMatrixAt(e,n),this.mesh.instanceColor!==null){const r=new O.Color,c=new O.Color;this.mesh.getColorAt(t,r),this.mesh.getColorAt(e,c),this.mesh.setColorAt(t,c),this.mesh.setColorAt(e,r);const f=this._originalColors.get(s);if(f){const b=f.get(t);b&&(f.delete(t),f.set(e,b))}const l=this._originalColors.get(i);if(l){const b=l.get(e);b&&(l.delete(e),l.set(t,b))}}}};const Rs=2,at=4,dt=4,Q=4,wt=new Int32Array(2),Ve=new Float32Array(wt.buffer),Fe=new Float64Array(wt.buffer),ws=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;var Js;(function(a){a[a.UTF8_BYTES=1]="UTF8_BYTES",a[a.UTF16_STRING=2]="UTF16_STRING"})(Js||(Js={}));class Dt{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Dt(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return wt[0]=this.readInt32(t),Ve[0]}readFloat64(t){return wt[ws?0:1]=this.readInt32(t),wt[ws?1:0]=this.readInt32(t+4),Fe[0]}writeInt8(t,s){this.bytes_[t]=s}writeUint8(t,s){this.bytes_[t]=s}writeInt16(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8}writeUint16(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8}writeInt32(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8,this.bytes_[t+2]=s>>16,this.bytes_[t+3]=s>>24}writeUint32(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8,this.bytes_[t+2]=s>>16,this.bytes_[t+3]=s>>24}writeInt64(t,s){this.writeInt32(t,Number(BigInt.asIntN(32,s))),this.writeInt32(t+4,Number(BigInt.asIntN(32,s>>BigInt(32))))}writeUint64(t,s){this.writeUint32(t,Number(BigInt.asUintN(32,s))),this.writeUint32(t+4,Number(BigInt.asUintN(32,s>>BigInt(32))))}writeFloat32(t,s){Ve[0]=s,this.writeInt32(t,wt[0])}writeFloat64(t,s){Fe[0]=s,this.writeInt32(t,wt[ws?0:1]),this.writeInt32(t+4,wt[ws?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+at+dt)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let s=0;s<dt;s++)t+=String.fromCharCode(this.readInt8(this.position_+at+s));return t}__offset(t,s){const e=t-this.readInt32(t);return s<this.readInt16(e)?this.readInt16(e+s):0}__union(t,s){return t.bb_pos=s+this.readInt32(s),t.bb=this,t}__string(t,s){t+=this.readInt32(t);const e=this.readInt32(t);t+=at;const i=this.bytes_.subarray(t,t+e);return s===Js.UTF8_BYTES?i:this.text_decoder_.decode(i)}__union_with_string(t,s){return typeof t=="string"?this.__string(s):this.__union(t,s)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+at}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(t.length!=dt)throw new Error("FlatBuffers: file identifier must be length "+dt);for(let s=0;s<dt;s++)if(t.charCodeAt(s)!=this.readInt8(this.position()+at+s))return!1;return!0}createScalarList(t,s){const e=[];for(let i=0;i<s;++i){const n=t(i);n!==null&&e.push(n)}return e}createObjList(t,s){const e=[];for(let i=0;i<s;++i){const n=t(i);n!==null&&e.push(n.unpack())}return e}}class is{constructor(t){this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder;let s;t?s=t:s=1024,this.bb=Dt.allocate(s),this.space=s}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,s){t>this.minalign&&(this.minalign=t);const e=~(this.bb.capacity()-this.space+s)+1&t-1;for(;this.space<e+t+s;){const i=this.bb.capacity();this.bb=is.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(e)}pad(t){for(let s=0;s<t;s++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,s,e){(this.force_defaults||s!=e)&&(this.addInt8(s),this.slot(t))}addFieldInt16(t,s,e){(this.force_defaults||s!=e)&&(this.addInt16(s),this.slot(t))}addFieldInt32(t,s,e){(this.force_defaults||s!=e)&&(this.addInt32(s),this.slot(t))}addFieldInt64(t,s,e){(this.force_defaults||s!==e)&&(this.addInt64(s),this.slot(t))}addFieldFloat32(t,s,e){(this.force_defaults||s!=e)&&(this.addFloat32(s),this.slot(t))}addFieldFloat64(t,s,e){(this.force_defaults||s!=e)&&(this.addFloat64(s),this.slot(t))}addFieldOffset(t,s,e){(this.force_defaults||s!=e)&&(this.addOffset(s),this.slot(t))}addFieldStruct(t,s,e){s!=e&&(this.nested(s),this.slot(t))}nested(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")}slot(t){this.vtable!==null&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const s=t.capacity();if(s&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const e=s<<1,i=Dt.allocate(e);return i.setPosition(e-s),i.bytes().set(t.bytes(),e-s),i}addOffset(t){this.prep(at,0),this.writeInt32(this.offset()-t+at)}startObject(t){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=t;for(let s=0;s<t;s++)this.vtable[s]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let s=this.vtable_in_use-1;for(;s>=0&&this.vtable[s]==0;s--);const e=s+1;for(;s>=0;s--)this.addInt16(this.vtable[s]!=0?t-this.vtable[s]:0);const i=2;this.addInt16(t-this.object_start);const n=(e+i)*Rs;this.addInt16(n);let o=0;const r=this.space;t:for(s=0;s<this.vtables.length;s++){const c=this.bb.capacity()-this.vtables[s];if(n==this.bb.readInt16(c)){for(let f=Rs;f<n;f+=Rs)if(this.bb.readInt16(r+f)!=this.bb.readInt16(c+f))continue t;o=this.vtables[s];break}}return o?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,o-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,s,e){const i=e?Q:0;if(s){const n=s;if(this.prep(this.minalign,at+dt+i),n.length!=dt)throw new Error("FlatBuffers: file identifier must be length "+dt);for(let o=dt-1;o>=0;o--)this.writeInt8(n.charCodeAt(o))}this.prep(this.minalign,at+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,s){this.finish(t,s,!0)}requiredField(t,s){const e=this.bb.capacity()-t,i=e-this.bb.readInt32(e);if(!(s<this.bb.readInt16(i)&&this.bb.readInt16(i+s)!=0))throw new Error("FlatBuffers: field "+s+" must be set")}startVector(t,s,e){this.notNested(),this.vector_num_elems=s,this.prep(at,t*s),this.prep(e,t*s)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const s=this.createString(t);return this.string_maps.set(t,s),s}createString(t){if(t==null)return 0;let s;t instanceof Uint8Array?s=t:s=this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,s.length,1),this.bb.setPosition(this.space-=s.length);for(let e=0,i=this.space,n=this.bb.bytes();e<s.length;e++)n[i++]=s[e];return this.endVector()}createObjectOffset(t){return t===null?0:typeof t=="string"?this.createString(t):t.pack(this)}createObjectOffsetList(t){const s=[];for(let e=0;e<t.length;++e){const i=t[e];if(i!==null)s.push(this.createObjectOffset(i));else throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.")}return s}createStructOffsetList(t,s){return s(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}let xs=class St{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new St).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+Q),(s||new St).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return St.startCivilCurve(t),St.addPoints(t,s),St.addData(t,e),St.endCivilCurve(t)}},Te=class lt{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new lt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+Q),(s||new lt).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,i,n){return lt.startAlignment(t),lt.addVertical(t,s),lt.addHorizontal(t,e),lt.addAbsolute(t,i),lt.addInitialPk(t,n),lt.endAlignment(t)}},De=class Bt{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new Bt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+Q),(s||new Bt).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Te).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return Bt.startCivilData(t),Bt.addAlignments(t,s),Bt.addCoordinationMatrix(t,e),Bt.endCivilData(t)}},Ws=class j{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new j).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+Q),(s||new j).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,i,n,o,r,c,f,l,b,h,d){return j.startFragment(t),j.addPosition(t,s),j.addNormal(t,e),j.addIndex(t,i),j.addGroups(t,n),j.addMaterials(t,o),j.addMatrices(t,r),j.addColors(t,c),j.addItemsSize(t,f),j.addIds(t,l),j.addId(t,b),j.addCapacity(t,h),j.addCapacityOffset(t,d),j.endFragment(t)}},Ns=class Qs{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new Qs).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+Q),(s||new Qs).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Ws).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new De).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,34);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,34);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(18)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addId(t,s){t.addFieldOffset(9,s,0)}static addName(t,s){t.addFieldOffset(10,s,0)}static addIfcName(t,s){t.addFieldOffset(11,s,0)}static addIfcDescription(t,s){t.addFieldOffset(12,s,0)}static addIfcSchema(t,s){t.addFieldOffset(13,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(14,s,0)}static addBoundingBox(t,s){t.addFieldOffset(15,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(16,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class $i{constructor(){S(this,"version",1);S(this,"fragmentIDSeparator","|")}import(t){const s=new Dt(t),e=Ns.getRootAsFragmentsGroup(s),i=this.constructFragmentGroup(e),n=e.itemsLength();for(let o=0;o<n;o++){const r=e.items(o);if(!r)continue;const c=this.constructGeometry(r),f=this.constructMaterials(r),l=r.capacity(),b=new ne(c,f,l);b.capacityOffset=r.capacityOffset(),this.setInstances(r,b),this.setID(r,b),i.items.push(b),i.add(b.mesh)}return i}export(t){const s=new is(1024),e=[],i=Ns,n=Ws;let o=null;if(t.civilData){const K=[],E=Te,z=De;for(const[ct,_t]of t.civilData.alignments){const{absolute:Ot,horizontal:pt,vertical:vt}=_t,Vt=this.saveCivilCurves(pt,s),Ft=this.saveCivilCurves(vt,s),Ct=this.saveCivilCurves(Ot,s),Mt=E.createHorizontalVector(s,Vt),Pt=E.createVerticalVector(s,Ft),mt=E.createAbsoluteVector(s,Ct);E.startAlignment(s),E.addHorizontal(s,Mt),E.addVertical(s,Pt),E.addAbsolute(s,mt),E.addInitialPk(s,_t.initialKP);const Ht=E.endAlignment(s);K.push(Ht)}const U=z.createAlignmentsVector(s,K),$=z.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);z.startCivilData(s),z.addAlignments(s,U),z.addCoordinationMatrix(s,$),o=z.endCivilData(s)}for(const K of t.items){const E=K.exportData(),z=[];for(const Pt of K.ids){const mt=K.getInstancesIDs(Pt);if(!mt)throw new Error("Instances not found!");z.push(mt.size)}const U=n.createPositionVector(s,E.position),$=n.createNormalVector(s,E.normal),ct=n.createIndexVector(s,E.index),_t=n.createGroupsVector(s,E.groups),Ot=n.createMaterialsVector(s,E.materials),pt=n.createMatricesVector(s,E.matrices),vt=n.createColorsVector(s,E.colors),Vt=n.createIdsVector(s,E.ids),Ft=n.createItemsSizeVector(s,z),Ct=s.createString(E.id);n.startFragment(s),n.addPosition(s,U),n.addNormal(s,$),n.addIndex(s,ct),n.addGroups(s,_t),n.addMaterials(s,Ot),n.addMatrices(s,pt),n.addColors(s,vt),n.addIds(s,Vt),n.addItemsSize(s,Ft),n.addId(s,Ct),n.addCapacity(s,K.capacity),n.addCapacityOffset(s,K.capacityOffset);const Mt=Ws.endFragment(s);e.push(Mt)}const r=i.createItemsVector(s,e),c=i.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let f="";for(const K of t.keyFragments.values())f.length&&(f+=this.fragmentIDSeparator),f+=K;const l=s.createString(f),b=[],h=[],d=[],_=[],I=[];let y=0,u=0;for(const[K,[E,z]]of t.data){b.push(y),d.push(u),I.push(K);for(const U of E)h.push(U);for(const U of z)_.push(U);y+=E.length,u+=z.length}const p=[],w=[];for(const[K,E]of t.geometryIDs.opaque)p.push(K,E);for(const[K,E]of t.geometryIDs.transparent)w.push(K,E);const m=s.createString(t.uuid),g=s.createString(t.name),A=s.createString(t.ifcMetadata.name),C=s.createString(t.ifcMetadata.description),x=s.createString(t.ifcMetadata.schema),M=i.createItemsKeysIndicesVector(s,b),v=i.createItemsKeysVector(s,h),B=i.createItemsRelsIndicesVector(s,d),F=i.createItemsRelsVector(s,_),P=i.createIdsVector(s,I),T=i.createOpaqueGeometriesIdsVector(s,p),D=i.createTransparentGeometriesIdsVector(s,w),{min:L,max:H}=t.boundingBox,Y=[L.x,L.y,L.z,H.x,H.y,H.z],Z=i.createBoundingBoxVector(s,Y);i.startFragmentsGroup(s),i.addId(s,m),i.addName(s,g),i.addIfcName(s,A),i.addIfcDescription(s,C),i.addIfcSchema(s,x),i.addMaxExpressId(s,t.ifcMetadata.maxExpressID),i.addItems(s,r),i.addFragmentKeys(s,l),i.addIds(s,P),i.addItemsKeysIndices(s,M),i.addItemsKeys(s,v),i.addItemsRelsIndices(s,B),i.addItemsRels(s,F),i.addCoordinationMatrix(s,c),i.addBoundingBox(s,Z),i.addOpaqueGeometriesIds(s,T),i.addTransparentGeometriesIds(s,D),o!==null&&i.addCivil(s,o);const Ms=Ns.endFragmentsGroup(s);return s.finish(Ms),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),i=t.colorsArray(),n=t.idsArray(),o=t.itemsSizeArray();if(!e||!n||!o)throw new Error("Error: Can't load empty fragment!");const r=[];let c=0;for(let f=0;f<o.length;f++){const l=n[f],b=o[f],h=[],d=[];for(let I=0;I<b;I++){const y=c*16,u=e.subarray(y,y+17),p=new O.Matrix4().fromArray(u);if(h.push(p),i){const w=c*3,[m,g,A]=i.subarray(w,w+4),C=new O.Color(m,g,A);d.push(C)}c++}const _=d.length?d:void 0;r.push({id:l,transforms:h,colors:_})}s.add(r)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let i=0;i<s.length;i+=5){const n=s[i],o=!!s[i+1],r=s[i+2],c=s[i+3],f=s[i+4],l=new O.Color(r,c,f),b=new O.MeshLambertMaterial({color:l,opacity:n,transparent:o});e.push(b)}return e}constructFragmentGroup(t){const s=new es,e=t.civil();if(e){const x=e.coordinationMatrixArray(),M=new O.Matrix4;x&&M.fromArray(x),s.civilData={alignments:new Map,coordinationMatrix:M};const v=e.alignmentsLength();for(let B=0;B<v;B++){const F=new O.LineBasicMaterial({color:16777215}),P=new oe,T=e.alignments(B);if(!T)throw new Error("Alignment not found!");const D=T.horizontalLength();P.horizontal=this.constructCivilCurves(T,P,"horizontal",D,F);const L=T.verticalLength();P.vertical=this.constructCivilCurves(T,P,"vertical",L,F);const H=T.horizontalLength();P.absolute=this.constructCivilCurves(T,P,"absolute",H,F),P.initialKP=T.initialPk(),s.civilData.alignments.set(B,P)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=new O.Matrix4().elements,n=t.coordinationMatrixArray()||i,o=t.idsArray()||new Uint32Array,r=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,f=t.itemsRelsArray()||new Uint32Array,l=t.itemsRelsIndicesArray()||new Uint32Array,h=(t.fragmentKeys()||"").split(this.fragmentIDSeparator);this.setGroupData(s,o,r,c,0),this.setGroupData(s,o,l,f,1);const d=t.opaqueGeometriesIdsArray()||new Uint32Array,_=t.transparentGeometriesIdsArray()||new Uint32Array,I=new Map;for(let x=0;x<d.length-1;x+=2){const M=d[x],v=d[x+1];I.set(M,v)}const y=new Map;for(let x=0;x<_.length-1;x+=2){const M=_[x],v=_[x+1];y.set(M,v)}s.geometryIDs={opaque:I,transparent:y};const u=t.boundingBoxArray()||[0,0,0,0,0,0],[p,w,m,g,A,C]=u;s.boundingBox.min.set(p,w,m),s.boundingBox.max.set(g,A,C);for(let x=0;x<h.length;x++)s.keyFragments.set(x,h[x]);return n.length===16&&s.coordinationMatrix.fromArray(n),s}setGroupData(t,s,e,i,n){for(let o=0;o<e.length;o++){const r=s[o],c=e[o],f=e[o+1]||i.length,l=[];for(let h=c;h<f;h++)l.push(i[h]);t.data.has(r)||t.data.set(r,[[],[]]);const b=t.data.get(r);b&&(b[n]=l)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,i=t.indexArray(),n=t.groupsArray();if(!i)throw new Error("Index not found!");const o=new O.BufferGeometry;if(o.setIndex(Array.from(i)),o.setAttribute("position",new O.BufferAttribute(s,3)),o.setAttribute("normal",new O.BufferAttribute(e,3)),n)for(let r=0;r<n.length;r+=3){const c=n[r],f=n[r+1],l=n[r+2];o.addGroup(c,f,l)}return o}constructCivilCurves(t,s,e,i,n){const o=[];for(let r=0;r<i;r++){const c=t[e](r);if(!c)throw new Error("Curve not found!");const f=c.pointsArray();if(f===null)throw new Error("Curve points not found!");let l={};const b=c.data();b&&(l=JSON.parse(b));const h=new O.EdgesGeometry,d=new O.BufferAttribute(f,3);h.setAttribute("position",d);const _=[];for(let y=0;y<f.length/3-1;y++)_.push(y,y+1);h.setIndex(_);const I=new re(r,l,s,h,n);o.push(I.curve)}return o}saveCivilCurves(t,s){const e=xs,i=[];for(const n of t){const r=n.mesh.geometry.attributes.position.array,c=e.createPointsVector(s,r),f=s.createString(JSON.stringify(n.data));e.startCivilCurve(s),e.addPoints(s,c),e.addData(s,f);const l=e.endCivilCurve(s);i.push(l)}return i}}let As=class Tt{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new Tt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+Q),(s||new Tt).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return Tt.startCivilCurve(t),Tt.addPoints(t,s),Tt.addData(t,e),Tt.endCivilCurve(t)}},Oe=class ht{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new ht).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+Q),(s||new ht).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,i,n){return ht.startAlignment(t),ht.addVertical(t,s),ht.addHorizontal(t,e),ht.addAbsolute(t,i),ht.addInitialPk(t,n),ht.endAlignment(t)}};class bt{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new bt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+Q),(s||new bt).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Oe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return bt.startCivilData(t),bt.addAlignments(t,s),bt.addCoordinationMatrix(t,e),bt.endCivilData(t)}}class k{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new k).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+Q),(s||new k).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,i,n,o,r,c,f,l,b,h,d){return k.startFragment(t),k.addPosition(t,s),k.addNormal(t,e),k.addIndex(t,i),k.addGroups(t,n),k.addMaterials(t,o),k.addMatrices(t,r),k.addColors(t,c),k.addItemsSize(t,f),k.addIds(t,l),k.addId(t,b),k.addCapacity(t,h),k.addCapacityOffset(t,d),k.endFragment(t)}}let ks=class te{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new te).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+Q),(s||new te).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new k).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new bt).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}globalIds(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,32);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,40);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,40);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,40);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(19)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addGlobalIds(t,s){t.addFieldOffset(9,s,0)}static addId(t,s){t.addFieldOffset(10,s,0)}static addName(t,s){t.addFieldOffset(11,s,0)}static addIfcName(t,s){t.addFieldOffset(12,s,0)}static addIfcDescription(t,s){t.addFieldOffset(13,s,0)}static addIfcSchema(t,s){t.addFieldOffset(14,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(15,s,0)}static addBoundingBox(t,s){t.addFieldOffset(16,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(18,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class Hi{constructor(){S(this,"version",2);S(this,"separator","|")}import(t){const s=new Dt(t),e=ks.getRootAsFragmentsGroup(s),i=this.constructFragmentGroup(e),n=e.itemsLength();for(let o=0;o<n;o++){const r=e.items(o);if(!r)continue;const c=this.constructGeometry(r),f=this.constructMaterials(r),l=r.capacity(),b=new ne(c,f,l);b.capacityOffset=r.capacityOffset(),this.setInstances(r,b),this.setID(r,b),i.items.push(b),i.add(b.mesh)}return i}export(t){const s=new is(1024),e=[],i=ks,n=k;let o=null;if(t.civilData){const z=[],U=Oe,$=bt;for(const[Ot,pt]of t.civilData.alignments){const{absolute:vt,horizontal:Vt,vertical:Ft}=pt,Ct=this.saveCivilCurves(Vt,s),Mt=this.saveCivilCurves(Ft,s),Pt=this.saveCivilCurves(vt,s),mt=U.createHorizontalVector(s,Ct),Ht=U.createVerticalVector(s,Mt),ns=U.createAbsoluteVector(s,Pt);U.startAlignment(s),U.addHorizontal(s,mt),U.addVertical(s,Ht),U.addAbsolute(s,ns),U.addInitialPk(s,pt.initialKP);const ze=U.endAlignment(s);z.push(ze)}const ct=$.createAlignmentsVector(s,z),_t=$.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);$.startCivilData(s),$.addAlignments(s,ct),$.addCoordinationMatrix(s,_t),o=$.endCivilData(s)}for(const z of t.items){const U=z.exportData(),$=[];for(const Ht of z.ids){const ns=z.getInstancesIDs(Ht);if(!ns)throw new Error("Instances not found!");$.push(ns.size)}const ct=n.createPositionVector(s,U.position),_t=n.createNormalVector(s,U.normal),Ot=n.createIndexVector(s,U.index),pt=n.createGroupsVector(s,U.groups),vt=n.createMaterialsVector(s,U.materials),Vt=n.createMatricesVector(s,U.matrices),Ft=n.createColorsVector(s,U.colors),Ct=n.createIdsVector(s,U.ids),Mt=n.createItemsSizeVector(s,$),Pt=s.createString(U.id);n.startFragment(s),n.addPosition(s,ct),n.addNormal(s,_t),n.addIndex(s,Ot),n.addGroups(s,pt),n.addMaterials(s,vt),n.addMatrices(s,Vt),n.addColors(s,Ft),n.addIds(s,Ct),n.addItemsSize(s,Mt),n.addId(s,Pt),n.addCapacity(s,z.capacity),n.addCapacityOffset(s,z.capacityOffset);const mt=k.endFragment(s);e.push(mt)}const r=i.createItemsVector(s,e),c=i.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let f="";for(const z of t.keyFragments.values())f.length&&(f+=this.separator),f+=z;let l="";for(const[z]of t.globalToExpressIDs)l.length&&(l+=this.separator),l+=z;const b=s.createString(f),h=s.createString(l),d=[],_=[],I=[],y=[],u=[];let p=0,w=0;for(const[z,[U,$]]of t.data){d.push(p),I.push(w),u.push(z);for(const ct of U)_.push(ct);for(const ct of $)y.push(ct);p+=U.length,w+=$.length}const m=[],g=[];for(const[z,U]of t.geometryIDs.opaque)m.push(z,U);for(const[z,U]of t.geometryIDs.transparent)g.push(z,U);const A=s.createString(t.uuid),C=s.createString(t.name),x=s.createString(t.ifcMetadata.name),M=s.createString(t.ifcMetadata.description),v=s.createString(t.ifcMetadata.schema),B=i.createItemsKeysIndicesVector(s,d),F=i.createItemsKeysVector(s,_),P=i.createItemsRelsIndicesVector(s,I),T=i.createItemsRelsVector(s,y),D=i.createIdsVector(s,u),L=i.createOpaqueGeometriesIdsVector(s,m),H=i.createTransparentGeometriesIdsVector(s,g),{min:Y,max:Z}=t.boundingBox,Ms=[Y.x,Y.y,Y.z,Z.x,Z.y,Z.z],K=i.createBoundingBoxVector(s,Ms);i.startFragmentsGroup(s),i.addId(s,A),i.addName(s,C),i.addIfcName(s,x),i.addIfcDescription(s,M),i.addIfcSchema(s,v),i.addMaxExpressId(s,t.ifcMetadata.maxExpressID),i.addItems(s,r),i.addFragmentKeys(s,b),i.addGlobalIds(s,h),i.addIds(s,D),i.addItemsKeysIndices(s,B),i.addItemsKeys(s,F),i.addItemsRelsIndices(s,P),i.addItemsRels(s,T),i.addCoordinationMatrix(s,c),i.addBoundingBox(s,K),i.addOpaqueGeometriesIds(s,L),i.addTransparentGeometriesIds(s,H),o!==null&&i.addCivil(s,o);const E=ks.endFragmentsGroup(s);return s.finish(E),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),i=t.colorsArray(),n=t.idsArray(),o=t.itemsSizeArray();if(!e||!n||!o)throw new Error("Error: Can't load empty fragment!");const r=[];let c=0;for(let f=0;f<o.length;f++){const l=n[f],b=o[f],h=[],d=[];for(let I=0;I<b;I++){const y=c*16,u=e.subarray(y,y+17),p=new O.Matrix4().fromArray(u);if(h.push(p),i){const w=c*3,[m,g,A]=i.subarray(w,w+4),C=new O.Color(m,g,A);d.push(C)}c++}const _=d.length?d:void 0;r.push({id:l,transforms:h,colors:_})}s.add(r)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let i=0;i<s.length;i+=5){const n=s[i],o=!!s[i+1],r=s[i+2],c=s[i+3],f=s[i+4],l=new O.Color(r,c,f),b=new O.MeshLambertMaterial({color:l,opacity:n,transparent:o});e.push(b)}return e}constructFragmentGroup(t){const s=new es,e=t.civil();if(e){const v=e.coordinationMatrixArray(),B=new O.Matrix4;v&&B.fromArray(v),s.civilData={alignments:new Map,coordinationMatrix:B};const F=e.alignmentsLength();for(let P=0;P<F;P++){const T=new O.LineBasicMaterial({color:16777215}),D=new oe,L=e.alignments(P);if(!L)throw new Error("Alignment not found!");const H=L.horizontalLength();D.horizontal=this.constructCivilCurves(L,D,"horizontal",H,T);const Y=L.verticalLength();D.vertical=this.constructCivilCurves(L,D,"vertical",Y,T);const Z=L.horizontalLength();D.absolute=this.constructCivilCurves(L,D,"absolute",Z,T),D.initialKP=L.initialPk(),s.civilData.alignments.set(P,D)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=new O.Matrix4().elements,n=t.coordinationMatrixArray()||i,o=t.idsArray()||new Uint32Array,r=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,f=t.itemsRelsArray()||new Uint32Array,l=t.itemsRelsIndicesArray()||new Uint32Array,h=(t.fragmentKeys()||"").split(this.separator),_=(t.globalIds()||"").split(this.separator);this.setGroupData(s,o,r,c,0),this.setGroupData(s,o,l,f,1);const I=t.opaqueGeometriesIdsArray()||new Uint32Array,y=t.transparentGeometriesIdsArray()||new Uint32Array,u=new Map;for(let v=0;v<I.length-1;v+=2){const B=I[v],F=I[v+1];u.set(B,F)}const p=new Map;for(let v=0;v<y.length-1;v+=2){const B=y[v],F=y[v+1];p.set(B,F)}s.geometryIDs={opaque:u,transparent:p};const w=t.boundingBoxArray()||[0,0,0,0,0,0],[m,g,A,C,x,M]=w;s.boundingBox.min.set(m,g,A),s.boundingBox.max.set(C,x,M);for(let v=0;v<h.length;v++)s.keyFragments.set(v,h[v]);n.length===16&&s.coordinationMatrix.fromArray(n);for(let v=0;v<o.length;v++)s.globalToExpressIDs.set(_[v],o[v]);return s}setGroupData(t,s,e,i,n){for(let o=0;o<e.length;o++){const r=s[o],c=e[o],f=e[o+1],l=f===void 0?i.length:f,b=[];for(let d=c;d<l;d++)b.push(i[d]);t.data.has(r)||t.data.set(r,[[],[]]);const h=t.data.get(r);h&&(h[n]=b)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,i=t.indexArray(),n=t.groupsArray();if(!i)throw new Error("Index not found!");const o=new O.BufferGeometry;if(o.setIndex(Array.from(i)),o.setAttribute("position",new O.BufferAttribute(s,3)),o.setAttribute("normal",new O.BufferAttribute(e,3)),n)for(let r=0;r<n.length;r+=3){const c=n[r],f=n[r+1],l=n[r+2];o.addGroup(c,f,l)}return o}constructCivilCurves(t,s,e,i,n){const o=[];for(let r=0;r<i;r++){const c=t[e](r);if(!c)throw new Error("Curve not found!");const f=c.pointsArray();if(f===null)throw new Error("Curve points not found!");let l={};const b=c.data();b&&(l=JSON.parse(b));const h=new O.EdgesGeometry,d=new O.BufferAttribute(f,3);h.setAttribute("position",d);const _=[];for(let y=0;y<f.length/3-1;y++)_.push(y,y+1);h.setIndex(_);const I=new re(r,l,s,h,n);o.push(I.curve)}return o}saveCivilCurves(t,s){const e=As,i=[];for(const n of t){const r=n.mesh.geometry.attributes.position.array,c=e.createPointsVector(s,r),f=s.createString(JSON.stringify(n.data));e.startCivilCurve(s),e.addPoints(s,c),e.addData(s,f);const l=e.endCivilCurve(s);i.push(l)}return i}}class Xi{constructor(){S(this,"parsers",[new Hi,new $i]);S(this,"version","auto")}import(t){const s=this.parsers.length;if(this.version==="auto"){for(let o=0;o<this.parsers.length;o++){const c=this.parsers[o].import(t);if(Object.keys(c).length!==0){if(o!==0){const f=this.parsers.length-o;this.warnVersion(f,s)}return c}}throw new Error("No valid parser found for this file")}this.checkCurrentVersionValid(this.version);const e=this.parsers.length-this.version,n=this.parsers[e].import(t);if(Object.keys(n).length===0)throw new Error(`The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`);return n}export(t){if(this.version==="auto")return this.parsers[0].export(t);this.checkCurrentVersionValid(this.version);const s=this.parsers.length-this.version;return this.parsers[s].export(t)}checkCurrentVersionValid(t){if(this.version==="auto")return;if(this.version!==t&&this.warnVersion(this.version,t),!Number.isInteger(this.version))throw new Error("Invalid version. Non-automatic versions must an integer.");if(this.version<1||this.version>t)throw new Error(`Invalid version. Versions range from 1 to ${t}.`)}warnVersion(t,s){console.warn(`This fragment file version is ${t}. The latest version is ${s}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`)}}class Le{constructor(t){S(this,"baseDirectory");S(this,"maxDeadTime",6e4);S(this,"mode","buffer");S(this,"_memoryCleanTime",1e4);S(this,"_intervalID",null);S(this,"_isCleaningMemory",!1);S(this,"cleanMemory",async()=>{if(this._isCleaningMemory)return;this._isCleaningMemory=!0;const t=await this.getDir(this.baseDirectory),s=new Set,e=new Date().getTime();for await(const i of t.values()){const n=localStorage.getItem(i.name)||"0",o=parseInt(n,10);e-o>this.maxDeadTime&&(s.add(i.name),localStorage.removeItem(i.name))}for(const i of s)t.removeEntry(i);this._isCleaningMemory=!1});this.baseDirectory=t,this.setupMemoryCleanup()}get memoryCleanTime(){return this._memoryCleanTime}set memoryCleanTime(t){this._memoryCleanTime=t,this.dispose(),this.setupMemoryCleanup()}async get(t){const s=this.encodeName(t),e=await this.getDir(this.baseDirectory);try{const n=await(await e.getFileHandle(s)).getFile();return this.updateLastAccessTime(s),n}catch{return null}}async add(t,s){const e=this.encodeName(t),o=await(await(await this.getDir(this.baseDirectory)).getFileHandle(e,{create:!0})).createWritable();await o.write(s),await o.close(),this.updateLastAccessTime(e)}async clear(){const t=await this.getDir(this.baseDirectory);for await(const[s]of t.entries())await t.removeEntry(s)}dispose(){this._intervalID!==null&&window.clearInterval(this._intervalID)}setupMemoryCleanup(){this._intervalID=window.setInterval(this.cleanMemory,this.memoryCleanTime)}async getDir(t){return(await navigator.storage.getDirectory()).getDirectoryHandle(t,{create:!0})}encodeName(t){const s=/[\\/:*?"<>|]/g;return t.replace(s,"")}updateLastAccessTime(t){const s=new Date().getTime().toString();localStorage.setItem(t,s)}}const N=class N extends O.Group{constructor(){super(...arguments);S(this,"items",[]);S(this,"boundingBox",new O.Box3);S(this,"coordinationMatrix",new O.Matrix4);S(this,"keyFragments",new Map);S(this,"globalToExpressIDs",new Map);S(this,"data",new Map);S(this,"geometryIDs",{opaque:new Map,transparent:new Map});S(this,"ifcMetadata",{name:"",description:"",schema:"IFC2X3",maxExpressID:0});S(this,"civilData");S(this,"streamSettings",{baseFileName:"",ids:new Map,types:new Map});S(this,"isStreamed",!1);S(this,"_properties")}get hasProperties(){const s=this._properties!==void 0,e=this.streamSettings.ids.size!==0;return s||e}getFragmentMap(s){const e={};for(const i of s){const n=this.data.get(i);if(n)for(const o of n[0]){const r=this.keyFragments.get(o);r!==void 0&&(e[r]||(e[r]=new Set),e[r].add(i))}}return e}getItemVertices(s){const e=[],i=this.getFragmentMap([s]);for(const n in i){const o=this.items.find(c=>c.id===n);if(!o)continue;const r=o.getInstancesIDs(s);if(r)for(const c of r){const f=new O.Matrix4;o.mesh.getMatrixAt(c,f);for(const l of o.uniqueVertices){const b=l.clone().applyMatrix4(f);e.push(b)}}}return e}static setPropertiesDB(s){s?N.propertiesDB||(N.propertiesDB=new Le("that-open-company-streaming-properties")):s||N.propertiesDB&&N.propertiesDB.dispose()}dispose(s=!0){for(const e of this.items)e.dispose(s);if(this.coordinationMatrix=new O.Matrix4,this.keyFragments.clear(),this.data.clear(),this._properties={},this.removeFromParent(),this.items=[],this.civilData){const{alignments:e}=this.civilData;for(const[i,n]of e)this.disposeAlignment(n.vertical),this.disposeAlignment(n.horizontal),this.disposeAlignment(n.absolute)}this.civilData=void 0}setLocalProperties(s){this._properties=s}getLocalProperties(){return this._properties}getAllPropertiesIDs(){return this._properties?Object.keys(this._properties).map(s=>parseInt(s,10)):Array.from(this.streamSettings.ids.keys())}getAllPropertiesTypes(){if(this._properties){const s=new Set;for(const e in this._properties){const i=this._properties[e];i.type!==void 0&&s.add(i.type)}return Array.from(s)}return Array.from(this.streamSettings.types.keys())}async getProperties(s){if(this._properties)return this._properties[s]||null;const e=this.getPropsURL(s),i=await this.getPropertiesData(e);return i?i[s]:null}async setProperties(s,e){if(this._properties){e!==null?this._properties[s]=e:delete this._properties[s];return}throw new Error("Writing streamed properties not supported yet!")}async getAllPropertiesOfType(s){if(this._properties){const o={};let r=!1;for(const c in this._properties){const f=this._properties[c];f.type===s&&(o[f.expressID]=f,r=!0)}return r?o:null}const{types:e}=this.streamSettings,i=e.get(s);if(i===void 0)return null;const n={};for(const o of i){const r=this.constructFileName(o),c=await this.getPropertiesData(r);for(const f in c)n[parseInt(f,10)]=c[f]}return n}clone(s){throw new Error("Use FragmentsGroup.cloneGroup instead!")}cloneGroup(s){const e=new N;e.coordinationMatrix=this.coordinationMatrix,e.position.copy(this.position),e.rotation.copy(this.rotation),e.scale.copy(this.scale),e.updateMatrix(),e.ifcMetadata={...this.ifcMetadata},s||(s=this.getFragmentMap(this.data.keys()));const i=new Set,n=new Map;for(const o of this.items){if(!s[o.id])continue;const r=s[o.id],c=o.clone(r);n.set(o.id,c.id),e.items.push(c),e.add(c.mesh);for(const f of r)i.add(f)}for(const o of i){const r=this.data.get(o);r&&e.data.set(o,r)}for(const[o,r]of this.keyFragments)if(n.has(r)){const c=n.get(r);if(c===void 0)throw new Error("Malformed fragment ID map during clone!");e.keyFragments.set(o,c)}for(const[o,r]of this.globalToExpressIDs)i.has(r)&&e.globalToExpressIDs.set(o,r);return this.civilData&&(e.civilData={coordinationMatrix:this.coordinationMatrix,alignments:new Map}),e}getPropsURL(s){const{ids:e}=this.streamSettings,i=e.get(s);if(i===void 0)throw new Error("ID not found");return this.constructFileName(i)}async getPropertiesData(s){var i;(i=this.streamSettings.baseUrl)!=null&&i.length&&(console.warn("streamSettings.baseUrl is deprecated. Use FragmentsGroup.url instead."),N.url=this.streamSettings.baseUrl);let e;if(N.useCache){let n=null;if(N.propertiesDB&&(n=await N.propertiesDB.get(s)),n)e=await n.text();else if(e=await(await N.fetch(s)).text(),N.propertiesDB){const c=new TextEncoder().encode(e);await N.propertiesDB.add(s,c)}}else e=await(await N.fetch(s)).text();return JSON.parse(e)}constructFileName(s){const{baseFileName:e}=this.streamSettings;return`${e}-${s}`}disposeAlignment(s){for(const e of s)if(e.mesh.geometry.dispose(),Array.isArray(e.mesh.material))for(const i of e.mesh.material)i.dispose();else e.mesh.material.dispose();s.length=0}};S(N,"fetch",async s=>fetch(`${N.url}${s}`)),S(N,"url",""),S(N,"useCache",!0),S(N,"propertiesDB",null);let es=N;class oe{constructor(){S(this,"vertical",[]);S(this,"horizontal",[]);S(this,"absolute",[]);S(this,"initialKP",0)}getLength(t){let s=0;for(const e of this[t])s+=e.getLength();return s}getPointAt(t,s){const e=this.getCurveAt(t,s);return e.curve.getPointAt(e.percentage)}getPercentageAt(t,s,e=.01){const i=this[s];let n=0;for(const o of i){const r=o.getPercentageAt(t,e),c=o.getLength();if(r!==null){const f=n+r*c,l=this.getLength(s);return f/l}n+=c}return null}getCurveAt(t,s){t<0?t=0:t>1&&(t=1);const e=this[s],n=this.getLength(s)*t;let o=0;for(const r of e){const c=r.getLength();if(o+c>=n){const l=(n-o)/c;return{curve:r,percentage:l}}o+=c}throw new Error("Could not compute point!")}}class Ue{constructor(t,s,e,i){S(this,"index");S(this,"mesh");S(this,"data");S(this,"alignment");this.index=t,this.mesh=s,this.data=e,this.alignment=i}get _index(){return this.mesh.geometry.index}get _pos(){return this.mesh.geometry.attributes.position.array}getLength(){let t=0;for(let s=0;s<this._index.array.length-1;s+=2){const{startPoint:e,endPoint:i}=this.getSegment(s);t+=e.distanceTo(i)}return t}getPointAt(t){const{startPoint:s,endPoint:e,distanceToStart:i}=this.getSegmentAt(t),n=e.clone();return n.sub(s),n.normalize(),n.multiplyScalar(i),n.add(s),n}getSegmentAt(t){t<0?t=0:t>1&&(t=1);const e=this.getLength()*t;let i=0;for(let n=0;n<this._index.array.length-1;n+=2){const{startPoint:o,endPoint:r}=this.getSegment(n),c=o.distanceTo(r);if(i+c>=e)return{distanceToStart:e-i,index:n,startPoint:o,endPoint:r};i+=c}throw new Error("Could not compute point")}getPercentageAt(t,s=.01){let e=0;for(let i=0;i<this._index.array.length-1;i+=2){const{startPoint:n,endPoint:o}=this.getSegment(i),r=n.distanceTo(o),c=t.distanceTo(n),f=t.distanceTo(o);if(c+f-r<=s){const h=e+c,d=this.getLength();return h/d}e+=r}return null}getSegment(t){const s=this._index.array[t]*3,e=this._index.array[t+1]*3,i=new O.Vector3(this._pos[s],this._pos[s+1],this._pos[s+2]),n=new O.Vector3(this._pos[e],this._pos[e+1],this._pos[e+2]);return{startPoint:i,endPoint:n}}}class re extends O.LineSegments{constructor(s,e,i,n,o){super(n,o);S(this,"curve");this.curve=new Ue(s,this,e,i)}}class ot{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsStreamedGeometry(t,s){return(s||new ot).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometry(t,s){return t.setPosition(t.position()+Q),(s||new ot).__init(t.readInt32(t.position())+t.position(),t)}geometryId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}position(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startStreamedGeometry(t){t.startObject(4)}static addGeometryId(t,s){t.addFieldInt32(0,s,0)}static addPosition(t,s){t.addFieldOffset(1,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(2,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(3,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static endStreamedGeometry(t){return t.endObject()}static createStreamedGeometry(t,s,e,i,n){return ot.startStreamedGeometry(t),ot.addGeometryId(t,s),ot.addPosition(t,e),ot.addNormal(t,i),ot.addIndex(t,n),ot.endStreamedGeometry(t)}}class It{constructor(){S(this,"bb",null);S(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsStreamedGeometries(t,s){return(s||new It).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometries(t,s){return t.setPosition(t.position()+Q),(s||new It).__init(t.readInt32(t.position())+t.position(),t)}geometries(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new ot).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}geometriesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startStreamedGeometries(t){t.startObject(1)}static addGeometries(t,s){t.addFieldOffset(0,s,0)}static createGeometriesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startGeometriesVector(t,s){t.startVector(4,s,4)}static endStreamedGeometries(t){return t.endObject()}static finishStreamedGeometriesBuffer(t,s){t.finish(s)}static finishSizePrefixedStreamedGeometriesBuffer(t,s){t.finish(s,void 0,!0)}static createStreamedGeometries(t,s){return It.startStreamedGeometries(t),It.addGeometries(t,s),It.endStreamedGeometries(t)}}class Yi{import(t){const s=new Dt(t),e=It.getRootAsStreamedGeometries(s),i=new Map,n=e.geometriesLength();for(let o=0;o<n;o++){const r=e.geometries(o);if(!r)continue;const c=r.geometryId();if(c===null)throw new Error("Error finding ID!");const f=r.positionArray(),l=r.normalArray(),b=r.indexArray();!f||!l||!b||i.set(c,{position:f,normal:l,index:b})}return i}export(t){const s=new is(1024),e=[],i=It,n=ot;for(const[c,{index:f,position:l,normal:b}]of t){const h=n.createIndexVector(s,f),d=n.createPositionVector(s,l),_=n.createNormalVector(s,b);n.startStreamedGeometry(s),n.addGeometryId(s,c),n.addIndex(s,h),n.addPosition(s,d),n.addNormal(s,_);const I=n.endStreamedGeometry(s);e.push(I)}const o=i.createGeometriesVector(s,e);i.startStreamedGeometries(s),i.addGeometries(s,o);const r=i.endStreamedGeometries(s);return s.finish(r),s.asUint8Array()}}class Zi{static combine(t){if(t.length===0)return{};if(t.length===1)return t[0];const s={};for(const e of t)for(const i in e){s[i]||(s[i]=new Set);for(const n of e[i])s[i].add(n)}return s}static intersect(t){if(t.length===0)return{};if(t.length===1)return t[0];const s=new Map;let e=0;for(const n of t){e++;for(const o in n){s.has(o)||s.set(o,{count:0,ids:new Map});const r=s.get(o);r.count++;for(const c of n[o]){const f=r.ids.get(c)||0;r.ids.set(c,f+1)}}}const i={};for(const[n,{count:o,ids:r}]of s)if(o===e)for(const[c,f]of r)f===e&&(i[n]||(i[n]=new Set),i[n].add(c));return i}static export(t){const s={};for(const e in t)s[e]=Array.from(t[e]);return JSON.stringify(s)}static import(t){const s=JSON.parse(t),e={};for(const i in s)e[i]=new Set(s[i]);return e}}exports.Alignment=oe;exports.CivilCurve=Ue;exports.CurveMesh=re;exports.Fragment=ne;exports.FragmentMesh=qs;exports.FragmentUtils=Zi;exports.FragmentsGroup=es;exports.Serializer=Xi;exports.StreamSerializer=Yi;exports.StreamerFileDb=Le;
