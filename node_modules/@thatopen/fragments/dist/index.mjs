var Ke = Object.defineProperty;
var je = (a, t, s) => t in a ? Ke(a, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : a[t] = s;
var S = (a, t, s) => (je(a, typeof t != "symbol" ? t + "" : t, s), s);
import * as L from "three";
import { BufferAttribute as Me, Vector3 as T, Vector2 as Xt, Plane as Se, Line3 as dt, Triangle as is, Sphere as $e, Matrix4 as vt, Box3 as rt, BackSide as He, DoubleSide as Xe, FrontSide as re, Mesh as Be, Ray as Ye, BufferGeometry as ce } from "three";
class ae extends L.InstancedMesh {
  /**
   * Constructs a new FragmentMesh.
   *
   * @param geometry - The geometry for the mesh. Must be indexed.
   * @param material - The material(s) for the mesh. If a single material is provided, it will be wrapped in an array.
   * @param count - The number of instances to create.
   * @param fragment - The fragment associated with this mesh.
   */
  constructor(s, e, i, n) {
    super(s, e, i);
    /**
     * The fragment associated with this mesh.
     */
    S(this, "fragment");
    /**
     * The materials used by this mesh.
     * If a single material is provided, it will be wrapped in an array.
     */
    S(this, "material");
    /**
     * The geometry used by this mesh.
     * It must be an IndexedGeometry.
     */
    S(this, "geometry");
    if (Array.isArray(e) || (e = [e]), this.material = e, !s.index)
      throw new Error("The geometry for fragments must be indexed!");
    this.geometry = s, this.fragment = n;
    const o = s.index.count;
    s.groups.length || s.groups.push({
      start: 0,
      count: o,
      materialIndex: 0
    });
  }
  /**
   * Exports the data of the fragment mesh to a serializable format.
   *
   * @returns An object containing the position, normal, index, groups, materials, matrices, and colors of the fragment mesh.
   */
  exportData() {
    const s = this.geometry.attributes.position.array, e = this.geometry.attributes.normal.array, i = Array.from(this.geometry.index.array), n = [];
    for (const f of this.geometry.groups) {
      const l = f.materialIndex || 0, { start: b, count: h } = f;
      n.push(b, h, l);
    }
    const o = [];
    if (Array.isArray(this.material))
      for (const f of this.material) {
        const l = f.opacity, b = f.transparent ? 1 : 0, h = new L.Color(f.color).toArray();
        o.push(l, b, ...h);
      }
    const r = Array.from(this.instanceMatrix.array);
    let c;
    return this.instanceColor !== null ? c = Array.from(this.instanceColor.array) : c = [], {
      position: s,
      normal: e,
      index: i,
      groups: n,
      materials: o,
      matrices: r,
      colors: c
    };
  }
}
const Te = 0, Ze = 1, Je = 2, fe = 2, Ts = 1.25, le = 1, vs = 6 * 4 + 4 + 4, Ms = 65535, We = Math.pow(2, -24), Os = Symbol("SKIP_GENERATION");
function Qe(a) {
  return a.index ? a.index.count : a.attributes.position.count;
}
function Yt(a) {
  return Qe(a) / 3;
}
function ti(a, t = ArrayBuffer) {
  return a > 65535 ? new Uint32Array(new t(4 * a)) : new Uint16Array(new t(2 * a));
}
function si(a, t) {
  if (!a.index) {
    const s = a.attributes.position.count, e = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = ti(s, e);
    a.setIndex(new Me(i, 1));
    for (let n = 0; n < s; n++)
      i[n] = n;
  }
}
function Oe(a) {
  const t = Yt(a), s = a.drawRange, e = s.start / 3, i = (s.start + s.count) / 3, n = Math.max(0, e), o = Math.min(t, i) - n;
  return [{
    offset: Math.floor(n),
    count: Math.floor(o)
  }];
}
function Le(a) {
  if (!a.groups || !a.groups.length)
    return Oe(a);
  const t = [], s = /* @__PURE__ */ new Set(), e = a.drawRange, i = e.start / 3, n = (e.start + e.count) / 3;
  for (const r of a.groups) {
    const c = r.start / 3, f = (r.start + r.count) / 3;
    s.add(Math.max(i, c)), s.add(Math.min(n, f));
  }
  const o = Array.from(s.values()).sort((r, c) => r - c);
  for (let r = 0; r < o.length - 1; r++) {
    const c = o[r], f = o[r + 1];
    t.push({
      offset: Math.floor(c),
      count: Math.floor(f - c)
    });
  }
  return t;
}
function ei(a) {
  if (a.groups.length === 0)
    return !1;
  const t = Yt(a), s = Le(a).sort((n, o) => n.offset - o.offset), e = s[s.length - 1];
  e.count = Math.min(t - e.offset, e.count);
  let i = 0;
  return s.forEach(({ count: n }) => i += n), t !== i;
}
function R(a, t, s) {
  return s.min.x = t[a], s.min.y = t[a + 1], s.min.z = t[a + 2], s.max.x = t[a + 3], s.max.y = t[a + 4], s.max.z = t[a + 5], s;
}
function ii(a) {
  a[0] = a[1] = a[2] = 1 / 0, a[3] = a[4] = a[5] = -1 / 0;
}
function he(a) {
  let t = -1, s = -1 / 0;
  for (let e = 0; e < 3; e++) {
    const i = a[e + 3] - a[e];
    i > s && (s = i, t = e);
  }
  return t;
}
function be(a, t) {
  t.set(a);
}
function ue(a, t, s) {
  let e, i;
  for (let n = 0; n < 3; n++) {
    const o = n + 3;
    e = a[n], i = t[n], s[n] = e < i ? e : i, e = a[o], i = t[o], s[o] = e > i ? e : i;
  }
}
function as(a, t, s) {
  for (let e = 0; e < 3; e++) {
    const i = t[a + 2 * e], n = t[a + 2 * e + 1], o = i - n, r = i + n;
    o < s[e] && (s[e] = o), r > s[e + 3] && (s[e + 3] = r);
  }
}
function Jt(a) {
  const t = a[3] - a[0], s = a[4] - a[1], e = a[5] - a[2];
  return 2 * (t * s + s * e + e * t);
}
function Ls(a, t, s, e, i = null) {
  let n = 1 / 0, o = 1 / 0, r = 1 / 0, c = -1 / 0, f = -1 / 0, l = -1 / 0, b = 1 / 0, h = 1 / 0, u = 1 / 0, _ = -1 / 0, w = -1 / 0, y = -1 / 0;
  const d = i !== null;
  for (let p = t * 6, I = (t + s) * 6; p < I; p += 6) {
    const m = a[p + 0], g = a[p + 1], A = m - g, F = m + g;
    A < n && (n = A), F > c && (c = F), d && m < b && (b = m), d && m > _ && (_ = m);
    const x = a[p + 2], C = a[p + 3], v = x - C, M = x + C;
    v < o && (o = v), M > f && (f = M), d && x < h && (h = x), d && x > w && (w = x);
    const V = a[p + 4], P = a[p + 5], B = V - P, O = V + P;
    B < r && (r = B), O > l && (l = O), d && V < u && (u = V), d && V > y && (y = V);
  }
  e[0] = n, e[1] = o, e[2] = r, e[3] = c, e[4] = f, e[5] = l, d && (i[0] = b, i[1] = h, i[2] = u, i[3] = _, i[4] = w, i[5] = y);
}
function ni(a, t, s, e) {
  let i = 1 / 0, n = 1 / 0, o = 1 / 0, r = -1 / 0, c = -1 / 0, f = -1 / 0;
  for (let l = t * 6, b = (t + s) * 6; l < b; l += 6) {
    const h = a[l + 0];
    h < i && (i = h), h > r && (r = h);
    const u = a[l + 2];
    u < n && (n = u), u > c && (c = u);
    const _ = a[l + 4];
    _ < o && (o = _), _ > f && (f = _);
  }
  e[0] = i, e[1] = n, e[2] = o, e[3] = r, e[4] = c, e[5] = f;
}
function oi(a, t) {
  ii(t);
  const s = a.attributes.position, e = a.index ? a.index.array : null, i = Yt(a), n = new Float32Array(i * 6), o = s.normalized, r = s.array, c = s.offset || 0;
  let f = 3;
  s.isInterleavedBufferAttribute && (f = s.data.stride);
  const l = ["getX", "getY", "getZ"];
  for (let b = 0; b < i; b++) {
    const h = b * 3, u = b * 6;
    let _ = h + 0, w = h + 1, y = h + 2;
    e && (_ = e[_], w = e[w], y = e[y]), o || (_ = _ * f + c, w = w * f + c, y = y * f + c);
    for (let d = 0; d < 3; d++) {
      let p, I, m;
      o ? (p = s[l[d]](_), I = s[l[d]](w), m = s[l[d]](y)) : (p = r[_ + d], I = r[w + d], m = r[y + d]);
      let g = p;
      I < g && (g = I), m < g && (g = m);
      let A = p;
      I > A && (A = I), m > A && (A = m);
      const F = (A - g) / 2, x = d * 2;
      n[u + x + 0] = g + F, n[u + x + 1] = F + (Math.abs(g) + F) * We, g < t[d] && (t[d] = g), A > t[d + 3] && (t[d + 3] = A);
    }
  }
  return n;
}
const ft = 32, ri = (a, t) => a.candidate - t.candidate, gt = new Array(ft).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
})), fs = new Float32Array(6);
function ci(a, t, s, e, i, n) {
  let o = -1, r = 0;
  if (n === Te)
    o = he(t), o !== -1 && (r = (t[o] + t[o + 3]) / 2);
  else if (n === Ze)
    o = he(a), o !== -1 && (r = ai(s, e, i, o));
  else if (n === Je) {
    const c = Jt(a);
    let f = Ts * i;
    const l = e * 6, b = (e + i) * 6;
    for (let h = 0; h < 3; h++) {
      const u = t[h], y = (t[h + 3] - u) / ft;
      if (i < ft / 4) {
        const d = [...gt];
        d.length = i;
        let p = 0;
        for (let m = l; m < b; m += 6, p++) {
          const g = d[p];
          g.candidate = s[m + 2 * h], g.count = 0;
          const {
            bounds: A,
            leftCacheBounds: F,
            rightCacheBounds: x
          } = g;
          for (let C = 0; C < 3; C++)
            x[C] = 1 / 0, x[C + 3] = -1 / 0, F[C] = 1 / 0, F[C + 3] = -1 / 0, A[C] = 1 / 0, A[C + 3] = -1 / 0;
          as(m, s, A);
        }
        d.sort(ri);
        let I = i;
        for (let m = 0; m < I; m++) {
          const g = d[m];
          for (; m + 1 < I && d[m + 1].candidate === g.candidate; )
            d.splice(m + 1, 1), I--;
        }
        for (let m = l; m < b; m += 6) {
          const g = s[m + 2 * h];
          for (let A = 0; A < I; A++) {
            const F = d[A];
            g >= F.candidate ? as(m, s, F.rightCacheBounds) : (as(m, s, F.leftCacheBounds), F.count++);
          }
        }
        for (let m = 0; m < I; m++) {
          const g = d[m], A = g.count, F = i - g.count, x = g.leftCacheBounds, C = g.rightCacheBounds;
          let v = 0;
          A !== 0 && (v = Jt(x) / c);
          let M = 0;
          F !== 0 && (M = Jt(C) / c);
          const V = le + Ts * (v * A + M * F);
          V < f && (o = h, f = V, r = g.candidate);
        }
      } else {
        for (let I = 0; I < ft; I++) {
          const m = gt[I];
          m.count = 0, m.candidate = u + y + I * y;
          const g = m.bounds;
          for (let A = 0; A < 3; A++)
            g[A] = 1 / 0, g[A + 3] = -1 / 0;
        }
        for (let I = l; I < b; I += 6) {
          let A = ~~((s[I + 2 * h] - u) / y);
          A >= ft && (A = ft - 1);
          const F = gt[A];
          F.count++, as(I, s, F.bounds);
        }
        const d = gt[ft - 1];
        be(d.bounds, d.rightCacheBounds);
        for (let I = ft - 2; I >= 0; I--) {
          const m = gt[I], g = gt[I + 1];
          ue(m.bounds, g.rightCacheBounds, m.rightCacheBounds);
        }
        let p = 0;
        for (let I = 0; I < ft - 1; I++) {
          const m = gt[I], g = m.count, A = m.bounds, x = gt[I + 1].rightCacheBounds;
          g !== 0 && (p === 0 ? be(A, fs) : ue(A, fs, fs)), p += g;
          let C = 0, v = 0;
          p !== 0 && (C = Jt(fs) / c);
          const M = i - p;
          M !== 0 && (v = Jt(x) / c);
          const V = le + Ts * (C * p + v * M);
          V < f && (o = h, f = V, r = m.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);
  return { axis: o, pos: r };
}
function ai(a, t, s, e) {
  let i = 0;
  for (let n = t, o = t + s; n < o; n++)
    i += a[n * 6 + e * 2];
  return i / s;
}
class ls {
  constructor() {
  }
}
function fi(a, t, s, e, i, n) {
  let o = e, r = e + i - 1;
  const c = n.pos, f = n.axis * 2;
  for (; ; ) {
    for (; o <= r && s[o * 6 + f] < c; )
      o++;
    for (; o <= r && s[r * 6 + f] >= c; )
      r--;
    if (o < r) {
      for (let l = 0; l < 3; l++) {
        let b = t[o * 3 + l];
        t[o * 3 + l] = t[r * 3 + l], t[r * 3 + l] = b;
      }
      for (let l = 0; l < 6; l++) {
        let b = s[o * 6 + l];
        s[o * 6 + l] = s[r * 6 + l], s[r * 6 + l] = b;
      }
      o++, r--;
    } else
      return o;
  }
}
function li(a, t, s, e, i, n) {
  let o = e, r = e + i - 1;
  const c = n.pos, f = n.axis * 2;
  for (; ; ) {
    for (; o <= r && s[o * 6 + f] < c; )
      o++;
    for (; o <= r && s[r * 6 + f] >= c; )
      r--;
    if (o < r) {
      let l = a[o];
      a[o] = a[r], a[r] = l;
      for (let b = 0; b < 6; b++) {
        let h = s[o * 6 + b];
        s[o * 6 + b] = s[r * 6 + b], s[r * 6 + b] = h;
      }
      o++, r--;
    } else
      return o;
  }
}
function hi(a, t) {
  const s = (a.index ? a.index.count : a.attributes.position.count) / 3, e = s > 2 ** 16, i = e ? 4 : 2, n = t ? new SharedArrayBuffer(s * i) : new ArrayBuffer(s * i), o = e ? new Uint32Array(n) : new Uint16Array(n);
  for (let r = 0, c = o.length; r < c; r++)
    o[r] = r;
  return o;
}
function bi(a, t) {
  const s = a.geometry, e = s.index ? s.index.array : null, i = t.maxDepth, n = t.verbose, o = t.maxLeafTris, r = t.strategy, c = t.onProgress, f = Yt(s), l = a._indirectBuffer;
  let b = !1;
  const h = new Float32Array(6), u = new Float32Array(6), _ = oi(s, h), w = t.indirect ? li : fi, y = [], d = t.indirect ? Oe(s) : Le(s);
  if (d.length === 1) {
    const m = d[0], g = new ls();
    g.boundingData = h, ni(_, m.offset, m.count, u), I(g, m.offset, m.count, u), y.push(g);
  } else
    for (let m of d) {
      const g = new ls();
      g.boundingData = new Float32Array(6), Ls(_, m.offset, m.count, g.boundingData, u), I(g, m.offset, m.count, u), y.push(g);
    }
  return y;
  function p(m) {
    c && c(m / f);
  }
  function I(m, g, A, F = null, x = 0) {
    if (!b && x >= i && (b = !0, n && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`), console.warn(s))), A <= o || x >= i)
      return p(g + A), m.offset = g, m.count = A, m;
    const C = ci(m.boundingData, F, _, g, A, r);
    if (C.axis === -1)
      return p(g + A), m.offset = g, m.count = A, m;
    const v = w(l, e, _, g, A, C);
    if (v === g || v === g + A)
      p(g + A), m.offset = g, m.count = A;
    else {
      m.splitAxis = C.axis;
      const M = new ls(), V = g, P = v - g;
      m.left = M, M.boundingData = new Float32Array(6), Ls(_, V, P, M.boundingData, u), I(M, V, P, u, x + 1);
      const B = new ls(), O = v, D = A - P;
      m.right = B, B.boundingData = new Float32Array(6), Ls(_, O, D, B.boundingData, u), I(B, O, D, u, x + 1);
    }
    return m;
  }
}
function ui(a, t) {
  const s = a.geometry;
  t.indirect && (a._indirectBuffer = hi(s, t.useSharedArrayBuffer), ei(s) && !t.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), a._indirectBuffer || si(s, t);
  const e = bi(a, t);
  let i, n, o;
  const r = [], c = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let b = 0; b < e.length; b++) {
    const h = e[b];
    let u = f(h);
    const _ = new c(vs * u);
    i = new Float32Array(_), n = new Uint32Array(_), o = new Uint16Array(_), l(0, h), r.push(_);
  }
  a._roots = r;
  return;
  function f(b) {
    return b.count ? 1 : 1 + f(b.left) + f(b.right);
  }
  function l(b, h) {
    const u = b / 4, _ = b / 2, w = !!h.count, y = h.boundingData;
    for (let d = 0; d < 6; d++)
      i[u + d] = y[d];
    if (w) {
      const d = h.offset, p = h.count;
      return n[u + 6] = d, o[_ + 14] = p, o[_ + 15] = Ms, b + vs;
    } else {
      const d = h.left, p = h.right, I = h.splitAxis;
      let m;
      if (m = l(b + vs, d), m / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return n[u + 6] = m / 4, m = l(m, p), n[u + 7] = I, m;
    }
  }
}
class _t {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, s) {
    let e = 1 / 0, i = -1 / 0;
    for (let n = 0, o = t.length; n < o; n++) {
      const c = t[n][s];
      e = c < e ? c : e, i = c > i ? c : i;
    }
    this.min = e, this.max = i;
  }
  setFromPoints(t, s) {
    let e = 1 / 0, i = -1 / 0;
    for (let n = 0, o = s.length; n < o; n++) {
      const r = s[n], c = t.dot(r);
      e = c < e ? c : e, i = c > i ? c : i;
    }
    this.min = e, this.max = i;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
}
_t.prototype.setFromBox = function() {
  const a = new T();
  return function(s, e) {
    const i = e.min, n = e.max;
    let o = 1 / 0, r = -1 / 0;
    for (let c = 0; c <= 1; c++)
      for (let f = 0; f <= 1; f++)
        for (let l = 0; l <= 1; l++) {
          a.x = i.x * c + n.x * (1 - c), a.y = i.y * f + n.y * (1 - f), a.z = i.z * l + n.z * (1 - l);
          const b = s.dot(a);
          o = Math.min(b, o), r = Math.max(b, r);
        }
    this.min = o, this.max = r;
  };
}();
const di = function() {
  const a = new T(), t = new T(), s = new T();
  return function(i, n, o) {
    const r = i.start, c = a, f = n.start, l = t;
    s.subVectors(r, f), a.subVectors(i.end, i.start), t.subVectors(n.end, n.start);
    const b = s.dot(l), h = l.dot(c), u = l.dot(l), _ = s.dot(c), y = c.dot(c) * u - h * h;
    let d, p;
    y !== 0 ? d = (b * h - _ * u) / y : d = 0, p = (b + d * h) / u, o.x = d, o.y = p;
  };
}(), ie = function() {
  const a = new Xt(), t = new T(), s = new T();
  return function(i, n, o, r) {
    di(i, n, a);
    let c = a.x, f = a.y;
    if (c >= 0 && c <= 1 && f >= 0 && f <= 1) {
      i.at(c, o), n.at(f, r);
      return;
    } else if (c >= 0 && c <= 1) {
      f < 0 ? n.at(0, r) : n.at(1, r), i.closestPointToPoint(r, !0, o);
      return;
    } else if (f >= 0 && f <= 1) {
      c < 0 ? i.at(0, o) : i.at(1, o), n.closestPointToPoint(o, !0, r);
      return;
    } else {
      let l;
      c < 0 ? l = i.start : l = i.end;
      let b;
      f < 0 ? b = n.start : b = n.end;
      const h = t, u = s;
      if (i.closestPointToPoint(b, !0, t), n.closestPointToPoint(l, !0, s), h.distanceToSquared(b) <= u.distanceToSquared(l)) {
        o.copy(h), r.copy(b);
        return;
      } else {
        o.copy(l), r.copy(u);
        return;
      }
    }
  };
}(), _i = function() {
  const a = new T(), t = new T(), s = new Se(), e = new dt();
  return function(n, o) {
    const { radius: r, center: c } = n, { a: f, b: l, c: b } = o;
    if (e.start = f, e.end = l, e.closestPointToPoint(c, !0, a).distanceTo(c) <= r || (e.start = f, e.end = b, e.closestPointToPoint(c, !0, a).distanceTo(c) <= r) || (e.start = l, e.end = b, e.closestPointToPoint(c, !0, a).distanceTo(c) <= r))
      return !0;
    const w = o.getPlane(s);
    if (Math.abs(w.distanceToPoint(c)) <= r) {
      const d = w.projectPoint(c, t);
      if (o.containsPoint(d))
        return !0;
    }
    return !1;
  };
}(), pi = 1e-15;
function Ds(a) {
  return Math.abs(a) < pi;
}
class ot extends is {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new T()), this.satBounds = new Array(4).fill().map(() => new _t()), this.points = [this.a, this.b, this.c], this.sphere = new $e(), this.plane = new Se(), this.needsUpdate = !0;
  }
  intersectsSphere(t) {
    return _i(t, this);
  }
  update() {
    const t = this.a, s = this.b, e = this.c, i = this.points, n = this.satAxes, o = this.satBounds, r = n[0], c = o[0];
    this.getNormal(r), c.setFromPoints(r, i);
    const f = n[1], l = o[1];
    f.subVectors(t, s), l.setFromPoints(f, i);
    const b = n[2], h = o[2];
    b.subVectors(s, e), h.setFromPoints(b, i);
    const u = n[3], _ = o[3];
    u.subVectors(e, t), _.setFromPoints(u, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(r, t), this.needsUpdate = !1;
  }
}
ot.prototype.closestPointToSegment = function() {
  const a = new T(), t = new T(), s = new dt();
  return function(i, n = null, o = null) {
    const { start: r, end: c } = i, f = this.points;
    let l, b = 1 / 0;
    for (let h = 0; h < 3; h++) {
      const u = (h + 1) % 3;
      s.start.copy(f[h]), s.end.copy(f[u]), ie(s, i, a, t), l = a.distanceToSquared(t), l < b && (b = l, n && n.copy(a), o && o.copy(t));
    }
    return this.closestPointToPoint(r, a), l = r.distanceToSquared(a), l < b && (b = l, n && n.copy(a), o && o.copy(r)), this.closestPointToPoint(c, a), l = c.distanceToSquared(a), l < b && (b = l, n && n.copy(a), o && o.copy(c)), Math.sqrt(b);
  };
}();
ot.prototype.intersectsTriangle = function() {
  const a = new ot(), t = new Array(3), s = new Array(3), e = new _t(), i = new _t(), n = new T(), o = new T(), r = new T(), c = new T(), f = new T(), l = new dt(), b = new dt(), h = new dt(), u = new T();
  function _(w, y, d) {
    const p = w.points;
    let I = 0, m = -1;
    for (let g = 0; g < 3; g++) {
      const { start: A, end: F } = l;
      A.copy(p[g]), F.copy(p[(g + 1) % 3]), l.delta(o);
      const x = Ds(y.distanceToPoint(A));
      if (Ds(y.normal.dot(o)) && x) {
        d.copy(l), I = 2;
        break;
      }
      const C = y.intersectLine(l, u);
      if (!C && x && u.copy(A), (C || x) && !Ds(u.distanceTo(F))) {
        if (I <= 1)
          (I === 1 ? d.start : d.end).copy(u), x && (m = I);
        else if (I >= 2) {
          (m === 1 ? d.start : d.end).copy(u), I = 2;
          break;
        }
        if (I++, I === 2 && m === -1)
          break;
      }
    }
    return I;
  }
  return function(y, d = null, p = !1) {
    this.needsUpdate && this.update(), y.isExtendedTriangle ? y.needsUpdate && y.update() : (a.copy(y), a.update(), y = a);
    const I = this.plane, m = y.plane;
    if (Math.abs(I.normal.dot(m.normal)) > 1 - 1e-10) {
      const g = this.satBounds, A = this.satAxes;
      s[0] = y.a, s[1] = y.b, s[2] = y.c;
      for (let C = 0; C < 4; C++) {
        const v = g[C], M = A[C];
        if (e.setFromPoints(M, s), v.isSeparated(e))
          return !1;
      }
      const F = y.satBounds, x = y.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let C = 0; C < 4; C++) {
        const v = F[C], M = x[C];
        if (e.setFromPoints(M, t), v.isSeparated(e))
          return !1;
      }
      for (let C = 0; C < 4; C++) {
        const v = A[C];
        for (let M = 0; M < 4; M++) {
          const V = x[M];
          if (n.crossVectors(v, V), e.setFromPoints(n, t), i.setFromPoints(n, s), e.isSeparated(i))
            return !1;
        }
      }
      return d && (p || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), d.start.set(0, 0, 0), d.end.set(0, 0, 0)), !0;
    } else {
      const g = _(this, m, b);
      if (g === 1 && y.containsPoint(b.end))
        return d && (d.start.copy(b.end), d.end.copy(b.end)), !0;
      if (g !== 2)
        return !1;
      const A = _(y, I, h);
      if (A === 1 && this.containsPoint(h.end))
        return d && (d.start.copy(h.end), d.end.copy(h.end)), !0;
      if (A !== 2)
        return !1;
      if (b.delta(r), h.delta(c), r.dot(c) < 0) {
        let P = h.start;
        h.start = h.end, h.end = P;
      }
      const F = b.start.dot(r), x = b.end.dot(r), C = h.start.dot(r), v = h.end.dot(r), M = x < C, V = F < v;
      return F !== v && C !== x && M === V ? !1 : (d && (f.subVectors(b.start, h.start), f.dot(r) > 0 ? d.start.copy(b.start) : d.start.copy(h.start), f.subVectors(b.end, h.end), f.dot(r) < 0 ? d.end.copy(b.end) : d.end.copy(h.end)), !0);
    }
  };
}();
ot.prototype.distanceToPoint = function() {
  const a = new T();
  return function(s) {
    return this.closestPointToPoint(s, a), s.distanceTo(a);
  };
}();
ot.prototype.distanceToTriangle = function() {
  const a = new T(), t = new T(), s = ["a", "b", "c"], e = new dt(), i = new dt();
  return function(o, r = null, c = null) {
    const f = r || c ? e : null;
    if (this.intersectsTriangle(o, f))
      return (r || c) && (r && f.getCenter(r), c && f.getCenter(c)), 0;
    let l = 1 / 0;
    for (let b = 0; b < 3; b++) {
      let h;
      const u = s[b], _ = o[u];
      this.closestPointToPoint(_, a), h = _.distanceToSquared(a), h < l && (l = h, r && r.copy(a), c && c.copy(_));
      const w = this[u];
      o.closestPointToPoint(w, a), h = w.distanceToSquared(a), h < l && (l = h, r && r.copy(w), c && c.copy(a));
    }
    for (let b = 0; b < 3; b++) {
      const h = s[b], u = s[(b + 1) % 3];
      e.set(this[h], this[u]);
      for (let _ = 0; _ < 3; _++) {
        const w = s[_], y = s[(_ + 1) % 3];
        i.set(o[w], o[y]), ie(e, i, a, t);
        const d = a.distanceToSquared(t);
        d < l && (l = d, r && r.copy(a), c && c.copy(t));
      }
    }
    return Math.sqrt(l);
  };
}();
class H {
  constructor(t, s, e) {
    this.isOrientedBox = !0, this.min = new T(), this.max = new T(), this.matrix = new vt(), this.invMatrix = new vt(), this.points = new Array(8).fill().map(() => new T()), this.satAxes = new Array(3).fill().map(() => new T()), this.satBounds = new Array(3).fill().map(() => new _t()), this.alignedSatBounds = new Array(3).fill().map(() => new _t()), this.needsUpdate = !1, t && this.min.copy(t), s && this.max.copy(s), e && this.matrix.copy(e);
  }
  set(t, s, e) {
    this.min.copy(t), this.max.copy(s), this.matrix.copy(e), this.needsUpdate = !0;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = !0;
  }
}
H.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const t = this.matrix, s = this.min, e = this.max, i = this.points;
    for (let f = 0; f <= 1; f++)
      for (let l = 0; l <= 1; l++)
        for (let b = 0; b <= 1; b++) {
          const h = 1 * f | 2 * l | 4 * b, u = i[h];
          u.x = f ? e.x : s.x, u.y = l ? e.y : s.y, u.z = b ? e.z : s.z, u.applyMatrix4(t);
        }
    const n = this.satBounds, o = this.satAxes, r = i[0];
    for (let f = 0; f < 3; f++) {
      const l = o[f], b = n[f], h = 1 << f, u = i[h];
      l.subVectors(r, u), b.setFromPoints(l, i);
    }
    const c = this.alignedSatBounds;
    c[0].setFromPointsField(i, "x"), c[1].setFromPointsField(i, "y"), c[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
  };
}();
H.prototype.intersectsBox = function() {
  const a = new _t();
  return function(s) {
    this.needsUpdate && this.update();
    const e = s.min, i = s.max, n = this.satBounds, o = this.satAxes, r = this.alignedSatBounds;
    if (a.min = e.x, a.max = i.x, r[0].isSeparated(a) || (a.min = e.y, a.max = i.y, r[1].isSeparated(a)) || (a.min = e.z, a.max = i.z, r[2].isSeparated(a)))
      return !1;
    for (let c = 0; c < 3; c++) {
      const f = o[c], l = n[c];
      if (a.setFromBox(f, s), l.isSeparated(a))
        return !1;
    }
    return !0;
  };
}();
H.prototype.intersectsTriangle = function() {
  const a = new ot(), t = new Array(3), s = new _t(), e = new _t(), i = new T();
  return function(o) {
    this.needsUpdate && this.update(), o.isExtendedTriangle ? o.needsUpdate && o.update() : (a.copy(o), a.update(), o = a);
    const r = this.satBounds, c = this.satAxes;
    t[0] = o.a, t[1] = o.b, t[2] = o.c;
    for (let h = 0; h < 3; h++) {
      const u = r[h], _ = c[h];
      if (s.setFromPoints(_, t), u.isSeparated(s))
        return !1;
    }
    const f = o.satBounds, l = o.satAxes, b = this.points;
    for (let h = 0; h < 3; h++) {
      const u = f[h], _ = l[h];
      if (s.setFromPoints(_, b), u.isSeparated(s))
        return !1;
    }
    for (let h = 0; h < 3; h++) {
      const u = c[h];
      for (let _ = 0; _ < 4; _++) {
        const w = l[_];
        if (i.crossVectors(u, w), s.setFromPoints(i, t), e.setFromPoints(i, b), s.isSeparated(e))
          return !1;
      }
    }
    return !0;
  };
}();
H.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(t, s) {
    return this.needsUpdate && this.update(), s.copy(t).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), s;
  };
}();
H.prototype.distanceToPoint = function() {
  const a = new T();
  return function(s) {
    return this.closestPointToPoint(s, a), s.distanceTo(a);
  };
}();
H.prototype.distanceToBox = function() {
  const a = ["x", "y", "z"], t = new Array(12).fill().map(() => new dt()), s = new Array(12).fill().map(() => new dt()), e = new T(), i = new T();
  return function(o, r = 0, c = null, f = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(o))
      return (c || f) && (o.getCenter(i), this.closestPointToPoint(i, e), o.closestPointToPoint(e, i), c && c.copy(e), f && f.copy(i)), 0;
    const l = r * r, b = o.min, h = o.max, u = this.points;
    let _ = 1 / 0;
    for (let y = 0; y < 8; y++) {
      const d = u[y];
      i.copy(d).clamp(b, h);
      const p = d.distanceToSquared(i);
      if (p < _ && (_ = p, c && c.copy(d), f && f.copy(i), p < l))
        return Math.sqrt(p);
    }
    let w = 0;
    for (let y = 0; y < 3; y++)
      for (let d = 0; d <= 1; d++)
        for (let p = 0; p <= 1; p++) {
          const I = (y + 1) % 3, m = (y + 2) % 3, g = d << I | p << m, A = 1 << y | d << I | p << m, F = u[g], x = u[A];
          t[w].set(F, x);
          const v = a[y], M = a[I], V = a[m], P = s[w], B = P.start, O = P.end;
          B[v] = b[v], B[M] = d ? b[M] : h[M], B[V] = p ? b[V] : h[M], O[v] = h[v], O[M] = d ? b[M] : h[M], O[V] = p ? b[V] : h[M], w++;
        }
    for (let y = 0; y <= 1; y++)
      for (let d = 0; d <= 1; d++)
        for (let p = 0; p <= 1; p++) {
          i.x = y ? h.x : b.x, i.y = d ? h.y : b.y, i.z = p ? h.z : b.z, this.closestPointToPoint(i, e);
          const I = i.distanceToSquared(e);
          if (I < _ && (_ = I, c && c.copy(e), f && f.copy(i), I < l))
            return Math.sqrt(I);
        }
    for (let y = 0; y < 12; y++) {
      const d = t[y];
      for (let p = 0; p < 12; p++) {
        const I = s[p];
        ie(d, I, e, i);
        const m = e.distanceToSquared(i);
        if (m < _ && (_ = m, c && c.copy(e), f && f.copy(i), m < l))
          return Math.sqrt(m);
      }
    }
    return Math.sqrt(_);
  };
}();
class ne {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
}
class mi extends ne {
  constructor() {
    super(() => new ot());
  }
}
const Q = /* @__PURE__ */ new mi();
function Z(a, t) {
  return t[a + 15] === 65535;
}
function J(a, t) {
  return t[a + 6];
}
function tt(a, t) {
  return t[a + 14];
}
function st(a) {
  return a + 8;
}
function et(a, t) {
  return t[a + 6];
}
function De(a, t) {
  return t[a + 7];
}
class yi {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t = [];
    let s = null;
    this.setBuffer = (e) => {
      s && t.push(s), s = e, this.float32Array = new Float32Array(e), this.uint16Array = new Uint16Array(e), this.uint32Array = new Uint32Array(e);
    }, this.clearBuffer = () => {
      s = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, t.length !== 0 && this.setBuffer(t.pop());
    };
  }
}
const G = new yi();
let At, Ht;
const zt = [], hs = /* @__PURE__ */ new ne(() => new rt());
function gi(a, t, s, e, i, n) {
  At = hs.getPrimitive(), Ht = hs.getPrimitive(), zt.push(At, Ht), G.setBuffer(a._roots[t]);
  const o = $s(0, a.geometry, s, e, i, n);
  G.clearBuffer(), hs.releasePrimitive(At), hs.releasePrimitive(Ht), zt.pop(), zt.pop();
  const r = zt.length;
  return r > 0 && (Ht = zt[r - 1], At = zt[r - 2]), o;
}
function $s(a, t, s, e, i = null, n = 0, o = 0) {
  const { float32Array: r, uint16Array: c, uint32Array: f } = G;
  let l = a * 2;
  if (Z(l, c)) {
    const h = J(a, f), u = tt(l, c);
    return R(a, r, At), e(h, u, !1, o, n + a, At);
  } else {
    let v = function(V) {
      const { uint16Array: P, uint32Array: B } = G;
      let O = V * 2;
      for (; !Z(O, P); )
        V = st(V), O = V * 2;
      return J(V, B);
    }, M = function(V) {
      const { uint16Array: P, uint32Array: B } = G;
      let O = V * 2;
      for (; !Z(O, P); )
        V = et(V, B), O = V * 2;
      return J(V, B) + tt(O, P);
    };
    const h = st(a), u = et(a, f);
    let _ = h, w = u, y, d, p, I;
    if (i && (p = At, I = Ht, R(_, r, p), R(w, r, I), y = i(p), d = i(I), d < y)) {
      _ = u, w = h;
      const V = y;
      y = d, d = V, p = I;
    }
    p || (p = At, R(_, r, p));
    const m = Z(_ * 2, c), g = s(p, m, y, o + 1, n + _);
    let A;
    if (g === fe) {
      const V = v(_), B = M(_) - V;
      A = e(V, B, !0, o + 1, n + _, p);
    } else
      A = g && $s(
        _,
        t,
        s,
        e,
        i,
        n,
        o + 1
      );
    if (A)
      return !0;
    I = Ht, R(w, r, I);
    const F = Z(w * 2, c), x = s(I, F, d, o + 1, n + w);
    let C;
    if (x === fe) {
      const V = v(w), B = M(w) - V;
      C = e(V, B, !0, o + 1, n + w, I);
    } else
      C = x && $s(
        w,
        t,
        s,
        e,
        i,
        n,
        o + 1
      );
    return !!C;
  }
}
const Wt = /* @__PURE__ */ new T(), Us = /* @__PURE__ */ new T();
function Ii(a, t, s = {}, e = 0, i = 1 / 0) {
  const n = e * e, o = i * i;
  let r = 1 / 0, c = null;
  if (a.shapecast(
    {
      boundsTraverseOrder: (l) => (Wt.copy(t).clamp(l.min, l.max), Wt.distanceToSquared(t)),
      intersectsBounds: (l, b, h) => h < r && h < o,
      intersectsTriangle: (l, b) => {
        l.closestPointToPoint(t, Wt);
        const h = t.distanceToSquared(Wt);
        return h < r && (Us.copy(Wt), r = h, c = b), h < n;
      }
    }
  ), r === 1 / 0)
    return null;
  const f = Math.sqrt(r);
  return s.point ? s.point.copy(Us) : s.point = Us.clone(), s.distance = f, s.faceIndex = c, s;
}
const Et = /* @__PURE__ */ new T(), Gt = /* @__PURE__ */ new T(), Rt = /* @__PURE__ */ new T(), bs = /* @__PURE__ */ new Xt(), us = /* @__PURE__ */ new Xt(), ds = /* @__PURE__ */ new Xt(), de = /* @__PURE__ */ new T(), _e = /* @__PURE__ */ new T(), pe = /* @__PURE__ */ new T(), _s = /* @__PURE__ */ new T();
function wi(a, t, s, e, i, n) {
  let o;
  return n === He ? o = a.intersectTriangle(e, s, t, !0, i) : o = a.intersectTriangle(t, s, e, n !== Xe, i), o === null ? null : {
    distance: a.origin.distanceTo(i),
    point: i.clone()
  };
}
function xi(a, t, s, e, i, n, o, r, c) {
  Et.fromBufferAttribute(t, n), Gt.fromBufferAttribute(t, o), Rt.fromBufferAttribute(t, r);
  const f = wi(a, Et, Gt, Rt, _s, c);
  if (f) {
    e && (bs.fromBufferAttribute(e, n), us.fromBufferAttribute(e, o), ds.fromBufferAttribute(e, r), f.uv = is.getInterpolation(_s, Et, Gt, Rt, bs, us, ds, new Xt())), i && (bs.fromBufferAttribute(i, n), us.fromBufferAttribute(i, o), ds.fromBufferAttribute(i, r), f.uv1 = is.getInterpolation(_s, Et, Gt, Rt, bs, us, ds, new Xt())), s && (de.fromBufferAttribute(s, n), _e.fromBufferAttribute(s, o), pe.fromBufferAttribute(s, r), f.normal = is.getInterpolation(_s, Et, Gt, Rt, de, _e, pe, new T()), f.normal.dot(a.direction) > 0 && f.normal.multiplyScalar(-1));
    const l = {
      a: n,
      b: o,
      c: r,
      normal: new T(),
      materialIndex: 0
    };
    is.getNormal(Et, Gt, Rt, l.normal), f.face = l, f.faceIndex = n;
  }
  return f;
}
function Ss(a, t, s, e, i) {
  const n = e * 3;
  let o = n + 0, r = n + 1, c = n + 2;
  const f = a.index;
  a.index && (o = f.getX(o), r = f.getX(r), c = f.getX(c));
  const { position: l, normal: b, uv: h, uv1: u } = a.attributes, _ = xi(s, l, b, h, u, o, r, c, t);
  return _ ? (_.faceIndex = e, i && i.push(_), _) : null;
}
function k(a, t, s, e) {
  const i = a.a, n = a.b, o = a.c;
  let r = t, c = t + 1, f = t + 2;
  s && (r = s.getX(r), c = s.getX(c), f = s.getX(f)), i.x = e.getX(r), i.y = e.getY(r), i.z = e.getZ(r), n.x = e.getX(c), n.y = e.getY(c), n.z = e.getZ(c), o.x = e.getX(f), o.y = e.getY(f), o.z = e.getZ(f);
}
function Ai(a, t, s, e, i, n) {
  const { geometry: o, _indirectBuffer: r } = a;
  for (let c = e, f = e + i; c < f; c++)
    Ss(o, t, s, c, n);
}
function vi(a, t, s, e, i) {
  const { geometry: n, _indirectBuffer: o } = a;
  let r = 1 / 0, c = null;
  for (let f = e, l = e + i; f < l; f++) {
    let b;
    b = Ss(n, t, s, f), b && b.distance < r && (c = b, r = b.distance);
  }
  return c;
}
function Vi(a, t, s, e, i, n, o) {
  const { geometry: r } = s, { index: c } = r, f = r.attributes.position;
  for (let l = a, b = t + a; l < b; l++) {
    let h;
    if (h = l, k(o, h * 3, c, f), o.needsUpdate = !0, e(o, h, i, n))
      return !0;
  }
  return !1;
}
function Fi(a, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const s = a.geometry, e = s.index ? s.index.array : null, i = s.attributes.position;
  let n, o, r, c, f = 0;
  const l = a._roots;
  for (let h = 0, u = l.length; h < u; h++)
    n = l[h], o = new Uint32Array(n), r = new Uint16Array(n), c = new Float32Array(n), b(0, f), f += n.byteLength;
  function b(h, u, _ = !1) {
    const w = h * 2;
    if (r[w + 15] === Ms) {
      const d = o[h + 6], p = r[w + 14];
      let I = 1 / 0, m = 1 / 0, g = 1 / 0, A = -1 / 0, F = -1 / 0, x = -1 / 0;
      for (let C = 3 * d, v = 3 * (d + p); C < v; C++) {
        let M = e[C];
        const V = i.getX(M), P = i.getY(M), B = i.getZ(M);
        V < I && (I = V), V > A && (A = V), P < m && (m = P), P > F && (F = P), B < g && (g = B), B > x && (x = B);
      }
      return c[h + 0] !== I || c[h + 1] !== m || c[h + 2] !== g || c[h + 3] !== A || c[h + 4] !== F || c[h + 5] !== x ? (c[h + 0] = I, c[h + 1] = m, c[h + 2] = g, c[h + 3] = A, c[h + 4] = F, c[h + 5] = x, !0) : !1;
    } else {
      const d = h + 8, p = o[h + 6], I = d + u, m = p + u;
      let g = _, A = !1, F = !1;
      t ? g || (A = t.has(I), F = t.has(m), g = !A && !F) : (A = !0, F = !0);
      const x = g || A, C = g || F;
      let v = !1;
      x && (v = b(d, u, g));
      let M = !1;
      C && (M = b(p, u, g));
      const V = v || M;
      if (V)
        for (let P = 0; P < 3; P++) {
          const B = d + P, O = p + P, D = c[B], $ = c[B + 3], X = c[O], Y = c[O + 3];
          c[h + P] = D < X ? D : X, c[h + P + 3] = $ > Y ? $ : Y;
        }
      return V;
    }
  }
}
const me = /* @__PURE__ */ new rt();
function Vt(a, t, s, e) {
  return R(a, t, me), s.intersectBox(me, e);
}
function Ci(a, t, s, e, i, n) {
  const { geometry: o, _indirectBuffer: r } = a;
  for (let c = e, f = e + i; c < f; c++) {
    let l = r ? r[c] : c;
    Ss(o, t, s, l, n);
  }
}
function Pi(a, t, s, e, i) {
  const { geometry: n, _indirectBuffer: o } = a;
  let r = 1 / 0, c = null;
  for (let f = e, l = e + i; f < l; f++) {
    let b;
    b = Ss(n, t, s, o ? o[f] : f), b && b.distance < r && (c = b, r = b.distance);
  }
  return c;
}
function Mi(a, t, s, e, i, n, o) {
  const { geometry: r } = s, { index: c } = r, f = r.attributes.position;
  for (let l = a, b = t + a; l < b; l++) {
    let h;
    if (h = s.resolveTriangleIndex(l), k(o, h * 3, c, f), o.needsUpdate = !0, e(o, h, i, n))
      return !0;
  }
  return !1;
}
const ye = /* @__PURE__ */ new T();
function Si(a, t, s, e, i) {
  G.setBuffer(a._roots[t]), Hs(0, a, s, e, i), G.clearBuffer();
}
function Hs(a, t, s, e, i) {
  const { float32Array: n, uint16Array: o, uint32Array: r } = G, c = a * 2;
  if (Z(c, o)) {
    const l = J(a, r), b = tt(c, o);
    Ai(t, s, e, l, b, i);
  } else {
    const l = st(a);
    Vt(l, n, e, ye) && Hs(l, t, s, e, i);
    const b = et(a, r);
    Vt(b, n, e, ye) && Hs(b, t, s, e, i);
  }
}
const ge = /* @__PURE__ */ new T(), Bi = ["x", "y", "z"];
function Ti(a, t, s, e) {
  G.setBuffer(a._roots[t]);
  const i = Xs(0, a, s, e);
  return G.clearBuffer(), i;
}
function Xs(a, t, s, e) {
  const { float32Array: i, uint16Array: n, uint32Array: o } = G;
  let r = a * 2;
  if (Z(r, n)) {
    const f = J(a, o), l = tt(r, n);
    return vi(t, s, e, f, l);
  } else {
    const f = De(a, o), l = Bi[f], h = e.direction[l] >= 0;
    let u, _;
    h ? (u = st(a), _ = et(a, o)) : (u = et(a, o), _ = st(a));
    const y = Vt(u, i, e, ge) ? Xs(u, t, s, e) : null;
    if (y) {
      const I = y.point[l];
      if (h ? I <= i[_ + f] : (
        // min bounding data
        I >= i[_ + f + 3]
      ))
        return y;
    }
    const p = Vt(_, i, e, ge) ? Xs(_, t, s, e) : null;
    return y && p ? y.distance <= p.distance ? y : p : y || p || null;
  }
}
const ps = /* @__PURE__ */ new rt(), Nt = /* @__PURE__ */ new ot(), kt = /* @__PURE__ */ new ot(), Qt = /* @__PURE__ */ new vt(), Ie = /* @__PURE__ */ new H(), ms = /* @__PURE__ */ new H();
function Oi(a, t, s, e) {
  G.setBuffer(a._roots[t]);
  const i = Ys(0, a, s, e);
  return G.clearBuffer(), i;
}
function Ys(a, t, s, e, i = null) {
  const { float32Array: n, uint16Array: o, uint32Array: r } = G;
  let c = a * 2;
  if (i === null && (s.boundingBox || s.computeBoundingBox(), Ie.set(s.boundingBox.min, s.boundingBox.max, e), i = Ie), Z(c, o)) {
    const l = t.geometry, b = l.index, h = l.attributes.position, u = s.index, _ = s.attributes.position, w = J(a, r), y = tt(c, o);
    if (Qt.copy(e).invert(), s.boundsTree)
      return R(a, n, ms), ms.matrix.copy(Qt), ms.needsUpdate = !0, s.boundsTree.shapecast({
        intersectsBounds: (p) => ms.intersectsBox(p),
        intersectsTriangle: (p) => {
          p.a.applyMatrix4(e), p.b.applyMatrix4(e), p.c.applyMatrix4(e), p.needsUpdate = !0;
          for (let I = w * 3, m = (y + w) * 3; I < m; I += 3)
            if (k(kt, I, b, h), kt.needsUpdate = !0, p.intersectsTriangle(kt))
              return !0;
          return !1;
        }
      });
    for (let d = w * 3, p = (y + w) * 3; d < p; d += 3) {
      k(Nt, d, b, h), Nt.a.applyMatrix4(Qt), Nt.b.applyMatrix4(Qt), Nt.c.applyMatrix4(Qt), Nt.needsUpdate = !0;
      for (let I = 0, m = u.count; I < m; I += 3)
        if (k(kt, I, u, _), kt.needsUpdate = !0, Nt.intersectsTriangle(kt))
          return !0;
    }
  } else {
    const l = a + 8, b = r[a + 6];
    return R(l, n, ps), !!(i.intersectsBox(ps) && Ys(l, t, s, e, i) || (R(b, n, ps), i.intersectsBox(ps) && Ys(b, t, s, e, i)));
  }
}
const ys = /* @__PURE__ */ new vt(), zs = /* @__PURE__ */ new H(), ts = /* @__PURE__ */ new H(), Li = /* @__PURE__ */ new T(), Di = /* @__PURE__ */ new T(), Ui = /* @__PURE__ */ new T(), zi = /* @__PURE__ */ new T();
function Ei(a, t, s, e = {}, i = {}, n = 0, o = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), zs.set(t.boundingBox.min, t.boundingBox.max, s), zs.needsUpdate = !0;
  const r = a.geometry, c = r.attributes.position, f = r.index, l = t.attributes.position, b = t.index, h = Q.getPrimitive(), u = Q.getPrimitive();
  let _ = Li, w = Di, y = null, d = null;
  i && (y = Ui, d = zi);
  let p = 1 / 0, I = null, m = null;
  return ys.copy(s).invert(), ts.matrix.copy(ys), a.shapecast(
    {
      boundsTraverseOrder: (g) => zs.distanceToBox(g),
      intersectsBounds: (g, A, F) => F < p && F < o ? (A && (ts.min.copy(g.min), ts.max.copy(g.max), ts.needsUpdate = !0), !0) : !1,
      intersectsRange: (g, A) => {
        if (t.boundsTree)
          return t.boundsTree.shapecast({
            boundsTraverseOrder: (x) => ts.distanceToBox(x),
            intersectsBounds: (x, C, v) => v < p && v < o,
            intersectsRange: (x, C) => {
              for (let v = x, M = x + C; v < M; v++) {
                k(u, 3 * v, b, l), u.a.applyMatrix4(s), u.b.applyMatrix4(s), u.c.applyMatrix4(s), u.needsUpdate = !0;
                for (let V = g, P = g + A; V < P; V++) {
                  k(h, 3 * V, f, c), h.needsUpdate = !0;
                  const B = h.distanceToTriangle(u, _, y);
                  if (B < p && (w.copy(_), d && d.copy(y), p = B, I = V, m = v), B < n)
                    return !0;
                }
              }
            }
          });
        {
          const F = Yt(t);
          for (let x = 0, C = F; x < C; x++) {
            k(u, 3 * x, b, l), u.a.applyMatrix4(s), u.b.applyMatrix4(s), u.c.applyMatrix4(s), u.needsUpdate = !0;
            for (let v = g, M = g + A; v < M; v++) {
              k(h, 3 * v, f, c), h.needsUpdate = !0;
              const V = h.distanceToTriangle(u, _, y);
              if (V < p && (w.copy(_), d && d.copy(y), p = V, I = v, m = x), V < n)
                return !0;
            }
          }
        }
      }
    }
  ), Q.releasePrimitive(h), Q.releasePrimitive(u), p === 1 / 0 ? null : (e.point ? e.point.copy(w) : e.point = w.clone(), e.distance = p, e.faceIndex = I, i && (i.point ? i.point.copy(d) : i.point = d.clone(), i.point.applyMatrix4(ys), w.applyMatrix4(ys), i.distance = w.sub(i.point).length(), i.faceIndex = m), e);
}
function Gi(a, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const s = a.geometry, e = s.index ? s.index.array : null, i = s.attributes.position;
  let n, o, r, c, f = 0;
  const l = a._roots;
  for (let h = 0, u = l.length; h < u; h++)
    n = l[h], o = new Uint32Array(n), r = new Uint16Array(n), c = new Float32Array(n), b(0, f), f += n.byteLength;
  function b(h, u, _ = !1) {
    const w = h * 2;
    if (r[w + 15] === Ms) {
      const d = o[h + 6], p = r[w + 14];
      let I = 1 / 0, m = 1 / 0, g = 1 / 0, A = -1 / 0, F = -1 / 0, x = -1 / 0;
      for (let C = d, v = d + p; C < v; C++) {
        const M = 3 * a.resolveTriangleIndex(C);
        for (let V = 0; V < 3; V++) {
          let P = M + V;
          P = e ? e[P] : P;
          const B = i.getX(P), O = i.getY(P), D = i.getZ(P);
          B < I && (I = B), B > A && (A = B), O < m && (m = O), O > F && (F = O), D < g && (g = D), D > x && (x = D);
        }
      }
      return c[h + 0] !== I || c[h + 1] !== m || c[h + 2] !== g || c[h + 3] !== A || c[h + 4] !== F || c[h + 5] !== x ? (c[h + 0] = I, c[h + 1] = m, c[h + 2] = g, c[h + 3] = A, c[h + 4] = F, c[h + 5] = x, !0) : !1;
    } else {
      const d = h + 8, p = o[h + 6], I = d + u, m = p + u;
      let g = _, A = !1, F = !1;
      t ? g || (A = t.has(I), F = t.has(m), g = !A && !F) : (A = !0, F = !0);
      const x = g || A, C = g || F;
      let v = !1;
      x && (v = b(d, u, g));
      let M = !1;
      C && (M = b(p, u, g));
      const V = v || M;
      if (V)
        for (let P = 0; P < 3; P++) {
          const B = d + P, O = p + P, D = c[B], $ = c[B + 3], X = c[O], Y = c[O + 3];
          c[h + P] = D < X ? D : X, c[h + P + 3] = $ > Y ? $ : Y;
        }
      return V;
    }
  }
}
const we = /* @__PURE__ */ new T();
function Ri(a, t, s, e, i) {
  G.setBuffer(a._roots[t]), Zs(0, a, s, e, i), G.clearBuffer();
}
function Zs(a, t, s, e, i) {
  const { float32Array: n, uint16Array: o, uint32Array: r } = G, c = a * 2;
  if (Z(c, o)) {
    const l = J(a, r), b = tt(c, o);
    Ci(t, s, e, l, b, i);
  } else {
    const l = st(a);
    Vt(l, n, e, we) && Zs(l, t, s, e, i);
    const b = et(a, r);
    Vt(b, n, e, we) && Zs(b, t, s, e, i);
  }
}
const xe = /* @__PURE__ */ new T(), Ni = ["x", "y", "z"];
function ki(a, t, s, e) {
  G.setBuffer(a._roots[t]);
  const i = Js(0, a, s, e);
  return G.clearBuffer(), i;
}
function Js(a, t, s, e) {
  const { float32Array: i, uint16Array: n, uint32Array: o } = G;
  let r = a * 2;
  if (Z(r, n)) {
    const f = J(a, o), l = tt(r, n);
    return Pi(t, s, e, f, l);
  } else {
    const f = De(a, o), l = Ni[f], h = e.direction[l] >= 0;
    let u, _;
    h ? (u = st(a), _ = et(a, o)) : (u = et(a, o), _ = st(a));
    const y = Vt(u, i, e, xe) ? Js(u, t, s, e) : null;
    if (y) {
      const I = y.point[l];
      if (h ? I <= i[_ + f] : (
        // min bounding data
        I >= i[_ + f + 3]
      ))
        return y;
    }
    const p = Vt(_, i, e, xe) ? Js(_, t, s, e) : null;
    return y && p ? y.distance <= p.distance ? y : p : y || p || null;
  }
}
const gs = /* @__PURE__ */ new rt(), qt = /* @__PURE__ */ new ot(), Kt = /* @__PURE__ */ new ot(), ss = /* @__PURE__ */ new vt(), Ae = /* @__PURE__ */ new H(), Is = /* @__PURE__ */ new H();
function qi(a, t, s, e) {
  G.setBuffer(a._roots[t]);
  const i = Ws(0, a, s, e);
  return G.clearBuffer(), i;
}
function Ws(a, t, s, e, i = null) {
  const { float32Array: n, uint16Array: o, uint32Array: r } = G;
  let c = a * 2;
  if (i === null && (s.boundingBox || s.computeBoundingBox(), Ae.set(s.boundingBox.min, s.boundingBox.max, e), i = Ae), Z(c, o)) {
    const l = t.geometry, b = l.index, h = l.attributes.position, u = s.index, _ = s.attributes.position, w = J(a, r), y = tt(c, o);
    if (ss.copy(e).invert(), s.boundsTree)
      return R(a, n, Is), Is.matrix.copy(ss), Is.needsUpdate = !0, s.boundsTree.shapecast({
        intersectsBounds: (p) => Is.intersectsBox(p),
        intersectsTriangle: (p) => {
          p.a.applyMatrix4(e), p.b.applyMatrix4(e), p.c.applyMatrix4(e), p.needsUpdate = !0;
          for (let I = w, m = y + w; I < m; I++)
            if (k(Kt, 3 * t.resolveTriangleIndex(I), b, h), Kt.needsUpdate = !0, p.intersectsTriangle(Kt))
              return !0;
          return !1;
        }
      });
    for (let d = w, p = y + w; d < p; d++) {
      const I = t.resolveTriangleIndex(d);
      k(qt, 3 * I, b, h), qt.a.applyMatrix4(ss), qt.b.applyMatrix4(ss), qt.c.applyMatrix4(ss), qt.needsUpdate = !0;
      for (let m = 0, g = u.count; m < g; m += 3)
        if (k(Kt, m, u, _), Kt.needsUpdate = !0, qt.intersectsTriangle(Kt))
          return !0;
    }
  } else {
    const l = a + 8, b = r[a + 6];
    return R(l, n, gs), !!(i.intersectsBox(gs) && Ws(l, t, s, e, i) || (R(b, n, gs), i.intersectsBox(gs) && Ws(b, t, s, e, i)));
  }
}
const ws = /* @__PURE__ */ new vt(), Es = /* @__PURE__ */ new H(), es = /* @__PURE__ */ new H(), Ki = /* @__PURE__ */ new T(), ji = /* @__PURE__ */ new T(), $i = /* @__PURE__ */ new T(), Hi = /* @__PURE__ */ new T();
function Xi(a, t, s, e = {}, i = {}, n = 0, o = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), Es.set(t.boundingBox.min, t.boundingBox.max, s), Es.needsUpdate = !0;
  const r = a.geometry, c = r.attributes.position, f = r.index, l = t.attributes.position, b = t.index, h = Q.getPrimitive(), u = Q.getPrimitive();
  let _ = Ki, w = ji, y = null, d = null;
  i && (y = $i, d = Hi);
  let p = 1 / 0, I = null, m = null;
  return ws.copy(s).invert(), es.matrix.copy(ws), a.shapecast(
    {
      boundsTraverseOrder: (g) => Es.distanceToBox(g),
      intersectsBounds: (g, A, F) => F < p && F < o ? (A && (es.min.copy(g.min), es.max.copy(g.max), es.needsUpdate = !0), !0) : !1,
      intersectsRange: (g, A) => {
        if (t.boundsTree) {
          const F = t.boundsTree;
          return F.shapecast({
            boundsTraverseOrder: (x) => es.distanceToBox(x),
            intersectsBounds: (x, C, v) => v < p && v < o,
            intersectsRange: (x, C) => {
              for (let v = x, M = x + C; v < M; v++) {
                const V = F.resolveTriangleIndex(v);
                k(u, 3 * V, b, l), u.a.applyMatrix4(s), u.b.applyMatrix4(s), u.c.applyMatrix4(s), u.needsUpdate = !0;
                for (let P = g, B = g + A; P < B; P++) {
                  const O = a.resolveTriangleIndex(P);
                  k(h, 3 * O, f, c), h.needsUpdate = !0;
                  const D = h.distanceToTriangle(u, _, y);
                  if (D < p && (w.copy(_), d && d.copy(y), p = D, I = P, m = v), D < n)
                    return !0;
                }
              }
            }
          });
        } else {
          const F = Yt(t);
          for (let x = 0, C = F; x < C; x++) {
            k(u, 3 * x, b, l), u.a.applyMatrix4(s), u.b.applyMatrix4(s), u.c.applyMatrix4(s), u.needsUpdate = !0;
            for (let v = g, M = g + A; v < M; v++) {
              const V = a.resolveTriangleIndex(v);
              k(h, 3 * V, f, c), h.needsUpdate = !0;
              const P = h.distanceToTriangle(u, _, y);
              if (P < p && (w.copy(_), d && d.copy(y), p = P, I = v, m = x), P < n)
                return !0;
            }
          }
        }
      }
    }
  ), Q.releasePrimitive(h), Q.releasePrimitive(u), p === 1 / 0 ? null : (e.point ? e.point.copy(w) : e.point = w.clone(), e.distance = p, e.faceIndex = I, i && (i.point ? i.point.copy(d) : i.point = d.clone(), i.point.applyMatrix4(ws), w.applyMatrix4(ws), i.distance = w.sub(i.point).length(), i.faceIndex = m), e);
}
function Yi() {
  return typeof SharedArrayBuffer < "u";
}
const ns = new G.constructor(), Cs = new G.constructor(), It = new ne(() => new rt()), jt = new rt(), $t = new rt(), Gs = new rt(), Rs = new rt();
let Ns = !1;
function Zi(a, t, s, e) {
  if (Ns)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Ns = !0;
  const i = a._roots, n = t._roots;
  let o, r = 0, c = 0;
  const f = new vt().copy(s).invert();
  for (let l = 0, b = i.length; l < b; l++) {
    ns.setBuffer(i[l]), c = 0;
    const h = It.getPrimitive();
    R(0, ns.float32Array, h), h.applyMatrix4(f);
    for (let u = 0, _ = n.length; u < _ && (Cs.setBuffer(n[l]), o = it(
      0,
      0,
      s,
      f,
      e,
      r,
      c,
      0,
      0,
      h
    ), Cs.clearBuffer(), c += n[u].length, !o); u++)
      ;
    if (It.releasePrimitive(h), ns.clearBuffer(), r += i[l].length, o)
      break;
  }
  return Ns = !1, o;
}
function it(a, t, s, e, i, n = 0, o = 0, r = 0, c = 0, f = null, l = !1) {
  let b, h;
  l ? (b = Cs, h = ns) : (b = ns, h = Cs);
  const u = b.float32Array, _ = b.uint32Array, w = b.uint16Array, y = h.float32Array, d = h.uint32Array, p = h.uint16Array, I = a * 2, m = t * 2, g = Z(I, w), A = Z(m, p);
  let F = !1;
  if (A && g)
    l ? F = i(
      J(t, d),
      tt(t * 2, p),
      J(a, _),
      tt(a * 2, w),
      c,
      o + t,
      r,
      n + a
    ) : F = i(
      J(a, _),
      tt(a * 2, w),
      J(t, d),
      tt(t * 2, p),
      r,
      n + a,
      c,
      o + t
    );
  else if (A) {
    const x = It.getPrimitive();
    R(t, y, x), x.applyMatrix4(s);
    const C = st(a), v = et(a, _);
    R(C, u, jt), R(v, u, $t);
    const M = x.intersectsBox(jt), V = x.intersectsBox($t);
    F = M && it(
      t,
      C,
      e,
      s,
      i,
      o,
      n,
      c,
      r + 1,
      x,
      !l
    ) || V && it(
      t,
      v,
      e,
      s,
      i,
      o,
      n,
      c,
      r + 1,
      x,
      !l
    ), It.releasePrimitive(x);
  } else {
    const x = st(t), C = et(t, d);
    R(x, y, Gs), R(C, y, Rs);
    const v = f.intersectsBox(Gs), M = f.intersectsBox(Rs);
    if (v && M)
      F = it(
        a,
        x,
        s,
        e,
        i,
        n,
        o,
        r,
        c + 1,
        f,
        l
      ) || it(
        a,
        C,
        s,
        e,
        i,
        n,
        o,
        r,
        c + 1,
        f,
        l
      );
    else if (v)
      if (g)
        F = it(
          a,
          x,
          s,
          e,
          i,
          n,
          o,
          r,
          c + 1,
          f,
          l
        );
      else {
        const V = It.getPrimitive();
        V.copy(Gs).applyMatrix4(s);
        const P = st(a), B = et(a, _);
        R(P, u, jt), R(B, u, $t);
        const O = V.intersectsBox(jt), D = V.intersectsBox($t);
        F = O && it(
          x,
          P,
          e,
          s,
          i,
          o,
          n,
          c,
          r + 1,
          V,
          !l
        ) || D && it(
          x,
          B,
          e,
          s,
          i,
          o,
          n,
          c,
          r + 1,
          V,
          !l
        ), It.releasePrimitive(V);
      }
    else if (M)
      if (g)
        F = it(
          a,
          C,
          s,
          e,
          i,
          n,
          o,
          r,
          c + 1,
          f,
          l
        );
      else {
        const V = It.getPrimitive();
        V.copy(Rs).applyMatrix4(s);
        const P = st(a), B = et(a, _);
        R(P, u, jt), R(B, u, $t);
        const O = V.intersectsBox(jt), D = V.intersectsBox($t);
        F = O && it(
          C,
          P,
          e,
          s,
          i,
          o,
          n,
          c,
          r + 1,
          V,
          !l
        ) || D && it(
          C,
          B,
          e,
          s,
          i,
          o,
          n,
          c,
          r + 1,
          V,
          !l
        ), It.releasePrimitive(V);
      }
  }
  return F;
}
const xs = /* @__PURE__ */ new H(), ve = /* @__PURE__ */ new rt();
class oe {
  static serialize(t, s = {}) {
    s = {
      cloneBuffers: !0,
      ...s
    };
    const e = t.geometry, i = t._roots, n = t._indirectBuffer, o = e.getIndex();
    let r;
    return s.cloneBuffers ? r = {
      roots: i.map((c) => c.slice()),
      index: o.array.slice(),
      indirectBuffer: n ? n.slice() : null
    } : r = {
      roots: i,
      index: o.array,
      indirectBuffer: n
    }, r;
  }
  static deserialize(t, s, e = {}) {
    e = {
      setIndex: !0,
      indirect: !!t.indirectBuffer,
      ...e
    };
    const { index: i, roots: n, indirectBuffer: o } = t, r = new oe(s, { ...e, [Os]: !0 });
    if (r._roots = n, r._indirectBuffer = o || null, e.setIndex) {
      const c = s.getIndex();
      if (c === null) {
        const f = new Me(t.index, 1, !1);
        s.setIndex(f);
      } else
        c.array !== i && (c.array.set(i), c.needsUpdate = !0);
    }
    return r;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t, s = {}) {
    if (t.isBufferGeometry) {
      if (t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (s = Object.assign({
      strategy: Te,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: !0,
      useSharedArrayBuffer: !1,
      setBoundingBox: !0,
      onProgress: null,
      indirect: !1,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Os]: !1
    }, s), s.useSharedArrayBuffer && !Yi())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t, this._roots = null, this._indirectBuffer = null, s[Os] || (ui(this, s), !t.boundingBox && s.setBoundingBox && (t.boundingBox = this.getBoundingBox(new rt())));
    const { _indirectBuffer: e } = this;
    this.resolveTriangleIndex = s.indirect ? (i) => e[i] : (i) => i;
  }
  refit(t = null) {
    return (this.indirect ? Gi : Fi)(this, t);
  }
  traverse(t, s = 0) {
    const e = this._roots[s], i = new Uint32Array(e), n = new Uint16Array(e);
    o(0);
    function o(r, c = 0) {
      const f = r * 2, l = n[f + 15] === Ms;
      if (l) {
        const b = i[r + 6], h = n[f + 14];
        t(c, l, new Float32Array(e, r * 4, 6), b, h);
      } else {
        const b = r + vs / 4, h = i[r + 6], u = i[r + 7];
        t(c, l, new Float32Array(e, r * 4, 6), u) || (o(b, c + 1), o(h, c + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(t, s = re) {
    const e = this._roots, i = this.geometry, n = [], o = s.isMaterial, r = Array.isArray(s), c = i.groups, f = o ? s.side : s, l = this.indirect ? Ri : Si;
    for (let b = 0, h = e.length; b < h; b++) {
      const u = r ? s[c[b].materialIndex].side : f, _ = n.length;
      if (l(this, b, u, t, n), r) {
        const w = c[b].materialIndex;
        for (let y = _, d = n.length; y < d; y++)
          n[y].face.materialIndex = w;
      }
    }
    return n;
  }
  raycastFirst(t, s = re) {
    const e = this._roots, i = this.geometry, n = s.isMaterial, o = Array.isArray(s);
    let r = null;
    const c = i.groups, f = n ? s.side : s, l = this.indirect ? ki : Ti;
    for (let b = 0, h = e.length; b < h; b++) {
      const u = o ? s[c[b].materialIndex].side : f, _ = l(this, b, u, t);
      _ != null && (r == null || _.distance < r.distance) && (r = _, o && (_.face.materialIndex = c[b].materialIndex));
    }
    return r;
  }
  intersectsGeometry(t, s) {
    let e = !1;
    const i = this._roots, n = this.indirect ? qi : Oi;
    for (let o = 0, r = i.length; o < r && (e = n(this, o, t, s), !e); o++)
      ;
    return e;
  }
  shapecast(t) {
    const s = Q.getPrimitive(), e = this.indirect ? Mi : Vi;
    let {
      boundsTraverseOrder: i,
      intersectsBounds: n,
      intersectsRange: o,
      intersectsTriangle: r
    } = t;
    if (o && r) {
      const b = o;
      o = (h, u, _, w, y) => b(h, u, _, w, y) ? !0 : e(h, u, this, r, _, w, s);
    } else
      o || (r ? o = (b, h, u, _) => e(b, h, this, r, u, _, s) : o = (b, h, u) => u);
    let c = !1, f = 0;
    const l = this._roots;
    for (let b = 0, h = l.length; b < h; b++) {
      const u = l[b];
      if (c = gi(this, b, n, o, i, f), c)
        break;
      f += u.byteLength;
    }
    return Q.releasePrimitive(s), c;
  }
  bvhcast(t, s, e) {
    let {
      intersectsRanges: i,
      intersectsTriangles: n
    } = e;
    const o = Q.getPrimitive(), r = this.geometry.index, c = this.geometry.attributes.position, f = this.indirect ? (_) => {
      const w = this.resolveTriangleIndex(_);
      k(o, w * 3, r, c);
    } : (_) => {
      k(o, _ * 3, r, c);
    }, l = Q.getPrimitive(), b = t.geometry.index, h = t.geometry.attributes.position, u = t.indirect ? (_) => {
      const w = t.resolveTriangleIndex(_);
      k(l, w * 3, b, h);
    } : (_) => {
      k(l, _ * 3, b, h);
    };
    if (n) {
      const _ = (w, y, d, p, I, m, g, A) => {
        for (let F = d, x = d + p; F < x; F++) {
          u(F), l.a.applyMatrix4(s), l.b.applyMatrix4(s), l.c.applyMatrix4(s), l.needsUpdate = !0;
          for (let C = w, v = w + y; C < v; C++)
            if (f(C), o.needsUpdate = !0, n(o, l, C, F, I, m, g, A))
              return !0;
        }
        return !1;
      };
      if (i) {
        const w = i;
        i = function(y, d, p, I, m, g, A, F) {
          return w(y, d, p, I, m, g, A, F) ? !0 : _(y, d, p, I, m, g, A, F);
        };
      } else
        i = _;
    }
    return Zi(this, t, s, i);
  }
  /* Derived Cast Functions */
  intersectsBox(t, s) {
    return xs.set(t.min, t.max, s), xs.needsUpdate = !0, this.shapecast(
      {
        intersectsBounds: (e) => xs.intersectsBox(e),
        intersectsTriangle: (e) => xs.intersectsTriangle(e)
      }
    );
  }
  intersectsSphere(t) {
    return this.shapecast(
      {
        intersectsBounds: (s) => t.intersectsBox(s),
        intersectsTriangle: (s) => s.intersectsSphere(t)
      }
    );
  }
  closestPointToGeometry(t, s, e = {}, i = {}, n = 0, o = 1 / 0) {
    return (this.indirect ? Xi : Ei)(
      this,
      t,
      s,
      e,
      i,
      n,
      o
    );
  }
  closestPointToPoint(t, s = {}, e = 0, i = 1 / 0) {
    return Ii(
      this,
      t,
      s,
      e,
      i
    );
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((e) => {
      R(0, new Float32Array(e), ve), t.union(ve);
    }), t;
  }
}
function Ve(a, t, s) {
  return a === null || (a.point.applyMatrix4(t.matrixWorld), a.distance = a.point.distanceTo(s.ray.origin), a.object = t, a.distance < s.near || a.distance > s.far) ? null : a;
}
const ks = /* @__PURE__ */ new Ye(), Fe = /* @__PURE__ */ new vt(), Ji = Be.prototype.raycast;
function Wi(a, t) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    Fe.copy(this.matrixWorld).invert(), ks.copy(a.ray).applyMatrix4(Fe);
    const s = this.geometry.boundsTree;
    if (a.firstHitOnly === !0) {
      const e = Ve(s.raycastFirst(ks, this.material), this, a);
      e && t.push(e);
    } else {
      const e = s.raycast(ks, this.material);
      for (let i = 0, n = e.length; i < n; i++) {
        const o = Ve(e[i], this, a);
        o && t.push(o);
      }
    }
  } else
    Ji.call(this, a, t);
}
function Qi(a) {
  return this.boundsTree = new oe(this, a), this.boundsTree;
}
function tn() {
  this.boundsTree = null;
}
const os = class os {
  /**
   * Applies the Bounding Volume Hierarchy (BVH) to a given BufferGeometry.
   * If the BVH is not already initialized, it adds the necessary methods to the BufferGeometry and Mesh prototypes.
   * If the geometry does not have a boundsTree, it computes one.
   *
   * @param geometry - The BufferGeometry to apply the BVH to.
   */
  static apply(t) {
    os.initialized || (ce.prototype.computeBoundsTree = Qi, ce.prototype.disposeBoundsTree = tn, Be.prototype.raycast = Wi, os.initialized = !0), t.boundsTree || t.computeBoundsTree();
  }
  /**
   * Disposes of the BVH associated with the given BufferGeometry.
   * If the geometry has a boundsTree, it disposes of it.
   *
   * @param geometry - The BufferGeometry to dispose of the BVH from.
   */
  static dispose(t) {
    t && t.disposeBoundsTree && t.disposeBoundsTree();
  }
};
/**
 * A flag indicating whether the BVH has been initialized.
 * Initialized means the necessary methods have been added to BufferGeometry and Mesh prototypes.
 */
S(os, "initialized", !1);
let Ps = os, Ue = class {
  /**
   * Constructs a new Fragment.
   * @param geometry - The geometry of the fragment.
   * @param material - The material(s) of the fragment.
   * @param count - The initial number of instances in the fragment.
   */
  constructor(t, s, e) {
    /**
     * A set of unique item IDs associated with this fragment.
     */
    S(this, "ids", /* @__PURE__ */ new Set());
    /**
     * A map of item IDs to sets of instance IDs.
     */
    S(this, "itemToInstances", /* @__PURE__ */ new Map());
    /**
     * A map of instance IDs to item IDs.
     */
    S(this, "instanceToItem", /* @__PURE__ */ new Map());
    /**
     * A set of item IDs of instances that are currently hidden.
     */
    S(this, "hiddenItems", /* @__PURE__ */ new Set());
    /**
     * The unique identifier of this fragment.
     */
    S(this, "id");
    /**
     * The mesh associated with this fragment.
     */
    S(this, "mesh");
    /**
     * The amount of instances that this fragment can contain.
     */
    S(this, "capacity", 0);
    /**
     * The amount by which to increase the capacity when necessary.
     */
    S(this, "capacityOffset", 10);
    /**
     * The group of fragments to which this fragment belongs.
     */
    S(this, "group");
    S(this, "_originalColors", /* @__PURE__ */ new Map());
    S(this, "_settingVisibility", !1);
    this.mesh = new ae(t, s, e, this), this.id = this.mesh.uuid, this.capacity = e, this.mesh.count = 0, this.mesh.geometry.index.count && Ps.apply(this.mesh.geometry);
  }
  /**
   * A getter property that returns the unique vertices of the fragment's geometry.
   * The unique vertices are determined by comparing the vertex positions.
   *
   * @returns An array of unique vertices.
   */
  get uniqueVertices() {
    const t = [], s = this.mesh.geometry.getAttribute(
      "position"
    );
    if (!s)
      return t;
    const e = /* @__PURE__ */ new Set();
    for (let i = 0; i < s.count; i++) {
      const n = s.getX(i), o = s.getY(i), r = s.getZ(i), c = `${n},${o},${r}`;
      e.has(c) || (e.add(c), t.push(new L.Vector3(n, o, r)));
    }
    return t;
  }
  /**
   * Disposes of the fragment and its associated resources.
   *
   * @param disposeResources - If true, disposes geometries and materials associated with the fragment. If false, only disposes of the fragment itself.
   */
  dispose(t = !0) {
    if (this.clear(), this.group = void 0, this._originalColors.clear(), this.mesh) {
      if (t) {
        for (const s of this.mesh.material)
          s.dispose();
        this.mesh.material = [], Ps.dispose(this.mesh.geometry), this.mesh.geometry && this.mesh.geometry.dispose(), this.mesh.geometry = null;
      }
      this.mesh.removeFromParent(), this.mesh.userData = {}, this.mesh.dispose(), this.mesh.fragment = null, this.mesh = null;
    }
  }
  /**
   * Retrieves the transform matrices and colors of instances associated with a given item ID.
   *
   * @param itemID - The unique identifier of the item.
   * @throws Will throw an error if the item is not found.
   * @returns An object containing the item ID, an array of transform matrices, and an optional array of colors.
   * If no colors are found, the colors array will be undefined.
   */
  get(t) {
    const s = this.getInstancesIDs(t);
    if (!s)
      throw new Error("Item not found!");
    const e = [], i = [];
    for (const o of s) {
      const r = new L.Matrix4();
      if (this.mesh.getMatrixAt(o, r), e.push(r), this.mesh.instanceColor) {
        const c = new L.Color();
        this.mesh.getColorAt(o, c), i.push(c);
      }
    }
    const n = i.length ? i : void 0;
    return { id: t, transforms: e, colors: n };
  }
  /**
   * Retrieves the item ID associated with a given instance ID.
   *
   * @param instanceID - The unique identifier of the instance.
   * @returns The item ID associated with the instance, or null if no association exists.
   */
  getItemID(t) {
    return this.instanceToItem.get(t) || null;
  }
  /**
   * Retrieves the instance IDs associated with a given item ID.
   *
   * @param itemID - The unique identifier of the item.
   * @returns The set of instance IDs associated with the item, or null if no association exists.
   */
  getInstancesIDs(t) {
    return this.itemToInstances.get(t) || null;
  }
  /**
   * Updates the instance color and matrix attributes of the fragment's mesh.
   * This method should be called whenever the instance color or matrix attributes
   * need to be updated.
   */
  update() {
    this.mesh.instanceColor && (this.mesh.instanceColor.needsUpdate = !0), this.mesh.instanceMatrix.needsUpdate = !0;
  }
  /**
   * Adds items to the fragment.
   *
   * @param items - An array of items to be added. Each item contains an ID, an array of transform matrices, and an optional array of colors.
   *
   * If the necessary capacity to accommodate the new items exceeds the current capacity,
   * a new mesh with a larger capacity is created, and the old mesh is disposed.
   *
   * The transform matrices and colors of the items are added to the respective attributes of the mesh.
   *
   * The instance IDs, item IDs, and associations between instance IDs and item IDs are updated accordingly.
   *
   * The instance color and matrix attributes of the mesh are updated.
   */
  add(t) {
    var i;
    let s = 0;
    for (const n of t)
      s += n.transforms.length;
    const e = this.mesh.count + s;
    if (e > this.capacity) {
      const n = e + this.capacityOffset, o = new ae(
        this.mesh.geometry,
        this.mesh.material,
        n,
        this
      );
      o.count = this.mesh.count, this.capacity = n;
      const r = this.mesh;
      (i = r.parent) == null || i.add(o), r.removeFromParent(), this.mesh = o;
      const c = new L.Matrix4();
      for (let f = 0; f < r.instanceMatrix.count; f++)
        r.getMatrixAt(f, c), o.setMatrixAt(f, c);
      if (r.instanceColor) {
        const f = new L.Color();
        for (let l = 0; l < r.instanceColor.count; l++)
          r.getColorAt(l, f), o.setColorAt(l, f);
      }
      r.dispose();
    }
    for (let n = 0; n < t.length; n++) {
      const { transforms: o, colors: r, id: c } = t[n];
      this.itemToInstances.has(c) || this.itemToInstances.set(c, /* @__PURE__ */ new Set());
      const f = this.itemToInstances.get(c);
      this.ids.add(c);
      for (let l = 0; l < o.length; l++) {
        const b = o[l], h = this.mesh.count;
        if (this.mesh.setMatrixAt(h, b), r) {
          const u = r[l];
          this.mesh.setColorAt(h, u);
        }
        f.add(h), this.instanceToItem.set(h, c), this.mesh.count++;
      }
    }
    this.update();
  }
  /**
   * Removes items from the fragment.
   *
   * @param itemsIDs - An iterable of item IDs to be removed.
   *
   * The instance IDs, item IDs, and associations between instance IDs and item IDs are updated accordingly.
   *
   * The instance color and matrix attributes of the mesh are updated.
   *
   * @throws Will throw an error if the instances are not found.
   */
  remove(t) {
    if (this.mesh.count !== 0) {
      for (const s of t) {
        const e = this.itemToInstances.get(s);
        if (e === void 0)
          throw new Error("Instances not found!");
        for (const i of e) {
          if (this.mesh.count === 0)
            throw new Error("Error with mesh count!");
          this.putLast(i), this.instanceToItem.delete(i), this.mesh.count--;
        }
        this.itemToInstances.delete(s), this.ids.delete(s);
      }
      this.update();
    }
  }
  /**
   * Clears the fragment by resetting the hidden items, item IDs, instance-to-item associations,
   * instance-to-item map, and the count of instances in the fragment's mesh.
   *
   * @remarks
   * This method is used to reset the fragment to its initial state.
   *
   * @example
   * ```typescript
   * fragment.clear();
   * ```
   */
  clear() {
    this.hiddenItems.clear(), this.ids.clear(), this.instanceToItem.clear(), this.itemToInstances.clear(), this.mesh.count = 0;
  }
  /**
   * Sets the visibility of items in the fragment.
   *
   * @param visible - A boolean indicating whether the items should be visible or hidden.
   * @param itemIDs - An iterable of item IDs to be affected. If not provided, all items in the fragment will be affected.
   *
   * @remarks
   * This method updates the visibility of items in the fragment based on the provided visibility flag.
   *
   * @throws Will throw an error if the instances are not found or if the item IDs are not found in the fragment.
   *
   * @example
   * ```typescript
   * fragment.setVisibility(true, [1, 2, 3]); // Makes items with IDs 1, 2, and 3 visible.
   * fragment.setVisibility(false); // Makes all items in the fragment hidden.
   * ```
   */
  setVisibility(t, s = this.ids) {
    if (!this._settingVisibility) {
      if (this._settingVisibility = !0, t)
        for (const e of s) {
          if (!this.ids.has(e))
            throw new Error(`This item doesn't exist here: ${e}`);
          if (!this.hiddenItems.has(e))
            continue;
          const i = this.itemToInstances.get(e);
          if (!i)
            throw new Error("Instances not found!");
          for (const n of new Set(i))
            this.mesh.count++, this.putLast(n);
          this.hiddenItems.delete(e);
        }
      else
        for (const e of s) {
          if (!this.ids.has(e))
            throw new Error(`This item doesn't exist here: ${e}`);
          if (this.hiddenItems.has(e))
            continue;
          const i = this.itemToInstances.get(e);
          if (!i)
            throw new Error("Instances not found!");
          for (const n of new Set(i))
            this.putLast(n), this.mesh.count--;
          this.hiddenItems.add(e);
        }
      this.update(), this._settingVisibility = !1;
    }
  }
  /**
   * Sets the color of items in the fragment.
   *
   * @param color - The color to be set for the items.
   * @param itemIDs - An iterable of item IDs to be affected. If not provided, all items in the fragment will be affected.
   * @param override - A boolean indicating whether the original color should be overridden. If true, the original color will be replaced with the new color.
   *
   * @throws Will throw an error if the fragment doesn't have color per instance or if the item IDs are not found in the fragment.
   *
   * @example
   * ```typescript
   * fragment.setColor(new THREE.Color(0xff0000), [1, 2, 3], true); // Sets the color of items with IDs 1, 2, and 3 to red, overriding their original colors.
   * fragment.setColor(new THREE.Color(0x00ff00)); // Sets the color of all items in the fragment to green.
   * ```
   */
  setColor(t, s = this.ids, e = !1) {
    if (!this.mesh.instanceColor)
      throw new Error("This fragment doesn't have color per instance!");
    for (const i of s) {
      if (!this.ids.has(i))
        throw new Error(`This item doesn't exist here: ${i}`);
      const n = this.itemToInstances.get(i);
      if (!n)
        throw new Error("Instances not found!");
      const o = this._originalColors.has(i);
      o || this._originalColors.set(i, /* @__PURE__ */ new Map());
      const r = this._originalColors.get(i);
      for (const c of new Set(n)) {
        if (!o) {
          const f = new L.Color();
          this.mesh.getColorAt(c, f), r.set(c, f);
        }
        this.mesh.setColorAt(c, t), e && r.set(c, t);
      }
    }
    this.mesh.instanceColor.needsUpdate = !0;
  }
  /**
   * Resets the color of items in the fragment to their original colors.
   *
   * @param itemIDs - An iterable of item IDs to be affected. If not provided, all items in the fragment will be affected.
   *
   * @throws Will throw an error if the fragment doesn't have color per instance or if the item IDs are not found in the fragment.
   *
   * @example
   * ```typescript
   * fragment.resetColor([1, 2, 3]); // Resets the color of items with IDs 1, 2, and 3 to their original colors.
   * fragment.resetColor(); // Resets the color of all items in the fragment to their original colors.
   * ```
   */
  resetColor(t = this.ids) {
    if (!this.mesh.instanceColor)
      throw new Error("This fragment doesn't have color per instance!");
    for (const s of t) {
      if (!this.ids.has(s))
        throw new Error(`This item doesn't exist here: ${s}`);
      const e = this.itemToInstances.get(s);
      if (!e)
        throw new Error("Instances not found!");
      const i = this._originalColors.get(s);
      if (i)
        for (const n of new Set(e)) {
          const o = i.get(n);
          if (!o)
            throw new Error("Original color not found!");
          this.mesh.setColorAt(n, o);
        }
    }
    this.mesh.instanceColor.needsUpdate = !0;
  }
  /**
   * Applies a transformation matrix to instances associated with given item IDs.
   *
   * @param itemIDs - An iterable of item IDs to be affected.
   * @param transform - The transformation matrix to be applied.
   *
   * @remarks
   * This method applies the provided transformation matrix to the instances associated with the given item IDs.
   *
   * @example
   * ```typescript
   * fragment.applyTransform([1, 2, 3], new THREE.Matrix4().makeTranslation(1, 0, 0)); // Applies a translation of (1, 0, 0) to instances with IDs 1, 2, and 3.
   * ```
   */
  applyTransform(t, s) {
    const e = new L.Matrix4();
    for (const i of t) {
      const n = this.getInstancesIDs(i);
      if (n !== null)
        for (const o of n)
          this.mesh.getMatrixAt(o, e), e.premultiply(s), this.mesh.setMatrixAt(o, e);
    }
    this.update();
  }
  /**
   * Exports the fragment's geometry and associated data.
   *
   * @returns An object containing the exported geometry, an array of IDs associated with the fragment, and the fragment's ID.
   *
   * @remarks
   * This method is used to export the fragment's geometry and associated data for further processing or storage.
   *
   * @example
   * ```typescript
   * const exportedData = fragment.exportData();
   * // Use the exportedData object for further processing or storage
   * ```
   */
  exportData() {
    const t = this.mesh.exportData(), s = Array.from(this.ids), e = this.id;
    return { ...t, ids: s, id: e };
  }
  putLast(t) {
    if (this.mesh.count === 0)
      return;
    const s = this.instanceToItem.get(t), e = this.mesh.count - 1;
    if (e === t)
      return;
    const i = this.instanceToItem.get(e);
    if (s === void 0 || i === void 0)
      throw new Error("Keys not found");
    if (s !== i) {
      const r = this.itemToInstances.get(s), c = this.itemToInstances.get(i);
      if (!r || !c)
        throw new Error("Instances not found");
      if (!r.has(t) || !c.has(e))
        throw new Error("Malformed fragment structure");
      r.delete(t), c.delete(e), r.add(e), c.add(t), this.instanceToItem.set(t, i), this.instanceToItem.set(e, s);
    }
    const n = new L.Matrix4(), o = new L.Matrix4();
    if (this.mesh.getMatrixAt(t, n), this.mesh.getMatrixAt(e, o), this.mesh.setMatrixAt(t, o), this.mesh.setMatrixAt(e, n), this.mesh.instanceColor !== null) {
      const r = new L.Color(), c = new L.Color();
      this.mesh.getColorAt(t, r), this.mesh.getColorAt(e, c), this.mesh.setColorAt(t, c), this.mesh.setColorAt(e, r);
      const f = this._originalColors.get(s);
      if (f) {
        const b = f.get(t);
        b && (f.delete(t), f.set(e, b));
      }
      const l = this._originalColors.get(i);
      if (l) {
        const b = l.get(e);
        b && (l.delete(e), l.set(t, b));
      }
    }
  }
};
const qs = 2, at = 4, ut = 4, W = 4, wt = new Int32Array(2), Ce = new Float32Array(wt.buffer), Pe = new Float64Array(wt.buffer), As = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var Qs;
(function(a) {
  a[a.UTF8_BYTES = 1] = "UTF8_BYTES", a[a.UTF16_STRING = 2] = "UTF16_STRING";
})(Qs || (Qs = {}));
class Dt {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(t) {
    this.bytes_ = t, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(t) {
    return new Dt(new Uint8Array(t));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(t) {
    this.position_ = t;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(t) {
    return this.readUint8(t) << 24 >> 24;
  }
  readUint8(t) {
    return this.bytes_[t];
  }
  readInt16(t) {
    return this.readUint16(t) << 16 >> 16;
  }
  readUint16(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8;
  }
  readInt32(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24;
  }
  readUint32(t) {
    return this.readInt32(t) >>> 0;
  }
  readInt64(t) {
    return BigInt.asIntN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
  }
  readUint64(t) {
    return BigInt.asUintN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
  }
  readFloat32(t) {
    return wt[0] = this.readInt32(t), Ce[0];
  }
  readFloat64(t) {
    return wt[As ? 0 : 1] = this.readInt32(t), wt[As ? 1 : 0] = this.readInt32(t + 4), Pe[0];
  }
  writeInt8(t, s) {
    this.bytes_[t] = s;
  }
  writeUint8(t, s) {
    this.bytes_[t] = s;
  }
  writeInt16(t, s) {
    this.bytes_[t] = s, this.bytes_[t + 1] = s >> 8;
  }
  writeUint16(t, s) {
    this.bytes_[t] = s, this.bytes_[t + 1] = s >> 8;
  }
  writeInt32(t, s) {
    this.bytes_[t] = s, this.bytes_[t + 1] = s >> 8, this.bytes_[t + 2] = s >> 16, this.bytes_[t + 3] = s >> 24;
  }
  writeUint32(t, s) {
    this.bytes_[t] = s, this.bytes_[t + 1] = s >> 8, this.bytes_[t + 2] = s >> 16, this.bytes_[t + 3] = s >> 24;
  }
  writeInt64(t, s) {
    this.writeInt32(t, Number(BigInt.asIntN(32, s))), this.writeInt32(t + 4, Number(BigInt.asIntN(32, s >> BigInt(32))));
  }
  writeUint64(t, s) {
    this.writeUint32(t, Number(BigInt.asUintN(32, s))), this.writeUint32(t + 4, Number(BigInt.asUintN(32, s >> BigInt(32))));
  }
  writeFloat32(t, s) {
    Ce[0] = s, this.writeInt32(t, wt[0]);
  }
  writeFloat64(t, s) {
    Pe[0] = s, this.writeInt32(t, wt[As ? 0 : 1]), this.writeInt32(t + 4, wt[As ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + at + ut)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let t = "";
    for (let s = 0; s < ut; s++)
      t += String.fromCharCode(this.readInt8(this.position_ + at + s));
    return t;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(t, s) {
    const e = t - this.readInt32(t);
    return s < this.readInt16(e) ? this.readInt16(e + s) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, s) {
    return t.bb_pos = s + this.readInt32(s), t.bb = this, t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(t, s) {
    t += this.readInt32(t);
    const e = this.readInt32(t);
    t += at;
    const i = this.bytes_.subarray(t, t + e);
    return s === Qs.UTF8_BYTES ? i : this.text_decoder_.decode(i);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(t, s) {
    return typeof t == "string" ? this.__string(s) : this.__union(t, s);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(t) {
    return t + this.readInt32(t);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(t) {
    return t + this.readInt32(t) + at;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(t) {
    return this.readInt32(t + this.readInt32(t));
  }
  __has_identifier(t) {
    if (t.length != ut)
      throw new Error("FlatBuffers: file identifier must be length " + ut);
    for (let s = 0; s < ut; s++)
      if (t.charCodeAt(s) != this.readInt8(this.position() + at + s))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(t, s) {
    const e = [];
    for (let i = 0; i < s; ++i) {
      const n = t(i);
      n !== null && e.push(n);
    }
    return e;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(t, s) {
    const e = [];
    for (let i = 0; i < s; ++i) {
      const n = t(i);
      n !== null && e.push(n.unpack());
    }
    return e;
  }
}
class rs {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(t) {
    this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null, this.text_encoder = new TextEncoder();
    let s;
    t ? s = t : s = 1024, this.bb = Dt.allocate(s), this.space = s;
  }
  clear() {
    this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(t) {
    this.force_defaults = t;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(t, s) {
    t > this.minalign && (this.minalign = t);
    const e = ~(this.bb.capacity() - this.space + s) + 1 & t - 1;
    for (; this.space < e + t + s; ) {
      const i = this.bb.capacity();
      this.bb = rs.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;
    }
    this.pad(e);
  }
  pad(t) {
    for (let s = 0; s < t; s++)
      this.bb.writeInt8(--this.space, 0);
  }
  writeInt8(t) {
    this.bb.writeInt8(this.space -= 1, t);
  }
  writeInt16(t) {
    this.bb.writeInt16(this.space -= 2, t);
  }
  writeInt32(t) {
    this.bb.writeInt32(this.space -= 4, t);
  }
  writeInt64(t) {
    this.bb.writeInt64(this.space -= 8, t);
  }
  writeFloat32(t) {
    this.bb.writeFloat32(this.space -= 4, t);
  }
  writeFloat64(t) {
    this.bb.writeFloat64(this.space -= 8, t);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the buffer.
   */
  addInt8(t) {
    this.prep(1, 0), this.writeInt8(t);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the buffer.
   */
  addInt16(t) {
    this.prep(2, 0), this.writeInt16(t);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the buffer.
   */
  addInt32(t) {
    this.prep(4, 0), this.writeInt32(t);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the buffer.
   */
  addInt64(t) {
    this.prep(8, 0), this.writeInt64(t);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the buffer.
   */
  addFloat32(t) {
    this.prep(4, 0), this.writeFloat32(t);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the buffer.
   */
  addFloat64(t) {
    this.prep(8, 0), this.writeFloat64(t);
  }
  addFieldInt8(t, s, e) {
    (this.force_defaults || s != e) && (this.addInt8(s), this.slot(t));
  }
  addFieldInt16(t, s, e) {
    (this.force_defaults || s != e) && (this.addInt16(s), this.slot(t));
  }
  addFieldInt32(t, s, e) {
    (this.force_defaults || s != e) && (this.addInt32(s), this.slot(t));
  }
  addFieldInt64(t, s, e) {
    (this.force_defaults || s !== e) && (this.addInt64(s), this.slot(t));
  }
  addFieldFloat32(t, s, e) {
    (this.force_defaults || s != e) && (this.addFloat32(s), this.slot(t));
  }
  addFieldFloat64(t, s, e) {
    (this.force_defaults || s != e) && (this.addFloat64(s), this.slot(t));
  }
  addFieldOffset(t, s, e) {
    (this.force_defaults || s != e) && (this.addOffset(s), this.slot(t));
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(t, s, e) {
    s != e && (this.nested(s), this.slot(t));
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(t) {
    if (t != this.offset())
      throw new Error("FlatBuffers: struct must be serialized inline.");
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested)
      throw new Error("FlatBuffers: object serialization must not be nested.");
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(t) {
    this.vtable !== null && (this.vtable[t] = this.offset());
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(t) {
    const s = t.capacity();
    if (s & 3221225472)
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    const e = s << 1, i = Dt.allocate(e);
    return i.setPosition(e - s), i.bytes().set(t.bytes(), e - s), i;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(t) {
    this.prep(at, 0), this.writeInt32(this.offset() - t + at);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(t) {
    this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = t;
    for (let s = 0; s < t; s++)
      this.vtable[s] = 0;
    this.isNested = !0, this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested)
      throw new Error("FlatBuffers: endObject called without startObject");
    this.addInt32(0);
    const t = this.offset();
    let s = this.vtable_in_use - 1;
    for (; s >= 0 && this.vtable[s] == 0; s--)
      ;
    const e = s + 1;
    for (; s >= 0; s--)
      this.addInt16(this.vtable[s] != 0 ? t - this.vtable[s] : 0);
    const i = 2;
    this.addInt16(t - this.object_start);
    const n = (e + i) * qs;
    this.addInt16(n);
    let o = 0;
    const r = this.space;
    t:
      for (s = 0; s < this.vtables.length; s++) {
        const c = this.bb.capacity() - this.vtables[s];
        if (n == this.bb.readInt16(c)) {
          for (let f = qs; f < n; f += qs)
            if (this.bb.readInt16(r + f) != this.bb.readInt16(c + f))
              continue t;
          o = this.vtables[s];
          break;
        }
      }
    return o ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, o - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(t, s, e) {
    const i = e ? W : 0;
    if (s) {
      const n = s;
      if (this.prep(this.minalign, at + ut + i), n.length != ut)
        throw new Error("FlatBuffers: file identifier must be length " + ut);
      for (let o = ut - 1; o >= 0; o--)
        this.writeInt8(n.charCodeAt(o));
    }
    this.prep(this.minalign, at + i), this.addOffset(t), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(t, s) {
    this.finish(t, s, !0);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(t, s) {
    const e = this.bb.capacity() - t, i = e - this.bb.readInt32(e);
    if (!(s < this.bb.readInt16(i) && this.bb.readInt16(i + s) != 0))
      throw new Error("FlatBuffers: field " + s + " must be set");
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(t, s, e) {
    this.notNested(), this.vector_num_elems = s, this.prep(at, t * s), this.prep(e, t * s);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    return this.writeInt32(this.vector_num_elems), this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(t) {
    if (!t)
      return 0;
    if (this.string_maps || (this.string_maps = /* @__PURE__ */ new Map()), this.string_maps.has(t))
      return this.string_maps.get(t);
    const s = this.createString(t);
    return this.string_maps.set(t, s), s;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(t) {
    if (t == null)
      return 0;
    let s;
    t instanceof Uint8Array ? s = t : s = this.text_encoder.encode(t), this.addInt8(0), this.startVector(1, s.length, 1), this.bb.setPosition(this.space -= s.length);
    for (let e = 0, i = this.space, n = this.bb.bytes(); e < s.length; e++)
      n[i++] = s[e];
    return this.endVector();
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(t) {
    return t === null ? 0 : typeof t == "string" ? this.createString(t) : t.pack(this);
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(t) {
    const s = [];
    for (let e = 0; e < t.length; ++e) {
      const i = t[e];
      if (i !== null)
        s.push(this.createObjectOffset(i));
      else
        throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
    }
    return s;
  }
  createStructOffsetList(t, s) {
    return s(this, t.length), this.createObjectOffsetList(t.slice().reverse()), this.endVector();
  }
}
let Vs = class Tt {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsCivilCurve(t, s) {
    return (s || new Tt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsCivilCurve(t, s) {
    return t.setPosition(t.position() + W), (s || new Tt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  points(t) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  pointsLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  pointsArray() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  data(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  static startCivilCurve(t) {
    t.startObject(2);
  }
  static addPoints(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createPointsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startPointsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addData(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static endCivilCurve(t) {
    return t.endObject();
  }
  static createCivilCurve(t, s, e) {
    return Tt.startCivilCurve(t), Tt.addPoints(t, s), Tt.addData(t, e), Tt.endCivilCurve(t);
  }
}, ze = class lt {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsAlignment(t, s) {
    return (s || new lt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsAlignment(t, s) {
    return t.setPosition(t.position() + W), (s || new lt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  vertical(t, s) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? (s || new Vs()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  verticalLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  horizontal(t, s) {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? (s || new Vs()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  horizontalLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  absolute(t, s) {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? (s || new Vs()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  absoluteLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  initialPk() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
  }
  static startAlignment(t) {
    t.startObject(4);
  }
  static addVertical(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createVerticalVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startVerticalVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addHorizontal(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static createHorizontalVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startHorizontalVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addAbsolute(t, s) {
    t.addFieldOffset(2, s, 0);
  }
  static createAbsoluteVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startAbsoluteVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addInitialPk(t, s) {
    t.addFieldFloat32(3, s, 0);
  }
  static endAlignment(t) {
    return t.endObject();
  }
  static createAlignment(t, s, e, i, n) {
    return lt.startAlignment(t), lt.addVertical(t, s), lt.addHorizontal(t, e), lt.addAbsolute(t, i), lt.addInitialPk(t, n), lt.endAlignment(t);
  }
}, Ee = class Ot {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsCivilData(t, s) {
    return (s || new Ot()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsCivilData(t, s) {
    return t.setPosition(t.position() + W), (s || new Ot()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  alignments(t, s) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? (s || new ze()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  alignmentsLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  coordinationMatrix(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  coordinationMatrixLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  coordinationMatrixArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  static startCivilData(t) {
    t.startObject(2);
  }
  static addAlignments(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createAlignmentsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startAlignmentsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addCoordinationMatrix(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static createCoordinationMatrixVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startCoordinationMatrixVector(t, s) {
    t.startVector(4, s, 4);
  }
  static endCivilData(t) {
    return t.endObject();
  }
  static createCivilData(t, s, e) {
    return Ot.startCivilData(t), Ot.addAlignments(t, s), Ot.addCoordinationMatrix(t, e), Ot.endCivilData(t);
  }
}, te = class K {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsFragment(t, s) {
    return (s || new K()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFragment(t, s) {
    return t.setPosition(t.position() + W), (s || new K()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  position(t) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  positionLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  positionArray() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  normal(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  normalLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  normalArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  index(t) {
    const s = this.bb.__offset(this.bb_pos, 8);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  indexLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  indexArray() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  groups(t) {
    const s = this.bb.__offset(this.bb_pos, 10);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  groupsLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  groupsArray() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  materials(t) {
    const s = this.bb.__offset(this.bb_pos, 12);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  materialsLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  materialsArray() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  matrices(t) {
    const s = this.bb.__offset(this.bb_pos, 14);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  matricesLength() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  matricesArray() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  colors(t) {
    const s = this.bb.__offset(this.bb_pos, 16);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  colorsLength() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  colorsArray() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  itemsSize(t) {
    const s = this.bb.__offset(this.bb_pos, 18);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsSizeLength() {
    const t = this.bb.__offset(this.bb_pos, 18);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsSizeArray() {
    const t = this.bb.__offset(this.bb_pos, 18);
    return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  ids(t) {
    const s = this.bb.__offset(this.bb_pos, 20);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  idsLength() {
    const t = this.bb.__offset(this.bb_pos, 20);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  idsArray() {
    const t = this.bb.__offset(this.bb_pos, 20);
    return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  id(t) {
    const s = this.bb.__offset(this.bb_pos, 22);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  capacity() {
    const t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.readUint32(this.bb_pos + t) : 0;
  }
  capacityOffset() {
    const t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.readUint32(this.bb_pos + t) : 0;
  }
  static startFragment(t) {
    t.startObject(12);
  }
  static addPosition(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createPositionVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startPositionVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addNormal(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static createNormalVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startNormalVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addIndex(t, s) {
    t.addFieldOffset(2, s, 0);
  }
  static createIndexVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startIndexVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addGroups(t, s) {
    t.addFieldOffset(3, s, 0);
  }
  static createGroupsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startGroupsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addMaterials(t, s) {
    t.addFieldOffset(4, s, 0);
  }
  static createMaterialsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startMaterialsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addMatrices(t, s) {
    t.addFieldOffset(5, s, 0);
  }
  static createMatricesVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startMatricesVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addColors(t, s) {
    t.addFieldOffset(6, s, 0);
  }
  static createColorsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startColorsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsSize(t, s) {
    t.addFieldOffset(7, s, 0);
  }
  static createItemsSizeVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsSizeVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addIds(t, s) {
    t.addFieldOffset(8, s, 0);
  }
  static createIdsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startIdsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addId(t, s) {
    t.addFieldOffset(9, s, 0);
  }
  static addCapacity(t, s) {
    t.addFieldInt32(10, s, 0);
  }
  static addCapacityOffset(t, s) {
    t.addFieldInt32(11, s, 0);
  }
  static endFragment(t) {
    return t.endObject();
  }
  static createFragment(t, s, e, i, n, o, r, c, f, l, b, h, u) {
    return K.startFragment(t), K.addPosition(t, s), K.addNormal(t, e), K.addIndex(t, i), K.addGroups(t, n), K.addMaterials(t, o), K.addMatrices(t, r), K.addColors(t, c), K.addItemsSize(t, f), K.addIds(t, l), K.addId(t, b), K.addCapacity(t, h), K.addCapacityOffset(t, u), K.endFragment(t);
  }
}, Ks = class se {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsFragmentsGroup(t, s) {
    return (s || new se()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsFragmentsGroup(t, s) {
    return t.setPosition(t.position() + W), (s || new se()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  items(t, s) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? (s || new te()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  itemsLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  civil(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? (t || new Ee()).__init(
      this.bb.__indirect(this.bb_pos + s),
      this.bb
    ) : null;
  }
  coordinationMatrix(t) {
    const s = this.bb.__offset(this.bb_pos, 8);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  coordinationMatrixLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  coordinationMatrixArray() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  ids(t) {
    const s = this.bb.__offset(this.bb_pos, 10);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  idsLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  idsArray() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  itemsKeys(t) {
    const s = this.bb.__offset(this.bb_pos, 12);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsKeysLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsKeysArray() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  itemsKeysIndices(t) {
    const s = this.bb.__offset(this.bb_pos, 14);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsKeysIndicesLength() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsKeysIndicesArray() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  itemsRels(t) {
    const s = this.bb.__offset(this.bb_pos, 16);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsRelsLength() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsRelsArray() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  itemsRelsIndices(t) {
    const s = this.bb.__offset(this.bb_pos, 18);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsRelsIndicesLength() {
    const t = this.bb.__offset(this.bb_pos, 18);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsRelsIndicesArray() {
    const t = this.bb.__offset(this.bb_pos, 18);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  fragmentKeys(t) {
    const s = this.bb.__offset(this.bb_pos, 20);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  id(t) {
    const s = this.bb.__offset(this.bb_pos, 22);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  name(t) {
    const s = this.bb.__offset(this.bb_pos, 24);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  ifcName(t) {
    const s = this.bb.__offset(this.bb_pos, 26);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  ifcDescription(t) {
    const s = this.bb.__offset(this.bb_pos, 28);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  ifcSchema(t) {
    const s = this.bb.__offset(this.bb_pos, 30);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  maxExpressId() {
    const t = this.bb.__offset(this.bb_pos, 32);
    return t ? this.bb.readUint32(this.bb_pos + t) : 0;
  }
  boundingBox(t) {
    const s = this.bb.__offset(this.bb_pos, 34);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  boundingBoxLength() {
    const t = this.bb.__offset(this.bb_pos, 34);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  boundingBoxArray() {
    const t = this.bb.__offset(this.bb_pos, 34);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  opaqueGeometriesIds(t) {
    const s = this.bb.__offset(this.bb_pos, 36);
    return s ? this.bb.readInt32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  opaqueGeometriesIdsLength() {
    const t = this.bb.__offset(this.bb_pos, 36);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  opaqueGeometriesIdsArray() {
    const t = this.bb.__offset(this.bb_pos, 36);
    return t ? new Int32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  transparentGeometriesIds(t) {
    const s = this.bb.__offset(this.bb_pos, 38);
    return s ? this.bb.readInt32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  transparentGeometriesIdsLength() {
    const t = this.bb.__offset(this.bb_pos, 38);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  transparentGeometriesIdsArray() {
    const t = this.bb.__offset(this.bb_pos, 38);
    return t ? new Int32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  static startFragmentsGroup(t) {
    t.startObject(18);
  }
  static addItems(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createItemsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startItemsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addCivil(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static addCoordinationMatrix(t, s) {
    t.addFieldOffset(2, s, 0);
  }
  static createCoordinationMatrixVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startCoordinationMatrixVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addIds(t, s) {
    t.addFieldOffset(3, s, 0);
  }
  static createIdsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startIdsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsKeys(t, s) {
    t.addFieldOffset(4, s, 0);
  }
  static createItemsKeysVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsKeysVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsKeysIndices(t, s) {
    t.addFieldOffset(5, s, 0);
  }
  static createItemsKeysIndicesVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsKeysIndicesVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsRels(t, s) {
    t.addFieldOffset(6, s, 0);
  }
  static createItemsRelsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsRelsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsRelsIndices(t, s) {
    t.addFieldOffset(7, s, 0);
  }
  static createItemsRelsIndicesVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsRelsIndicesVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addFragmentKeys(t, s) {
    t.addFieldOffset(8, s, 0);
  }
  static addId(t, s) {
    t.addFieldOffset(9, s, 0);
  }
  static addName(t, s) {
    t.addFieldOffset(10, s, 0);
  }
  static addIfcName(t, s) {
    t.addFieldOffset(11, s, 0);
  }
  static addIfcDescription(t, s) {
    t.addFieldOffset(12, s, 0);
  }
  static addIfcSchema(t, s) {
    t.addFieldOffset(13, s, 0);
  }
  static addMaxExpressId(t, s) {
    t.addFieldInt32(14, s, 0);
  }
  static addBoundingBox(t, s) {
    t.addFieldOffset(15, s, 0);
  }
  static createBoundingBoxVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startBoundingBoxVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addOpaqueGeometriesIds(t, s) {
    t.addFieldOffset(16, s, 0);
  }
  static createOpaqueGeometriesIdsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startOpaqueGeometriesIdsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addTransparentGeometriesIds(t, s) {
    t.addFieldOffset(17, s, 0);
  }
  static createTransparentGeometriesIdsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startTransparentGeometriesIdsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static endFragmentsGroup(t) {
    return t.endObject();
  }
  static finishFragmentsGroupBuffer(t, s) {
    t.finish(s);
  }
  static finishSizePrefixedFragmentsGroupBuffer(t, s) {
    t.finish(s, void 0, !0);
  }
};
class sn {
  constructor() {
    S(this, "version", 1);
    S(this, "fragmentIDSeparator", "|");
  }
  /** {@link FragmentParser.import} */
  import(t) {
    const s = new Dt(t), e = Ks.getRootAsFragmentsGroup(s), i = this.constructFragmentGroup(e), n = e.itemsLength();
    for (let o = 0; o < n; o++) {
      const r = e.items(o);
      if (!r)
        continue;
      const c = this.constructGeometry(r), f = this.constructMaterials(r), l = r.capacity(), b = new Ue(c, f, l);
      b.capacityOffset = r.capacityOffset(), this.setInstances(r, b), this.setID(r, b), i.items.push(b), i.add(b.mesh);
    }
    return i;
  }
  /**
   * Exports the FragmentsGroup to a flatbuffer binary file.
   *
   * @param group - The FragmentsGroup to be exported.
   * @returns The flatbuffer binary file as a Uint8Array.
   */
  export(t) {
    const s = new rs(1024), e = [], i = Ks, n = te;
    let o = null;
    if (t.civilData) {
      const q = [], E = ze, z = Ee;
      for (const [ct, pt] of t.civilData.alignments) {
        const { absolute: Ut, horizontal: mt, vertical: Ft } = pt, Ct = this.saveCivilCurves(mt, s), Pt = this.saveCivilCurves(Ft, s), Mt = this.saveCivilCurves(Ut, s), St = E.createHorizontalVector(s, Ct), Bt = E.createVerticalVector(s, Pt), yt = E.createAbsoluteVector(s, Mt);
        E.startAlignment(s), E.addHorizontal(s, St), E.addVertical(s, Bt), E.addAbsolute(s, yt), E.addInitialPk(s, pt.initialKP);
        const Zt = E.endAlignment(s);
        q.push(Zt);
      }
      const U = z.createAlignmentsVector(s, q), j = z.createCoordinationMatrixVector(
        s,
        t.coordinationMatrix.elements
      );
      z.startCivilData(s), z.addAlignments(s, U), z.addCoordinationMatrix(s, j), o = z.endCivilData(s);
    }
    for (const q of t.items) {
      const E = q.exportData(), z = [];
      for (const Bt of q.ids) {
        const yt = q.getInstancesIDs(Bt);
        if (!yt)
          throw new Error("Instances not found!");
        z.push(yt.size);
      }
      const U = n.createPositionVector(s, E.position), j = n.createNormalVector(s, E.normal), ct = n.createIndexVector(s, E.index), pt = n.createGroupsVector(s, E.groups), Ut = n.createMaterialsVector(s, E.materials), mt = n.createMatricesVector(s, E.matrices), Ft = n.createColorsVector(s, E.colors), Ct = n.createIdsVector(s, E.ids), Pt = n.createItemsSizeVector(s, z), Mt = s.createString(E.id);
      n.startFragment(s), n.addPosition(s, U), n.addNormal(s, j), n.addIndex(s, ct), n.addGroups(s, pt), n.addMaterials(s, Ut), n.addMatrices(s, mt), n.addColors(s, Ft), n.addIds(s, Ct), n.addItemsSize(s, Pt), n.addId(s, Mt), n.addCapacity(s, q.capacity), n.addCapacityOffset(s, q.capacityOffset);
      const St = te.endFragment(s);
      e.push(St);
    }
    const r = i.createItemsVector(s, e), c = i.createCoordinationMatrixVector(
      s,
      t.coordinationMatrix.elements
    );
    let f = "";
    for (const q of t.keyFragments.values())
      f.length && (f += this.fragmentIDSeparator), f += q;
    const l = s.createString(f), b = [], h = [], u = [], _ = [], w = [];
    let y = 0, d = 0;
    for (const [q, [E, z]] of t.data) {
      b.push(y), u.push(d), w.push(q);
      for (const U of E)
        h.push(U);
      for (const U of z)
        _.push(U);
      y += E.length, d += z.length;
    }
    const p = [], I = [];
    for (const [q, E] of t.geometryIDs.opaque)
      p.push(q, E);
    for (const [q, E] of t.geometryIDs.transparent)
      I.push(q, E);
    const m = s.createString(t.uuid), g = s.createString(t.name), A = s.createString(t.ifcMetadata.name), F = s.createString(t.ifcMetadata.description), x = s.createString(t.ifcMetadata.schema), C = i.createItemsKeysIndicesVector(s, b), v = i.createItemsKeysVector(s, h), M = i.createItemsRelsIndicesVector(s, u), V = i.createItemsRelsVector(s, _), P = i.createIdsVector(s, w), B = i.createOpaqueGeometriesIdsVector(s, p), O = i.createTransparentGeometriesIdsVector(
      s,
      I
    ), { min: D, max: $ } = t.boundingBox, X = [D.x, D.y, D.z, $.x, $.y, $.z], Y = i.createBoundingBoxVector(s, X);
    i.startFragmentsGroup(s), i.addId(s, m), i.addName(s, g), i.addIfcName(s, A), i.addIfcDescription(s, F), i.addIfcSchema(s, x), i.addMaxExpressId(s, t.ifcMetadata.maxExpressID), i.addItems(s, r), i.addFragmentKeys(s, l), i.addIds(s, P), i.addItemsKeysIndices(s, C), i.addItemsKeys(s, v), i.addItemsRelsIndices(s, M), i.addItemsRels(s, V), i.addCoordinationMatrix(s, c), i.addBoundingBox(s, Y), i.addOpaqueGeometriesIds(s, B), i.addTransparentGeometriesIds(s, O), o !== null && i.addCivil(s, o);
    const Bs = Ks.endFragmentsGroup(s);
    return s.finish(Bs), s.asUint8Array();
  }
  setID(t, s) {
    const e = t.id();
    e && (s.id = e, s.mesh.uuid = e);
  }
  setInstances(t, s) {
    const e = t.matricesArray(), i = t.colorsArray(), n = t.idsArray(), o = t.itemsSizeArray();
    if (!e || !n || !o)
      throw new Error("Error: Can't load empty fragment!");
    const r = [];
    let c = 0;
    for (let f = 0; f < o.length; f++) {
      const l = n[f], b = o[f], h = [], u = [];
      for (let w = 0; w < b; w++) {
        const y = c * 16, d = e.subarray(y, y + 17), p = new L.Matrix4().fromArray(d);
        if (h.push(p), i) {
          const I = c * 3, [m, g, A] = i.subarray(I, I + 4), F = new L.Color(m, g, A);
          u.push(F);
        }
        c++;
      }
      const _ = u.length ? u : void 0;
      r.push({ id: l, transforms: h, colors: _ });
    }
    s.add(r);
  }
  constructMaterials(t) {
    const s = t.materialsArray(), e = [];
    if (!s)
      return e;
    for (let i = 0; i < s.length; i += 5) {
      const n = s[i], o = !!s[i + 1], r = s[i + 2], c = s[i + 3], f = s[i + 4], l = new L.Color(r, c, f), b = new L.MeshLambertMaterial({
        color: l,
        opacity: n,
        transparent: o
      });
      e.push(b);
    }
    return e;
  }
  constructFragmentGroup(t) {
    const s = new Re(), e = t.civil();
    if (e) {
      const x = e.coordinationMatrixArray(), C = new L.Matrix4();
      x && C.fromArray(x), s.civilData = { alignments: /* @__PURE__ */ new Map(), coordinationMatrix: C };
      const v = e.alignmentsLength();
      for (let M = 0; M < v; M++) {
        const V = new L.LineBasicMaterial({ color: 16777215 }), P = new Ne(), B = e.alignments(M);
        if (!B)
          throw new Error("Alignment not found!");
        const O = B.horizontalLength();
        P.horizontal = this.constructCivilCurves(
          B,
          P,
          "horizontal",
          O,
          V
        );
        const D = B.verticalLength();
        P.vertical = this.constructCivilCurves(
          B,
          P,
          "vertical",
          D,
          V
        );
        const $ = B.horizontalLength();
        P.absolute = this.constructCivilCurves(
          B,
          P,
          "absolute",
          $,
          V
        ), P.initialKP = B.initialPk(), s.civilData.alignments.set(M, P);
      }
    }
    s.uuid = t.id() || s.uuid, s.name = t.name() || "", s.ifcMetadata = {
      name: t.ifcName() || "",
      description: t.ifcDescription() || "",
      schema: t.ifcSchema() || "IFC2X3",
      maxExpressID: t.maxExpressId() || 0
    };
    const i = new L.Matrix4().elements, n = t.coordinationMatrixArray() || i, o = t.idsArray() || new Uint32Array(), r = t.itemsKeysIndicesArray() || new Uint32Array(), c = t.itemsKeysArray() || new Uint32Array(), f = t.itemsRelsArray() || new Uint32Array(), l = t.itemsRelsIndicesArray() || new Uint32Array(), h = (t.fragmentKeys() || "").split(this.fragmentIDSeparator);
    this.setGroupData(s, o, r, c, 0), this.setGroupData(s, o, l, f, 1);
    const u = t.opaqueGeometriesIdsArray() || new Uint32Array(), _ = t.transparentGeometriesIdsArray() || new Uint32Array(), w = /* @__PURE__ */ new Map();
    for (let x = 0; x < u.length - 1; x += 2) {
      const C = u[x], v = u[x + 1];
      w.set(C, v);
    }
    const y = /* @__PURE__ */ new Map();
    for (let x = 0; x < _.length - 1; x += 2) {
      const C = _[x], v = _[x + 1];
      y.set(C, v);
    }
    s.geometryIDs = { opaque: w, transparent: y };
    const d = t.boundingBoxArray() || [0, 0, 0, 0, 0, 0], [p, I, m, g, A, F] = d;
    s.boundingBox.min.set(p, I, m), s.boundingBox.max.set(g, A, F);
    for (let x = 0; x < h.length; x++)
      s.keyFragments.set(x, h[x]);
    return n.length === 16 && s.coordinationMatrix.fromArray(n), s;
  }
  setGroupData(t, s, e, i, n) {
    for (let o = 0; o < e.length; o++) {
      const r = s[o], c = e[o], f = e[o + 1] || i.length, l = [];
      for (let h = c; h < f; h++)
        l.push(i[h]);
      t.data.has(r) || t.data.set(r, [[], []]);
      const b = t.data.get(r);
      b && (b[n] = l);
    }
  }
  constructGeometry(t) {
    const s = t.positionArray() || new Float32Array(), e = t.normalArray() || new Float32Array(), i = t.indexArray(), n = t.groupsArray();
    if (!i)
      throw new Error("Index not found!");
    const o = new L.BufferGeometry();
    if (o.setIndex(Array.from(i)), o.setAttribute("position", new L.BufferAttribute(s, 3)), o.setAttribute("normal", new L.BufferAttribute(e, 3)), n)
      for (let r = 0; r < n.length; r += 3) {
        const c = n[r], f = n[r + 1], l = n[r + 2];
        o.addGroup(c, f, l);
      }
    return o;
  }
  constructCivilCurves(t, s, e, i, n) {
    const o = [];
    for (let r = 0; r < i; r++) {
      const c = t[e](r);
      if (!c)
        throw new Error("Curve not found!");
      const f = c.pointsArray();
      if (f === null)
        throw new Error("Curve points not found!");
      let l = {};
      const b = c.data();
      b && (l = JSON.parse(b));
      const h = new L.EdgesGeometry(), u = new L.BufferAttribute(f, 3);
      h.setAttribute("position", u);
      const _ = [];
      for (let y = 0; y < f.length / 3 - 1; y++)
        _.push(y, y + 1);
      h.setIndex(_);
      const w = new ke(r, l, s, h, n);
      o.push(w.curve);
    }
    return o;
  }
  saveCivilCurves(t, s) {
    const e = Vs, i = [];
    for (const n of t) {
      const r = n.mesh.geometry.attributes.position.array, c = e.createPointsVector(s, r), f = s.createString(JSON.stringify(n.data));
      e.startCivilCurve(s), e.addPoints(s, c), e.addData(s, f);
      const l = e.endCivilCurve(s);
      i.push(l);
    }
    return i;
  }
}
let Fs = class Lt {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsCivilCurve(t, s) {
    return (s || new Lt()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsCivilCurve(t, s) {
    return t.setPosition(t.position() + W), (s || new Lt()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  points(t) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  pointsLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  pointsArray() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  data(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  static startCivilCurve(t) {
    t.startObject(2);
  }
  static addPoints(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createPointsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startPointsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addData(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static endCivilCurve(t) {
    return t.endObject();
  }
  static createCivilCurve(t, s, e) {
    return Lt.startCivilCurve(t), Lt.addPoints(t, s), Lt.addData(t, e), Lt.endCivilCurve(t);
  }
}, Ge = class ht {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsAlignment(t, s) {
    return (s || new ht()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsAlignment(t, s) {
    return t.setPosition(t.position() + W), (s || new ht()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  vertical(t, s) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? (s || new Fs()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  verticalLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  horizontal(t, s) {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? (s || new Fs()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  horizontalLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  absolute(t, s) {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? (s || new Fs()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  absoluteLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  initialPk() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
  }
  static startAlignment(t) {
    t.startObject(4);
  }
  static addVertical(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createVerticalVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startVerticalVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addHorizontal(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static createHorizontalVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startHorizontalVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addAbsolute(t, s) {
    t.addFieldOffset(2, s, 0);
  }
  static createAbsoluteVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startAbsoluteVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addInitialPk(t, s) {
    t.addFieldFloat32(3, s, 0);
  }
  static endAlignment(t) {
    return t.endObject();
  }
  static createAlignment(t, s, e, i, n) {
    return ht.startAlignment(t), ht.addVertical(t, s), ht.addHorizontal(t, e), ht.addAbsolute(t, i), ht.addInitialPk(t, n), ht.endAlignment(t);
  }
};
class bt {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsCivilData(t, s) {
    return (s || new bt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsCivilData(t, s) {
    return t.setPosition(t.position() + W), (s || new bt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  alignments(t, s) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? (s || new Ge()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  alignmentsLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  coordinationMatrix(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  coordinationMatrixLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  coordinationMatrixArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  static startCivilData(t) {
    t.startObject(2);
  }
  static addAlignments(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createAlignmentsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startAlignmentsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addCoordinationMatrix(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static createCoordinationMatrixVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startCoordinationMatrixVector(t, s) {
    t.startVector(4, s, 4);
  }
  static endCivilData(t) {
    return t.endObject();
  }
  static createCivilData(t, s, e) {
    return bt.startCivilData(t), bt.addAlignments(t, s), bt.addCoordinationMatrix(t, e), bt.endCivilData(t);
  }
}
class N {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsFragment(t, s) {
    return (s || new N()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFragment(t, s) {
    return t.setPosition(t.position() + W), (s || new N()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  position(t) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  positionLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  positionArray() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  normal(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  normalLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  normalArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  index(t) {
    const s = this.bb.__offset(this.bb_pos, 8);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  indexLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  indexArray() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  groups(t) {
    const s = this.bb.__offset(this.bb_pos, 10);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  groupsLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  groupsArray() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  materials(t) {
    const s = this.bb.__offset(this.bb_pos, 12);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  materialsLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  materialsArray() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  matrices(t) {
    const s = this.bb.__offset(this.bb_pos, 14);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  matricesLength() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  matricesArray() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  colors(t) {
    const s = this.bb.__offset(this.bb_pos, 16);
    return s ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  colorsLength() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  colorsArray() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  itemsSize(t) {
    const s = this.bb.__offset(this.bb_pos, 18);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsSizeLength() {
    const t = this.bb.__offset(this.bb_pos, 18);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsSizeArray() {
    const t = this.bb.__offset(this.bb_pos, 18);
    return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  ids(t) {
    const s = this.bb.__offset(this.bb_pos, 20);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  idsLength() {
    const t = this.bb.__offset(this.bb_pos, 20);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  idsArray() {
    const t = this.bb.__offset(this.bb_pos, 20);
    return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  id(t) {
    const s = this.bb.__offset(this.bb_pos, 22);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  capacity() {
    const t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.readUint32(this.bb_pos + t) : 0;
  }
  capacityOffset() {
    const t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.readUint32(this.bb_pos + t) : 0;
  }
  static startFragment(t) {
    t.startObject(12);
  }
  static addPosition(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createPositionVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startPositionVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addNormal(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static createNormalVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startNormalVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addIndex(t, s) {
    t.addFieldOffset(2, s, 0);
  }
  static createIndexVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startIndexVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addGroups(t, s) {
    t.addFieldOffset(3, s, 0);
  }
  static createGroupsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startGroupsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addMaterials(t, s) {
    t.addFieldOffset(4, s, 0);
  }
  static createMaterialsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startMaterialsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addMatrices(t, s) {
    t.addFieldOffset(5, s, 0);
  }
  static createMatricesVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startMatricesVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addColors(t, s) {
    t.addFieldOffset(6, s, 0);
  }
  static createColorsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startColorsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsSize(t, s) {
    t.addFieldOffset(7, s, 0);
  }
  static createItemsSizeVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsSizeVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addIds(t, s) {
    t.addFieldOffset(8, s, 0);
  }
  static createIdsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startIdsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addId(t, s) {
    t.addFieldOffset(9, s, 0);
  }
  static addCapacity(t, s) {
    t.addFieldInt32(10, s, 0);
  }
  static addCapacityOffset(t, s) {
    t.addFieldInt32(11, s, 0);
  }
  static endFragment(t) {
    return t.endObject();
  }
  static createFragment(t, s, e, i, n, o, r, c, f, l, b, h, u) {
    return N.startFragment(t), N.addPosition(t, s), N.addNormal(t, e), N.addIndex(t, i), N.addGroups(t, n), N.addMaterials(t, o), N.addMatrices(t, r), N.addColors(t, c), N.addItemsSize(t, f), N.addIds(t, l), N.addId(t, b), N.addCapacity(t, h), N.addCapacityOffset(t, u), N.endFragment(t);
  }
}
let js = class ee {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsFragmentsGroup(t, s) {
    return (s || new ee()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsFragmentsGroup(t, s) {
    return t.setPosition(t.position() + W), (s || new ee()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  items(t, s) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? (s || new N()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  itemsLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  civil(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? (t || new bt()).__init(
      this.bb.__indirect(this.bb_pos + s),
      this.bb
    ) : null;
  }
  coordinationMatrix(t) {
    const s = this.bb.__offset(this.bb_pos, 8);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  coordinationMatrixLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  coordinationMatrixArray() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  ids(t) {
    const s = this.bb.__offset(this.bb_pos, 10);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  idsLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  idsArray() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  itemsKeys(t) {
    const s = this.bb.__offset(this.bb_pos, 12);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsKeysLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsKeysArray() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  itemsKeysIndices(t) {
    const s = this.bb.__offset(this.bb_pos, 14);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsKeysIndicesLength() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsKeysIndicesArray() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  itemsRels(t) {
    const s = this.bb.__offset(this.bb_pos, 16);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsRelsLength() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsRelsArray() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  itemsRelsIndices(t) {
    const s = this.bb.__offset(this.bb_pos, 18);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  itemsRelsIndicesLength() {
    const t = this.bb.__offset(this.bb_pos, 18);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  itemsRelsIndicesArray() {
    const t = this.bb.__offset(this.bb_pos, 18);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  fragmentKeys(t) {
    const s = this.bb.__offset(this.bb_pos, 20);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  globalIds(t) {
    const s = this.bb.__offset(this.bb_pos, 22);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  id(t) {
    const s = this.bb.__offset(this.bb_pos, 24);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  name(t) {
    const s = this.bb.__offset(this.bb_pos, 26);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  ifcName(t) {
    const s = this.bb.__offset(this.bb_pos, 28);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  ifcDescription(t) {
    const s = this.bb.__offset(this.bb_pos, 30);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  ifcSchema(t) {
    const s = this.bb.__offset(this.bb_pos, 32);
    return s ? this.bb.__string(this.bb_pos + s, t) : null;
  }
  maxExpressId() {
    const t = this.bb.__offset(this.bb_pos, 34);
    return t ? this.bb.readUint32(this.bb_pos + t) : 0;
  }
  boundingBox(t) {
    const s = this.bb.__offset(this.bb_pos, 36);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  boundingBoxLength() {
    const t = this.bb.__offset(this.bb_pos, 36);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  boundingBoxArray() {
    const t = this.bb.__offset(this.bb_pos, 36);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  opaqueGeometriesIds(t) {
    const s = this.bb.__offset(this.bb_pos, 38);
    return s ? this.bb.readInt32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  opaqueGeometriesIdsLength() {
    const t = this.bb.__offset(this.bb_pos, 38);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  opaqueGeometriesIdsArray() {
    const t = this.bb.__offset(this.bb_pos, 38);
    return t ? new Int32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  transparentGeometriesIds(t) {
    const s = this.bb.__offset(this.bb_pos, 40);
    return s ? this.bb.readInt32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  transparentGeometriesIdsLength() {
    const t = this.bb.__offset(this.bb_pos, 40);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  transparentGeometriesIdsArray() {
    const t = this.bb.__offset(this.bb_pos, 40);
    return t ? new Int32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  static startFragmentsGroup(t) {
    t.startObject(19);
  }
  static addItems(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createItemsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startItemsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addCivil(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static addCoordinationMatrix(t, s) {
    t.addFieldOffset(2, s, 0);
  }
  static createCoordinationMatrixVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startCoordinationMatrixVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addIds(t, s) {
    t.addFieldOffset(3, s, 0);
  }
  static createIdsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startIdsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsKeys(t, s) {
    t.addFieldOffset(4, s, 0);
  }
  static createItemsKeysVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsKeysVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsKeysIndices(t, s) {
    t.addFieldOffset(5, s, 0);
  }
  static createItemsKeysIndicesVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsKeysIndicesVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsRels(t, s) {
    t.addFieldOffset(6, s, 0);
  }
  static createItemsRelsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsRelsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addItemsRelsIndices(t, s) {
    t.addFieldOffset(7, s, 0);
  }
  static createItemsRelsIndicesVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startItemsRelsIndicesVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addFragmentKeys(t, s) {
    t.addFieldOffset(8, s, 0);
  }
  static addGlobalIds(t, s) {
    t.addFieldOffset(9, s, 0);
  }
  static addId(t, s) {
    t.addFieldOffset(10, s, 0);
  }
  static addName(t, s) {
    t.addFieldOffset(11, s, 0);
  }
  static addIfcName(t, s) {
    t.addFieldOffset(12, s, 0);
  }
  static addIfcDescription(t, s) {
    t.addFieldOffset(13, s, 0);
  }
  static addIfcSchema(t, s) {
    t.addFieldOffset(14, s, 0);
  }
  static addMaxExpressId(t, s) {
    t.addFieldInt32(15, s, 0);
  }
  static addBoundingBox(t, s) {
    t.addFieldOffset(16, s, 0);
  }
  static createBoundingBoxVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startBoundingBoxVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addOpaqueGeometriesIds(t, s) {
    t.addFieldOffset(17, s, 0);
  }
  static createOpaqueGeometriesIdsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startOpaqueGeometriesIdsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addTransparentGeometriesIds(t, s) {
    t.addFieldOffset(18, s, 0);
  }
  static createTransparentGeometriesIdsVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startTransparentGeometriesIdsVector(t, s) {
    t.startVector(4, s, 4);
  }
  static endFragmentsGroup(t) {
    return t.endObject();
  }
  static finishFragmentsGroupBuffer(t, s) {
    t.finish(s);
  }
  static finishSizePrefixedFragmentsGroupBuffer(t, s) {
    t.finish(s, void 0, !0);
  }
};
class en {
  constructor() {
    S(this, "version", 2);
    S(this, "separator", "|");
  }
  /** {@link FragmentParser.import} */
  import(t) {
    const s = new Dt(t), e = js.getRootAsFragmentsGroup(s), i = this.constructFragmentGroup(e), n = e.itemsLength();
    for (let o = 0; o < n; o++) {
      const r = e.items(o);
      if (!r)
        continue;
      const c = this.constructGeometry(r), f = this.constructMaterials(r), l = r.capacity(), b = new Ue(c, f, l);
      b.capacityOffset = r.capacityOffset(), this.setInstances(r, b), this.setID(r, b), i.items.push(b), i.add(b.mesh);
    }
    return i;
  }
  /**
   * Exports the FragmentsGroup to a flatbuffer binary file.
   *
   * @param group - The FragmentsGroup to be exported.
   * @returns The flatbuffer binary file as a Uint8Array.
   */
  export(t) {
    const s = new rs(1024), e = [], i = js, n = N;
    let o = null;
    if (t.civilData) {
      const z = [], U = Ge, j = bt;
      for (const [Ut, mt] of t.civilData.alignments) {
        const { absolute: Ft, horizontal: Ct, vertical: Pt } = mt, Mt = this.saveCivilCurves(Ct, s), St = this.saveCivilCurves(Pt, s), Bt = this.saveCivilCurves(Ft, s), yt = U.createHorizontalVector(s, Mt), Zt = U.createVerticalVector(s, St), cs = U.createAbsoluteVector(s, Bt);
        U.startAlignment(s), U.addHorizontal(s, yt), U.addVertical(s, Zt), U.addAbsolute(s, cs), U.addInitialPk(s, mt.initialKP);
        const qe = U.endAlignment(s);
        z.push(qe);
      }
      const ct = j.createAlignmentsVector(s, z), pt = j.createCoordinationMatrixVector(
        s,
        t.coordinationMatrix.elements
      );
      j.startCivilData(s), j.addAlignments(s, ct), j.addCoordinationMatrix(s, pt), o = j.endCivilData(s);
    }
    for (const z of t.items) {
      const U = z.exportData(), j = [];
      for (const Zt of z.ids) {
        const cs = z.getInstancesIDs(Zt);
        if (!cs)
          throw new Error("Instances not found!");
        j.push(cs.size);
      }
      const ct = n.createPositionVector(s, U.position), pt = n.createNormalVector(s, U.normal), Ut = n.createIndexVector(s, U.index), mt = n.createGroupsVector(s, U.groups), Ft = n.createMaterialsVector(s, U.materials), Ct = n.createMatricesVector(s, U.matrices), Pt = n.createColorsVector(s, U.colors), Mt = n.createIdsVector(s, U.ids), St = n.createItemsSizeVector(s, j), Bt = s.createString(U.id);
      n.startFragment(s), n.addPosition(s, ct), n.addNormal(s, pt), n.addIndex(s, Ut), n.addGroups(s, mt), n.addMaterials(s, Ft), n.addMatrices(s, Ct), n.addColors(s, Pt), n.addIds(s, Mt), n.addItemsSize(s, St), n.addId(s, Bt), n.addCapacity(s, z.capacity), n.addCapacityOffset(s, z.capacityOffset);
      const yt = N.endFragment(s);
      e.push(yt);
    }
    const r = i.createItemsVector(s, e), c = i.createCoordinationMatrixVector(
      s,
      t.coordinationMatrix.elements
    );
    let f = "";
    for (const z of t.keyFragments.values())
      f.length && (f += this.separator), f += z;
    let l = "";
    for (const [z] of t.globalToExpressIDs)
      l.length && (l += this.separator), l += z;
    const b = s.createString(f), h = s.createString(l), u = [], _ = [], w = [], y = [], d = [];
    let p = 0, I = 0;
    for (const [z, [U, j]] of t.data) {
      u.push(p), w.push(I), d.push(z);
      for (const ct of U)
        _.push(ct);
      for (const ct of j)
        y.push(ct);
      p += U.length, I += j.length;
    }
    const m = [], g = [];
    for (const [z, U] of t.geometryIDs.opaque)
      m.push(z, U);
    for (const [z, U] of t.geometryIDs.transparent)
      g.push(z, U);
    const A = s.createString(t.uuid), F = s.createString(t.name), x = s.createString(t.ifcMetadata.name), C = s.createString(t.ifcMetadata.description), v = s.createString(t.ifcMetadata.schema), M = i.createItemsKeysIndicesVector(s, u), V = i.createItemsKeysVector(s, _), P = i.createItemsRelsIndicesVector(s, w), B = i.createItemsRelsVector(s, y), O = i.createIdsVector(s, d), D = i.createOpaqueGeometriesIdsVector(s, m), $ = i.createTransparentGeometriesIdsVector(
      s,
      g
    ), { min: X, max: Y } = t.boundingBox, Bs = [X.x, X.y, X.z, Y.x, Y.y, Y.z], q = i.createBoundingBoxVector(s, Bs);
    i.startFragmentsGroup(s), i.addId(s, A), i.addName(s, F), i.addIfcName(s, x), i.addIfcDescription(s, C), i.addIfcSchema(s, v), i.addMaxExpressId(s, t.ifcMetadata.maxExpressID), i.addItems(s, r), i.addFragmentKeys(s, b), i.addGlobalIds(s, h), i.addIds(s, O), i.addItemsKeysIndices(s, M), i.addItemsKeys(s, V), i.addItemsRelsIndices(s, P), i.addItemsRels(s, B), i.addCoordinationMatrix(s, c), i.addBoundingBox(s, q), i.addOpaqueGeometriesIds(s, D), i.addTransparentGeometriesIds(s, $), o !== null && i.addCivil(s, o);
    const E = js.endFragmentsGroup(s);
    return s.finish(E), s.asUint8Array();
  }
  setID(t, s) {
    const e = t.id();
    e && (s.id = e, s.mesh.uuid = e);
  }
  setInstances(t, s) {
    const e = t.matricesArray(), i = t.colorsArray(), n = t.idsArray(), o = t.itemsSizeArray();
    if (!e || !n || !o)
      throw new Error("Error: Can't load empty fragment!");
    const r = [];
    let c = 0;
    for (let f = 0; f < o.length; f++) {
      const l = n[f], b = o[f], h = [], u = [];
      for (let w = 0; w < b; w++) {
        const y = c * 16, d = e.subarray(y, y + 17), p = new L.Matrix4().fromArray(d);
        if (h.push(p), i) {
          const I = c * 3, [m, g, A] = i.subarray(I, I + 4), F = new L.Color(m, g, A);
          u.push(F);
        }
        c++;
      }
      const _ = u.length ? u : void 0;
      r.push({ id: l, transforms: h, colors: _ });
    }
    s.add(r);
  }
  constructMaterials(t) {
    const s = t.materialsArray(), e = [];
    if (!s)
      return e;
    for (let i = 0; i < s.length; i += 5) {
      const n = s[i], o = !!s[i + 1], r = s[i + 2], c = s[i + 3], f = s[i + 4], l = new L.Color(r, c, f), b = new L.MeshLambertMaterial({
        color: l,
        opacity: n,
        transparent: o
      });
      e.push(b);
    }
    return e;
  }
  constructFragmentGroup(t) {
    const s = new Re(), e = t.civil();
    if (e) {
      const v = e.coordinationMatrixArray(), M = new L.Matrix4();
      v && M.fromArray(v), s.civilData = { alignments: /* @__PURE__ */ new Map(), coordinationMatrix: M };
      const V = e.alignmentsLength();
      for (let P = 0; P < V; P++) {
        const B = new L.LineBasicMaterial({ color: 16777215 }), O = new Ne(), D = e.alignments(P);
        if (!D)
          throw new Error("Alignment not found!");
        const $ = D.horizontalLength();
        O.horizontal = this.constructCivilCurves(
          D,
          O,
          "horizontal",
          $,
          B
        );
        const X = D.verticalLength();
        O.vertical = this.constructCivilCurves(
          D,
          O,
          "vertical",
          X,
          B
        );
        const Y = D.horizontalLength();
        O.absolute = this.constructCivilCurves(
          D,
          O,
          "absolute",
          Y,
          B
        ), O.initialKP = D.initialPk(), s.civilData.alignments.set(P, O);
      }
    }
    s.uuid = t.id() || s.uuid, s.name = t.name() || "", s.ifcMetadata = {
      name: t.ifcName() || "",
      description: t.ifcDescription() || "",
      schema: t.ifcSchema() || "IFC2X3",
      maxExpressID: t.maxExpressId() || 0
    };
    const i = new L.Matrix4().elements, n = t.coordinationMatrixArray() || i, o = t.idsArray() || new Uint32Array(), r = t.itemsKeysIndicesArray() || new Uint32Array(), c = t.itemsKeysArray() || new Uint32Array(), f = t.itemsRelsArray() || new Uint32Array(), l = t.itemsRelsIndicesArray() || new Uint32Array(), h = (t.fragmentKeys() || "").split(this.separator), _ = (t.globalIds() || "").split(this.separator);
    this.setGroupData(s, o, r, c, 0), this.setGroupData(s, o, l, f, 1);
    const w = t.opaqueGeometriesIdsArray() || new Uint32Array(), y = t.transparentGeometriesIdsArray() || new Uint32Array(), d = /* @__PURE__ */ new Map();
    for (let v = 0; v < w.length - 1; v += 2) {
      const M = w[v], V = w[v + 1];
      d.set(M, V);
    }
    const p = /* @__PURE__ */ new Map();
    for (let v = 0; v < y.length - 1; v += 2) {
      const M = y[v], V = y[v + 1];
      p.set(M, V);
    }
    s.geometryIDs = { opaque: d, transparent: p };
    const I = t.boundingBoxArray() || [0, 0, 0, 0, 0, 0], [m, g, A, F, x, C] = I;
    s.boundingBox.min.set(m, g, A), s.boundingBox.max.set(F, x, C);
    for (let v = 0; v < h.length; v++)
      s.keyFragments.set(v, h[v]);
    n.length === 16 && s.coordinationMatrix.fromArray(n);
    for (let v = 0; v < o.length; v++)
      s.globalToExpressIDs.set(_[v], o[v]);
    return s;
  }
  setGroupData(t, s, e, i, n) {
    for (let o = 0; o < e.length; o++) {
      const r = s[o], c = e[o], f = e[o + 1] || i.length, l = [];
      for (let h = c; h < f; h++)
        l.push(i[h]);
      t.data.has(r) || t.data.set(r, [[], []]);
      const b = t.data.get(r);
      b && (b[n] = l);
    }
  }
  constructGeometry(t) {
    const s = t.positionArray() || new Float32Array(), e = t.normalArray() || new Float32Array(), i = t.indexArray(), n = t.groupsArray();
    if (!i)
      throw new Error("Index not found!");
    const o = new L.BufferGeometry();
    if (o.setIndex(Array.from(i)), o.setAttribute("position", new L.BufferAttribute(s, 3)), o.setAttribute("normal", new L.BufferAttribute(e, 3)), n)
      for (let r = 0; r < n.length; r += 3) {
        const c = n[r], f = n[r + 1], l = n[r + 2];
        o.addGroup(c, f, l);
      }
    return o;
  }
  constructCivilCurves(t, s, e, i, n) {
    const o = [];
    for (let r = 0; r < i; r++) {
      const c = t[e](r);
      if (!c)
        throw new Error("Curve not found!");
      const f = c.pointsArray();
      if (f === null)
        throw new Error("Curve points not found!");
      let l = {};
      const b = c.data();
      b && (l = JSON.parse(b));
      const h = new L.EdgesGeometry(), u = new L.BufferAttribute(f, 3);
      h.setAttribute("position", u);
      const _ = [];
      for (let y = 0; y < f.length / 3 - 1; y++)
        _.push(y, y + 1);
      h.setIndex(_);
      const w = new ke(r, l, s, h, n);
      o.push(w.curve);
    }
    return o;
  }
  saveCivilCurves(t, s) {
    const e = Fs, i = [];
    for (const n of t) {
      const r = n.mesh.geometry.attributes.position.array, c = e.createPointsVector(s, r), f = s.createString(JSON.stringify(n.data));
      e.startCivilCurve(s), e.addPoints(s, c), e.addData(s, f);
      const l = e.endCivilCurve(s);
      i.push(l);
    }
    return i;
  }
}
class an {
  constructor() {
    // prettier-ignore
    S(this, "parsers", [
      new en(),
      new sn()
    ]);
    /** {@link FragmentParser.version} */
    S(this, "version", "auto");
  }
  /** {@link FragmentParser.import} */
  import(t) {
    const s = this.parsers.length - 1;
    if (this.version === "auto") {
      for (let o = 0; o < this.parsers.length; o++) {
        const c = this.parsers[o].import(t);
        if (Object.keys(c).length !== 0) {
          if (o !== 0) {
            const f = this.parsers.length - o;
            this.warnVersion(f, s);
          }
          return c;
        }
      }
      throw new Error("No valid parser found for this file");
    }
    this.checkCurrentVersionValid(s);
    const e = this.parsers.length - this.version, n = this.parsers[e].import(t);
    if (Object.keys(n).length === 0)
      throw new Error(
        `The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`
      );
    return n;
  }
  /** {@link FragmentParser.export} */
  export(t) {
    const s = this.parsers.length - 1;
    if (this.version === "auto")
      return this.parsers[this.parsers.length - 1].export(t);
    this.checkCurrentVersionValid(s);
    const e = this.parsers.length - this.version;
    return this.parsers[e].export(t);
  }
  checkCurrentVersionValid(t) {
    if (this.version !== "auto") {
      if (this.version !== t && this.warnVersion(this.version, t), Number.isInteger(this.version))
        throw new Error(
          "Invalid version. Non-automatic versions must an integer."
        );
      if (this.version < 1 || this.version > t)
        throw new Error(
          `Invalid version. Versions range from 1 to ${t}.`
        );
    }
  }
  warnVersion(t, s) {
    console.warn(
      `This fragment file version is ${t}. The latest version is ${s}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`
    );
  }
}
class Re extends L.Group {
  constructor() {
    super(...arguments);
    /**
     * An array of Fragment objects that are part of this group.
     */
    S(this, "items", []);
    /**
     * A THREE.Box3 object representing the bounding box of all fragments in this group.
     */
    S(this, "boundingBox", new L.Box3());
    /**
     * A THREE.Matrix4 object representing the coordination matrix of this group.
     */
    S(this, "coordinationMatrix", new L.Matrix4());
    /**
     * A Map object where the keys are uints and the values are strings representing fragment IDs.
     * This is used to save memory by mapping keys to fragment IDs.
     */
    S(this, "keyFragments", /* @__PURE__ */ new Map());
    /**
     * A Map object where the keys are global IDs and the values are expressIDs.
     */
    S(this, "globalToExpressIDs", /* @__PURE__ */ new Map());
    /**
     * A Map object where the keys are express IDs and the values are arrays of two arrays.
     * The first array contains fragment keys to which this asset belongs, and the second array contains floor and category IDs.
     */
    S(this, "data", /* @__PURE__ */ new Map());
    /**
     * An object with two Map properties, 'opaque' and 'transparent', representing the geometry IDs and keys of opaque and transparent fragments. They must be distinguished because THREE.js doesn't support transparency per instance in InstancedMesh.
     */
    S(this, "geometryIDs", {
      opaque: /* @__PURE__ */ new Map(),
      transparent: /* @__PURE__ */ new Map()
    });
    /**
     * An object representing metadata about the IFC model defined by the IFC schema.
     */
    S(this, "ifcMetadata", {
      name: "",
      description: "",
      schema: "IFC2X3",
      maxExpressID: 0
    });
    /**
     * An optional object containing civil engineering data.
     */
    S(this, "civilData");
    /**
     * An object containing settings for streaming data, including base URL, base file name, IDs, and types.
     */
    S(this, "streamSettings", {
      baseUrl: "",
      baseFileName: "",
      ids: /* @__PURE__ */ new Map(),
      types: /* @__PURE__ */ new Map()
    });
    /**
     * A protected property representing local properties of the fragments in this group.
     */
    S(this, "_properties");
  }
  /**
   * A getter that checks if this group has properties, either locally defined or streamed from a data source.
   */
  get hasProperties() {
    const s = this._properties !== void 0, e = this.streamSettings.ids.size !== 0;
    return s || e;
  }
  /**
   * A method to create a map of fragment IDs and express IDs contained within them. This is useful because if you want to get "a chair", it might be made of 4 different geometries, and thus the subsets of 4 different fragments. Using this method, you would get exactly the fragments of where that chair is.
   * @param expressIDs - An iterable of express IDs to create the map for.
   * @returns A map where the keys are fragment IDs and the values are sets of express IDs.
   */
  getFragmentMap(s) {
    const e = {};
    for (const i of s) {
      const n = this.data.get(i);
      if (n)
        for (const o of n[0]) {
          const r = this.keyFragments.get(o);
          r !== void 0 && (e[r] || (e[r] = /* @__PURE__ */ new Set()), e[r].add(i));
        }
    }
    return e;
  }
  /**
   * Method to retrieve the vertices of a specific item within the fragments.
   * This method finds the fragments that contain the specified item,
   * then retrieves the vertices of those fragments.
   *
   * @param itemID - The ID of the item for which to retrieve vertices. Usually, an IFC expressID.
   * @returns An array of THREE.Vector3 objects representing the vertices of the specified item.
   *
   * @example
   * ```typescript
   * const itemVertices = fragmentsGroup.getItemVertices(12345);
   * for (const vertex of itemVertices) {
   *   console.log(`Vertex: ${vertex.x}, ${vertex.y}, ${vertex.z}`);
   * }
   * ```
   */
  getItemVertices(s) {
    const e = [], i = this.getFragmentMap([s]);
    for (const n in i) {
      const o = this.items.find(
        (c) => c.id === n
      );
      if (!o)
        continue;
      const r = o.getInstancesIDs(s);
      if (r)
        for (const c of r) {
          const f = new L.Matrix4();
          o.mesh.getMatrixAt(c, f);
          for (const l of o.uniqueVertices) {
            const b = l.clone().applyMatrix4(f);
            e.push(b);
          }
        }
    }
    return e;
  }
  /**
   * Method to dispose of the resources used by the FragmentsGroup.
   *
   * @param disposeResources - If true, also dispose of the resources used by the fragments (geometries and materials). Default is true.
   */
  dispose(s = !0) {
    for (const e of this.items)
      e.dispose(s);
    if (this.coordinationMatrix = new L.Matrix4(), this.keyFragments.clear(), this.data.clear(), this._properties = {}, this.removeFromParent(), this.items = [], this.civilData) {
      const { alignments: e } = this.civilData;
      for (const [i, n] of e)
        this.disposeAlignment(n.vertical), this.disposeAlignment(n.horizontal), this.disposeAlignment(n.absolute);
    }
    this.civilData = void 0;
  }
  /**
   * Method to set local properties of the fragments in this group.
   *
   * @param properties - An object containing properties of type IfcProperties.
   * The keys of the object are express IDs as strings, and the values are objects representing the properties of the corresponding express ID.
   *
   * @example
   * ```typescript
   * const properties: IfcProperties = {
   *   "12345": {
   *     name: "Chair",
   *     type: 1001,
   *     color: [0.5, 0.5, 0.5],
   *     //... other properties
   *   },
   *   "67890": {
   *     name: "Table",
   *     type: 1002,
   *     color: [0.8, 0.8, 0.8],
   *     //... other properties
   *   },
   *   //... more properties
   * };
   *
   * fragmentsGroup.setLocalProperties(properties);
   * ```
   */
  setLocalProperties(s) {
    this._properties = s;
  }
  /**
   * Method to retrieve the local properties of the fragments in this group.
   *
   * @returns {IfcProperties | undefined} - An object containing properties of type IfcProperties.
   * The keys of the object are express IDs as strings, and the values are objects representing the properties of the corresponding express ID.
   * If no local properties are set, it returns `undefined`.
   *
   * @example
   * ```typescript
   * const properties = fragmentsGroup.getLocalProperties();
   * if (properties) {
   *   for (const id in properties) {
   *     const property = properties[id];
   *     console.log(`ID: ${id}, Name: ${property.name}, Type: ${property.type}`);
   *   }
   * }
   * ```
   */
  getLocalProperties() {
    return this._properties;
  }
  /**
   * Method to retrieve all property IDs from either local properties or streamed properties.
   *
   * @returns {number[]} - An array of property IDs.
   *
   * @example
   * ```typescript
   * const propertyIDs = fragmentsGroup.getAllPropertiesIDs();
   * console.log(propertyIDs); // Output: [12345, 67890,...]
   * ```
   */
  getAllPropertiesIDs() {
    return this._properties ? Object.keys(this._properties).map((s) => parseInt(s, 10)) : Array.from(this.streamSettings.ids.keys());
  }
  /**
   * Method to retrieve all property types from either local properties or streamed properties.
   *
   * @returns {number[]} - An array of unique property types.
   *
   * @example
   * ```typescript
   * const propertyTypes = fragmentsGroup.getAllPropertiesTypes();
   * console.log(propertyTypes); // Output: [1001, 1002,...]
   * ```
   */
  getAllPropertiesTypes() {
    if (this._properties) {
      const s = /* @__PURE__ */ new Set();
      for (const e in this._properties) {
        const i = this._properties[e];
        i.type !== void 0 && s.add(i.type);
      }
      return Array.from(s);
    }
    return Array.from(this.streamSettings.types.keys());
  }
  async getProperties(s) {
    if (this._properties)
      return this._properties[s] || null;
    const e = this.getPropsURL(s), i = await this.getPropertiesData(e);
    return i ? i[s] : null;
  }
  /**
   * Method to set properties of a specific fragment in this group.
   *
   * @param id - The ID of the fragment for which to set properties.
   * @param value - The new properties to set for the fragment. If null, it deletes the properties for the fragment.
   * @throws Will throw an error if writing streamed properties, as it is not supported yet.
   *
   * @example
   * ```typescript
   * const properties: IfcProperties = {
   *   "12345": {
   *     name: "Chair",
   *     type: 1001,
   *     color: [0.5, 0.5, 0.5],
   *     //... other properties
   *   },
   * };
   *
   * fragmentsGroup.setProperties(12345, properties[12345]);
   * ```
   */
  async setProperties(s, e) {
    if (this._properties) {
      e !== null ? this._properties[s] = e : delete this._properties[s];
      return;
    }
    throw new Error("Writing streamed properties not supported yet!");
  }
  /**
   * Method to retrieve all properties of a specific type from either local properties or streamed properties.
   *
   * @param type - The type of properties to retrieve.
   * @returns A Promise that resolves to an object containing properties of type IfcProperties, or null if no properties of the specified type are found.
   *
   * @example
   * ```typescript
   * const type = 1001; // Example type
   * fragmentsGroup.getAllPropertiesOfType(type).then((properties) => {
   *   if (properties) {
   *     for (const id in properties) {
   *       const property = properties[id];
   *       console.log(`ID: ${id}, Name: ${property.name}, Type: ${property.type}`);
   *     }
   *   } else {
   *     console.log(`No properties of type ${type} found.`);
   *   }
   * });
   * ```
   */
  async getAllPropertiesOfType(s) {
    if (this._properties) {
      const o = {};
      let r = !1;
      for (const c in this._properties) {
        const f = this._properties[c];
        f.type === s && (o[f.expressID] = f, r = !0);
      }
      return r ? o : null;
    }
    const { types: e } = this.streamSettings, i = e.get(s);
    if (i === void 0)
      return null;
    const n = {};
    for (const o of i) {
      const r = this.constructFileName(o), c = this.constructURL(r), f = await this.getPropertiesData(c);
      for (const l in f)
        n[parseInt(l, 10)] = f[l];
    }
    return n;
  }
  getPropsURL(s) {
    const { ids: e } = this.streamSettings, i = e.get(s);
    if (i === void 0)
      throw new Error("ID not found");
    const n = this.constructFileName(i);
    return this.constructURL(n);
  }
  async getPropertiesData(s) {
    return (await fetch(s)).json();
  }
  constructFileName(s) {
    const { baseFileName: e } = this.streamSettings;
    return `${e}-${s}`;
  }
  constructURL(s) {
    const { baseUrl: e } = this.streamSettings;
    return `${e}${s}`;
  }
  disposeAlignment(s) {
    for (const e of s)
      if (e.mesh.geometry.dispose(), Array.isArray(e.mesh.material))
        for (const i of e.mesh.material)
          i.dispose();
      else
        e.mesh.material.dispose();
    s.length = 0;
  }
}
class Ne {
  constructor() {
    /**
     * Vertical civil curves in the alignment.
     */
    S(this, "vertical", []);
    /**
     * Horizontal civil curves in the alignment.
     */
    S(this, "horizontal", []);
    /**
     * Absolute civil curves in the alignment.
     */
    S(this, "absolute", []);
    /**
     * Initial KP (Kilometer Point) of the alignment.
     */
    S(this, "initialKP", 0);
  }
  /**
   * Returns the total length of the specified alignment type.
   * @param type - The type of alignment (vertical, horizontal, or absolute).
   * @returns The total length of the specified alignment type.
   */
  getLength(t) {
    let s = 0;
    for (const e of this[t])
      s += e.getLength();
    return s;
  }
  /**
   * Returns the point at the specified percentage along the specified alignment type.
   * @param percentage - The percentage along the alignment type (between zero and one).
   * @param type - The type of alignment (vertical, horizontal, or absolute).
   * @returns The point at the specified percentage along the specified alignment type.
   * @throws Will throw an error if the percentage is out of range or if the point cannot be computed.
   */
  getPointAt(t, s) {
    const e = this.getCurveAt(t, s);
    return e.curve.getPointAt(e.percentage);
  }
  // Returns the percentage or null if the point is not contained in this alignment
  getPercentageAt(t, s, e = 0.01) {
    const i = this[s];
    let n = 0;
    for (const o of i) {
      const r = o.getPercentageAt(t, e), c = o.getLength();
      if (r !== null) {
        const f = n + r * c, l = this.getLength(s);
        return f / l;
      }
      n += c;
    }
    return null;
  }
  /**
   * Returns the curve and the percentage at the specified percentage along the specified alignment type.
   * If the percentage is out of range, it will be clamped to the nearest valid value (0 or 1).
   * If the point cannot be computed, an error will be thrown.
   *
   * @param percentage - The percentage along the alignment type (between zero and one).
   * @param type - The type of alignment (vertical, horizontal, or absolute).
   * @returns An object containing the curve and the percentage along the curve.
   * @throws Will throw an error if the percentage is out of range or if the point cannot be computed.
   */
  getCurveAt(t, s) {
    t < 0 ? t = 0 : t > 1 && (t = 1);
    const e = this[s], n = this.getLength(s) * t;
    let o = 0;
    for (const r of e) {
      const c = r.getLength();
      if (o + c >= n) {
        const l = (n - o) / c;
        return { curve: r, percentage: l };
      }
      o += c;
    }
    throw new Error("Could not compute point!");
  }
}
class nn {
  /**
   * Constructs a new instance of CivilCurve.
   * @param index - The index of the curve.
   * @param mesh - The mesh associated with the curve.
   * @param data - Additional data associated with the curve.
   * @param alignment - The alignment of the curve.
   */
  constructor(t, s, e, i) {
    /**
     * The index of the curve. An alignment is a sequence of ordered curves, and this is the index of this curve in that sequence.
     */
    S(this, "index");
    /**
     * The THREE.js mesh containing the vertices of the curve.
     */
    S(this, "mesh");
    /**
     * Additional data associated with the curve.
     */
    S(this, "data");
    /**
     * The alignment to which this curve belongs.
     */
    S(this, "alignment");
    this.index = t, this.mesh = s, this.data = e, this.alignment = i;
  }
  get _index() {
    return this.mesh.geometry.index;
  }
  get _pos() {
    return this.mesh.geometry.attributes.position.array;
  }
  /**
   * Calculates the total length of the curve by summing up the lengths of all segments.
   * @returns The total length of the curve.
   */
  getLength() {
    let t = 0;
    for (let s = 0; s < this._index.array.length - 1; s += 2) {
      const { startPoint: e, endPoint: i } = this.getSegment(s);
      t += e.distanceTo(i);
    }
    return t;
  }
  /**
   * Calculates a point on the curve based on the given percentage.
   *
   * @param percentage - The percentage along the curve (between zero and one).
   * @returns A new THREE.Vector3 representing the point on the curve.
   *
   * @remarks
   * The method works by first finding the segment that corresponds to the given percentage.
   * It then normalizes the direction of the segment, multiplies it by the distance to the start of the segment,
   * and adds it to the start point of the segment.
   *
   * @throws Will throw an error if the percentage is outside the range [0, 1].
   */
  getPointAt(t) {
    const { startPoint: s, endPoint: e, distanceToStart: i } = this.getSegmentAt(t), n = e.clone();
    return n.sub(s), n.normalize(), n.multiplyScalar(i), n.add(s), n;
  }
  /**
   * Calculates a segment of the curve based on the given percentage.
   *
   * @param percentage - The percentage along the curve (between zero and one).
   * @returns An object containing the distance to the start of the segment, the index of the segment, and the start and end points of the segment.
   *
   * @remarks
   * The method works by first finding the segment that corresponds to the given percentage.
   * It then returns an object containing the distance to the start of the segment, the index of the segment, and the start and end points of the segment.
   *
   * @throws Will throw an error if the percentage is outside the range [0, 1].
   */
  getSegmentAt(t) {
    t < 0 ? t = 0 : t > 1 && (t = 1);
    const e = this.getLength() * t;
    let i = 0;
    for (let n = 0; n < this._index.array.length - 1; n += 2) {
      const { startPoint: o, endPoint: r } = this.getSegment(n), c = o.distanceTo(r);
      if (i + c >= e)
        return { distanceToStart: e - i, index: n, startPoint: o, endPoint: r };
      i += c;
    }
    throw new Error("Could not compute point");
  }
  /**
   * Calculates the percentage of the curve that corresponds to the given point.
   *
   * @param point - The point for which to calculate the percentage.
   * @param tolerance - The tolerance for determining if a point is on the curve. Default is 0.01.
   * @returns The percentage of the curve that corresponds to the given point, or null if the point is not contained in this curve.
   *
   * @remarks
   * The method works by iterating over each segment of the curve and checking if the given point is within the tolerance of the segment.
   * If a point is found, it calculates the percentage of the curve that corresponds to the point.
   * If no point is found, it returns null.
   */
  getPercentageAt(t, s = 0.01) {
    let e = 0;
    for (let i = 0; i < this._index.array.length - 1; i += 2) {
      const { startPoint: n, endPoint: o } = this.getSegment(i), r = n.distanceTo(o), c = t.distanceTo(n), f = t.distanceTo(o);
      if (c + f - r <= s) {
        const h = e + c, u = this.getLength();
        return h / u;
      }
      e += r;
    }
    return null;
  }
  /**
   * Retrieves a segment of the curve based on the given index.
   *
   * @param index - The index of the segment.
   * @returns An object containing the start and end points of the segment.
   *
   * @remarks
   * The method calculates the start and end points of the segment based on the given index.
   * It uses the index array and position attribute of the curve's geometry to determine the start and end points.
   *
   * @throws Will throw an error if the index is out of range.
   */
  getSegment(t) {
    const s = this._index.array[t] * 3, e = this._index.array[t + 1] * 3, i = new L.Vector3(
      this._pos[s],
      this._pos[s + 1],
      this._pos[s + 2]
    ), n = new L.Vector3(
      this._pos[e],
      this._pos[e + 1],
      this._pos[e + 2]
    );
    return { startPoint: i, endPoint: n };
  }
}
class ke extends L.LineSegments {
  /**
   * Constructs a new instance of CurveMesh.
   *
   * @param index - The index of the curve mesh.
   * @param data - The data associated with the curve mesh.
   * @param alignment - The alignment of the curve mesh.
   * @param geometry - The geometry for the curve mesh. Optional.
   * @param material - The material(s) for the curve mesh. Optional.
   */
  constructor(s, e, i, n, o) {
    super(n, o);
    /**
     * The civil curve associated with this curve mesh.
     */
    S(this, "curve");
    this.curve = new nn(s, this, e, i);
  }
}
class nt {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsStreamedGeometry(t, s) {
    return (s || new nt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsStreamedGeometry(t, s) {
    return t.setPosition(t.position() + W), (s || new nt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  geometryId() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readUint32(this.bb_pos + t) : 0;
  }
  position(t) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  positionLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  positionArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  normal(t) {
    const s = this.bb.__offset(this.bb_pos, 8);
    return s ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + s) + t * 4
    ) : 0;
  }
  normalLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  normalArray() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  index(t) {
    const s = this.bb.__offset(this.bb_pos, 10);
    return s ? this.bb.readUint32(this.bb.__vector(this.bb_pos + s) + t * 4) : 0;
  }
  indexLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  indexArray() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
      this.bb.__vector_len(this.bb_pos + t)
    ) : null;
  }
  static startStreamedGeometry(t) {
    t.startObject(4);
  }
  static addGeometryId(t, s) {
    t.addFieldInt32(0, s, 0);
  }
  static addPosition(t, s) {
    t.addFieldOffset(1, s, 0);
  }
  static createPositionVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startPositionVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addNormal(t, s) {
    t.addFieldOffset(2, s, 0);
  }
  static createNormalVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addFloat32(s[e]);
    return t.endVector();
  }
  static startNormalVector(t, s) {
    t.startVector(4, s, 4);
  }
  static addIndex(t, s) {
    t.addFieldOffset(3, s, 0);
  }
  static createIndexVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addInt32(s[e]);
    return t.endVector();
  }
  static startIndexVector(t, s) {
    t.startVector(4, s, 4);
  }
  static endStreamedGeometry(t) {
    return t.endObject();
  }
  static createStreamedGeometry(t, s, e, i, n) {
    return nt.startStreamedGeometry(t), nt.addGeometryId(t, s), nt.addPosition(t, e), nt.addNormal(t, i), nt.addIndex(t, n), nt.endStreamedGeometry(t);
  }
}
class xt {
  constructor() {
    S(this, "bb", null);
    S(this, "bb_pos", 0);
  }
  __init(t, s) {
    return this.bb_pos = t, this.bb = s, this;
  }
  static getRootAsStreamedGeometries(t, s) {
    return (s || new xt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  static getSizePrefixedRootAsStreamedGeometries(t, s) {
    return t.setPosition(t.position() + W), (s || new xt()).__init(
      t.readInt32(t.position()) + t.position(),
      t
    );
  }
  geometries(t, s) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? (s || new nt()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + e) + t * 4
      ),
      this.bb
    ) : null;
  }
  geometriesLength() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startStreamedGeometries(t) {
    t.startObject(1);
  }
  static addGeometries(t, s) {
    t.addFieldOffset(0, s, 0);
  }
  static createGeometriesVector(t, s) {
    t.startVector(4, s.length, 4);
    for (let e = s.length - 1; e >= 0; e--)
      t.addOffset(s[e]);
    return t.endVector();
  }
  static startGeometriesVector(t, s) {
    t.startVector(4, s, 4);
  }
  static endStreamedGeometries(t) {
    return t.endObject();
  }
  static finishStreamedGeometriesBuffer(t, s) {
    t.finish(s);
  }
  static finishSizePrefixedStreamedGeometriesBuffer(t, s) {
    t.finish(s, void 0, !0);
  }
  static createStreamedGeometries(t, s) {
    return xt.startStreamedGeometries(t), xt.addGeometries(t, s), xt.endStreamedGeometries(t);
  }
}
class fn {
  /**
   * Imports geometry data from a byte array in a streamed format.
   *
   * @param bytes - The byte array containing the serialized geometry data.
   * @returns A Map of geometry IDs to their respective position, normal, and index arrays.
   * @throws Will throw an error if the geometry ID is not found.
   */
  import(t) {
    const s = new Dt(t), e = xt.getRootAsStreamedGeometries(s), i = /* @__PURE__ */ new Map(), n = e.geometriesLength();
    for (let o = 0; o < n; o++) {
      const r = e.geometries(o);
      if (!r)
        continue;
      const c = r.geometryId();
      if (c === null)
        throw new Error("Error finding ID!");
      const f = r.positionArray(), l = r.normalArray(), b = r.indexArray();
      !f || !l || !b || i.set(c, { position: f, normal: l, index: b });
    }
    return i;
  }
  /**
   * Exports geometry data to a byte array in a streamed format.
   *
   * @param geometries - A Map of geometry IDs to their respective position, normal, and index arrays.
   * @returns A Uint8Array containing the serialized geometry data.
   */
  export(t) {
    const s = new rs(1024), e = [], i = xt, n = nt;
    for (const [c, { index: f, position: l, normal: b }] of t) {
      const h = n.createIndexVector(s, f), u = n.createPositionVector(s, l), _ = n.createNormalVector(s, b);
      n.startStreamedGeometry(s), n.addGeometryId(s, c), n.addIndex(s, h), n.addPosition(s, u), n.addNormal(s, _);
      const w = n.endStreamedGeometry(s);
      e.push(w);
    }
    const o = i.createGeometriesVector(s, e);
    i.startStreamedGeometries(s), i.addGeometries(s, o);
    const r = i.endStreamedGeometries(s);
    return s.finish(r), s.asUint8Array();
  }
}
export {
  Ne as Alignment,
  nn as CivilCurve,
  ke as CurveMesh,
  Ue as Fragment,
  ae as FragmentMesh,
  Re as FragmentsGroup,
  an as Serializer,
  fn as StreamSerializer
};
